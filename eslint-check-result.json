[{"filePath":"F:\\_THE KINETIC ALPHABET\\_TKA-STUDIO\\src\\lib\\modules\\explore\\gallery\\display\\services\\implementations\\ExploreLoader.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":88,"column":24,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":88,"endColumn":41},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":89,"column":25,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":89,"endColumn":43},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":109,"column":19,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":109,"endColumn":36},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":144,"column":60,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":144,"endColumn":62,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[5085,5087],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":145,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":145,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[5159,5161],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":224,"column":27,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":224,"endColumn":29,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[8342,8344],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":277,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":277,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[10066,10068],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":278,"column":56,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":278,"endColumn":58,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[10138,10140],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":289,"column":16,"nodeType":"LogicalExpression","messageId":"neverNullish","endLine":289,"endColumn":35},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":314,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":314,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[11459,11461],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":315,"column":56,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":315,"endColumn":58,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[11531,11533],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":324,"column":16,"nodeType":"LogicalExpression","messageId":"neverNullish","endLine":324,"endColumn":35}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Explore Loader Service\n *\n * Orchestrates loading of gallery sequences from the sequence index.\n * Handles validation, metadata extraction, and data normalization.\n */\n\nimport type { GridPositionGroup } from \"$shared\";\nimport type { SequenceData } from \"$shared\";\nimport { createSequenceData } from \"$shared\";\nimport { TYPES } from \"$shared/inversify/types\";\nimport { GridMode } from \"$shared/pictograph/grid/domain/enums/grid-enums\";\nimport { PropType } from \"$shared/pictograph/prop/domain/enums/PropType\";\nimport { inject, injectable } from \"inversify\";\nimport type { IExploreLoader } from \"../contracts/IExploreLoader\";\nimport type { IExploreMetadataExtractor } from \"../contracts/IExploreMetadataExtractor\";\n// Constants for validation\nconst MAX_WORD_LENGTH = 200;\nconst SEQUENCE_INDEX_URL = \"/sequence-index.json\";\n\ninterface RawSequenceData {\n  word?: string;\n  name?: string;\n  id?: string;\n  thumbnails?: unknown;\n  isFavorite?: unknown;\n  isCircular?: unknown;\n  tags?: unknown;\n  metadata?: unknown;\n  author?: string;\n  gridMode?: unknown;\n  difficultyLevel?: unknown;\n  sequenceLength?: unknown;\n  level?: unknown;\n  dateAdded?: unknown;\n  propType?: unknown;\n  startingPosition?: unknown;\n  fullMetadata?: unknown; // Bundled metadata from build script\n  metadataBundled?: boolean; // Flag indicating metadata is pre-bundled\n}\n\n@injectable()\nexport class ExploreLoader implements IExploreLoader {\n  constructor(\n    @inject(TYPES.IExploreMetadataExtractor)\n    private metadataExtractor: IExploreMetadataExtractor\n  ) {}\n\n  async loadSequenceMetadata(): Promise<SequenceData[]> {\n    try {\n      const rawSequences = await this.fetchSequenceIndex();\n      const validSequences = this.processRawSequences(rawSequences);\n      return validSequences;\n    } catch (error) {\n      console.error(\"‚ùå Failed to load sequence metadata:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Lazy-load full sequence data including beats (only called when user opens a sequence)\n   * This prevents the N+1 query problem during initial gallery load\n   *\n   * OPTIMIZATION: If metadata was bundled via build script, use it directly.\n   * Otherwise, fetch from .meta.json file (fallback for development).\n   */\n  async loadFullSequenceData(\n    sequenceName: string\n  ): Promise<SequenceData | null> {\n    try {\n      // Check if we have bundled metadata in the sequence index cache\n      // This would be populated if you run: npm run bundle:metadata\n      const cachedSequence = this.sequenceCache.get(sequenceName);\n\n      if (cachedSequence?.fullMetadata) {\n        console.log(`‚ö° Using bundled metadata for ${sequenceName}`);\n        return this.createSequenceFromBundledMetadata(cachedSequence);\n      }\n\n      // Fallback: Fetch metadata from .meta.json file (slower, but works in development)\n      console.log(`üîÑ Fetching metadata for ${sequenceName} from .meta.json`);\n      const thumbnailPath = `/gallery/${sequenceName}/${sequenceName}.webp`;\n      const metadata = await this.metadataExtractor.extractMetadata(\n        sequenceName,\n        thumbnailPath\n      );\n\n      const gridMode = metadata.gridMode || GridMode.BOX;\n      const dateAdded = metadata.dateAdded || new Date();\n      const difficultyLevel = metadata.difficultyLevel || \"beginner\";\n      const calculatedLevel = this.difficultyStringToLevel(difficultyLevel);\n\n      return createSequenceData({\n        id: sequenceName,\n        name: this.cleanSequenceName(sequenceName),\n        word: sequenceName,\n        beats: metadata.beats,\n        thumbnails: [thumbnailPath],\n        isFavorite: false,\n        isCircular: metadata.isCircular || false,\n        tags: [\"flow\", \"practice\"],\n        metadata: { source: \"tka_dictionary\" },\n        author: metadata.author || \"Unknown\",\n        gridMode,\n        difficultyLevel,\n        sequenceLength: metadata.sequenceLength,\n        level: calculatedLevel,\n        dateAdded,\n        propType: metadata.propType || PropType.STAFF,\n        startingPositionGroup: (metadata.startingPosition ||\n          \"alpha\") as GridPositionGroup,\n      });\n    } catch (error) {\n      console.error(\n        `‚ùå Failed to load full sequence data for ${sequenceName}:`,\n        error\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Cache to store raw sequences for quick lookup during lazy loading\n   */\n  private sequenceCache = new Map<string, RawSequenceData>();\n\n  /**\n   * Create SequenceData from bundled metadata (instant, no HTTP request!)\n   */\n  private createSequenceFromBundledMetadata(\n    rawSeq: RawSequenceData\n  ): SequenceData | null {\n    try {\n      const fullMetadata = rawSeq.fullMetadata as Record<string, unknown> | undefined;\n      if (!fullMetadata || typeof fullMetadata !== 'object') {\n        throw new Error('Invalid fullMetadata');\n      }\n      const sequence = Array.isArray(fullMetadata.sequence) ? fullMetadata.sequence : [];\n\n      // Parse beats from bundled metadata\n      const beats = this.parseBundledBeats(sequence);\n\n      const word = rawSeq.word ?? rawSeq.id ?? \"\";\n      const gridMode = this.parseGridMode(rawSeq.gridMode) || GridMode.BOX;\n      const dateAdded = this.parseDate(rawSeq.dateAdded) || new Date();\n      const difficultyLevel = this.parseDifficulty(rawSeq.difficultyLevel);\n      const calculatedLevel = this.difficultyStringToLevel(difficultyLevel);\n\n      return createSequenceData({\n        id: word,\n        name: this.cleanSequenceName(String(rawSeq.name ?? word)),\n        word,\n        beats,\n        thumbnails: this.parseThumbnails(rawSeq.thumbnails),\n        isFavorite: Boolean(rawSeq.isFavorite),\n        isCircular: Boolean(rawSeq.isCircular),\n        tags: this.parseTags(rawSeq.tags),\n        metadata: this.parseMetadata(rawSeq.metadata),\n        author: String(rawSeq.author ?? \"Unknown\"),\n        gridMode,\n        difficultyLevel,\n        sequenceLength: beats.length,\n        level: calculatedLevel,\n        dateAdded,\n        propType: (rawSeq.propType || \"Staff\") as PropType,\n        startingPositionGroup: (rawSeq.startingPosition ||\n          \"alpha\") as GridPositionGroup,\n      });\n    } catch (error) {\n      console.error(`‚ùå Failed to parse bundled metadata:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Parse beats from bundled metadata (simplified version)\n   * Full parsing is handled by ExploreMetadataExtractor when needed\n   */\n  private parseBundledBeats(sequence: unknown[]): unknown[] {\n    // Handle two different metadata formats:\n    // Format 1: Has explicit 'beat' field (newer format)\n    // Format 2: No 'beat' field, just 'letter' field (older format)\n\n    const hasBeatNumbers = sequence.some(\n      (item) => typeof item === 'object' && item !== null && 'beat' in item && typeof (item as Record<string, unknown>).beat === \"number\"\n    );\n\n    if (hasBeatNumbers) {\n      // Format 1: Filter out the start position (beat 0) - only return beats >= 1\n      return sequence.filter((item) => {\n        if (typeof item !== 'object' || item === null || !('beat' in item)) return false;\n        const beat = (item as Record<string, unknown>).beat;\n        return typeof beat === \"number\" && beat >= 1;\n      });\n    } else {\n      // Format 2: Count items with 'letter' field\n      // Exclude: sequence metadata (has 'word' field) and start position (has 'sequence_start_position')\n      return sequence.filter((item) => {\n        if (typeof item !== 'object' || item === null) return false;\n        const obj = item as Record<string, unknown>;\n        return 'letter' in obj && obj.letter && !('word' in obj) && !('sequence_start_position' in obj);\n      });\n    }\n  }\n\n  // ============================================================================\n  // Data Loading\n  // ============================================================================\n\n  private async fetchSequenceIndex(): Promise<RawSequenceData[]> {\n    // Add cache-busting parameter to force fresh load after difficulty calculator changes\n    const cacheBuster = Date.now();\n    const url = `${SEQUENCE_INDEX_URL}?v=${cacheBuster}`;\n\n    const response = await fetch(url, {\n      cache: \"no-store\", // Prevent browser caching\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to load sequence index: ${response.status}`);\n    }\n\n    const data = (await response.json()) as { sequences?: RawSequenceData[] };\n    return data.sequences || [];\n  }\n\n  // ============================================================================\n  // Data Processing\n  // ============================================================================\n\n  private processRawSequences(\n    rawSequences: RawSequenceData[]\n  ): SequenceData[] {\n    const sequences: SequenceData[] = [];\n\n    for (const rawSeq of rawSequences) {\n      const word = this.extractWord(rawSeq);\n\n      if (!this.isValidWord(word)) {\n        console.warn(`üö´ Skipping invalid sequence: ${word}`);\n        continue;\n      }\n\n      // Cache the raw sequence for later lazy loading\n      this.sequenceCache.set(word, rawSeq);\n\n      try {\n        const sequence = this.createSequenceFromRaw(rawSeq, word);\n        sequences.push(sequence);\n      } catch (error) {\n        const shouldLog = !this.isRoutineError(error);\n        if (shouldLog) {\n          console.warn(`‚ö†Ô∏è Failed to process ${word}:`, error);\n        }\n\n        // Use fallback sequence creation\n        const fallbackSequence = this.createFallbackSequence(rawSeq, word);\n        sequences.push(fallbackSequence);\n      }\n    }\n\n    return sequences;\n  }\n\n  // ============================================================================\n  // Sequence Creation\n  // ============================================================================\n\n  private createSequenceFromRaw(\n    rawSeq: RawSequenceData,\n    word: string\n  ): SequenceData {\n    // ‚ö° PERFORMANCE FIX: Skip expensive metadata extraction during initial load\n    // The sequence-index.json already has all the data we need for the gallery view\n    // Full beat data will be loaded lazily when user clicks on a sequence\n\n    const gridMode = this.parseGridMode(rawSeq.gridMode) || GridMode.BOX;\n    const dateAdded = this.parseDate(rawSeq.dateAdded) || new Date();\n\n    // Get difficulty from sequence-index.json (no need to extract from .meta.json)\n    const difficultyLevel = this.parseDifficulty(rawSeq.difficultyLevel);\n\n    // Calculate numeric level from difficulty string\n    const calculatedLevel = this.difficultyStringToLevel(difficultyLevel);\n\n    return createSequenceData({\n      id: word,\n      name: this.cleanSequenceName(\n        String(rawSeq.name ?? word ?? \"Unnamed Sequence\")\n      ),\n      word,\n      beats: [], // Empty - will be loaded lazily via loadFullSequenceData()\n      thumbnails: this.parseThumbnails(rawSeq.thumbnails),\n      isFavorite: Boolean(rawSeq.isFavorite),\n      isCircular: Boolean(rawSeq.isCircular),\n      tags: this.parseTags(rawSeq.tags),\n      metadata: this.parseMetadata(rawSeq.metadata),\n      author: String(rawSeq.author ?? \"Unknown\"),\n      gridMode,\n      difficultyLevel,\n      sequenceLength: this.parseSequenceLength(rawSeq.sequenceLength),\n      level: calculatedLevel,\n      dateAdded,\n      propType: (rawSeq.propType || \"Staff\") as PropType,\n      startingPositionGroup: (rawSeq.startingPosition ||\n        \"alpha\") as GridPositionGroup,\n    });\n  }\n\n  private createFallbackSequence(\n    rawSeq: RawSequenceData,\n    word: string\n  ): SequenceData {\n    const gridMode = this.parseGridMode(rawSeq.gridMode) || GridMode.BOX;\n    const dateAdded = this.parseDate(rawSeq.dateAdded) || new Date();\n\n    // Get difficulty and calculate numeric level\n    const difficultyLevel = this.parseDifficulty(rawSeq.difficultyLevel);\n    const calculatedLevel = this.difficultyStringToLevel(difficultyLevel);\n\n    return createSequenceData({\n      id: word,\n      name: this.cleanSequenceName(\n        String(rawSeq.name ?? word ?? \"Unnamed Sequence\")\n      ),\n      word,\n      beats: [],\n      thumbnails: this.parseThumbnails(rawSeq.thumbnails),\n      isFavorite: Boolean(rawSeq.isFavorite),\n      isCircular: Boolean(rawSeq.isCircular),\n      tags: this.parseTags(rawSeq.tags),\n      metadata: this.parseMetadata(rawSeq.metadata),\n      author: String(rawSeq.author ?? \"Unknown\"),\n      gridMode,\n      difficultyLevel,\n      sequenceLength: this.parseSequenceLength(rawSeq.sequenceLength),\n      level: calculatedLevel, // Use calculated level instead of old stored value\n      dateAdded,\n      propType: (rawSeq.propType || \"Staff\") as PropType,\n      startingPositionGroup: (rawSeq.startingPosition ||\n        \"alpha\") as GridPositionGroup,\n    });\n  }\n\n  // ============================================================================\n  // Validation\n  // ============================================================================\n\n  private extractWord(rawSeq: RawSequenceData): string {\n    return rawSeq.word ?? rawSeq.name ?? rawSeq.id ?? \"\";\n  }\n\n  private isValidWord(word: string): boolean {\n    return (\n      word.length > 0 &&\n      word.length <= MAX_WORD_LENGTH &&\n      !word.toLowerCase().includes(\"test\")\n    );\n  }\n\n  private isRoutineError(error: unknown): boolean {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    return errorMessage.includes(\"No valid version found\");\n  }\n\n  // ============================================================================\n  // Data Parsing Helpers\n  // ============================================================================\n\n  private parseThumbnails(value: unknown): string[] {\n    return Array.isArray(value) ? (value as string[]) : [];\n  }\n\n  private parseTags(value: unknown): string[] {\n    return Array.isArray(value) ? (value as string[]) : [\"flow\", \"practice\"];\n  }\n\n  private parseMetadata(value: unknown): Record<string, unknown> {\n    return typeof value === \"object\" && value !== null\n      ? (value as Record<string, unknown>)\n      : { source: \"tka_dictionary\" };\n  }\n\n  private parseGridMode(value: unknown): GridMode | null {\n    if (!value) return null;\n\n    if (typeof value === \"string\") {\n      const normalized = value.toLowerCase();\n      if (normalized === \"gridmode.diamond\" || normalized === \"diamond\") {\n        return GridMode.DIAMOND;\n      }\n      if (normalized === \"gridmode.box\" || normalized === \"box\") {\n        return GridMode.BOX;\n      }\n    }\n\n    return value as GridMode;\n  }\n\n  private parseDifficulty(value: unknown): string {\n    return typeof value === \"string\" ? value : \"beginner\";\n  }\n\n  private parseSequenceLength(value: unknown): number {\n    return typeof value === \"number\" ? value : 0;\n  }\n\n  /**\n   * Convert difficulty string to numeric level for SequenceCard styling\n   * This ensures the card uses the NEW calculated difficulty, not old stored values\n   */\n  private difficultyStringToLevel(difficulty: string): number {\n    const normalized = difficulty.toLowerCase();\n    switch (normalized) {\n      case \"beginner\":\n        return 1;\n      case \"intermediate\":\n        return 2;\n      case \"advanced\":\n        return 3;\n      case \"mythic\":\n        return 4;\n      case \"legendary\":\n        return 5;\n      default:\n        return 1; // Default to beginner\n    }\n  }\n\n  private parseDate(value: unknown): Date | null {\n    if (!value) return null;\n\n    if (value instanceof Date) {\n      return value;\n    }\n\n    if (typeof value === \"string\") {\n      const date = new Date(value);\n      return isNaN(date.getTime()) ? null : date;\n    }\n\n    return null;\n  }\n\n  /**\n   * Remove \" Sequence\" suffix from sequence names\n   */\n  private cleanSequenceName(name: string): string {\n    return name.replace(/\\s+Sequence$/i, \"\");\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\_THE KINETIC ALPHABET\\_TKA-STUDIO\\src\\lib\\modules\\explore\\gallery\\display\\services\\implementations\\ExploreMetadataExtractor.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":159,"column":31,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":159,"endColumn":40},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":177,"column":30,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":177,"endColumn":38},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":274,"column":29,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":274,"endColumn":31,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[8601,8603],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Explore Metadata Extractor Service\n *\n * Extracts metadata from sequence files (PNG, WebP, or JSON sidecars)\n * with proper error handling and type safety.\n */\n\nimport type { BeatData } from \"$shared\";\nimport {\n  createMotionData,\n  GridLocation,\n  GridMode,\n  MotionColor,\n  MotionType,\n  Orientation,\n  RotationDirection,\n} from \"$shared\";\nimport { TYPES } from \"$shared/inversify/types\";\nimport { PropType } from \"$shared/pictograph/prop/domain/enums/PropType\";\nimport { UniversalMetadataExtractor } from \"$shared/services/UniversalMetadataExtractor\";\nimport { inject, injectable } from \"inversify\";\nimport type {\n  IExploreMetadataExtractor,\n  SequenceMetadata,\n} from \"../contracts/IExploreMetadataExtractor\";\nimport type { ISequenceDifficultyCalculator } from \"../contracts/ISequenceDifficultyCalculator\";\n// Constants for metadata extraction\n// Using function to avoid module-level enum reference (fixes test initialization)\nconst getDefaultMetadata = (): SequenceMetadata => ({\n  beats: [],\n  author: \"Unknown\",\n  difficultyLevel: \"beginner\",\n  dateAdded: new Date(),\n  gridMode: GridMode.DIAMOND,\n  isCircular: false,\n  propType: \"Staff\" as PropType,\n  sequenceLength: 0,\n  startingPosition: \"alpha\",\n});\n\nconst DATE_FIELD_NAMES = [\n  \"date_added\",\n  \"dateAdded\",\n  \"date\",\n  \"created_date\",\n  \"timestamp\",\n] as const;\n\n@injectable()\nexport class ExploreMetadataExtractor implements IExploreMetadataExtractor {\n  constructor(\n    @inject(TYPES.ISequenceDifficultyCalculator)\n    private readonly difficultyCalculator: ISequenceDifficultyCalculator\n  ) {}\n\n  async extractMetadata(\n    sequenceName: string,\n    thumbnailPath?: string\n  ): Promise<SequenceMetadata> {\n    try {\n      const sequenceWithVersion = this.determineSequenceVersion(\n        sequenceName,\n        thumbnailPath\n      );\n\n      const result =\n        await UniversalMetadataExtractor.extractMetadata(sequenceWithVersion);\n\n      if (!result.success || !result.data) {\n        return getDefaultMetadata();\n      }\n\n      return this.parseMetadataResult(sequenceName, result.data);\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n\n      // Only log non-routine errors\n      if (!errorMessage.includes(\"No valid version found\")) {\n        console.warn(\n          `‚ö†Ô∏è Failed to extract metadata for ${sequenceName}:`,\n          error\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Determine the sequence version from thumbnail path or default to ver1\n   */\n  private determineSequenceVersion(\n    sequenceName: string,\n    thumbnailPath?: string\n  ): string {\n    if (!thumbnailPath) {\n      return `${sequenceName}_ver1`;\n    }\n\n    const versionMatch = thumbnailPath.match(/_ver(\\d+)\\.webp$/);\n    if (versionMatch) {\n      const version = versionMatch[1];\n      return `${sequenceName}_ver${version}`;\n    }\n\n    return `${sequenceName}_ver1`;\n  }\n\n  /**\n   * Parse raw metadata into typed SequenceMetadata\n   */\n  private parseMetadataResult(\n    sequenceName: string,\n    rawData: Record<string, unknown>\n  ): SequenceMetadata {\n    const beats = this.parseBeats(sequenceName, rawData[\"sequence\"]);\n    const gridMode = this.parseGridMode(rawData[\"grid_mode\"]);\n\n    // Calculate difficulty from actual sequence data instead of stored level\n    const difficultyLevel = this.calculateDifficultyLevel(beats);\n\n    const dateAdded = this.parseDateAdded(rawData);\n    const startingPosition = this.parseStartingPosition(beats);\n\n    return {\n      beats,\n      author: String(rawData[\"author\"] || \"Unknown\"),\n      difficultyLevel,\n      dateAdded,\n      gridMode,\n      isCircular: Boolean(rawData[\"is_circular\"]),\n      propType: String(rawData[\"prop_type\"] || \"Staff\") as PropType,\n      sequenceLength: beats.length,\n      startingPosition,\n    };\n  }\n\n  /**\n   * Parse beat data from sequence array with full motion parsing\n   */\n  private parseBeats(sequenceName: string, sequence: unknown): BeatData[] {\n    if (!Array.isArray(sequence)) {\n      return [];\n    }\n\n    return sequence.map((step: unknown, index: number) => {\n      const stepData = step as Record<string, unknown>;\n      const blueAttrs = stepData[\"blue_attributes\"] as Record<string, unknown>;\n      const redAttrs = stepData[\"red_attributes\"] as Record<string, unknown>;\n\n      return {\n        // PictographData properties\n        id: `beat-${sequenceName}-${index + 1}`,\n        letter: String(stepData[\"letter\"] || \"\"),\n        startPosition: null,\n        endPosition: null,\n        motions: {\n          [MotionColor.BLUE]: blueAttrs\n            ? createMotionData({\n                color: MotionColor.BLUE,\n                motionType: this.parseMotionType(blueAttrs[\"motion_type\"]),\n                startLocation: this.parseLocation(blueAttrs[\"start_loc\"]),\n                endLocation: this.parseLocation(blueAttrs[\"end_loc\"]),\n                startOrientation: this.parseOrientation(blueAttrs[\"start_ori\"]),\n                endOrientation: this.parseOrientation(blueAttrs[\"end_ori\"]),\n                rotationDirection: this.parseRotationDirection(\n                  blueAttrs[\"prop_rot_dir\"]\n                ),\n                turns: this.parseTurns(blueAttrs[\"turns\"]),\n                isVisible: true,\n                propType: PropType.STAFF,\n                arrowLocation: this.parseLocation(blueAttrs[\"start_loc\"]),\n                gridMode: GridMode.DIAMOND,\n              })\n            : undefined,\n          [MotionColor.RED]: redAttrs\n            ? createMotionData({\n                color: MotionColor.RED,\n                motionType: this.parseMotionType(redAttrs[\"motion_type\"]),\n                startLocation: this.parseLocation(redAttrs[\"start_loc\"]),\n                endLocation: this.parseLocation(redAttrs[\"end_loc\"]),\n                startOrientation: this.parseOrientation(redAttrs[\"start_ori\"]),\n                endOrientation: this.parseOrientation(redAttrs[\"end_ori\"]),\n                rotationDirection: this.parseRotationDirection(\n                  redAttrs[\"prop_rot_dir\"]\n                ),\n                turns: this.parseTurns(redAttrs[\"turns\"]),\n                isVisible: true,\n                propType: PropType.STAFF,\n                arrowLocation: this.parseLocation(redAttrs[\"start_loc\"]),\n                gridMode: GridMode.DIAMOND,\n              })\n            : undefined,\n        },\n        // Beat context properties\n        beatNumber: Number(stepData[\"beat\"] || index + 1),\n        duration: 1.0,\n        blueReversal: false,\n        redReversal: false,\n        isBlank: false,\n      } as BeatData;\n    });\n  }\n\n  /**\n   * Parse grid mode with fallback\n   */\n  private parseGridMode(gridModeValue: unknown): GridMode {\n    if (gridModeValue === \"diamond\") {\n      return GridMode.DIAMOND;\n    }\n    if (gridModeValue === \"box\") {\n      return GridMode.BOX;\n    }\n    return GridMode.DIAMOND;\n  }\n\n  /**\n   * Calculate difficulty level from actual beat data\n   * Replaces the old parseDifficultyLevel that just read a stored value\n   */\n  private calculateDifficultyLevel(beats: BeatData[]): string {\n    const numericLevel =\n      this.difficultyCalculator.calculateDifficultyLevel(beats);\n    return this.difficultyCalculator.levelToString(numericLevel);\n  }\n\n  /**\n   * Parse motion type with fallback\n   */\n  private parseMotionType(value: unknown): MotionType {\n    const str = String(value || \"\").toLowerCase();\n    switch (str) {\n      case \"pro\":\n        return MotionType.PRO;\n      case \"anti\":\n        return MotionType.ANTI;\n      case \"float\":\n        return MotionType.FLOAT;\n      case \"dash\":\n        return MotionType.DASH;\n      case \"static\":\n        return MotionType.STATIC;\n      default:\n        return MotionType.STATIC;\n    }\n  }\n\n  /**\n   * Parse grid location with fallback\n   */\n  private parseLocation(value: unknown): GridLocation {\n    const str = String(value || \"\").toUpperCase();\n    // Map common location strings to GridLocation enum values\n    const locationMap: Record<string, GridLocation> = {\n      N: GridLocation.NORTH,\n      NORTH: GridLocation.NORTH,\n      E: GridLocation.EAST,\n      EAST: GridLocation.EAST,\n      S: GridLocation.SOUTH,\n      SOUTH: GridLocation.SOUTH,\n      W: GridLocation.WEST,\n      WEST: GridLocation.WEST,\n      NE: GridLocation.NORTHEAST,\n      NORTHEAST: GridLocation.NORTHEAST,\n      SE: GridLocation.SOUTHEAST,\n      SOUTHEAST: GridLocation.SOUTHEAST,\n      SW: GridLocation.SOUTHWEST,\n      SOUTHWEST: GridLocation.SOUTHWEST,\n      NW: GridLocation.NORTHWEST,\n      NORTHWEST: GridLocation.NORTHWEST,\n    };\n    return locationMap[str] || GridLocation.NORTH;\n  }\n\n  /**\n   * Parse orientation with fallback\n   */\n  private parseOrientation(value: unknown): Orientation {\n    const str = String(value || \"\").toLowerCase();\n    switch (str) {\n      case \"in\":\n        return Orientation.IN;\n      case \"out\":\n        return Orientation.OUT;\n      case \"clock\":\n      case \"clockwise\":\n        return Orientation.CLOCK;\n      case \"counter\":\n      case \"counterclockwise\":\n        return Orientation.COUNTER;\n      default:\n        return Orientation.IN;\n    }\n  }\n\n  /**\n   * Parse rotation direction with fallback\n   */\n  private parseRotationDirection(value: unknown): RotationDirection {\n    const str = String(value || \"\").toLowerCase();\n    switch (str) {\n      case \"cw\":\n      case \"clockwise\":\n        return RotationDirection.CLOCKWISE;\n      case \"ccw\":\n      case \"counterclockwise\":\n      case \"counter_clockwise\":\n        return RotationDirection.COUNTER_CLOCKWISE;\n      case \"no_rotation\":\n      case \"norotation\":\n        return RotationDirection.NO_ROTATION;\n      default:\n        return RotationDirection.NO_ROTATION;\n    }\n  }\n\n  /**\n   * Parse turns value (can be number or \"fl\" for float)\n   */\n  private parseTurns(value: unknown): number | \"fl\" {\n    if (value === \"fl\" || value === \"float\") {\n      return \"fl\";\n    }\n    const num = Number(value);\n    return isNaN(num) ? 0 : num;\n  }\n\n  /**\n   * Parse date from various possible field names\n   */\n  private parseDateAdded(rawData: Record<string, unknown>): Date {\n    for (const fieldName of DATE_FIELD_NAMES) {\n      const fieldValue = rawData[fieldName];\n      if (fieldValue) {\n        try {\n          const date = new Date(String(fieldValue));\n          if (!isNaN(date.getTime())) {\n            return date;\n          }\n        } catch {\n          // Continue to next field\n        }\n      }\n    }\n\n    return new Date();\n  }\n\n  /**\n   * Extract starting position from first beat\n   */\n  private parseStartingPosition(beats: BeatData[]): string {\n    if (beats.length > 0) {\n      const firstLetter = beats[0]?.letter;\n      if (firstLetter) {\n        return firstLetter;\n      }\n    }\n    return \"alpha\";\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\_THE KINETIC ALPHABET\\_TKA-STUDIO\\src\\lib\\modules\\explore\\gallery\\display\\services\\implementations\\SequenceDifficultyCalculator.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":27,"column":10,"nodeType":"Identifier","messageId":"alwaysFalsy","endLine":27,"endColumn":15},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":36,"column":12,"nodeType":"MemberExpression","messageId":"alwaysFalsy","endLine":36,"endColumn":24},{"ruleId":"@typescript-eslint/no-redundant-type-constituents","severity":1,"message":"'any' overrides all other types in this union type.","line":82,"column":47,"nodeType":"TSTypeReference","messageId":"overrides","endLine":82,"endColumn":57},{"ruleId":"@typescript-eslint/no-redundant-type-constituents","severity":1,"message":"'any' overrides all other types in this union type.","line":82,"column":77,"nodeType":"TSTypeReference","messageId":"overrides","endLine":82,"endColumn":87},{"ruleId":"@typescript-eslint/no-redundant-type-constituents","severity":1,"message":"'any' overrides all other types in this union type.","line":102,"column":32,"nodeType":"TSTypeReference","messageId":"overrides","endLine":102,"endColumn":42},{"ruleId":"@typescript-eslint/no-redundant-type-constituents","severity":1,"message":"'any' overrides all other types in this union type.","line":102,"column":62,"nodeType":"TSTypeReference","messageId":"overrides","endLine":102,"endColumn":72},{"ruleId":"@typescript-eslint/no-redundant-type-constituents","severity":1,"message":"'any' overrides all other types in this union type.","line":109,"column":34,"nodeType":"TSTypeReference","messageId":"overrides","endLine":109,"endColumn":44}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .startOrientation on an `any` value.","line":85,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":85,"endColumn":35,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .endOrientation on an `any` value.","line":86,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":86,"endColumn":33,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .startOrientation on an `any` value.","line":87,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":87,"endColumn":34,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .endOrientation on an `any` value.","line":88,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":88,"endColumn":32,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .turns on an `any` value.","line":116,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":116,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .turns on an `any` value.","line":121,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":121,"endColumn":28,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .turns on an `any` value.","line":122,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":122,"endColumn":26,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":2,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Sequence Difficulty Calculator Implementation\n *\n * Analyzes sequence beat data to determine difficulty level based on:\n * - Turn values (0, whole numbers, half values, floats)\n * - Orientation types (radial IN/OUT vs non-radial CLOCK/COUNTER)\n *\n * This replaces storing difficulty in metadata and calculates it on-the-fly.\n */\n\nimport { injectable } from \"inversify\";\nimport type { BeatData } from \"$shared\";\nimport {\n  Orientation,\n  MotionColor,\n} from \"$shared/pictograph/shared/domain/enums/pictograph-enums\";\nimport type { ISequenceDifficultyCalculator } from \"../contracts/ISequenceDifficultyCalculator\";\n\n@injectable()\nexport class SequenceDifficultyCalculator\n  implements ISequenceDifficultyCalculator\n{\n  /**\n   * Calculate difficulty level by analyzing all beats in the sequence\n   */\n  calculateDifficultyLevel(beats: BeatData[]): number {\n    if (!beats || beats.length === 0) {\n      return 1; // Default to beginner for empty sequences\n    }\n\n    let hasNonRadialOrientation = false;\n    let hasTurns = false;\n\n    // Analyze all beats\n    for (const beat of beats) {\n      if (!beat.motions) continue;\n\n      // Check both blue and red motions\n      const blueMotion = beat.motions[MotionColor.BLUE];\n      const redMotion = beat.motions[MotionColor.RED];\n\n      // Check for non-radial orientations\n      if (this.hasNonRadialOrientation(blueMotion, redMotion)) {\n        hasNonRadialOrientation = true;\n      }\n\n      // Check for turns\n      if (this.hasTurns(blueMotion, redMotion)) {\n        hasTurns = true;\n      }\n    }\n\n    // Determine level based on findings\n    if (hasNonRadialOrientation) {\n      return 3; // Level 3: Contains non-radial orientations\n    } else if (hasTurns) {\n      return 2; // Level 2: Contains turns with radial orientations only\n    } else {\n      return 1; // Level 1: No turns, only radial orientations\n    }\n  }\n\n  /**\n   * Convert numeric level to difficulty string\n   */\n  levelToString(level: number): string {\n    switch (level) {\n      case 1:\n        return \"beginner\";\n      case 2:\n        return \"intermediate\";\n      case 3:\n        return \"advanced\";\n      default:\n        return \"beginner\";\n    }\n  }\n\n  /**\n   * Check if any motion has non-radial orientations (CLOCK or COUNTER)\n   */\n  private hasNonRadialOrientation(blueMotion: MotionData | null, redMotion: MotionData | null): boolean {\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n    const orientationsToCheck = [\n      blueMotion?.startOrientation,\n      blueMotion?.endOrientation,\n      redMotion?.startOrientation,\n      redMotion?.endOrientation,\n    ].filter((o): o is Orientation => o !== undefined && o !== null);\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n    return orientationsToCheck.some(\n      (orientation) =>\n        orientation === Orientation.CLOCK || orientation === Orientation.COUNTER\n    );\n  }\n\n  /**\n   * Check if any motion has turns greater than 0\n   * Handles both numeric turns and \"fl\" (float) values\n   */\n  private hasTurns(blueMotion: MotionData | null, redMotion: MotionData | null): boolean {\n    return this.motionHasTurns(blueMotion) || this.motionHasTurns(redMotion);\n  }\n\n  /**\n   * Check if a single motion has turns\n   */\n  private motionHasTurns(motion: MotionData | null): boolean {\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n    if (!motion) {\n      return false;\n    }\n\n    // Handle \"fl\" (float) case - this is considered a turn\n    if (motion.turns === \"fl\") {\n      return true;\n    }\n\n    // Handle numeric turns\n    if (typeof motion.turns === \"number\") {\n      return motion.turns > 0;\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n    return false;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\_THE KINETIC ALPHABET\\_TKA-STUDIO\\src\\lib\\modules\\learn\\codex\\services\\implementations\\CodexLetterMappingRepo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\_THE KINETIC ALPHABET\\_TKA-STUDIO\\src\\lib\\modules\\learn\\quiz\\services\\implementations\\AnswerCheckerService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"F:\\_THE KINETIC ALPHABET\\_TKA-STUDIO\\src\\lib\\modules\\learn\\quiz\\services\\implementations\\QuizConfigurator.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":33,"column":42,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":33,"endColumn":44,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[772,774],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":39,"column":45,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":39,"endColumn":47,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[1088,1090],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Lesson Config Service\n *\n * Manages lesson configurations, validation, and provides utilities\n * for working with different lesson types and quiz modes.\n */\n\nimport {\n  LESSON_CONFIGS,\n  LESSON_INFO,\n  LESSON_TYPE_NAMES,\n  QUIZ_DEFAULTS,\n  QUIZ_MODE_NAMES,\n  QuizAnswerFormat,\n  QuizMode,\n  QuizQuestionFormat,\n  QuizType,\n  type QuizConfig,\n  type QuizInfo,\n} from \"../../domain\";\n\nexport class QuizConfigurator {\n  /**\n   * Get configuration for a specific lesson type.\n   */\n  static getQuizConfig(lessonType: QuizType): QuizConfig {\n    const config = LESSON_CONFIGS[lessonType];\n    // Convert to domain QuizConfig format\n    return {\n      id: config.type,\n      type: config.type,\n      name: config.quizDescription,\n      description: config.questionPrompt || \"\",\n      includedCategories: [], // Default empty array\n      lessonType: config.lessonType,\n      questionFormat: config.questionFormat as QuizQuestionFormat,\n      answerFormat: config.answerFormat as QuizAnswerFormat,\n      quizDescription: config.quizDescription,\n      questionPrompt: config.questionPrompt || \"\",\n    };\n  }\n\n  /**\n   * Get lesson information for display.\n   */\n  static getQuizInfo(lessonType: QuizType): QuizInfo {\n    const info = LESSON_INFO.find((lesson) => lesson.lessonType === lessonType);\n    if (!info) {\n      throw new Error(`No lesson info found for lesson type: ${lessonType}`);\n    }\n    return info;\n  }\n\n  /**\n   * Get all available lesson types.\n   */\n  static getAvailableQuizTypes(): QuizType[] {\n    return Object.values(QuizType);\n  }\n\n  /**\n   * Get all available quiz modes.\n   */\n  static getAvailableQuizModes(): QuizMode[] {\n    return Object.values(QuizMode);\n  }\n\n  /**\n   * Get display name for a lesson type.\n   */\n  static getQuizTypeName(lessonType: QuizType): string {\n    return LESSON_TYPE_NAMES[lessonType] || lessonType;\n  }\n\n  /**\n   * Get display name for a quiz mode.\n   */\n  static getQuizModeName(quizMode: QuizMode): string {\n    return QUIZ_MODE_NAMES[quizMode] || quizMode;\n  }\n\n  /**\n   * Get total questions for a quiz mode.\n   */\n  static getTotalQuestions(quizMode: QuizMode): number {\n    switch (quizMode) {\n      case QuizMode.FIXED_QUESTION:\n        return QUIZ_DEFAULTS.FIXED_QUESTION_COUNT;\n      case QuizMode.COUNTDOWN:\n        return 0; // Unlimited questions in countdown mode\n      default:\n        return QUIZ_DEFAULTS.FIXED_QUESTION_COUNT;\n    }\n  }\n\n  /**\n   * Get quiz time for a quiz mode.\n   */\n  static getQuizTime(quizMode: QuizMode): number {\n    switch (quizMode) {\n      case QuizMode.COUNTDOWN:\n        return QUIZ_DEFAULTS.COUNTDOWN_TIME_SECONDS;\n      case QuizMode.FIXED_QUESTION:\n        return 0; // No time limit for fixed question mode\n      default: // QuizMode.FIXED_QUESTION\n        return QUIZ_DEFAULTS.COUNTDOWN_TIME_SECONDS;\n    }\n  }\n\n  /**\n   * Validate lesson configuration.\n   */\n  static validateQuizConfig(config: QuizConfig): boolean {\n    return (\n      Object.values(QuizType).includes(config.lessonType) &&\n      Object.values(QuizQuestionFormat).includes(config.questionFormat) &&\n      Object.values(QuizAnswerFormat).includes(config.answerFormat) &&\n      typeof config.quizDescription === \"string\" &&\n      typeof config.questionPrompt === \"string\"\n    );\n  }\n\n  /**\n   * Check if a lesson type supports a specific question format.\n   */\n  static supportsQuestionFormat(\n    lessonType: QuizType,\n    format: QuizQuestionFormat\n  ): boolean {\n    const config = this.getQuizConfig(lessonType);\n    return config.questionFormat === format;\n  }\n\n  /**\n   * Check if a lesson type supports a specific answer format.\n   */\n  static supportsAnswerFormat(\n    lessonType: QuizType,\n    format: QuizAnswerFormat\n  ): boolean {\n    const config = this.getQuizConfig(lessonType);\n    return config.answerFormat === format;\n  }\n\n  /**\n   * Get quiz number from quiz type (for display purposes).\n   */\n  static getQuizNumber(quizType: QuizType): number {\n    switch (quizType) {\n      case QuizType.PICTOGRAPH_TO_LETTER:\n        return 1;\n      case QuizType.LETTER_TO_PICTOGRAPH:\n        return 2;\n      case QuizType.VALID_NEXT_PICTOGRAPH:\n        return 3;\n      default:\n        return 0;\n    }\n  }\n\n  /**\n   * Get quiz type from quiz number.\n   */\n  static getQuizTypeFromNumber(quizNumber: number): QuizType | null {\n    switch (quizNumber) {\n      case 1:\n        return QuizType.PICTOGRAPH_TO_LETTER;\n      case 2:\n        return QuizType.LETTER_TO_PICTOGRAPH;\n      case 3:\n        return QuizType.VALID_NEXT_PICTOGRAPH;\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Get formatted quiz title for display.\n   */\n  static getFormattedQuizTitle(quizType: QuizType): string {\n    const quizNumber = this.getQuizNumber(quizType);\n    const quizName = this.getQuizTypeName(quizType);\n    return `Quiz ${quizNumber}: ${quizName}`;\n  }\n\n  /**\n   * Get quiz description for display.\n   */\n  static getQuizDescription(quizType: QuizType): string {\n    const info = this.getQuizInfo(quizType);\n    return info.description;\n  }\n\n  /**\n   * Check if a quiz is available (for future use with unlocking system).\n   */\n  static isQuizAvailable(_quizType: QuizType): boolean {\n    // For now, all quizzes are available\n    // This can be extended to support quiz unlocking logic\n    return true;\n  }\n\n  /**\n   * Get recommended quiz mode for a quiz type.\n   */\n  static getRecommendedQuizMode(quizType: QuizType): QuizMode {\n    // For beginners, start with fixed questions\n    // More advanced quizzes could default to countdown\n    switch (quizType) {\n      case QuizType.PICTOGRAPH_TO_LETTER:\n        return QuizMode.FIXED_QUESTION;\n      case QuizType.LETTER_TO_PICTOGRAPH:\n        return QuizMode.FIXED_QUESTION;\n      case QuizType.VALID_NEXT_PICTOGRAPH:\n        return QuizMode.COUNTDOWN; // More challenging quiz\n      default:\n        return QuizMode.FIXED_QUESTION;\n    }\n  }\n\n  /**\n   * Get difficulty level for a quiz type (1-5 scale).\n   */\n  static getDifficultyLevel(quizType: QuizType): number {\n    switch (quizType) {\n      case QuizType.PICTOGRAPH_TO_LETTER:\n        return 1; // Easiest - just matching pictograph to letter\n      case QuizType.LETTER_TO_PICTOGRAPH:\n        return 2; // Medium - requires understanding pictograph structure\n      case QuizType.VALID_NEXT_PICTOGRAPH:\n        return 4; // Hardest - requires understanding flow and transitions\n      default:\n        return 1;\n    }\n  }\n\n  /**\n   * Get estimated completion time for a quiz (in minutes).\n   */\n  static getEstimatedCompletionTime(\n    quizType: QuizType,\n    quizMode: QuizMode\n  ): number {\n    const baseTime = this.getDifficultyLevel(quizType) * 2; // 2 minutes per difficulty level\n\n    switch (quizMode) {\n      case QuizMode.FIXED_QUESTION:\n        return baseTime + 5; // Add 5 minutes for fixed questions\n      case QuizMode.COUNTDOWN:\n        return 2; // Countdown mode is always 2 minutes\n      default:\n        return baseTime;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\_THE KINETIC ALPHABET\\_TKA-STUDIO\\src\\lib\\modules\\word-card\\services\\implementations\\PrintablePageLayoutService.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":209,"column":21,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":209,"endColumn":36},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":362,"column":9,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":362,"endColumn":33},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":362,"column":37,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":362,"endColumn":59}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Printable Page Layout Service Implementation\n *\n * Handles calculations for printable page layouts including paper sizes,\n * margins, grid configurations, and measurement conversions.\n *\n * Based on desktop application's printable_layout.py functionality.\n */\n\nimport type {\n  DPIConfiguration,\n  GridCalculationOptions,\n  LayoutCalculationRequest,\n  LayoutCalculationResult,\n  LayoutValidationError,\n  LayoutValidationResult,\n  LayoutValidationWarning,\n  PageDimensions,\n  PageLayoutConfig,\n  PageMargins,\n  PageOrientation,\n  Rectangle,\n  WordCardGridConfig,\n  WordCardPaperSize,\n} from \"$shared\";\nimport { injectable } from \"inversify\";\nimport type { IPrintablePageLayoutService } from \"../contracts\";\n\n@injectable()\nexport class PrintablePageLayoutService implements IPrintablePageLayoutService {\n  private readonly paperSizes = {\n    A4: { width: 595, height: 842 },\n    A3: { width: 842, height: 1191 },\n    Letter: { width: 612, height: 792 },\n    Legal: { width: 612, height: 1008 },\n    Tabloid: { width: 792, height: 1224 },\n  };\n\n  private readonly defaultMargins: PageMargins = {\n    top: 36, // 0.5 inch\n    right: 18, // 0.25 inch\n    bottom: 36, // 0.5 inch\n    left: 18, // 0.25 inch\n  };\n\n  private readonly dpiConfig: DPIConfiguration = {\n    screenDPI: 96,\n    printDPI: 300,\n    scaleFactor: 1.0,\n  };\n\n  calculatePageDimensions(\n    paperSize: WordCardPaperSize,\n    orientation: PageOrientation\n  ): PageDimensions {\n    const dimensions = this.paperSizes[paperSize];\n\n    if (orientation === \"landscape\") {\n      return {\n        width: dimensions.height,\n        height: dimensions.width,\n      };\n    }\n\n    return {\n      width: dimensions.width,\n      height: dimensions.height,\n    };\n  }\n\n  calculateMargins(_paperSize: WordCardPaperSize): PageMargins {\n    // For now, use default margins for all paper sizes\n    // Could be extended to have paper-specific margins\n    return { ...this.defaultMargins };\n  }\n\n  calculateContentArea(\n    pageSize: PageDimensions,\n    margins: PageMargins\n  ): Rectangle {\n    return {\n      x: margins.left,\n      y: margins.top,\n      width: pageSize.width - margins.left - margins.right,\n      height: pageSize.height - margins.top - margins.bottom,\n    };\n  }\n\n  calculateOptimalGrid(\n    cardAspectRatio: number,\n    contentArea: Rectangle,\n    options: Partial<GridCalculationOptions> = {}\n  ): WordCardGridConfig {\n    const opts: GridCalculationOptions = {\n      minCardsPerPage: 2,\n      maxCardsPerPage: 12,\n      preferSquareLayout: false,\n      prioritizeCardSize: true,\n      allowPartialLastPage: true,\n      ...options,\n    };\n\n    let bestGrid: WordCardGridConfig | null = null;\n    let bestScore = 0;\n\n    // Try different grid configurations\n    for (\n      let totalCards = opts.minCardsPerPage;\n      totalCards <= opts.maxCardsPerPage;\n      totalCards++\n    ) {\n      for (let rows = 1; rows <= Math.ceil(Math.sqrt(totalCards)); rows++) {\n        const cols = Math.ceil(totalCards / rows);\n\n        if (rows * cols < totalCards && !opts.allowPartialLastPage) {\n          continue;\n        }\n\n        const cellWidth = contentArea.width / cols;\n        const cellHeight = contentArea.height / rows;\n\n        // Calculate card dimensions maintaining aspect ratio\n        let cardWidth = cellWidth * 0.9; // Leave some spacing\n        let cardHeight = cardWidth / cardAspectRatio;\n\n        if (cardHeight > cellHeight * 0.9) {\n          cardHeight = cellHeight * 0.9;\n          cardWidth = cardHeight * cardAspectRatio;\n        }\n\n        // Calculate score based on card size and layout efficiency\n        const cardArea = cardWidth * cardHeight;\n        const totalUsedArea = totalCards * cardArea;\n        const totalAvailableArea = contentArea.width * contentArea.height;\n        const utilization = totalUsedArea / totalAvailableArea;\n\n        // Prefer layouts that maximize card size if prioritizeCardSize is true\n        const cardSizeScore = opts.prioritizeCardSize\n          ? cardArea / (contentArea.width * contentArea.height)\n          : 0.5;\n        const utilizationScore = Math.min(utilization, 1.0);\n        const layoutScore = opts.preferSquareLayout\n          ? 1 - Math.abs(rows - cols) / Math.max(rows, cols)\n          : 0.5;\n\n        const score =\n          cardSizeScore * 0.4 + utilizationScore * 0.4 + layoutScore * 0.2;\n\n        if (score > bestScore) {\n          bestScore = score;\n          bestGrid = {\n            rows,\n            columns: cols,\n            spacing: Math.min(\n              (cellWidth - cardWidth) / 2,\n              (cellHeight - cardHeight) / 2\n            ),\n            cardWidth,\n            cardHeight,\n          };\n        }\n      }\n    }\n\n    // Fallback to simple 2x2 if no optimal grid found\n    if (!bestGrid) {\n      const cellWidth = contentArea.width / 2;\n      const cellHeight = contentArea.height / 2;\n      const cardWidth = cellWidth * 0.9;\n      const cardHeight = cardWidth / cardAspectRatio;\n\n      bestGrid = {\n        rows: 2,\n        columns: 2,\n        spacing: Math.min(\n          (cellWidth - cardWidth) / 2,\n          (cellHeight - cardHeight) / 2\n        ),\n        cardWidth,\n        cardHeight,\n      };\n    }\n\n    return bestGrid;\n  }\n\n  getPageSizeInPixels(\n    paperSize: WordCardPaperSize,\n    orientation: PageOrientation,\n    dpi: number = this.dpiConfig.screenDPI\n  ): PageDimensions {\n    const pointDimensions = this.calculatePageDimensions(\n      paperSize,\n      orientation\n    );\n    const scaleFactor = dpi / 72; // Convert from points to pixels\n\n    return {\n      width: Math.round(pointDimensions.width * scaleFactor),\n      height: Math.round(pointDimensions.height * scaleFactor),\n    };\n  }\n\n  calculateLayout(request: LayoutCalculationRequest): LayoutCalculationResult {\n    const pageDimensions = this.calculatePageDimensions(\n      request.paperSize,\n      request.orientation\n    );\n    const margins = request.margins || this.calculateMargins(request.paperSize);\n    const contentArea = this.calculateContentArea(pageDimensions, margins);\n\n    const gridOptions: GridCalculationOptions = {\n      minCardsPerPage: 2,\n      maxCardsPerPage: request.preferredCardsPerPage ?? 12,\n      preferSquareLayout: false,\n      prioritizeCardSize: true,\n      allowPartialLastPage: true,\n    };\n\n    const gridConfig = this.calculateOptimalGrid(\n      request.cardAspectRatio || 0.7,\n      contentArea,\n      gridOptions\n    );\n\n    const cardsPerPage = gridConfig.rows * gridConfig.columns;\n\n    // Calculate utilization\n    const cardArea = gridConfig.cardWidth * gridConfig.cardHeight;\n    const totalCardArea = cardsPerPage * cardArea;\n    const contentAreaSize = contentArea.width * contentArea.height;\n    const utilization = Math.min(totalCardArea / contentAreaSize, 1.0);\n\n    // Consider layout optimal if utilization > 0.6 and card size is reasonable\n    const minCardSize = Math.min(contentArea.width, contentArea.height) * 0.2;\n    const isOptimal =\n      utilization > 0.6 &&\n      Math.min(gridConfig.cardWidth, gridConfig.cardHeight) > minCardSize;\n\n    return {\n      isOptimal,\n      gridConfig: {\n        rows: gridConfig.rows,\n        columns: gridConfig.columns,\n        cardWidth: gridConfig.cardWidth,\n        cardHeight: gridConfig.cardHeight,\n        spacing: gridConfig.spacing,\n      },\n      pageConfig: {\n        printConfig: {\n          paperSize: request.paperSize,\n          orientation: request.orientation,\n          margins,\n          dpi: this.dpiConfig.printDPI,\n          enablePageNumbers: false,\n          enableHeader: false,\n          enableFooter: false,\n        },\n        gridOptions: {\n          minCardsPerPage: 1,\n          maxCardsPerPage: 12,\n          preferSquareLayout: false,\n          prioritizeCardSize: true,\n          allowPartialLastPage: true,\n        },\n        sequencesPerPage: gridConfig.rows * gridConfig.columns,\n        enableOptimization: true,\n      },\n      utilization,\n    };\n  }\n\n  validateLayout(config: PageLayoutConfig): LayoutValidationResult {\n    const errors: LayoutValidationError[] = [];\n    const warnings: LayoutValidationWarning[] = [];\n\n    // Validate margins\n    const margins = config.printConfig.margins;\n    if (\n      margins.top < 0 ||\n      margins.right < 0 ||\n      margins.bottom < 0 ||\n      margins.left < 0\n    ) {\n      errors.push({\n        code: \"NEGATIVE_MARGINS\",\n        message: \"Margins cannot be negative\",\n        field: \"margins\",\n        severity: \"error\" as const,\n      });\n    }\n\n    // Validate sequences per page\n    if (config.sequencesPerPage < 1) {\n      errors.push({\n        code: \"INVALID_SEQUENCES_PER_PAGE\",\n        message: \"Sequences per page must be at least 1\",\n        field: \"sequencesPerPage\",\n        severity: \"error\" as const,\n      });\n    }\n\n    if (config.sequencesPerPage > 20) {\n      warnings.push({\n        code: \"HIGH_SEQUENCES_PER_PAGE\",\n        message:\n          \"High number of sequences per page may result in very small cards\",\n        severity: \"warning\",\n        suggestion:\n          \"Consider reducing sequences per page for better readability\",\n      });\n    }\n\n    // Check if margins are too large\n    const pageDimensions = this.calculatePageDimensions(\n      config.printConfig.paperSize,\n      config.printConfig.orientation\n    );\n    const totalMarginWidth = margins.left + margins.right;\n    const totalMarginHeight = margins.top + margins.bottom;\n\n    if (totalMarginWidth > pageDimensions.width * 0.5) {\n      warnings.push({\n        code: \"LARGE_HORIZONTAL_MARGINS\",\n        message: \"Horizontal margins are very large\",\n        severity: \"warning\",\n        suggestion: \"Consider reducing left and right margins\",\n      });\n    }\n\n    if (totalMarginHeight > pageDimensions.height * 0.5) {\n      warnings.push({\n        code: \"LARGE_VERTICAL_MARGINS\",\n        message: \"Vertical margins are very large\",\n        severity: \"warning\",\n        suggestion: \"Consider reducing top and bottom margins\",\n      });\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors: errors.map((e) => e.message),\n      warnings: warnings.map((w) => w.message),\n    };\n  }\n\n  getDPIConfiguration(): DPIConfiguration {\n    return { ...this.dpiConfig };\n  }\n\n  convertMeasurement(value: number, fromUnit: string, toUnit: string): number {\n    const units = {\n      points: 1,\n      inches: 72,\n      millimeters: 72 / 25.4,\n      centimeters: 72 / 2.54,\n    } as const;\n\n    const fromPoints = units[fromUnit as keyof typeof units];\n    const toPoints = units[toUnit as keyof typeof units];\n\n    if (fromPoints === undefined || toPoints === undefined) {\n      throw new Error(\n        `Invalid measurement unit. Supported: ${Object.keys(units).join(\", \")}`\n      );\n    }\n\n    // Convert to points, then to target unit\n    const valueInPoints = value * fromPoints;\n    return valueInPoints / toPoints;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\_THE KINETIC ALPHABET\\_TKA-STUDIO\\src\\lib\\modules\\word-card\\services\\implementations\\WordCardExportIntegrationService.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":98,"column":42,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":98,"endColumn":44,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[2950,2952],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":173,"column":32,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":173,"endColumn":50},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":369,"column":10,"nodeType":"MemberExpression","messageId":"alwaysFalsy","endLine":369,"endColumn":37}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Word Card Export Integration Service Implementation\n *\n * Bridges the gap between UI components and export services.\n * Handles DOM element selection, export orchestration, and file downloads.\n */\n\nimport type { IFileDownloadService } from \"$shared\";\nimport type { DownloadResult, ExportResult, SequenceData } from \"$shared\";\nimport { inject, injectable } from \"inversify\";\nimport { TYPES } from \"$shared/inversify/types\";\nimport type {\n  BatchExportResult,\n  WordCardExportOptions,\n} from \"../../domain/models/word-card-export\";\n\n// Local type definitions\n\n// File download functionality provided by FileDownloadService\n\nfunction generateTimestampedFilename(\n  prefix: string,\n  extension: string,\n  includeTime: boolean = true\n): string {\n  const now = new Date();\n  const date = now.toISOString().split(\"T\")[0];\n  const time = includeTime\n    ? (now.toTimeString().split(\" \")[0] ?? \"\").replace(/:/g, \"-\")\n    : \"\";\n  return `${prefix}_${date}${time ? \"_\" + time : \"\"}.${extension}`;\n}\n\nfunction sanitizeFilename(filename: string): string {\n  return filename.replace(/[^a-z0-9]/gi, \"_\").toLowerCase();\n}\n\nfunction supportsFileDownload(): boolean {\n  return typeof window !== \"undefined\" && \"document\" in window;\n}\n// import type {\n//   IPageImageExportService,\n//   IWordCardExportIntegrationService,\n// } from \"../contracts\";\n\ninterface IPageImageExportService {\n  exportPagesAsImages?(\n    pageElements: HTMLElement[],\n    options: WordCardExportOptions\n  ): Promise<BatchExportResult>;\n  cancelExport?(): Promise<void>;\n}\n\ninterface IWordCardExportIntegrationService {\n  exportWordCards(\n    sequences: SequenceData[],\n    options: WordCardExportOptions\n  ): Promise<ExportResult[]>;\n  cancelExport(): Promise<void>;\n}\n\n@injectable()\nexport class WordCardExportIntegrationService\n  implements IWordCardExportIntegrationService\n{\n  private isExporting = false;\n  private abortController: AbortController | null = null;\n\n  constructor(\n    @inject(TYPES.IFileDownloadService)\n    private fileDownloadService: IFileDownloadService,\n    private readonly pageImageExportService: IPageImageExportService\n  ) {}\n\n  async exportWordCards(\n    _sequences: SequenceData[],\n    options: WordCardExportOptions\n  ): Promise<ExportResult[]> {\n    // Filter options to only include supported formats\n    const filteredOptions = {\n      format:\n        options.format === \"PDF\"\n          ? \"PNG\"\n          : (options.format as \"PNG\" | \"JPEG\" | \"WebP\"),\n      quality: options.quality,\n      scale: options.scale,\n      ...(options.filename && { filenamePrefix: options.filename }),\n    };\n\n    // Delegate to the main export method\n    const result = await this.exportPrintablePagesAsImages(filteredOptions);\n\n    // Convert result to ExportResult format\n    const exportResult: ExportResult = {\n      success: result.successCount > 0,\n      filename: \"word-cards-export\",\n      ...(result.errors.length > 0 && {\n        error: result.errors[0]?.message || \"Unknown error\",\n      }),\n      metadata: {\n        format: \"PNG\", // Default format for word cards\n        size: 0, // Will be set when actual export happens\n        dimensions: { width: 800, height: 600 }, // Default dimensions\n        beatCount: 0, // Word cards don't have beats\n        processingTime: 0, // Will be measured during export\n        successCount: result.successCount,\n        failureCount: result.failureCount,\n        totalErrors: result.errors.length,\n      },\n    };\n\n    return [exportResult]; // Return as array to match interface\n  }\n\n  async exportPrintablePagesAsImages(\n    options: {\n      format?: \"PNG\" | \"JPEG\" | \"WebP\";\n      quality?: number;\n      scale?: number;\n      filenamePrefix?: string;\n    } = {},\n    onProgress?: (current: number, total: number, message: string) => void\n  ): Promise<{ successCount: number; failureCount: number; errors: Error[] }> {\n    console.log(\"üñºÔ∏è Starting export of all printable pages as images\");\n\n    // Validate export capability\n    const validation = this.validateExportCapability();\n    if (!validation.canExport) {\n      const error = new Error(\n        `Export not possible: ${validation.issues.join(\", \")}`\n      );\n      console.error(\"‚ùå Export validation failed:\", error);\n      return { successCount: 0, failureCount: 1, errors: [error] };\n    }\n\n    // Get page elements\n    const pageElements = this.getPrintablePageElements();\n    if (pageElements.length === 0) {\n      const error = new Error(\"No printable page elements found in DOM\");\n      console.error(\"‚ùå No page elements found:\", error);\n      return { successCount: 0, failureCount: 1, errors: [error] };\n    }\n\n    console.log(`üìÑ Found ${pageElements.length} page elements to export`);\n\n    try {\n      this.isExporting = true;\n      this.abortController = new AbortController();\n\n      // Prepare export options\n      const exportOptions = this.prepareImageExportOptions(options);\n      console.log(\"‚öôÔ∏è Export options prepared:\", exportOptions);\n\n      // Progress tracking\n      const totalCount = pageElements.length;\n\n      // Export pages to blobs\n      onProgress?.(0, totalCount, \"Starting page export...\");\n\n      if (!this.pageImageExportService.exportPagesAsImages) {\n        throw new Error(\"Export service not available\");\n      }\n\n      const batchResult = await this.pageImageExportService.exportPagesAsImages(\n        pageElements,\n        exportOptions\n      );\n\n      console.log(\"üìä Batch export result:\", batchResult);\n\n      // Prepare download data\n      const downloadData: Array<{ blob: Blob; filename: string }> = [];\n      const errors: Error[] = (batchResult.errors || []).map((err: unknown) =>\n        err instanceof Error ? err : new Error(String(err))\n      );\n\n      for (let i = 0; i < batchResult.results.length; i++) {\n        const result = batchResult.results[i];\n        if (!result) continue;\n\n        if (result.success && result.blob) {\n          const pageNumber = i + 1;\n          const filename = this.generatePageFilename(\n            options.filenamePrefix ?? \"word-cards\",\n            pageNumber,\n            exportOptions.format,\n            result.metrics?.resolution\n          );\n\n          downloadData.push({\n            blob: result.blob,\n            filename,\n          });\n        } else if (result.error) {\n          errors.push(\n            result.error instanceof Error\n              ? result.error\n              : new Error(String(result.error))\n          );\n        }\n      }\n\n      console.log(`üíæ Prepared ${downloadData.length} files for download`);\n\n      // Download files\n      if (downloadData.length > 0) {\n        onProgress?.(\n          totalCount,\n          totalCount,\n          `Downloading ${downloadData.length} files...`\n        );\n\n        const downloadResults =\n          await this.fileDownloadService.downloadBlobBatch(downloadData, {\n            delay: 200, // 200ms delay between downloads\n          });\n\n        // Check download results\n        const failedDownloads = downloadResults.filter(\n          (r: DownloadResult) => !r.success\n        );\n        if (failedDownloads.length > 0) {\n          console.warn(\"‚ö†Ô∏è Some downloads failed:\", failedDownloads);\n          failedDownloads.forEach((result: DownloadResult) => {\n            if (result.error) {\n              errors.push(result.error);\n            }\n          });\n        }\n\n        console.log(\n          `‚úÖ Successfully downloaded ${downloadData.length - failedDownloads.length} files`\n        );\n      }\n\n      onProgress?.(\n        totalCount,\n        totalCount,\n        `Export completed! ${batchResult.successCount} pages exported successfully.`\n      );\n\n      return {\n        successCount: batchResult.successCount,\n        failureCount: batchResult.failureCount,\n        errors,\n      };\n    } catch (error) {\n      console.error(\"‚ùå Export failed with error:\", error);\n      return {\n        successCount: 0,\n        failureCount: pageElements.length,\n        errors: [error as Error],\n      };\n    } finally {\n      this.isExporting = false;\n      this.abortController = null;\n    }\n  }\n\n  async exportSelectedPages(\n    pageIndices: number[],\n    options: {\n      format?: \"PNG\" | \"JPEG\" | \"WebP\";\n      quality?: number;\n      scale?: number;\n      filenamePrefix?: string;\n    } = {},\n    onProgress?: (current: number, total: number, message: string) => void\n  ): Promise<{ successCount: number; failureCount: number; errors: Error[] }> {\n    console.log(\"üéØ Starting export of selected pages:\", pageIndices);\n\n    // Get all page elements\n    const allPageElements = this.getPrintablePageElements();\n\n    // Filter to selected pages\n    const selectedElements = pageIndices\n      .filter((index) => index >= 0 && index < allPageElements.length)\n      .map((index) => allPageElements[index]);\n\n    if (selectedElements.length === 0) {\n      const error = new Error(\n        \"No valid page elements found for selected indices\"\n      );\n      console.error(\"‚ùå No valid selected elements:\", error);\n      return { successCount: 0, failureCount: 1, errors: [error] };\n    }\n\n    // For now, delegate to the full export method but with filtered elements\n    // TODO: Could optimize this by modifying the export service to accept specific elements\n    console.log(`üìÑ Exporting ${selectedElements.length} selected pages`);\n\n    // This is a simplified implementation - in reality, we'd need to modify the export flow\n    // For now, we'll export all and notify about the selected ones\n    onProgress?.(\n      0,\n      selectedElements.length,\n      \"Note: Currently exports all pages (selection feature in development)\"\n    );\n\n    return this.exportPrintablePagesAsImages(options, onProgress);\n  }\n\n  getPrintablePageElements(): HTMLElement[] {\n    console.log(\"üîç Searching for printable page elements in DOM\");\n\n    // Look for page elements with the expected data attribute or class\n    const selectors = [\n      \"[data-page-id]\",\n      \".printable-page\",\n      \".page-wrapper .printable-page\",\n      \".pages-display .printable-page\",\n    ];\n\n    let elements: HTMLElement[] = [];\n\n    for (const selector of selectors) {\n      const found = document.querySelectorAll(selector);\n      if (found.length > 0) {\n        elements = Array.from(found) as HTMLElement[];\n        console.log(\n          `‚úÖ Found ${elements.length} page elements using selector: ${selector}`\n        );\n        break;\n      }\n    }\n\n    if (elements.length === 0) {\n      console.warn(\"‚ö†Ô∏è No printable page elements found with any selector\");\n      console.log(\"üîç Available elements in DOM:\");\n      console.log(\n        \"- Elements with data-page-id:\",\n        document.querySelectorAll(\"[data-page-id]\").length\n      );\n      console.log(\n        \"- Elements with class printable-page:\",\n        document.querySelectorAll(\".printable-page\").length\n      );\n    }\n\n    return elements;\n  }\n\n  validateExportCapability(): {\n    canExport: boolean;\n    pageCount: number;\n    issues: string[];\n  } {\n    const issues: string[] = [];\n\n    // Check browser support\n    if (!supportsFileDownload()) {\n      issues.push(\"Browser does not support file downloads\");\n    }\n\n    // Check for DOM elements\n    const pageElements = this.getPrintablePageElements();\n    const pageCount = pageElements.length;\n\n    if (pageCount === 0) {\n      issues.push(\"No printable page elements found in DOM\");\n    }\n\n    // Check if already exporting\n    if (this.isExporting) {\n      issues.push(\"Export already in progress\");\n    }\n\n    // Check for required services\n    if (!this.pageImageExportService) {\n      issues.push(\"Page image export service not available\");\n    }\n\n    const canExport = issues.length === 0;\n\n    console.log(\"üîç Export capability validation:\", {\n      canExport,\n      pageCount,\n      issues,\n    });\n\n    return {\n      canExport,\n      pageCount,\n      issues,\n    };\n  }\n\n  cancelExport(): Promise<void> {\n    if (this.isExporting && this.abortController) {\n      console.log(\"üõë Cancelling export operation\");\n      this.abortController.abort();\n      void this.pageImageExportService.cancelExport?.();\n      this.isExporting = false;\n      this.abortController = null;\n    }\n    return Promise.resolve();\n  }\n\n  getDefaultExportOptions(): {\n    format: \"PNG\" | \"JPEG\" | \"WebP\";\n    quality: number;\n    scale: number;\n    filenamePrefix: string;\n  } {\n    return {\n      format: \"PNG\",\n      quality: 0.95,\n      scale: 2.0, // 2x for high quality\n      filenamePrefix: \"word-cards\",\n    };\n  }\n\n  // Private helper methods\n\n  private prepareImageExportOptions(options: {\n    format?: \"PNG\" | \"JPEG\" | \"WebP\";\n    quality?: number;\n    scale?: number;\n    filenamePrefix?: string;\n  }): WordCardExportOptions {\n    const defaults = this.getDefaultExportOptions();\n\n    return {\n      ...defaults,\n      ...options,\n      // Override with specific values\n      format: options.format ?? defaults.format,\n      quality: options.quality ?? defaults.quality,\n      scale: options.scale ?? defaults.scale,\n      includeMetadata: true, // Add required property\n    };\n  }\n\n  private generatePageFilename(\n    prefix: string,\n    pageNumber: number,\n    format: string,\n    dimensions?: { width: number; height: number }\n  ): string {\n    const sanitizedPrefix = sanitizeFilename(prefix);\n    const pageNumStr = pageNumber.toString().padStart(3, \"0\");\n    const extension = format.toLowerCase();\n\n    // Include dimensions in filename for reference\n    const dimensionStr = dimensions\n      ? `_${dimensions.width}x${dimensions.height}`\n      : \"\";\n\n    return generateTimestampedFilename(\n      `${sanitizedPrefix}_page_${pageNumStr}${dimensionStr}`,\n      extension,\n      false // Don't include time, just date\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"F:\\_THE KINETIC ALPHABET\\_TKA-STUDIO\\src\\lib\\modules\\word-card\\state\\word-card-state-factory.svelte.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":88,"column":9,"nodeType":"Identifier","messageId":"alwaysFalsy","endLine":88,"endColumn":27}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Word Card State Factory\n *\n * Connects word card display state with existing microservices.\n * NO REDUNDANT LOGIC - uses ExploreService for data, PageLayoutService for layout.\n */\n\nimport type { SequenceData } from \"$shared\";\n\nimport type {\n  IPageFactoryService,\n  IPrintablePageLayoutService,\n  IWordCardBrowseService,\n} from \"../services/contracts\";\nimport {\n  displayState,\n  exportSettings,\n  finishExport,\n  finishRegeneration,\n  layoutState,\n  progressState,\n  resetExportSettings,\n  setColumnCount,\n  setDeviceCapabilities,\n  setSelectedLength,\n  setShowBeatNumbers,\n  setTransparentBackground,\n  startExport,\n  startRegeneration,\n  updateContainerSize,\n  updateExportProgress,\n  updateExportSetting,\n} from \"./display-state.svelte\";\nimport createPageLayoutState from \"./page-layout-state.svelte\";\n// createPageLayoutState imported above at line 14\n\n// ============================================================================\n// SEQUENCE CARD STATE FACTORY\n// ============================================================================\n\nexport function createWordCardState(\n  _browseService: IWordCardBrowseService,\n  layoutService: IPrintablePageLayoutService,\n  pageFactoryService: IPageFactoryService\n) {\n  // Create page layout state for printable mode\n  const pageLayoutState = createPageLayoutState(\n    layoutService,\n    pageFactoryService,\n    []\n  );\n\n  // Reactive sequence data (synchronous state, async loading)\n  const allSequences = $state<SequenceData[]>([]);\n  const isLoadingSequences = $state(false);\n  const sequenceLoadError = $state<string | null>(null);\n\n  // Filtered sequences using EXISTING ExploreService\n  const filteredSequences = $derived.by(() => {\n    if (displayState.selectedLength === 0) {\n      return allSequences;\n    }\n\n    // Simple client-side filtering for now\n    return allSequences.filter(\n      (seq) => seq.beats.length === displayState.selectedLength\n    );\n  });\n\n  // Current page sequences for grid/list view\n  const currentPageSequences = $derived(() => {\n    const sequences = filteredSequences;\n    const startIndex = pageLayoutState.currentPage * 24; // items per page\n    return sequences.slice(startIndex, startIndex + 24);\n  });\n\n  // Total pages for pagination\n  const totalPages = $derived(() => {\n    return Math.ceil(filteredSequences.length / 24);\n  });\n\n  // Progress message\n  const statusMessage = $derived(() => {\n    if (progressState.isExporting || progressState.isRegenerating) {\n      return progressState.message;\n    }\n\n    if (isLoadingSequences) {\n      return \"Loading sequences...\";\n    }\n\n    if (sequenceLoadError) {\n      return `Error: ${sequenceLoadError}`;\n    }\n\n    const count = filteredSequences.length;\n\n    if (count === 0) {\n      return displayState.selectedLength === 0\n        ? \"No sequences available\"\n        : `No ${displayState.selectedLength}-beat sequences found`;\n    }\n\n    const lengthText =\n      displayState.selectedLength === 0\n        ? \"all\"\n        : `${displayState.selectedLength}-beat`;\n    return `${count} ${lengthText} sequence${count === 1 ? \"\" : \"s\"}`;\n  });\n\n  // Actions that connect to page layout\n  async function switchToPrintableMode() {\n    await pageLayoutState.createPages(filteredSequences);\n  }\n\n  async function refreshPages() {\n    await pageLayoutState.regeneratePages();\n  }\n\n  return {\n    // Display state\n    displayState,\n    exportSettings,\n    progressState,\n    layoutState,\n    pageLayoutState,\n\n    // Derived data (using existing services)\n    get filteredSequences() {\n      return filteredSequences;\n    },\n    get currentPageSequences() {\n      return currentPageSequences;\n    },\n    get totalPages() {\n      return totalPages;\n    },\n    get statusMessage() {\n      return statusMessage;\n    },\n\n    // Actions\n    setSelectedLength,\n    setColumnCount,\n    setShowBeatNumbers,\n    setTransparentBackground,\n    updateContainerSize,\n    setDeviceCapabilities,\n    startExport,\n    updateExportProgress,\n    finishExport,\n    startRegeneration,\n    finishRegeneration,\n    updateExportSetting,\n    resetExportSettings,\n    switchToPrintableMode,\n    refreshPages,\n  };\n}\n\nexport type WordCardState = ReturnType<typeof createWordCardState>;\n","usedDeprecatedRules":[]},{"filePath":"F:\\_THE KINETIC ALPHABET\\_TKA-STUDIO\\src\\lib\\modules\\word-card\\state\\word-card-state.svelte.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":87,"column":9,"nodeType":"Identifier","messageId":"alwaysFalsy","endLine":87,"endColumn":27}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Word Card State Factory\n *\n * Connects word card display state with existing microservices.\n * NO REDUNDANT LOGIC - uses ExploreService for data, PageLayoutService for layout.\n */\n\nimport type { SequenceData } from \"$shared\";\nimport type {\n  IPageFactoryService,\n  IPrintablePageLayoutService,\n  IWordCardBrowseService,\n} from \"../services/contracts\";\nimport {\n  displayState,\n  exportSettings,\n  finishExport,\n  finishRegeneration,\n  layoutState,\n  progressState,\n  resetExportSettings,\n  setColumnCount,\n  setDeviceCapabilities,\n  setSelectedLength,\n  setShowBeatNumbers,\n  setTransparentBackground,\n  startExport,\n  startRegeneration,\n  updateContainerSize,\n  updateExportProgress,\n  updateExportSetting,\n} from \"./display-state.svelte\";\nimport createPageLayoutState from \"./page-layout-state.svelte\";\n// createPageLayoutState imported above at line 14\n\n// ============================================================================\n// SEQUENCE CARD STATE FACTORY\n// ============================================================================\n\nexport function createWordCardState(\n  _browseService: IWordCardBrowseService,\n  layoutService: IPrintablePageLayoutService,\n  pageFactoryService: IPageFactoryService\n) {\n  // Create page layout state for printable mode\n  const pageLayoutState = createPageLayoutState(\n    layoutService,\n    pageFactoryService,\n    []\n  );\n\n  // Reactive sequence data (synchronous state, async loading)\n  const allSequences = $state<SequenceData[]>([]);\n  const isLoadingSequences = $state(false);\n  const sequenceLoadError = $state<string | null>(null);\n\n  // Filtered sequences using EXISTING ExploreService\n  const filteredSequences = $derived.by(() => {\n    if (displayState.selectedLength === 0) {\n      return allSequences;\n    }\n\n    // Simple client-side filtering for now\n    return allSequences.filter(\n      (seq) => seq.beats.length === displayState.selectedLength\n    );\n  });\n\n  // Current page sequences for grid/list view\n  const currentPageSequences = $derived(() => {\n    const sequences = filteredSequences;\n    const startIndex = pageLayoutState.currentPage * 24; // items per page\n    return sequences.slice(startIndex, startIndex + 24);\n  });\n\n  // Total pages for pagination\n  const totalPages = $derived(() => {\n    return Math.ceil(filteredSequences.length / 24);\n  });\n\n  // Progress message\n  const statusMessage = $derived(() => {\n    if (progressState.isExporting || progressState.isRegenerating) {\n      return progressState.message;\n    }\n\n    if (isLoadingSequences) {\n      return \"Loading sequences...\";\n    }\n\n    if (sequenceLoadError) {\n      return `Error: ${sequenceLoadError}`;\n    }\n\n    const count = filteredSequences.length;\n\n    if (count === 0) {\n      return displayState.selectedLength === 0\n        ? \"No sequences available\"\n        : `No ${displayState.selectedLength}-beat sequences found`;\n    }\n\n    const lengthText =\n      displayState.selectedLength === 0\n        ? \"all\"\n        : `${displayState.selectedLength}-beat`;\n    return `${count} ${lengthText} sequence${count === 1 ? \"\" : \"s\"}`;\n  });\n\n  // Actions that connect to page layout\n  async function switchToPrintableMode() {\n    await pageLayoutState.createPages(filteredSequences);\n  }\n\n  async function refreshPages() {\n    await pageLayoutState.regeneratePages();\n  }\n\n  return {\n    // Display state\n    displayState,\n    exportSettings,\n    progressState,\n    layoutState,\n    pageLayoutState,\n\n    // Derived data (using existing services)\n    get filteredSequences() {\n      return filteredSequences;\n    },\n    get currentPageSequences() {\n      return currentPageSequences;\n    },\n    get totalPages() {\n      return totalPages;\n    },\n    get statusMessage() {\n      return statusMessage;\n    },\n\n    // Actions\n    setSelectedLength,\n    setColumnCount,\n    setShowBeatNumbers,\n    setTransparentBackground,\n    updateContainerSize,\n    setDeviceCapabilities,\n    startExport,\n    updateExportProgress,\n    finishExport,\n    startRegeneration,\n    finishRegeneration,\n    updateExportSetting,\n    resetExportSettings,\n    switchToPrintableMode,\n    refreshPages,\n  };\n}\n\nexport type WordCardState = ReturnType<typeof createWordCardState>;\n","usedDeprecatedRules":[]},{"filePath":"F:\\_THE KINETIC ALPHABET\\_TKA-STUDIO\\src\\lib\\modules\\write\\services\\implementations\\MusicPlayerService.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":25,"column":9,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":25,"endColumn":28}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MusicPlayerService - Implementation for music playback in Write tab\n */\nimport { injectable } from \"inversify\";\nimport type { IMusicPlayerService } from \"../contracts/IMusicPlayerService\";\n\n@injectable()\nexport class MusicPlayerService implements IMusicPlayerService {\n  private audioContext: AudioContext | null = null;\n  private currentAudio: HTMLAudioElement | null = null;\n  private initialized = false;\n\n  constructor() {\n    console.log(\"üéµ MusicPlayerService initialized\");\n  }\n\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    console.log(\"üéµ MusicPlayerService: Initializing audio context...\");\n\n    try {\n      // Initialize Web Audio API context\n      const AudioContextClass =\n        window.AudioContext ||\n        (window as unknown as { webkitAudioContext: typeof AudioContext })\n          .webkitAudioContext;\n      this.audioContext = new AudioContextClass();\n\n      // Resume audio context if suspended (required for user interaction)\n      if (this.audioContext.state === \"suspended\") {\n        await this.audioContext.resume();\n      }\n\n      this.initialized = true;\n      console.log(\"‚úÖ MusicPlayerService initialized with audio context\");\n    } catch (error) {\n      console.error(\n        \"‚ùå MusicPlayerService: Failed to initialize audio context:\",\n        error\n      );\n      // Fallback to basic HTML audio without Web Audio API\n      this.initialized = true;\n      console.log(\"‚ö†Ô∏è MusicPlayerService: Fallback to basic HTML audio\");\n    }\n  }\n\n  cleanup(): void {\n    console.log(\"üéµ MusicPlayerService: Cleaning up...\");\n\n    if (this.currentAudio) {\n      this.currentAudio.pause();\n      this.currentAudio.removeEventListener(\n        \"loadedmetadata\",\n        this.handleLoadedMetadata\n      );\n      this.currentAudio.removeEventListener(\n        \"timeupdate\",\n        this.handleTimeUpdate\n      );\n      this.currentAudio.removeEventListener(\"ended\", this.handleEnded);\n      this.currentAudio.removeEventListener(\"error\", this.handleError);\n      this.currentAudio = null;\n    }\n\n    if (this.audioContext?.state !== \"closed\") {\n      void this.audioContext?.close();\n      this.audioContext = null;\n    }\n\n    this.initialized = false;\n  }\n\n  async play(track: string): Promise<void> {\n    await this.ensureInitialized();\n\n    console.log(\"üéµ MusicPlayerService: Playing track:\", track);\n\n    try {\n      // Stop current audio if playing\n      if (this.currentAudio) {\n        this.currentAudio.pause();\n      }\n\n      // Create new audio element\n      this.currentAudio = new Audio(track);\n      this.setupAudioEventListeners();\n\n      // Start playback\n      await this.currentAudio.play();\n      console.log(\"‚úÖ MusicPlayerService: Track started playing\");\n    } catch (error) {\n      console.error(\"‚ùå MusicPlayerService: Failed to play track:\", error);\n      throw new Error(`Failed to play track: ${track}`);\n    }\n  }\n\n  pause(): void {\n    if (!this.currentAudio) {\n      console.warn(\"üéµ MusicPlayerService: No audio to pause\");\n      return;\n    }\n\n    this.currentAudio.pause();\n    console.log(\"‚è∏Ô∏è MusicPlayerService: Playback paused\");\n  }\n\n  stop(): void {\n    if (!this.currentAudio) {\n      console.warn(\"üéµ MusicPlayerService: No audio to stop\");\n      return;\n    }\n\n    this.currentAudio.pause();\n    this.currentAudio.currentTime = 0;\n    console.log(\"‚èπÔ∏è MusicPlayerService: Playback stopped\");\n  }\n\n  private async ensureInitialized(): Promise<void> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n  }\n\n  private setupAudioEventListeners(): void {\n    if (!this.currentAudio) return;\n\n    this.currentAudio.addEventListener(\n      \"loadedmetadata\",\n      this.handleLoadedMetadata\n    );\n    this.currentAudio.addEventListener(\"timeupdate\", this.handleTimeUpdate);\n    this.currentAudio.addEventListener(\"ended\", this.handleEnded);\n    this.currentAudio.addEventListener(\"error\", this.handleError);\n  }\n\n  private handleLoadedMetadata = (): void => {\n    if (this.currentAudio) {\n      console.log(\n        \"üéµ MusicPlayerService: Audio metadata loaded, duration:\",\n        this.currentAudio.duration\n      );\n    }\n  };\n\n  private handleTimeUpdate = (): void => {\n    if (this.currentAudio) {\n      // Could emit events here for UI updates\n      // console.log(\"üéµ Time update:\", this.currentAudio.currentTime);\n    }\n  };\n\n  private handleEnded = (): void => {\n    console.log(\"üéµ MusicPlayerService: Track playback ended\");\n  };\n\n  private handleError = (event: Event): void => {\n    console.error(\"‚ùå MusicPlayerService: Audio error:\", event);\n  };\n}\n","usedDeprecatedRules":[]}]
