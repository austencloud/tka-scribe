import "/node_modules/.vite/deps/chunk-AGY74XF2.js?v=608ae08a";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "/node_modules/.vite/deps/chunk-XSCQBFM2.js?v=608ae08a";

// node_modules/@inversifyjs/common/lib/esm/index.js
function e(e2) {
  return ("object" == typeof e2 && null !== e2 || "function" == typeof e2) && "function" == typeof e2.then;
}
function t(e2) {
  switch (typeof e2) {
    case "string":
    case "symbol":
      return e2.toString();
    case "function":
      return e2.name;
    default:
      throw new Error(`Unexpected ${typeof e2} service id type`);
  }
}
var n = Symbol.for("@inversifyjs/common/islazyServiceIdentifier");
var _a, _e;
_a = n;
var r = class {
  constructor(e2) {
    __publicField(this, _a);
    __privateAdd(this, _e);
    __privateSet(this, _e, e2), this[n] = true;
  }
  static is(e2) {
    return "object" == typeof e2 && null !== e2 && true === e2[n];
  }
  unwrap() {
    return __privateGet(this, _e).call(this);
  }
};
_e = new WeakMap();

// node_modules/@inversifyjs/reflect-metadata-utils/lib/esm/index.js
function c(t4, n3, e2) {
  return Reflect.getOwnMetadata(n3, t4, e2);
}
function r2(t4, n3, e2, u2) {
  Reflect.defineMetadata(n3, e2, t4, u2);
}
function i(t4, n3, e2, u2, f2) {
  const a2 = u2(c(t4, n3, f2) ?? e2());
  Reflect.defineMetadata(n3, a2, t4, f2);
}

// node_modules/@inversifyjs/prototype-utils/lib/esm/index.js
function t2(t4) {
  const o = Object.getPrototypeOf(t4.prototype), r3 = o == null ? void 0 : o.constructor;
  return r3;
}

// node_modules/@inversifyjs/core/lib/esm/index.js
var a = "@inversifyjs/container/bindingId";
function c2() {
  const i2 = c(Object, a) ?? 0;
  return i2 === Number.MAX_SAFE_INTEGER ? r2(Object, a, Number.MIN_SAFE_INTEGER) : i(Object, a, () => i2, (e2) => e2 + 1), i2;
}
var d = { Request: "Request", Singleton: "Singleton", Transient: "Transient" };
var l = { ConstantValue: "ConstantValue", DynamicValue: "DynamicValue", Factory: "Factory", Instance: "Instance", Provider: "Provider", ResolvedValue: "ResolvedValue", ServiceRedirection: "ServiceRedirection" };
function* u(...e2) {
  for (const n3 of e2) yield* n3;
}
var _e2, _n, _t, _p_instances, r_fn, s_fn, i_fn, o_fn, l_fn, u_fn, c_fn, a_fn, d_fn, p_fn;
var _p = class _p {
  constructor(e2) {
    __privateAdd(this, _p_instances);
    __privateAdd(this, _e2);
    __privateAdd(this, _n);
    __privateAdd(this, _t);
    __privateSet(this, _e2, /* @__PURE__ */ new Map()), __privateSet(this, _n, {});
    for (const n3 of Reflect.ownKeys(e2)) __privateGet(this, _n)[n3] = /* @__PURE__ */ new Map();
    __privateSet(this, _t, e2);
  }
  add(e2, n3) {
    __privateMethod(this, _p_instances, i_fn).call(this, e2).push(n3);
    for (const t4 of Reflect.ownKeys(n3)) __privateMethod(this, _p_instances, o_fn).call(this, t4, n3[t4]).push(e2);
  }
  clone() {
    const e2 = __privateMethod(this, _p_instances, r_fn).call(this), n3 = __privateMethod(this, _p_instances, s_fn).call(this), t4 = Reflect.ownKeys(__privateGet(this, _t)), i2 = this._buildNewInstance(__privateGet(this, _t));
    __privateMethod(this, _p_instances, a_fn).call(this, __privateGet(this, _e2), __privateGet(i2, _e2), e2, n3);
    for (const n4 of t4) __privateMethod(this, _p_instances, c_fn).call(this, __privateGet(this, _n)[n4], __privateGet(i2, _n)[n4], e2);
    return i2;
  }
  get(e2, n3) {
    return __privateGet(this, _n)[e2].get(n3);
  }
  getAllKeys(e2) {
    return __privateGet(this, _n)[e2].keys();
  }
  removeByRelation(e2, n3) {
    const t4 = this.get(e2, n3);
    if (void 0 === t4) return;
    const i2 = new Set(t4);
    for (const t5 of i2) {
      const i3 = __privateGet(this, _e2).get(t5);
      if (void 0 === i3) throw new Error("Expecting model relation, none found");
      for (const o of i3) o[e2] === n3 && __privateMethod(this, _p_instances, d_fn).call(this, t5, o);
      __privateGet(this, _e2).delete(t5);
    }
  }
  _buildNewInstance(e2) {
    return new _p(e2);
  }
  _cloneModel(e2) {
    return e2;
  }
  _cloneRelation(e2) {
    return e2;
  }
};
_e2 = new WeakMap();
_n = new WeakMap();
_t = new WeakMap();
_p_instances = new WeakSet();
r_fn = function() {
  const e2 = /* @__PURE__ */ new Map();
  for (const n3 of __privateGet(this, _e2).keys()) {
    const t4 = this._cloneModel(n3);
    e2.set(n3, t4);
  }
  return e2;
};
s_fn = function() {
  const e2 = /* @__PURE__ */ new Map();
  for (const n3 of __privateGet(this, _e2).values()) for (const t4 of n3) {
    const n4 = this._cloneRelation(t4);
    e2.set(t4, n4);
  }
  return e2;
};
i_fn = function(e2) {
  let n3 = __privateGet(this, _e2).get(e2);
  return void 0 === n3 && (n3 = [], __privateGet(this, _e2).set(e2, n3)), n3;
};
o_fn = function(e2, n3) {
  let t4 = __privateGet(this, _n)[e2].get(n3);
  return void 0 === t4 && (t4 = [], __privateGet(this, _n)[e2].set(n3, t4)), t4;
};
l_fn = function(e2, n3) {
  const t4 = n3.get(e2);
  if (void 0 === t4) throw new Error("Expecting model to be cloned, none found");
  return t4;
};
u_fn = function(e2, n3) {
  const t4 = n3.get(e2);
  if (void 0 === t4) throw new Error("Expecting relation to be cloned, none found");
  return t4;
};
c_fn = function(e2, n3, t4) {
  for (const [i2, o] of e2) {
    const e3 = new Array();
    for (const n4 of o) e3.push(__privateMethod(this, _p_instances, l_fn).call(this, n4, t4));
    n3.set(i2, e3);
  }
};
a_fn = function(e2, n3, t4, i2) {
  for (const [o, r3] of e2) {
    const e3 = new Array();
    for (const n4 of r3) e3.push(__privateMethod(this, _p_instances, u_fn).call(this, n4, i2));
    n3.set(__privateMethod(this, _p_instances, l_fn).call(this, o, t4), e3);
  }
};
d_fn = function(e2, n3) {
  for (const t4 of Reflect.ownKeys(n3)) __privateMethod(this, _p_instances, p_fn).call(this, e2, t4, n3[t4]);
};
p_fn = function(e2, n3, t4) {
  const i2 = __privateGet(this, _n)[n3].get(t4);
  if (void 0 !== i2) {
    const o = i2.indexOf(e2);
    -1 !== o && i2.splice(o, 1), 0 === i2.length && __privateGet(this, _n)[n3].delete(t4);
  }
};
var p = _p;
var f;
var v;
var g;
!function(e2) {
  e2.moduleId = "moduleId", e2.serviceId = "serviceId";
}(f || (f = {}));
var _f, _v;
var _h = class _h {
  constructor(e2, n3) {
    __privateAdd(this, _f);
    __privateAdd(this, _v);
    __privateSet(this, _f, n3 ?? new p({ moduleId: { isOptional: true }, serviceId: { isOptional: false } })), __privateSet(this, _v, e2);
  }
  static build(e2) {
    return new _h(e2);
  }
  add(e2, n3) {
    __privateGet(this, _f).add(e2, n3);
  }
  clone() {
    return new _h(__privateGet(this, _v), __privateGet(this, _f).clone());
  }
  get(e2) {
    var _a10;
    const n3 = [], t4 = __privateGet(this, _f).get(f.serviceId, e2);
    void 0 !== t4 && n3.push(t4);
    const i2 = (_a10 = __privateGet(this, _v).call(this)) == null ? void 0 : _a10.get(e2);
    if (void 0 !== i2 && n3.push(i2), 0 !== n3.length) return u(...n3);
  }
  removeAllByModuleId(e2) {
    __privateGet(this, _f).removeByRelation(f.moduleId, e2);
  }
  removeAllByServiceId(e2) {
    __privateGet(this, _f).removeByRelation(f.serviceId, e2);
  }
};
_f = new WeakMap();
_v = new WeakMap();
var h = _h;
function m(e2) {
  return e2.isRight ? { isRight: true, value: e2.value } : e2;
}
function y(e2) {
  switch (e2.type) {
    case l.ConstantValue:
    case l.DynamicValue:
      return function(e3) {
        return { cache: m(e3.cache), id: e3.id, isSatisfiedBy: e3.isSatisfiedBy, moduleId: e3.moduleId, onActivation: e3.onActivation, onDeactivation: e3.onDeactivation, scope: e3.scope, serviceIdentifier: e3.serviceIdentifier, type: e3.type, value: e3.value };
      }(e2);
    case l.Factory:
      return function(e3) {
        return { cache: m(e3.cache), factory: e3.factory, id: e3.id, isSatisfiedBy: e3.isSatisfiedBy, moduleId: e3.moduleId, onActivation: e3.onActivation, onDeactivation: e3.onDeactivation, scope: e3.scope, serviceIdentifier: e3.serviceIdentifier, type: e3.type };
      }(e2);
    case l.Instance:
      return function(e3) {
        return { cache: m(e3.cache), id: e3.id, implementationType: e3.implementationType, isSatisfiedBy: e3.isSatisfiedBy, moduleId: e3.moduleId, onActivation: e3.onActivation, onDeactivation: e3.onDeactivation, scope: e3.scope, serviceIdentifier: e3.serviceIdentifier, type: e3.type };
      }(e2);
    case l.Provider:
      return function(e3) {
        return { cache: m(e3.cache), id: e3.id, isSatisfiedBy: e3.isSatisfiedBy, moduleId: e3.moduleId, onActivation: e3.onActivation, onDeactivation: e3.onDeactivation, provider: e3.provider, scope: e3.scope, serviceIdentifier: e3.serviceIdentifier, type: e3.type };
      }(e2);
    case l.ResolvedValue:
      return function(e3) {
        return { cache: m(e3.cache), factory: e3.factory, id: e3.id, isSatisfiedBy: e3.isSatisfiedBy, metadata: e3.metadata, moduleId: e3.moduleId, onActivation: e3.onActivation, onDeactivation: e3.onDeactivation, scope: e3.scope, serviceIdentifier: e3.serviceIdentifier, type: e3.type };
      }(e2);
    case l.ServiceRedirection:
      return function(e3) {
        return { id: e3.id, isSatisfiedBy: e3.isSatisfiedBy, moduleId: e3.moduleId, serviceIdentifier: e3.serviceIdentifier, targetServiceIdentifier: e3.targetServiceIdentifier, type: e3.type };
      }(e2);
  }
}
!function(e2) {
  e2.id = "id", e2.moduleId = "moduleId", e2.serviceId = "serviceId";
}(v || (v = {}));
var M = class _M2 extends p {
  _buildNewInstance(e2) {
    return new _M2(e2);
  }
  _cloneModel(e2) {
    return y(e2);
  }
};
var _g, _v2;
var _I = class _I {
  constructor(e2, n3) {
    __privateAdd(this, _g);
    __privateAdd(this, _v2);
    __privateSet(this, _g, n3 ?? new M({ id: { isOptional: false }, moduleId: { isOptional: true }, serviceId: { isOptional: false } })), __privateSet(this, _v2, e2);
  }
  static build(e2) {
    return new _I(e2);
  }
  clone() {
    return new _I(__privateGet(this, _v2), __privateGet(this, _g).clone());
  }
  get(e2) {
    var _a10;
    return this.getNonParentBindings(e2) ?? ((_a10 = __privateGet(this, _v2).call(this)) == null ? void 0 : _a10.get(e2));
  }
  *getChained(e2) {
    const n3 = this.getNonParentBindings(e2);
    void 0 !== n3 && (yield* n3);
    const t4 = __privateGet(this, _v2).call(this);
    void 0 !== t4 && (yield* t4.getChained(e2));
  }
  getBoundServices() {
    const e2 = new Set(__privateGet(this, _g).getAllKeys(v.serviceId)), n3 = __privateGet(this, _v2).call(this);
    if (void 0 !== n3) for (const t4 of n3.getBoundServices()) e2.add(t4);
    return e2;
  }
  getById(e2) {
    var _a10;
    return __privateGet(this, _g).get(v.id, e2) ?? ((_a10 = __privateGet(this, _v2).call(this)) == null ? void 0 : _a10.getById(e2));
  }
  getByModuleId(e2) {
    var _a10;
    return __privateGet(this, _g).get(v.moduleId, e2) ?? ((_a10 = __privateGet(this, _v2).call(this)) == null ? void 0 : _a10.getByModuleId(e2));
  }
  getNonParentBindings(e2) {
    return __privateGet(this, _g).get(v.serviceId, e2);
  }
  getNonParentBoundServices() {
    return __privateGet(this, _g).getAllKeys(v.serviceId);
  }
  removeById(e2) {
    __privateGet(this, _g).removeByRelation(v.id, e2);
  }
  removeAllByModuleId(e2) {
    __privateGet(this, _g).removeByRelation(v.moduleId, e2);
  }
  removeAllByServiceId(e2) {
    __privateGet(this, _g).removeByRelation(v.serviceId, e2);
  }
  set(e2) {
    const n3 = { [v.id]: e2.id, [v.serviceId]: e2.serviceIdentifier };
    void 0 !== e2.moduleId && (n3[v.moduleId] = e2.moduleId), __privateGet(this, _g).add(e2, n3);
  }
};
_g = new WeakMap();
_v2 = new WeakMap();
var I = _I;
!function(e2) {
  e2.moduleId = "moduleId", e2.serviceId = "serviceId";
}(g || (g = {}));
var _h2, _v3;
var _b = class _b {
  constructor(e2, n3) {
    __privateAdd(this, _h2);
    __privateAdd(this, _v3);
    __privateSet(this, _h2, n3 ?? new p({ moduleId: { isOptional: true }, serviceId: { isOptional: false } })), __privateSet(this, _v3, e2);
  }
  static build(e2) {
    return new _b(e2);
  }
  add(e2, n3) {
    __privateGet(this, _h2).add(e2, n3);
  }
  clone() {
    return new _b(__privateGet(this, _v3), __privateGet(this, _h2).clone());
  }
  get(e2) {
    var _a10;
    const n3 = [], t4 = __privateGet(this, _h2).get(g.serviceId, e2);
    void 0 !== t4 && n3.push(t4);
    const i2 = (_a10 = __privateGet(this, _v3).call(this)) == null ? void 0 : _a10.get(e2);
    if (void 0 !== i2 && n3.push(i2), 0 !== n3.length) return u(...n3);
  }
  removeAllByModuleId(e2) {
    __privateGet(this, _h2).removeByRelation(g.moduleId, e2);
  }
  removeAllByServiceId(e2) {
    __privateGet(this, _h2).removeByRelation(g.serviceId, e2);
  }
};
_h2 = new WeakMap();
_v3 = new WeakMap();
var b = _b;
function w(e2, n3, t4, i2) {
  const o = Array.isArray(e2) ? e2 : [e2];
  if (void 0 !== t4) if ("number" != typeof t4) if (void 0 !== i2) for (const e3 of o) e3(n3, t4, i2);
  else Reflect.decorate(o, n3.prototype, t4);
  else for (const e3 of o) e3(n3, void 0, t4);
  else Reflect.decorate(o, n3);
}
var C = "@inversifyjs/core/classMetadataReflectKey";
function S() {
  return { constructorArguments: [], lifecycle: { postConstructMethodName: void 0, preDestroyMethodName: void 0 }, properties: /* @__PURE__ */ new Map(), scope: void 0 };
}
var N = "@inversifyjs/core/pendingClassMetadataCountReflectKey";
var P = Symbol.for("@inversifyjs/core/InversifyCoreError");
var _a2, _b2;
var R = class _R extends (_b2 = Error, _a2 = P, _b2) {
  constructor(e2, n3, t4) {
    super(n3, t4);
    __publicField(this, _a2);
    __publicField(this, "kind");
    this[P] = true, this.kind = e2;
  }
  static is(e2) {
    return "object" == typeof e2 && null !== e2 && true === e2[P];
  }
  static isErrorOfKind(e2, n3) {
    return _R.is(e2) && e2.kind === n3;
  }
};
var A;
var T;
var x;
function j(n3) {
  const t4 = c(n3, C) ?? S();
  if (!function(n4) {
    const t5 = c(n4, N);
    return void 0 !== t5 && 0 !== t5;
  }(n3)) return function(e2, n4) {
    const t5 = [];
    if (n4.length < e2.length) throw new R(A.missingInjectionDecorator, `Found unexpected missing metadata on type "${e2.name}". "${e2.name}" constructor requires at least ${e2.length.toString()} arguments, found ${n4.length.toString()} instead.
Are you using @inject, @multiInject or @unmanaged decorators in every non optional constructor argument?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
    for (let e3 = 0; e3 < n4.length; ++e3) void 0 === n4[e3] && t5.push(e3);
    if (t5.length > 0) throw new R(A.missingInjectionDecorator, `Found unexpected missing metadata on type "${e2.name}" at constructor indexes "${t5.join('", "')}".

Are you using @inject, @multiInject or @unmanaged decorators at those indexes?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
  }(n3, t4.constructorArguments), t4;
  !function(e2, n4) {
    const t5 = [];
    for (let i2 = 0; i2 < n4.constructorArguments.length; ++i2) {
      const o = n4.constructorArguments[i2];
      void 0 !== o && o.kind !== T.unknown || t5.push(`  - Missing or incomplete metadata for type "${e2.name}" at constructor argument with index ${i2.toString()}.
Every constructor parameter must be decorated either with @inject, @multiInject or @unmanaged decorator.`);
    }
    for (const [i2, o] of n4.properties) o.kind === T.unknown && t5.push(`  - Missing or incomplete metadata for type "${e2.name}" at property "${i2.toString()}".
This property must be decorated either with @inject or @multiInject decorator.`);
    if (0 === t5.length) throw new R(A.unknown, `Unexpected class metadata for type "${e2.name}" with uncompletion traces.
This might be caused by one of the following reasons:

1. A third party library is targeting inversify reflection metadata.
2. A bug is causing the issue. Consider submiting an issue to fix it.`);
    throw new R(A.missingInjectionDecorator, `Invalid class metadata at type ${e2.name}:

${t5.join("\n\n")}`);
  }(n3, t4);
}
function B() {
  return 0;
}
function F(e2) {
  return (n3) => {
    void 0 !== n3 && n3.kind === T.unknown && i(e2, N, B, (e3) => e3 - 1);
  };
}
function k(e2, n3) {
  return (...t4) => (i2) => {
    if (void 0 === i2) return e2(...t4);
    if (i2.kind === x.unmanaged) throw new R(A.injectionDecoratorConflict, "Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found");
    return n3(i2, ...t4);
  };
}
function $(e2) {
  if (e2.kind !== T.unknown && true !== e2.isFromTypescriptParamType) throw new R(A.injectionDecoratorConflict, "Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found");
}
!function(e2) {
  e2[e2.injectionDecoratorConflict = 0] = "injectionDecoratorConflict", e2[e2.missingInjectionDecorator = 1] = "missingInjectionDecorator", e2[e2.planning = 2] = "planning", e2[e2.resolution = 3] = "resolution", e2[e2.unknown = 4] = "unknown";
}(A || (A = {})), function(e2) {
  e2[e2.unknown = 32] = "unknown";
}(T || (T = {})), function(e2) {
  e2[e2.multipleInjection = 0] = "multipleInjection", e2[e2.singleInjection = 1] = "singleInjection", e2[e2.unmanaged = 2] = "unmanaged";
}(x || (x = {}));
var D = k(function(e2, n3, t4) {
  return e2 === x.multipleInjection ? { chained: (t4 == null ? void 0 : t4.chained) ?? false, kind: e2, name: void 0, optional: false, tags: /* @__PURE__ */ new Map(), value: n3 } : { kind: e2, name: void 0, optional: false, tags: /* @__PURE__ */ new Map(), value: n3 };
}, function(e2, n3, t4, i2) {
  return $(e2), n3 === x.multipleInjection ? { ...e2, chained: (i2 == null ? void 0 : i2.chained) ?? false, kind: n3, value: t4 } : { ...e2, kind: n3, value: t4 };
});
function V(e2, n3) {
  return (t4) => {
    const i2 = t4.properties.get(n3);
    return t4.properties.set(n3, e2(i2)), t4;
  };
}
var E;
function O(e2, n3, t4, i2) {
  if (R.isErrorOfKind(i2, A.injectionDecoratorConflict)) {
    const o = function(e3, n4, t5) {
      if (void 0 === t5) {
        if (void 0 === n4) throw new R(A.unknown, "Unexpected undefined property and index values");
        return { kind: E.property, property: n4, targetClass: e3.constructor };
      }
      return "number" == typeof t5 ? { index: t5, kind: E.parameter, targetClass: e3 } : { kind: E.method, method: n4, targetClass: e3 };
    }(e2, n3, t4);
    throw new R(A.injectionDecoratorConflict, `Unexpected injection error.

Cause:

${i2.message}

Details

${function(e3) {
      switch (e3.kind) {
        case E.method:
          return `[class: "${e3.targetClass.name}", method: "${e3.method.toString()}"]`;
        case E.parameter:
          return `[class: "${e3.targetClass.name}", index: "${e3.index.toString()}"]`;
        case E.property:
          return `[class: "${e3.targetClass.name}", property: "${e3.property.toString()}"]`;
      }
    }(o)}`, { cause: i2 });
  }
  throw i2;
}
function _(e2, n3) {
  return (i2, o, r3) => {
    try {
      void 0 === r3 ? function(e3, n4) {
        const i3 = L(e3, n4);
        return (e4, n5) => {
          i(e4.constructor, C, S, V(i3(e4), n5));
        };
      }(e2, n3)(i2, o) : "number" == typeof r3 ? function(e3, n4) {
        const i3 = L(e3, n4);
        return (e4, n5, o2) => {
          if (!/* @__PURE__ */ function(e5, n6) {
            return "function" == typeof e5 && void 0 === n6;
          }(e4, n5)) throw new R(A.injectionDecoratorConflict, `Found an @inject decorator in a non constructor parameter.
Found @inject decorator at method "${(n5 == null ? void 0 : n5.toString()) ?? ""}" at class "${e4.constructor.name}"`);
          i(e4, C, S, /* @__PURE__ */ function(e5, n6) {
            return (t4) => {
              const i4 = t4.constructorArguments[n6];
              return t4.constructorArguments[n6] = e5(i4), t4;
            };
          }(i3(e4), o2));
        };
      }(e2, n3)(i2, o, r3) : function(e3, n4) {
        const i3 = L(e3, n4);
        return (e4, n5, o2) => {
          if (!function(e5) {
            return void 0 !== e5.set;
          }(o2)) throw new R(A.injectionDecoratorConflict, `Found an @inject decorator in a non setter property method.
Found @inject decorator at method "${n5.toString()}" at class "${e4.constructor.name}"`);
          i(e4.constructor, C, S, V(i3(e4), n5));
        };
      }(e2, n3)(i2, o, r3);
    } catch (e3) {
      O(i2, o, r3, e3);
    }
  };
}
function L(e2, n3) {
  return (t4) => {
    const i2 = n3(t4);
    return (n4) => (i2(n4), e2(n4));
  };
}
function z(e2) {
  return _(D(x.singleInjection, e2), F);
}
!function(e2) {
  e2[e2.method = 0] = "method", e2[e2.parameter = 1] = "parameter", e2[e2.property = 2] = "property";
}(E || (E = {}));
var U = "@inversifyjs/core/classIsInjectableFlagReflectKey";
var K = [Array, BigInt, Boolean, Function, Number, Object, String];
function q(n3) {
  const i2 = c(n3, "design:paramtypes");
  void 0 !== i2 && i(n3, C, S, /* @__PURE__ */ function(e2) {
    return (n4) => (e2.forEach((e3, t4) => {
      var i3;
      void 0 !== n4.constructorArguments[t4] || (i3 = e3, K.includes(i3)) || (n4.constructorArguments[t4] = function(e4) {
        return { isFromTypescriptParamType: true, kind: x.singleInjection, name: void 0, optional: false, tags: /* @__PURE__ */ new Map(), value: e4 };
      }(e3));
    }), n4);
  }(i2));
}
function G(i2) {
  return (o) => {
    !function(t4) {
      if (void 0 !== c(t4, U)) throw new R(A.injectionDecoratorConflict, `Cannot apply @injectable decorator multiple times at class "${t4.name}"`);
      r2(t4, U, true);
    }(o), q(o), void 0 !== i2 && i(o, C, S, (e2) => ({ ...e2, scope: i2 }));
  };
}
function W(e2, n3, t4) {
  let i2;
  return e2.extendConstructorArguments ?? true ? (i2 = [...n3.constructorArguments], t4.constructorArguments.map((e3, n4) => {
    i2[n4] = e3;
  })) : i2 = t4.constructorArguments, i2;
}
function X(e2, n3, t4) {
  let i2;
  return i2 = e2.extendProperties ?? true ? new Map(u(n3.properties, t4.properties)) : t4.properties, i2;
}
function H(e2) {
  return (n3) => {
    const i2 = j(e2.type);
    i(n3, C, S, /* @__PURE__ */ function(e3, n4) {
      const t4 = (t5) => ({ constructorArguments: W(e3, n4, t5), lifecycle: t5.lifecycle, properties: X(e3, n4, t5), scope: t5.scope });
      return t4;
    }(e2, i2));
  };
}
function J(e2) {
  return (n3) => {
    const t4 = t2(n3);
    if (void 0 === t4) throw new R(A.injectionDecoratorConflict, `Expected base type for type "${n3.name}", none found.`);
    H({ ...e2, type: t4 })(n3);
  };
}
function Q(e2) {
  return (n3) => {
    const t4 = [];
    let o = t2(n3);
    for (; void 0 !== o && o !== Object; ) {
      const e3 = o;
      t4.push(e3), o = t2(e3);
    }
    t4.reverse();
    for (const i2 of t4) H({ ...e2, type: i2 })(n3);
  };
}
function Y(e2, n3) {
  return _(D(x.multipleInjection, e2, n3), F);
}
function Z(e2) {
  return (n3) => {
    void 0 === n3 && i(e2, N, B, (e3) => e3 + 1);
  };
}
function ee(e2) {
  return (n3) => {
    const t4 = n3 ?? { kind: T.unknown, name: void 0, optional: false, tags: /* @__PURE__ */ new Map() };
    if (t4.kind === x.unmanaged) throw new R(A.injectionDecoratorConflict, "Unexpected injection found. Found @unmanaged injection with additional @named, @optional, @tagged or @targetName injections");
    return e2(t4);
  };
}
function ne(e2) {
  const n3 = ee(/* @__PURE__ */ function(e3) {
    return (n4) => {
      if (void 0 !== n4.name) throw new R(A.injectionDecoratorConflict, "Unexpected duplicated named decorator");
      return n4.name = e3, n4;
    };
  }(e2));
  return _(n3, Z);
}
function te(e2) {
  if (e2.optional) throw new R(A.injectionDecoratorConflict, "Unexpected duplicated optional decorator");
  return e2.optional = true, e2;
}
function ie() {
  return _(ee(te), Z);
}
function oe() {
  return (e2, n3, i2) => {
    try {
      i(e2.constructor, C, S, (o = n3, (e3) => {
        if (void 0 !== e3.lifecycle.postConstructMethodName) throw new R(A.injectionDecoratorConflict, "Unexpected duplicated postConstruct decorator");
        return e3.lifecycle.postConstructMethodName = o, e3;
      }));
    } catch (t4) {
      O(e2, n3, void 0, t4);
    }
    var o;
  };
}
function re() {
  return (e2, n3, i2) => {
    try {
      i(e2.constructor, C, S, (o = n3, (e3) => {
        if (void 0 !== e3.lifecycle.preDestroyMethodName) throw new R(A.injectionDecoratorConflict, "Unexpected duplicated preDestroy decorator");
        return e3.lifecycle.preDestroyMethodName = o, e3;
      }));
    } catch (t4) {
      O(e2, n3, void 0, t4);
    }
    var o;
  };
}
function se(e2, n3) {
  const t4 = ee(/* @__PURE__ */ function(e3, n4) {
    return (t5) => {
      if (t5.tags.has(e3)) throw new R(A.injectionDecoratorConflict, "Unexpected duplicated tag decorator with existing tag");
      return t5.tags.set(e3, n4), t5;
    };
  }(e2, n3));
  return _(t4, Z);
}
function ae() {
  return { kind: x.unmanaged };
}
var ce = k(ae, function(e2) {
  if ($(e2), function(e3) {
    return void 0 !== e3.name || e3.optional || e3.tags.size > 0;
  }(e2)) throw new R(A.injectionDecoratorConflict, "Unexpected injection found. Found @unmanaged injection with additional @named, @optional, @tagged or @targetName injections");
  return ae();
});
function de() {
  return _(ce(), F);
}
var le;
function ue(e2) {
  if (!(e2 instanceof Error)) return false;
  return e2 instanceof RangeError && /stack space|call stack|too much recursion/i.test(e2.message) || "InternalError" === e2.name && /too much recursion/.test(e2.message);
}
function pe(e2, n3) {
  if (ue(n3)) {
    const t4 = function(e3) {
      const n4 = [...e3];
      if (0 === n4.length) return "(No dependency trace)";
      return n4.map(t).join(" -> ");
    }(function(e3) {
      const n4 = /* @__PURE__ */ new Set();
      for (const t5 of e3.servicesBranch) {
        if (n4.has(t5)) return [...n4, t5];
        n4.add(t5);
      }
      return [...n4];
    }(e2));
    throw new R(A.planning, `Circular dependency found: ${t4}`, { cause: n3 });
  }
  throw n3;
}
!function(e2) {
  e2[e2.multipleInjection = 0] = "multipleInjection", e2[e2.singleInjection = 1] = "singleInjection";
}(le || (le = {}));
var fe = Symbol.for("@inversifyjs/core/LazyPlanServiceNode");
var _a3;
_a3 = fe;
var ve = class {
  constructor(e2, n3) {
    __publicField(this, _a3);
    __publicField(this, "_serviceIdentifier");
    __publicField(this, "_serviceNode");
    this[fe] = true, this._serviceNode = e2, this._serviceIdentifier = n3;
  }
  get bindings() {
    return this._getNode().bindings;
  }
  get isContextFree() {
    return this._getNode().isContextFree;
  }
  get serviceIdentifier() {
    return this._serviceIdentifier;
  }
  set bindings(e2) {
    this._getNode().bindings = e2;
  }
  set isContextFree(e2) {
    this._getNode().isContextFree = e2;
  }
  static is(e2) {
    return "object" == typeof e2 && null !== e2 && true === e2[fe];
  }
  invalidate() {
    this._serviceNode = void 0;
  }
  isExpanded() {
    return void 0 !== this._serviceNode;
  }
  _getNode() {
    return void 0 === this._serviceNode && (this._serviceNode = this._buildPlanServiceNode()), this._serviceNode;
  }
};
var _m;
var _ge = class _ge {
  constructor(e2) {
    __privateAdd(this, _m);
    __privateSet(this, _m, e2);
  }
  get name() {
    return __privateGet(this, _m).elem.name;
  }
  get serviceIdentifier() {
    return __privateGet(this, _m).elem.serviceIdentifier;
  }
  get tags() {
    return __privateGet(this, _m).elem.tags;
  }
  getAncestor() {
    if (__privateGet(this, _m).elem.getAncestorsCalled = true, void 0 !== __privateGet(this, _m).previous) return new _ge(__privateGet(this, _m).previous);
  }
};
_m = new WeakMap();
var ge = _ge;
function he(e2, n3, t4) {
  const i2 = (t4 == null ? void 0 : t4.customServiceIdentifier) ?? n3.serviceIdentifier, o = (true === (t4 == null ? void 0 : t4.chained) ? [...e2.operations.getBindingsChained(i2)] : [...e2.operations.getBindings(i2) ?? []]).filter((e3) => e3.isSatisfiedBy(n3));
  if (0 === o.length && void 0 !== e2.autobindOptions && "function" == typeof i2) {
    const n4 = function(e3, n5) {
      const t5 = j(n5), i3 = t5.scope ?? e3.scope;
      return { cache: { isRight: false, value: void 0 }, id: c2(), implementationType: n5, isSatisfiedBy: () => true, moduleId: void 0, onActivation: void 0, onDeactivation: void 0, scope: i3, serviceIdentifier: n5, type: l.Instance };
    }(e2.autobindOptions, i2);
    e2.operations.setBinding(n4), o.push(n4);
  }
  return o;
}
var me = class _me {
  constructor(e2) {
    __publicField(this, "last");
    this.last = e2;
  }
  concat(e2) {
    return new _me({ elem: e2, previous: this.last });
  }
  [Symbol.iterator]() {
    let e2 = this.last;
    return { next: () => {
      if (void 0 === e2) return { done: true, value: void 0 };
      const n3 = e2.elem;
      return e2 = e2.previous, { done: false, value: n3 };
    } };
  }
};
function ye(e2) {
  const n3 = /* @__PURE__ */ new Map();
  return void 0 !== e2.rootConstraints.tag && n3.set(e2.rootConstraints.tag.key, e2.rootConstraints.tag.value), new me({ elem: { getAncestorsCalled: false, name: e2.rootConstraints.name, serviceIdentifier: e2.rootConstraints.serviceIdentifier, tags: n3 }, previous: void 0 });
}
function Me(e2) {
  return void 0 !== e2.redirections;
}
function Ie(e2, n3, t4, i2) {
  var _a10;
  const r3 = t4.elem.serviceIdentifier, s = (_a10 = t4.previous) == null ? void 0 : _a10.elem.serviceIdentifier;
  Array.isArray(e2) ? function(e3, n4, t5, i3, r4, s2) {
    if (0 !== e3.length) {
      const n5 = s2[s2.length - 1] ?? t5, a2 = `Ambiguous bindings found for service: "${t(n5)}".${Se(s2)}

Registered bindings:

${e3.map((e4) => function(e5) {
        switch (e5.type) {
          case l.Instance:
            return `[ type: "${e5.type}", serviceIdentifier: "${t(e5.serviceIdentifier)}", scope: "${e5.scope}", implementationType: "${e5.implementationType.name}" ]`;
          case l.ServiceRedirection:
            return `[ type: "${e5.type}", serviceIdentifier: "${t(e5.serviceIdentifier)}", redirection: "${t(e5.targetServiceIdentifier)}" ]`;
          default:
            return `[ type: "${e5.type}", serviceIdentifier: "${t(e5.serviceIdentifier)}", scope: "${e5.scope}" ]`;
        }
      }(e4.binding)).join("\n")}

Trying to resolve bindings for "${we(t5, i3)}".${Ce(r4)}`;
      throw new R(A.planning, a2);
    }
    n4 || be(t5, i3, r4, s2);
  }(e2, n3, r3, s, t4.elem, i2) : function(e3, n4, t5, i3, o, r4) {
    void 0 !== e3 || n4 || be(t5, i3, o, r4);
  }(e2, n3, r3, s, t4.elem, i2);
}
function be(e2, n3, t4, i2) {
  const r3 = i2[i2.length - 1] ?? e2, s = `No bindings found for service: "${t(r3)}".

Trying to resolve bindings for "${we(e2, n3)}".${Se(i2)}${Ce(t4)}`;
  throw new R(A.planning, s);
}
function we(e2, n3) {
  return void 0 === n3 ? `${t(e2)} (Root service)` : t(n3);
}
function Ce(e2) {
  var _a10;
  const n3 = 0 === e2.tags.size ? "" : `
- tags:
  - ${[...e2.tags.keys()].map((e3) => e3.toString()).join("\n  - ")}`;
  return `

Binding constraints:
- service identifier: ${t(e2.serviceIdentifier)}
- name: ${((_a10 = e2.name) == null ? void 0 : _a10.toString()) ?? "-"}${n3}`;
}
function Se(e2) {
  return 0 === e2.length ? "" : `

- service redirections:
  - ${e2.map((e3) => t(e3)).join("\n  - ")}`;
}
function Ne(e2, n3, t4, i2) {
  if (1 === e2.redirections.length) {
    const [o] = e2.redirections;
    return void (Me(o) && Ne(o, n3, t4, [...i2, o.binding.targetServiceIdentifier]));
  }
  Ie(e2.redirections, n3, t4, i2);
}
function Pe(e2, n3, t4) {
  if (Array.isArray(e2.bindings) && 1 === e2.bindings.length) {
    const [i2] = e2.bindings;
    return void (Me(i2) && Ne(i2, n3, t4, [i2.binding.targetServiceIdentifier]));
  }
  Ie(e2.bindings, n3, t4, []);
}
function Re(e2) {
  return r.is(e2) ? e2.unwrap() : e2;
}
function Ae(e2) {
  return (n3, t4, i2) => {
    const o = Re(i2.value), r3 = t4.concat({ getAncestorsCalled: false, name: i2.name, serviceIdentifier: o, tags: i2.tags }), s = new ge(r3.last), a2 = i2.kind === x.multipleInjection && i2.chained, c3 = he(n3, s, { chained: a2 }), d2 = [], l2 = { bindings: d2, isContextFree: true, serviceIdentifier: o };
    if (d2.push(...e2(n3, r3, c3, l2, a2)), l2.isContextFree = !r3.last.elem.getAncestorsCalled, i2.kind === x.singleInjection) {
      Pe(l2, i2.optional, r3.last);
      const [e3] = d2;
      l2.bindings = e3;
    }
    return l2;
  };
}
function Te(e2) {
  return (n3, t4, i2) => {
    const o = Re(i2.value), r3 = t4.concat({ getAncestorsCalled: false, name: i2.name, serviceIdentifier: o, tags: i2.tags }), s = new ge(r3.last), a2 = i2.kind === le.multipleInjection && i2.chained, c3 = he(n3, s, { chained: a2 }), d2 = [], l2 = { bindings: d2, isContextFree: true, serviceIdentifier: o };
    if (d2.push(...e2(n3, r3, c3, l2, a2)), l2.isContextFree = !r3.last.elem.getAncestorsCalled, i2.kind === le.singleInjection) {
      Pe(l2, i2.optional, r3.last);
      const [e3] = d2;
      l2.bindings = e3;
    }
    return l2;
  };
}
function xe(e2) {
  const n3 = /* @__PURE__ */ function(e3) {
    return (n4, t5, i3) => {
      const o2 = { binding: t5, classMetadata: n4.operations.getClassMetadata(t5.implementationType), constructorParams: [], propertyParams: /* @__PURE__ */ new Map() }, r3 = { autobindOptions: n4.autobindOptions, node: o2, operations: n4.operations, servicesBranch: n4.servicesBranch };
      return e3(r3, i3);
    };
  }(e2), t4 = /* @__PURE__ */ function(e3) {
    return (n4, t5, i3) => {
      const o2 = { binding: t5, params: [] }, r3 = { autobindOptions: n4.autobindOptions, node: o2, operations: n4.operations, servicesBranch: n4.servicesBranch };
      return e3(r3, i3);
    };
  }(e2), i2 = (e3, i3, r3, s, a2) => {
    const c3 = Me(s) ? s.binding.targetServiceIdentifier : s.serviceIdentifier;
    e3.servicesBranch.push(c3);
    const d2 = [];
    for (const s2 of r3) switch (s2.type) {
      case l.Instance:
        d2.push(n3(e3, s2, i3));
        break;
      case l.ResolvedValue:
        d2.push(t4(e3, s2, i3));
        break;
      case l.ServiceRedirection: {
        const n4 = o(e3, i3, s2, a2);
        d2.push(n4);
        break;
      }
      default:
        d2.push({ binding: s2 });
    }
    return e3.servicesBranch.pop(), d2;
  }, o = /* @__PURE__ */ function(e3) {
    return (n4, t5, i3, o2) => {
      const r3 = { binding: i3, redirections: [] }, s = he(n4, new ge(t5.last), { chained: o2, customServiceIdentifier: i3.targetServiceIdentifier });
      return r3.redirections.push(...e3(n4, t5, s, r3, o2)), r3;
    };
  }(i2);
  return i2;
}
function je(e2, n3, t4, i2) {
  if (void 0 !== e2 && (ve.is(t4) && !t4.isExpanded() || t4.isContextFree)) {
    const i3 = { tree: { root: t4 } };
    n3.setPlan(e2, i3);
  } else n3.setNonCachedServiceNode(t4, i2);
}
var _y, _M, _I2, _b3;
var Be = class extends ve {
  constructor(e2, n3, t4, i2, o) {
    super(o, Re(i2.value));
    __privateAdd(this, _y);
    __privateAdd(this, _M);
    __privateAdd(this, _I2);
    __privateAdd(this, _b3);
    __privateSet(this, _M, n3), __privateSet(this, _y, e2), __privateSet(this, _I2, t4), __privateSet(this, _b3, i2);
  }
  _buildPlanServiceNode() {
    return __privateGet(this, _M).call(this, __privateGet(this, _y), __privateGet(this, _I2), __privateGet(this, _b3));
  }
};
_y = new WeakMap();
_M = new WeakMap();
_I2 = new WeakMap();
_b3 = new WeakMap();
var _y2, _w, _I3, _C;
var Fe = class extends ve {
  constructor(e2, n3, t4, i2, o) {
    super(o, Re(i2.value));
    __privateAdd(this, _y2);
    __privateAdd(this, _w);
    __privateAdd(this, _I3);
    __privateAdd(this, _C);
    __privateSet(this, _y2, e2), __privateSet(this, _w, n3), __privateSet(this, _I3, t4), __privateSet(this, _C, i2);
  }
  _buildPlanServiceNode() {
    return __privateGet(this, _w).call(this, __privateGet(this, _y2), __privateGet(this, _I3), __privateGet(this, _C));
  }
};
_y2 = new WeakMap();
_w = new WeakMap();
_I3 = new WeakMap();
_C = new WeakMap();
function ke(e2, n3, t4, i2) {
  const o = /* @__PURE__ */ function(e3, n4) {
    const t5 = /* @__PURE__ */ function(e4, n5) {
      return (t6, i3, o2) => {
        if (o2.kind === x.unmanaged) return;
        const s2 = function(e5) {
          let n6;
          if (0 === e5.tags.size) n6 = void 0;
          else {
            if (1 !== e5.tags.size) return;
            {
              const [t8, i4] = e5.tags.entries().next().value;
              n6 = { key: t8, value: i4 };
            }
          }
          const t7 = r.is(e5.value) ? e5.value.unwrap() : e5.value;
          return e5.kind === x.multipleInjection ? { chained: e5.chained, isMultiple: true, name: e5.name, optional: e5.optional, serviceIdentifier: t7, tag: n6 } : { isMultiple: false, name: e5.name, optional: e5.optional, serviceIdentifier: t7, tag: n6 };
        }(o2);
        if (void 0 !== s2) {
          const e5 = t6.operations.getPlan(s2);
          if (void 0 !== e5 && e5.tree.root.isContextFree) return e5.tree.root;
        }
        const a2 = n5(t6, i3, o2), c3 = new Be(t6, e4, i3, o2, a2);
        return je(s2, t6.operations, c3, { bindingConstraintsList: i3, chainedBindings: o2.kind === x.multipleInjection && o2.chained, optionalBindings: o2.optional }), c3;
      };
    }(e3, n4);
    return (e4, n5, i3) => {
      const o2 = n5.classMetadata;
      for (const [r3, s2] of o2.constructorArguments.entries()) n5.constructorParams[r3] = t5(e4, i3, s2);
      for (const [r3, s2] of o2.properties) {
        const o3 = t5(e4, i3, s2);
        void 0 !== o3 && n5.propertyParams.set(r3, o3);
      }
      return e4.node;
    };
  }(e2, t4), s = /* @__PURE__ */ function(e3, n4) {
    const t5 = /* @__PURE__ */ function(e4, n5) {
      return (t6, i3, o2) => {
        const s2 = function(e5) {
          let n6;
          if (0 === e5.tags.size) n6 = void 0;
          else {
            if (1 !== e5.tags.size) return;
            {
              const [t8, i4] = e5.tags.entries().next().value;
              n6 = { key: t8, value: i4 };
            }
          }
          const t7 = r.is(e5.value) ? e5.value.unwrap() : e5.value;
          return e5.kind === le.multipleInjection ? { chained: e5.chained, isMultiple: true, name: e5.name, optional: e5.optional, serviceIdentifier: t7, tag: n6 } : { isMultiple: false, name: e5.name, optional: e5.optional, serviceIdentifier: t7, tag: n6 };
        }(o2);
        if (void 0 !== s2) {
          const e5 = t6.operations.getPlan(s2);
          if (void 0 !== e5 && e5.tree.root.isContextFree) return e5.tree.root;
        }
        const a2 = n5(t6, i3, o2), c3 = new Fe(t6, e4, i3, o2, a2);
        return je(s2, t6.operations, c3, { bindingConstraintsList: i3, chainedBindings: o2.kind === le.multipleInjection && o2.chained, optionalBindings: o2.optional }), c3;
      };
    }(e3, n4);
    return (e4, n5, i3) => {
      const o2 = n5.binding.metadata;
      for (const [r3, s2] of o2.arguments.entries()) n5.params[r3] = t5(e4, i3, s2);
      return e4.node;
    };
  }(n3, i2);
  return (e3, n4) => e3.node.binding.type === l.Instance ? o(e3, e3.node, n4) : s(e3, e3.node, n4);
}
var _y3;
var $e = class extends ve {
  constructor(e2, n3) {
    super(n3, n3.serviceIdentifier);
    __privateAdd(this, _y3);
    __privateSet(this, _y3, e2);
  }
  _buildPlanServiceNode() {
    return _e3(__privateGet(this, _y3));
  }
};
_y3 = new WeakMap();
var De = Ae(Oe);
var Ve = Te(Oe);
var Ee = xe(ke(De, Ve, De, Ve));
function Oe(e2, n3, t4, i2, o) {
  return Ee(e2, n3, t4, i2, o);
}
var _e3 = /* @__PURE__ */ function(e2) {
  return (n3) => {
    const t4 = ye(n3), i2 = new ge(t4.last), o = n3.rootConstraints.isMultiple && n3.rootConstraints.chained, r3 = he(n3, i2, { chained: o }), s = [], a2 = { bindings: s, isContextFree: true, serviceIdentifier: n3.rootConstraints.serviceIdentifier };
    if (s.push(...e2(n3, t4, r3, a2, o)), a2.isContextFree = !t4.last.elem.getAncestorsCalled, !n3.rootConstraints.isMultiple) {
      Pe(a2, n3.rootConstraints.isOptional ?? false, t4.last);
      const [e3] = s;
      a2.bindings = e3;
    }
    return a2;
  };
}(Ee);
function Le(e2) {
  try {
    const n3 = function(e3) {
      return e3.rootConstraints.isMultiple ? { chained: e3.rootConstraints.chained, isMultiple: true, name: e3.rootConstraints.name, optional: e3.rootConstraints.isOptional ?? false, serviceIdentifier: e3.rootConstraints.serviceIdentifier, tag: e3.rootConstraints.tag } : { isMultiple: false, name: e3.rootConstraints.name, optional: e3.rootConstraints.isOptional ?? false, serviceIdentifier: e3.rootConstraints.serviceIdentifier, tag: e3.rootConstraints.tag };
    }(e2), t4 = e2.operations.getPlan(n3);
    if (void 0 !== t4) return t4;
    const i2 = _e3(e2), o = { tree: { root: new $e(e2, i2) } };
    return e2.operations.setPlan(n3, o), o;
  } catch (n3) {
    pe(e2, n3);
  }
}
var ze;
!function(e2) {
  e2.bindingAdded = "bindingAdded", e2.bindingRemoved = "bindingRemoved";
}(ze || (ze = {}));
var _S, _N, _P, _Ue_instances, A_fn, R_fn;
var Ue = class {
  constructor() {
    __privateAdd(this, _Ue_instances);
    __privateAdd(this, _S);
    __privateAdd(this, _N);
    __privateAdd(this, _P);
    __privateSet(this, _S, []), __privateSet(this, _N, 8), __privateSet(this, _P, 1024);
  }
  *[Symbol.iterator]() {
    let e2 = 0;
    for (const n3 of __privateGet(this, _S)) {
      const t4 = n3.deref();
      void 0 === t4 ? ++e2 : yield t4;
    }
    __privateGet(this, _S).length >= __privateGet(this, _N) && __privateMethod(this, _Ue_instances, R_fn).call(this, e2) && __privateMethod(this, _Ue_instances, A_fn).call(this, e2);
  }
  push(e2) {
    const n3 = new WeakRef(e2);
    if (__privateGet(this, _S).push(n3), __privateGet(this, _S).length >= __privateGet(this, _N) && __privateGet(this, _S).length % __privateGet(this, _P) === 0) {
      let e3 = 0;
      for (const n4 of __privateGet(this, _S)) void 0 === n4.deref() && ++e3;
      __privateMethod(this, _Ue_instances, R_fn).call(this, e3) && __privateMethod(this, _Ue_instances, A_fn).call(this, e3);
    }
  }
};
_S = new WeakMap();
_N = new WeakMap();
_P = new WeakMap();
_Ue_instances = new WeakSet();
A_fn = function(e2) {
  const n3 = new Array(__privateGet(this, _S).length - e2);
  let t4 = 0;
  for (const e3 of __privateGet(this, _S)) e3.deref() && (n3[t4++] = e3);
  __privateSet(this, _S, n3);
};
R_fn = function(e2) {
  return e2 >= 0.5 * __privateGet(this, _S).length;
};
var Ke = xe(ke(De, Ve, function(e2, n3, t4) {
  return qe(e2, n3, t4);
}, function(e2, n3, t4) {
  return Ge(e2, n3, t4);
}));
var qe = function(e2) {
  const n3 = Ae(e2);
  return (e3, t4, i2) => {
    try {
      return n3(e3, t4, i2);
    } catch (e4) {
      if (R.isErrorOfKind(e4, A.planning)) return;
      throw e4;
    }
  };
}(Ke);
var Ge = function(e2) {
  const n3 = Te(e2);
  return (e3, t4, i2) => {
    try {
      return n3(e3, t4, i2);
    } catch (e4) {
      if (R.isErrorOfKind(e4, A.planning)) return;
      throw e4;
    }
  };
}(Ke);
function We(e2, n3, t4, i2, o) {
  if (ve.is(n3) && !n3.isExpanded()) return { isContextFreeBinding: true, shouldInvalidateServiceNode: false };
  const r3 = new ge(i2.last);
  return !t4.isSatisfiedBy(r3) || i2.last.elem.getAncestorsCalled ? { isContextFreeBinding: !i2.last.elem.getAncestorsCalled, shouldInvalidateServiceNode: false } : function(e3, n4, t5, i3, o2) {
    let r4;
    try {
      [r4] = Ke(e3, i3, [t5], n4, o2);
    } catch (e4) {
      if (ue(e4)) return { isContextFreeBinding: false, shouldInvalidateServiceNode: true };
      throw e4;
    }
    return function(e4, n5) {
      if (Array.isArray(e4.bindings)) e4.bindings.push(n5);
      else {
        if (void 0 !== e4.bindings) {
          if (!ve.is(e4)) throw new R(A.planning, "Unexpected non-lazy plan service node. This is likely a bug in the planning logic. Please, report this issue");
          return { isContextFreeBinding: true, shouldInvalidateServiceNode: true };
        }
        e4.bindings = n5;
      }
      return { isContextFreeBinding: true, shouldInvalidateServiceNode: false };
    }(n4, r4);
  }(e2, n3, t4, i2, o);
}
function Xe(e2, n3, t4, i2) {
  var _a10;
  if (ve.is(e2) && !e2.isExpanded()) return { bindingNodeRemoved: void 0, isContextFreeBinding: true };
  const o = new ge(t4.last);
  if (!n3.isSatisfiedBy(o) || t4.last.elem.getAncestorsCalled) return { bindingNodeRemoved: void 0, isContextFreeBinding: !t4.last.elem.getAncestorsCalled };
  let r3;
  if (Array.isArray(e2.bindings)) e2.bindings = e2.bindings.filter((e3) => e3.binding !== n3 || (r3 = e3, false));
  else if (((_a10 = e2.bindings) == null ? void 0 : _a10.binding) === n3) if (r3 = e2.bindings, i2) e2.bindings = void 0;
  else {
    if (!ve.is(e2)) throw new R(A.planning, "Unexpected non-lazy plan service node. This is likely a bug in the planning logic. Please, report this issue");
    e2.invalidate();
  }
  return { bindingNodeRemoved: r3, isContextFreeBinding: true };
}
var _T, _x, _j, _B, _F, _k, _He_instances, $_fn, K_fn, U_fn, V_fn, D_fn, q_fn, O_fn, __fn, W_fn, X_fn, H_fn, z_fn, E_fn, L_fn, G_fn;
var He = class {
  constructor() {
    __privateAdd(this, _He_instances);
    __privateAdd(this, _T);
    __privateAdd(this, _x);
    __privateAdd(this, _j);
    __privateAdd(this, _B);
    __privateAdd(this, _F);
    __privateAdd(this, _k);
    __privateSet(this, _T, /* @__PURE__ */ new Map()), __privateSet(this, _x, __privateMethod(this, _He_instances, $_fn).call(this)), __privateSet(this, _j, __privateMethod(this, _He_instances, $_fn).call(this)), __privateSet(this, _B, __privateMethod(this, _He_instances, $_fn).call(this)), __privateSet(this, _F, __privateMethod(this, _He_instances, $_fn).call(this)), __privateSet(this, _k, new Ue());
  }
  clearCache() {
    for (const e2 of __privateMethod(this, _He_instances, D_fn).call(this)) e2.clear();
    for (const e2 of __privateGet(this, _k)) e2.clearCache();
  }
  get(e2) {
    var _a10, _b5, _c2, _d2, _e5, _f2;
    return void 0 === e2.name ? void 0 === e2.tag ? __privateMethod(this, _He_instances, V_fn).call(this, __privateGet(this, _x), e2).get(e2.serviceIdentifier) : (_b5 = (_a10 = __privateMethod(this, _He_instances, V_fn).call(this, __privateGet(this, _F), e2).get(e2.serviceIdentifier)) == null ? void 0 : _a10.get(e2.tag.key)) == null ? void 0 : _b5.get(e2.tag.value) : void 0 === e2.tag ? (_c2 = __privateMethod(this, _He_instances, V_fn).call(this, __privateGet(this, _j), e2).get(e2.serviceIdentifier)) == null ? void 0 : _c2.get(e2.name) : (_f2 = (_e5 = (_d2 = __privateMethod(this, _He_instances, V_fn).call(this, __privateGet(this, _B), e2).get(e2.serviceIdentifier)) == null ? void 0 : _d2.get(e2.name)) == null ? void 0 : _e5.get(e2.tag.key)) == null ? void 0 : _f2.get(e2.tag.value);
  }
  invalidateServiceBinding(e2) {
    __privateMethod(this, _He_instances, E_fn).call(this, e2), __privateMethod(this, _He_instances, O_fn).call(this, e2), __privateMethod(this, _He_instances, __fn).call(this, e2), __privateMethod(this, _He_instances, L_fn).call(this, e2), __privateMethod(this, _He_instances, z_fn).call(this, e2);
    for (const n3 of __privateGet(this, _k)) n3.invalidateServiceBinding(e2);
  }
  set(e2, n3) {
    void 0 === e2.name ? void 0 === e2.tag ? __privateMethod(this, _He_instances, V_fn).call(this, __privateGet(this, _x), e2).set(e2.serviceIdentifier, n3) : __privateMethod(this, _He_instances, U_fn).call(this, __privateMethod(this, _He_instances, U_fn).call(this, __privateMethod(this, _He_instances, V_fn).call(this, __privateGet(this, _F), e2), e2.serviceIdentifier), e2.tag.key).set(e2.tag.value, n3) : void 0 === e2.tag ? __privateMethod(this, _He_instances, U_fn).call(this, __privateMethod(this, _He_instances, V_fn).call(this, __privateGet(this, _j), e2), e2.serviceIdentifier).set(e2.name, n3) : __privateMethod(this, _He_instances, U_fn).call(this, __privateMethod(this, _He_instances, U_fn).call(this, __privateMethod(this, _He_instances, U_fn).call(this, __privateMethod(this, _He_instances, V_fn).call(this, __privateGet(this, _B), e2), e2.serviceIdentifier), e2.name), e2.tag.key).set(e2.tag.value, n3);
  }
  setNonCachedServiceNode(e2, n3) {
    let t4 = __privateGet(this, _T).get(e2.serviceIdentifier);
    void 0 === t4 && (t4 = /* @__PURE__ */ new Map(), __privateGet(this, _T).set(e2.serviceIdentifier, t4)), t4.set(e2, n3);
  }
  subscribe(e2) {
    __privateGet(this, _k).push(e2);
  }
};
_T = new WeakMap();
_x = new WeakMap();
_j = new WeakMap();
_B = new WeakMap();
_F = new WeakMap();
_k = new WeakMap();
_He_instances = new WeakSet();
$_fn = function() {
  const e2 = new Array(8);
  for (let n3 = 0; n3 < e2.length; ++n3) e2[n3] = /* @__PURE__ */ new Map();
  return e2;
};
K_fn = function(e2, n3, t4, i2) {
  const o = !!(2 & n3);
  let r3;
  if (o) {
    r3 = { chained: !!(0 & n3), isMultiple: o, serviceIdentifier: e2.binding.serviceIdentifier };
  } else r3 = { isMultiple: o, serviceIdentifier: e2.binding.serviceIdentifier };
  return !!(1 & n3) && (r3.isOptional = true), void 0 !== t4 && (r3.name = t4), void 0 !== i2 && (r3.tag = i2), { autobindOptions: void 0, operations: e2.operations, rootConstraints: r3, servicesBranch: [] };
};
U_fn = function(e2, n3) {
  let t4 = e2.get(n3);
  return void 0 === t4 && (t4 = /* @__PURE__ */ new Map(), e2.set(n3, t4)), t4;
};
V_fn = function(e2, n3) {
  return e2[__privateMethod(this, _He_instances, q_fn).call(this, n3)];
};
D_fn = function() {
  return [__privateGet(this, _T), ...__privateGet(this, _x), ...__privateGet(this, _j), ...__privateGet(this, _B), ...__privateGet(this, _F)];
};
q_fn = function(e2) {
  return e2.isMultiple ? (e2.chained ? 4 : 0) | (e2.optional ? 1 : 0) | 2 : e2.optional ? 1 : 0;
};
O_fn = function(e2) {
  for (const [n3, t4] of __privateGet(this, _j).entries()) {
    const i2 = t4.get(e2.binding.serviceIdentifier);
    if (void 0 !== i2) for (const [t5, o] of i2.entries()) __privateMethod(this, _He_instances, G_fn).call(this, e2, o, n3, t5, void 0);
  }
};
__fn = function(e2) {
  for (const [n3, t4] of __privateGet(this, _B).entries()) {
    const i2 = t4.get(e2.binding.serviceIdentifier);
    if (void 0 !== i2) for (const [t5, o] of i2.entries()) for (const [i3, r3] of o.entries()) for (const [o2, s] of r3.entries()) __privateMethod(this, _He_instances, G_fn).call(this, e2, s, n3, t5, { key: i3, value: o2 });
  }
};
W_fn = function(e2) {
  switch (e2.binding.type) {
    case l.ServiceRedirection:
      for (const n3 of e2.redirections) __privateMethod(this, _He_instances, W_fn).call(this, n3);
      break;
    case l.Instance:
      for (const n3 of e2.constructorParams) void 0 !== n3 && __privateMethod(this, _He_instances, X_fn).call(this, n3);
      for (const n3 of e2.propertyParams.values()) __privateMethod(this, _He_instances, X_fn).call(this, n3);
      break;
    case l.ResolvedValue:
      for (const n3 of e2.params) __privateMethod(this, _He_instances, X_fn).call(this, n3);
  }
};
X_fn = function(e2) {
  const n3 = __privateGet(this, _T).get(e2.serviceIdentifier);
  void 0 !== n3 && n3.has(e2) && (n3.delete(e2), __privateMethod(this, _He_instances, H_fn).call(this, e2));
};
H_fn = function(e2) {
  if ((!ve.is(e2) || e2.isExpanded()) && void 0 !== e2.bindings) if (Array.isArray(e2.bindings)) for (const n3 of e2.bindings) __privateMethod(this, _He_instances, W_fn).call(this, n3);
  else __privateMethod(this, _He_instances, W_fn).call(this, e2.bindings);
};
z_fn = function(e2) {
  const n3 = __privateGet(this, _T).get(e2.binding.serviceIdentifier);
  if (void 0 !== n3) switch (e2.kind) {
    case ze.bindingAdded:
      for (const [t4, i2] of n3) {
        const n4 = We({ autobindOptions: void 0, operations: e2.operations, servicesBranch: [] }, t4, e2.binding, i2.bindingConstraintsList, i2.chainedBindings);
        n4.isContextFreeBinding ? n4.shouldInvalidateServiceNode && ve.is(t4) && (__privateMethod(this, _He_instances, H_fn).call(this, t4), t4.invalidate()) : this.clearCache();
      }
      break;
    case ze.bindingRemoved:
      for (const [t4, i2] of n3) {
        const n4 = Xe(t4, e2.binding, i2.bindingConstraintsList, i2.optionalBindings);
        n4.isContextFreeBinding ? void 0 !== n4.bindingNodeRemoved && __privateMethod(this, _He_instances, W_fn).call(this, n4.bindingNodeRemoved) : this.clearCache();
      }
  }
};
E_fn = function(e2) {
  for (const [n3, t4] of __privateGet(this, _x).entries()) {
    const i2 = t4.get(e2.binding.serviceIdentifier);
    __privateMethod(this, _He_instances, G_fn).call(this, e2, i2, n3, void 0, void 0);
  }
};
L_fn = function(e2) {
  for (const [n3, t4] of __privateGet(this, _F).entries()) {
    const i2 = t4.get(e2.binding.serviceIdentifier);
    if (void 0 !== i2) for (const [t5, o] of i2.entries()) for (const [i3, r3] of o.entries()) __privateMethod(this, _He_instances, G_fn).call(this, e2, r3, n3, void 0, { key: t5, value: i3 });
  }
};
G_fn = function(e2, n3, t4, i2, o) {
  if (void 0 !== n3 && ve.is(n3.tree.root)) {
    const c3 = __privateMethod(this, _He_instances, K_fn).call(this, e2, t4, i2, o);
    switch (e2.kind) {
      case ze.bindingAdded:
        {
          const t5 = (r3 = c3, s = n3.tree.root, a2 = e2.binding, ve.is(s) && !s.isExpanded() ? { isContextFreeBinding: true, shouldInvalidateServiceNode: false } : We(r3, s, a2, ye(r3), r3.rootConstraints.isMultiple && r3.rootConstraints.chained));
          t5.isContextFreeBinding ? t5.shouldInvalidateServiceNode && (__privateMethod(this, _He_instances, H_fn).call(this, n3.tree.root), n3.tree.root.invalidate()) : this.clearCache();
        }
        break;
      case ze.bindingRemoved: {
        const t5 = function(e3, n4, t6) {
          return ve.is(n4) && !n4.isExpanded() ? { bindingNodeRemoved: void 0, isContextFreeBinding: true } : Xe(n4, t6, ye(e3), e3.rootConstraints.isOptional ?? false);
        }(c3, n3.tree.root, e2.binding);
        t5.isContextFreeBinding ? void 0 !== t5.bindingNodeRemoved && __privateMethod(this, _He_instances, W_fn).call(this, t5.bindingNodeRemoved) : this.clearCache();
      }
    }
  }
  var r3, s, a2;
};
function Je(e2, n3) {
  if (ue(n3)) {
    const t4 = function(e3) {
      const n4 = [...e3];
      if (0 === n4.length) return "(No dependency trace)";
      return n4.map(t).join(" -> ");
    }(function(e3) {
      const n4 = e3.planResult.tree.root, t5 = [];
      function i2(e4) {
        const n5 = t5.indexOf(e4);
        if (-1 !== n5) {
          return [...t5.slice(n5), e4].map((e5) => e5.serviceIdentifier);
        }
        t5.push(e4);
        try {
          for (const n6 of function(e5) {
            const n7 = [], t6 = e5.bindings;
            if (void 0 === t6) return n7;
            const i3 = (e6) => {
              if (Me(e6)) for (const n8 of e6.redirections) i3(n8);
              else switch (e6.binding.type) {
                case l.Instance: {
                  const t7 = e6;
                  for (const e7 of t7.constructorParams) void 0 !== e7 && n7.push(e7);
                  for (const e7 of t7.propertyParams.values()) n7.push(e7);
                  break;
                }
                case l.ResolvedValue: {
                  const t7 = e6;
                  for (const e7 of t7.params) n7.push(e7);
                  break;
                }
              }
            };
            if (Array.isArray(t6)) for (const e6 of t6) i3(e6);
            else i3(t6);
            return n7;
          }(e4)) {
            const e5 = i2(n6);
            if (void 0 !== e5) return e5;
          }
        } finally {
          t5.pop();
        }
      }
      return i2(n4) ?? [];
    }(e2));
    throw new R(A.planning, `Circular dependency found: ${t4}`, { cause: n3 });
  }
  throw n3;
}
function Qe(e2, n3) {
  return e(n3) ? (e2.cache = { isRight: true, value: n3 }, n3.then((n4) => Ye(e2, n4))) : Ye(e2, n3);
}
function Ye(e2, n3) {
  return e2.cache = { isRight: true, value: n3 }, n3;
}
function Ze(e2, n3, t4) {
  const i2 = e2.getActivations(n3);
  return void 0 === i2 ? t4 : e(t4) ? en(e2, t4, i2[Symbol.iterator]()) : function(e3, n4, t5) {
    let i3 = n4, o = t5.next();
    for (; true !== o.done; ) {
      const n5 = o.value(e3.context, i3);
      if (e(n5)) return en(e3, n5, t5);
      i3 = n5, o = t5.next();
    }
    return i3;
  }(e2, t4, i2[Symbol.iterator]());
}
async function en(e2, n3, t4) {
  let i2 = await n3, o = t4.next();
  for (; true !== o.done; ) i2 = await o.value(e2.context, i2), o = t4.next();
  return i2;
}
function nn(e2, n3, t4) {
  let i2 = t4;
  if (void 0 !== n3.onActivation) {
    const t5 = n3.onActivation;
    i2 = e(i2) ? i2.then((n4) => t5(e2.context, n4)) : t5(e2.context, i2);
  }
  return Ze(e2, n3.serviceIdentifier, i2);
}
function tn(e2) {
  return (n3, t4) => {
    if (t4.cache.isRight) return t4.cache.value;
    return Qe(t4, nn(n3, t4, e2(n3, t4)));
  };
}
var on = tn(function(e2, n3) {
  return n3.value;
});
function rn(e2) {
  return e2;
}
function sn(e2, n3) {
  return (t4, i2) => {
    const o = e2(i2);
    switch (o.scope) {
      case d.Singleton:
        if (o.cache.isRight) return o.cache.value;
        return Qe(o, nn(t4, o, n3(t4, i2)));
      case d.Request: {
        if (t4.requestScopeCache.has(o.id)) return t4.requestScopeCache.get(o.id);
        const e3 = nn(t4, o, n3(t4, i2));
        return t4.requestScopeCache.set(o.id, e3), e3;
      }
      case d.Transient:
        return nn(t4, o, n3(t4, i2));
    }
  };
}
var an = ((e2) => sn(rn, e2))(function(e2, n3) {
  return n3.value(e2.context);
});
var cn = tn(function(e2, n3) {
  return n3.factory(e2.context);
});
function dn(e2, n3, t4) {
  const i2 = function(e3, n4, t5) {
    if (void 0 === t5) return;
    if (!(t5 in e3)) throw new R(A.resolution, `Expecting a "${t5.toString()}" property when resolving "${n4.implementationType.name}" class @postConstruct decorated method, none found.`);
    if ("function" != typeof e3[t5]) throw new R(A.resolution, `Expecting a "${t5.toString()}" method when resolving "${n4.implementationType.name}" class @postConstruct decorated method, a non function property was found instead.`);
    {
      let i3;
      try {
        i3 = e3[t5]();
      } catch (e4) {
        throw new R(A.resolution, `Unexpected error found when calling "${t5.toString()}" @postConstruct decorated method on class "${n4.implementationType.name}"`, { cause: e4 });
      }
      if (e(i3)) return async function(e4, n5, t6) {
        try {
          await t6;
        } catch (t7) {
          throw new R(A.resolution, `Unexpected error found when calling "${n5.toString()}" @postConstruct decorated method on class "${e4.implementationType.name}"`, { cause: t7 });
        }
      }(n4, t5, i3);
    }
  }(e2, n3, t4);
  return e(i2) ? i2.then(() => e2) : e2;
}
function ln(e2) {
  return (n3, t4, i2) => {
    const o = new i2.binding.implementationType(...n3), r3 = e2(t4, o, i2);
    return e(r3) ? r3.then(() => dn(o, i2.binding, i2.classMetadata.lifecycle.postConstructMethodName)) : dn(o, i2.binding, i2.classMetadata.lifecycle.postConstructMethodName);
  };
}
var un = tn(function(e2, n3) {
  return n3.provider(e2.context);
});
function pn(e2) {
  return e2.binding;
}
function fn(e2) {
  return e2.binding;
}
var vn = /* @__PURE__ */ function(e2) {
  return (n3, t4, i2) => {
    const o = [];
    for (const [r3, a2] of i2.propertyParams) {
      const c3 = i2.classMetadata.properties.get(r3);
      if (void 0 === c3) throw new R(A.resolution, `Expecting metadata at property "${r3.toString()}", none found`);
      c3.kind !== x.unmanaged && void 0 !== a2.bindings && (t4[r3] = e2(n3, a2), e(t4[r3]) && o.push((async () => {
        t4[r3] = await t4[r3];
      })()));
    }
    if (o.length > 0) return Promise.all(o).then(() => {
    });
  };
}(wn);
var gn = /* @__PURE__ */ function(e2) {
  return function n3(t4, i2) {
    const o = [];
    for (const r3 of i2.redirections) Me(r3) ? o.push(...n3(t4, r3)) : o.push(e2(t4, r3));
    return o;
  };
}(bn);
var hn = /* @__PURE__ */ function(e2, n3, t4) {
  return (i2, o) => {
    const r3 = e2(i2, o);
    return e(r3) ? n3(r3, i2, o) : t4(r3, i2, o);
  };
}(/* @__PURE__ */ function(e2) {
  return (n3, t4) => {
    const i2 = [];
    for (const o of t4.constructorParams) void 0 === o ? i2.push(void 0) : i2.push(e2(n3, o));
    return i2.some(e) ? Promise.all(i2) : i2;
  };
}(wn), /* @__PURE__ */ function(e2) {
  return async (n3, t4, i2) => {
    const o = await n3;
    return e2(o, t4, i2);
  };
}(ln(vn)), ln(vn));
var mn = /* @__PURE__ */ function(e2) {
  return (n3, t4) => {
    const i2 = e2(n3, t4);
    return e(i2) ? i2.then((e3) => t4.binding.factory(...e3)) : t4.binding.factory(...i2);
  };
}(/* @__PURE__ */ function(e2) {
  return (n3, t4) => {
    const i2 = [];
    for (const o of t4.params) i2.push(e2(n3, o));
    return i2.some(e) ? Promise.all(i2) : i2;
  };
}(wn));
var yn = ((e2) => sn(pn, e2))(hn);
var Mn = ((e2) => sn(fn, e2))(mn);
function In(e2) {
  try {
    return wn(e2, e2.planResult.tree.root);
  } catch (n3) {
    Je(e2, n3);
  }
}
function bn(e2, n3) {
  switch (n3.binding.type) {
    case l.ConstantValue:
      return on(e2, n3.binding);
    case l.DynamicValue:
      return an(e2, n3.binding);
    case l.Factory:
      return cn(e2, n3.binding);
    case l.Instance:
      return yn(e2, n3);
    case l.Provider:
      return un(e2, n3.binding);
    case l.ResolvedValue:
      return Mn(e2, n3);
  }
}
function wn(e2, n3) {
  if (void 0 !== n3.bindings) return Array.isArray(n3.bindings) ? function(e3, n4) {
    const t4 = [];
    for (const i2 of n4) Me(i2) ? t4.push(...gn(e3, i2)) : t4.push(bn(e3, i2));
    if (t4.some(e)) return Promise.all(t4);
    return t4;
  }(e2, n3.bindings) : function(e3, n4) {
    if (Me(n4)) {
      const t4 = gn(e3, n4);
      if (1 === t4.length) return t4[0];
      throw new R(A.resolution, "Unexpected multiple resolved values on single injection");
    }
    return bn(e3, n4);
  }(e2, n3.bindings);
}
function Cn(e2) {
  return void 0 !== e2.scope;
}
function Sn(e2, n3) {
  if (void 0 !== e2.lifecycle.preDestroyMethodName && "function" == typeof n3[e2.lifecycle.preDestroyMethodName]) return n3[e2.lifecycle.preDestroyMethodName]();
}
function Nn(e2, n3, t4) {
  const i2 = e2.getDeactivations(n3);
  if (void 0 !== i2) return e(t4) ? Pn(t4, i2[Symbol.iterator]()) : function(e3, n4) {
    let t5 = n4.next();
    for (; true !== t5.done; ) {
      const i3 = t5.value(e3);
      if (e(i3)) return Pn(e3, n4);
      t5 = n4.next();
    }
  }(t4, i2[Symbol.iterator]());
}
async function Pn(e2, n3) {
  const t4 = await e2;
  let i2 = n3.next();
  for (; true !== i2.done; ) await i2.value(t4), i2 = n3.next();
}
function Rn(e2, n3) {
  const t4 = function(e3, n4) {
    if (n4.type === l.Instance) {
      const t5 = e3.getClassMetadata(n4.implementationType), i2 = n4.cache.value;
      return e(i2) ? i2.then((e4) => Sn(t5, e4)) : Sn(t5, i2);
    }
  }(e2, n3);
  return void 0 === t4 ? An(e2, n3) : t4.then(() => An(e2, n3));
}
function An(e2, n3) {
  const t4 = n3.cache;
  return e(t4.value) ? t4.value.then((t5) => Tn(e2, n3, t5)) : Tn(e2, n3, t4.value);
}
function Tn(e2, n3, t4) {
  let i2;
  if (void 0 !== n3.onDeactivation) {
    i2 = (0, n3.onDeactivation)(t4);
  }
  return void 0 === i2 ? Nn(e2, n3.serviceIdentifier, t4) : i2.then(() => Nn(e2, n3.serviceIdentifier, t4));
}
function xn(e2, n3) {
  if (void 0 === n3) return;
  const t4 = function(e3) {
    const n4 = [];
    for (const t5 of e3) Cn(t5) && t5.scope === d.Singleton && t5.cache.isRight && n4.push(t5);
    return n4;
  }(n3), i2 = [];
  for (const n4 of t4) {
    const t5 = Rn(e2, n4);
    void 0 !== t5 && i2.push(t5);
  }
  return i2.length > 0 ? Promise.all(i2).then(() => {
  }) : void 0;
}
function jn(e2, n3) {
  const t4 = e2.getBindingsFromModule(n3);
  return xn(e2, t4);
}
function Bn(e2, n3) {
  const t4 = e2.getBindings(n3);
  return xn(e2, t4);
}

// node_modules/@inversifyjs/plugin/lib/esm/index.js
var t3 = Symbol.for("@inversifyjs/plugin/isPlugin");
var _a4;
_a4 = t3;
var n2 = class {
  constructor(t4, n3) {
    __publicField(this, _a4, true);
    __publicField(this, "_container");
    __publicField(this, "_context");
    this._container = t4, this._context = n3;
  }
};

// node_modules/@inversifyjs/container/lib/esm/index.js
var m2 = "@inversifyjs/container/bindingId";
var _e4, _n2;
var w2 = class {
  constructor(t4) {
    __privateAdd(this, _e4);
    __privateAdd(this, _n2);
    __privateSet(this, _e4, function() {
      const t5 = c(Object, m2) ?? 0;
      return t5 === Number.MAX_SAFE_INTEGER ? r2(Object, m2, Number.MIN_SAFE_INTEGER) : i(Object, m2, () => t5, (e2) => e2 + 1), t5;
    }()), __privateSet(this, _n2, t4);
  }
  get id() {
    return __privateGet(this, _e4);
  }
  load(e2) {
    return __privateGet(this, _n2).call(this, e2);
  }
};
_e4 = new WeakMap();
_n2 = new WeakMap();
var I2 = Symbol.for("@inversifyjs/container/bindingIdentifier");
function P2(e2) {
  return "object" == typeof e2 && null !== e2 && true === e2[I2];
}
var A2 = class {
};
__publicField(A2, "always", (e2) => true);
var C2 = Symbol.for("@inversifyjs/container/InversifyContainerError");
var _a5, _b4;
var B2 = class _B3 extends (_b4 = Error, _a5 = C2, _b4) {
  constructor(e2, n3, i2) {
    super(n3, i2);
    __publicField(this, _a5);
    __publicField(this, "kind");
    this[C2] = true, this.kind = e2;
  }
  static is(e2) {
    return "object" == typeof e2 && null !== e2 && true === e2[C2];
  }
  static isErrorOfKind(e2, n3) {
    return _B3.is(e2) && e2.kind === n3;
  }
};
var O2;
function x2(e2) {
  return { [I2]: true, id: e2.id };
}
function k2(e2) {
  return (n3) => {
    for (let i2 = n3.getAncestor(); void 0 !== i2; i2 = i2.getAncestor()) if (e2(i2)) return true;
    return false;
  };
}
function N2(e2) {
  return (n3) => n3.name === e2;
}
function F2(e2) {
  return (n3) => n3.serviceIdentifier === e2;
}
function U2(e2, n3) {
  return (i2) => i2.tags.has(e2) && i2.tags.get(e2) === n3;
}
function D2(e2) {
  return void 0 === e2.name && 0 === e2.tags.size;
}
function j2(e2) {
  const n3 = k2(e2);
  return (e3) => !n3(e3);
}
function T2(e2) {
  return (n3) => {
    const i2 = n3.getAncestor();
    return void 0 === i2 || !e2(i2);
  };
}
function V2(e2) {
  return (n3) => {
    const i2 = n3.getAncestor();
    return void 0 !== i2 && e2(i2);
  };
}
!function(e2) {
  e2[e2.invalidOperation = 0] = "invalidOperation";
}(O2 || (O2 = {}));
var _i;
var E2 = class {
  constructor(e2) {
    __privateAdd(this, _i);
    __privateSet(this, _i, e2);
  }
  getIdentifier() {
    return x2(__privateGet(this, _i));
  }
  inRequestScope() {
    return __privateGet(this, _i).scope = d.Request, new G2(__privateGet(this, _i));
  }
  inSingletonScope() {
    return __privateGet(this, _i).scope = d.Singleton, new G2(__privateGet(this, _i));
  }
  inTransientScope() {
    return __privateGet(this, _i).scope = d.Transient, new G2(__privateGet(this, _i));
  }
};
_i = new WeakMap();
var _t2, _r, _a6, _s, _L_instances, o_fn2;
var L2 = class {
  constructor(e2, n3, i2, t4) {
    __privateAdd(this, _L_instances);
    __privateAdd(this, _t2);
    __privateAdd(this, _r);
    __privateAdd(this, _a6);
    __privateAdd(this, _s);
    __privateSet(this, _t2, e2), __privateSet(this, _r, n3), __privateSet(this, _a6, i2), __privateSet(this, _s, t4);
  }
  to(e2) {
    const n3 = j(e2), i2 = { cache: { isRight: false, value: void 0 }, id: c2(), implementationType: e2, isSatisfiedBy: A2.always, moduleId: __privateGet(this, _r), onActivation: void 0, onDeactivation: void 0, scope: n3.scope ?? __privateGet(this, _a6), serviceIdentifier: __privateGet(this, _s), type: l.Instance };
    return __privateGet(this, _t2).call(this, i2), new H2(i2);
  }
  toSelf() {
    if ("function" != typeof __privateGet(this, _s)) throw new Error('"toSelf" function can only be applied when a newable function is used as service identifier');
    return this.to(__privateGet(this, _s));
  }
  toConstantValue(e2) {
    const n3 = { cache: { isRight: false, value: void 0 }, id: c2(), isSatisfiedBy: A2.always, moduleId: __privateGet(this, _r), onActivation: void 0, onDeactivation: void 0, scope: d.Singleton, serviceIdentifier: __privateGet(this, _s), type: l.ConstantValue, value: e2 };
    return __privateGet(this, _t2).call(this, n3), new G2(n3);
  }
  toDynamicValue(e2) {
    const n3 = { cache: { isRight: false, value: void 0 }, id: c2(), isSatisfiedBy: A2.always, moduleId: __privateGet(this, _r), onActivation: void 0, onDeactivation: void 0, scope: __privateGet(this, _a6), serviceIdentifier: __privateGet(this, _s), type: l.DynamicValue, value: e2 };
    return __privateGet(this, _t2).call(this, n3), new H2(n3);
  }
  toResolvedValue(e2, n3) {
    const i2 = { cache: { isRight: false, value: void 0 }, factory: e2, id: c2(), isSatisfiedBy: A2.always, metadata: __privateMethod(this, _L_instances, o_fn2).call(this, n3), moduleId: __privateGet(this, _r), onActivation: void 0, onDeactivation: void 0, scope: __privateGet(this, _a6), serviceIdentifier: __privateGet(this, _s), type: l.ResolvedValue };
    return __privateGet(this, _t2).call(this, i2), new H2(i2);
  }
  toFactory(e2) {
    const n3 = { cache: { isRight: false, value: void 0 }, factory: e2, id: c2(), isSatisfiedBy: A2.always, moduleId: __privateGet(this, _r), onActivation: void 0, onDeactivation: void 0, scope: d.Singleton, serviceIdentifier: __privateGet(this, _s), type: l.Factory };
    return __privateGet(this, _t2).call(this, n3), new G2(n3);
  }
  toProvider(e2) {
    const n3 = { cache: { isRight: false, value: void 0 }, id: c2(), isSatisfiedBy: A2.always, moduleId: __privateGet(this, _r), onActivation: void 0, onDeactivation: void 0, provider: e2, scope: d.Singleton, serviceIdentifier: __privateGet(this, _s), type: l.Provider };
    return __privateGet(this, _t2).call(this, n3), new G2(n3);
  }
  toService(e2) {
    const n3 = { id: c2(), isSatisfiedBy: A2.always, moduleId: __privateGet(this, _r), serviceIdentifier: __privateGet(this, _s), targetServiceIdentifier: e2, type: l.ServiceRedirection };
    __privateGet(this, _t2).call(this, n3);
  }
};
_t2 = new WeakMap();
_r = new WeakMap();
_a6 = new WeakMap();
_s = new WeakMap();
_L_instances = new WeakSet();
o_fn2 = function(e2) {
  return { arguments: (e2 ?? []).map((e3) => function(e4) {
    return "object" == typeof e4 && !r.is(e4);
  }(e3) ? function(e4) {
    return true === e4.isMultiple;
  }(e3) ? { chained: e3.chained ?? false, kind: le.multipleInjection, name: e3.name, optional: e3.optional ?? false, tags: new Map((e3.tags ?? []).map((e4) => [e4.key, e4.value])), value: e3.serviceIdentifier } : { kind: le.singleInjection, name: e3.name, optional: e3.optional ?? false, tags: new Map((e3.tags ?? []).map((e4) => [e4.key, e4.value])), value: e3.serviceIdentifier } : { kind: le.singleInjection, name: void 0, optional: false, tags: /* @__PURE__ */ new Map(), value: e3 }) };
};
var _i2;
var $2 = class {
  constructor(e2) {
    __privateAdd(this, _i2);
    __privateSet(this, _i2, e2);
  }
  getIdentifier() {
    return x2(__privateGet(this, _i2));
  }
  onActivation(e2) {
    return __privateGet(this, _i2).onActivation = e2, new q2(__privateGet(this, _i2));
  }
  onDeactivation(e2) {
    if (__privateGet(this, _i2).onDeactivation = e2, __privateGet(this, _i2).scope !== d.Singleton) throw new B2(O2.invalidOperation, `Binding for service "${t(__privateGet(this, _i2).serviceIdentifier)}" has a deactivation function, but its scope is not singleton. Deactivation functions can only be used with singleton bindings.`);
    return new q2(__privateGet(this, _i2));
  }
};
_i2 = new WeakMap();
var _i3;
var q2 = class {
  constructor(e2) {
    __privateAdd(this, _i3);
    __privateSet(this, _i3, e2);
  }
  getIdentifier() {
    return x2(__privateGet(this, _i3));
  }
  when(e2) {
    return __privateGet(this, _i3).isSatisfiedBy = e2, new $2(__privateGet(this, _i3));
  }
  whenAnyAncestor(e2) {
    return this.when(k2(e2));
  }
  whenAnyAncestorIs(e2) {
    return this.when(k2(F2(e2)));
  }
  whenAnyAncestorNamed(e2) {
    return this.when(function(e3) {
      return k2(N2(e3));
    }(e2));
  }
  whenAnyAncestorTagged(e2, n3) {
    return this.when(function(e3, n4) {
      return k2(U2(e3, n4));
    }(e2, n3));
  }
  whenDefault() {
    return this.when(D2);
  }
  whenNamed(e2) {
    return this.when(N2(e2));
  }
  whenNoParent(e2) {
    return this.when(T2(e2));
  }
  whenNoParentIs(e2) {
    return this.when(T2(F2(e2)));
  }
  whenNoParentNamed(e2) {
    return this.when(function(e3) {
      return T2(N2(e3));
    }(e2));
  }
  whenNoParentTagged(e2, n3) {
    return this.when(function(e3, n4) {
      return T2(U2(e3, n4));
    }(e2, n3));
  }
  whenParent(e2) {
    return this.when(V2(e2));
  }
  whenParentIs(e2) {
    return this.when(V2(F2(e2)));
  }
  whenParentNamed(e2) {
    return this.when(function(e3) {
      return V2(N2(e3));
    }(e2));
  }
  whenParentTagged(e2, n3) {
    return this.when(function(e3, n4) {
      return V2(U2(e3, n4));
    }(e2, n3));
  }
  whenTagged(e2, n3) {
    return this.when(U2(e2, n3));
  }
  whenNoAncestor(e2) {
    return this.when(j2(e2));
  }
  whenNoAncestorIs(e2) {
    return this.when(j2(F2(e2)));
  }
  whenNoAncestorNamed(e2) {
    return this.when(function(e3) {
      return j2(N2(e3));
    }(e2));
  }
  whenNoAncestorTagged(e2, n3) {
    return this.when(function(e3, n4) {
      return j2(U2(e3, n4));
    }(e2, n3));
  }
};
_i3 = new WeakMap();
var _c;
var G2 = class extends q2 {
  constructor(e2) {
    super(e2);
    __privateAdd(this, _c);
    __privateSet(this, _c, new $2(e2));
  }
  onActivation(e2) {
    return __privateGet(this, _c).onActivation(e2);
  }
  onDeactivation(e2) {
    return __privateGet(this, _c).onDeactivation(e2);
  }
};
_c = new WeakMap();
var _d;
var H2 = class extends G2 {
  constructor(e2) {
    super(e2);
    __privateAdd(this, _d);
    __privateSet(this, _d, new E2(e2));
  }
  inRequestScope() {
    return __privateGet(this, _d).inRequestScope();
  }
  inSingletonScope() {
    return __privateGet(this, _d).inSingletonScope();
  }
  inTransientScope() {
    return __privateGet(this, _d).inTransientScope();
  }
};
_d = new WeakMap();
var _l, _a7, _u, _h3, ___instances, v_fn, b_fn, f_fn, p_fn2, M_fn, S_fn, R_fn2, g_fn;
var _2 = class {
  constructor(e2, n3, i2, t4) {
    __privateAdd(this, ___instances);
    __privateAdd(this, _l);
    __privateAdd(this, _a7);
    __privateAdd(this, _u);
    __privateAdd(this, _h3);
    __privateSet(this, _l, e2), __privateSet(this, _a7, n3), __privateSet(this, _u, i2), __privateSet(this, _h3, t4);
  }
  bind(e2) {
    return new L2((e3) => {
      __privateMethod(this, ___instances, v_fn).call(this, e3);
    }, void 0, __privateGet(this, _a7), e2);
  }
  isBound(e2, n3) {
    const i2 = __privateGet(this, _h3).bindingService.get(e2);
    return __privateMethod(this, ___instances, g_fn).call(this, e2, i2, n3);
  }
  isCurrentBound(e2, n3) {
    const i2 = __privateGet(this, _h3).bindingService.getNonParentBindings(e2);
    return __privateMethod(this, ___instances, g_fn).call(this, e2, i2, n3);
  }
  async rebind(e2) {
    return await this.unbind(e2), this.bind(e2);
  }
  rebindSync(e2) {
    return this.unbindSync(e2), this.bind(e2);
  }
  async unbind(e2) {
    await __privateMethod(this, ___instances, f_fn).call(this, e2);
  }
  async unbindAll() {
    const e2 = [...__privateGet(this, _h3).bindingService.getNonParentBoundServices()];
    await Promise.all(e2.map(async (e3) => Bn(__privateGet(this, _l), e3)));
    for (const n3 of e2) __privateGet(this, _h3).activationService.removeAllByServiceId(n3), __privateGet(this, _h3).bindingService.removeAllByServiceId(n3), __privateGet(this, _h3).deactivationService.removeAllByServiceId(n3);
    __privateGet(this, _h3).planResultCacheService.clearCache();
  }
  unbindSync(e2) {
    void 0 !== __privateMethod(this, ___instances, f_fn).call(this, e2) && __privateMethod(this, ___instances, b_fn).call(this, e2);
  }
};
_l = new WeakMap();
_a7 = new WeakMap();
_u = new WeakMap();
_h3 = new WeakMap();
___instances = new WeakSet();
v_fn = function(e2) {
  __privateGet(this, _h3).bindingService.set(e2), __privateGet(this, _u).invalidateService({ binding: e2, kind: ze.bindingAdded });
};
b_fn = function(e2) {
  var _a10;
  let n3;
  if (P2(e2)) {
    const t4 = __privateGet(this, _h3).bindingService.getById(e2.id), r3 = (_a10 = (i2 = t4, function(e3) {
      if (void 0 === e3) return;
      const n4 = e3.next();
      return true !== n4.done ? n4.value : void 0;
    }(i2 == null ? void 0 : i2[Symbol.iterator]()))) == null ? void 0 : _a10.serviceIdentifier;
    n3 = void 0 === r3 ? "Unexpected asynchronous deactivation when unbinding binding identifier. Consider using Container.unbind() instead." : `Unexpected asynchronous deactivation when unbinding "${t(r3)}" binding. Consider using Container.unbind() instead.`;
  } else n3 = `Unexpected asynchronous deactivation when unbinding "${t(e2)}" service. Consider using Container.unbind() instead.`;
  var i2;
  throw new B2(O2.invalidOperation, n3);
};
f_fn = function(e2) {
  return P2(e2) ? __privateMethod(this, ___instances, p_fn2).call(this, e2) : __privateMethod(this, ___instances, S_fn).call(this, e2);
};
p_fn2 = function(e2) {
  const n3 = __privateGet(this, _h3).bindingService.getById(e2.id), i2 = void 0 === n3 ? void 0 : [...n3], t4 = xn(__privateGet(this, _l), n3);
  if (void 0 !== t4) return t4.then(() => {
    __privateMethod(this, ___instances, M_fn).call(this, i2, e2);
  });
  __privateMethod(this, ___instances, M_fn).call(this, i2, e2);
};
M_fn = function(e2, n3) {
  if (__privateGet(this, _h3).bindingService.removeById(n3.id), void 0 !== e2) for (const n4 of e2) __privateGet(this, _u).invalidateService({ binding: n4, kind: ze.bindingRemoved });
};
S_fn = function(e2) {
  const n3 = __privateGet(this, _h3).bindingService.get(e2), i2 = void 0 === n3 ? void 0 : [...n3], t4 = xn(__privateGet(this, _l), n3);
  if (void 0 !== t4) return t4.then(() => {
    __privateMethod(this, ___instances, R_fn2).call(this, e2, i2);
  });
  __privateMethod(this, ___instances, R_fn2).call(this, e2, i2);
};
R_fn2 = function(e2, n3) {
  if (__privateGet(this, _h3).activationService.removeAllByServiceId(e2), __privateGet(this, _h3).bindingService.removeAllByServiceId(e2), __privateGet(this, _h3).deactivationService.removeAllByServiceId(e2), void 0 !== n3) for (const e3 of n3) __privateGet(this, _u).invalidateService({ binding: e3, kind: ze.bindingRemoved });
};
g_fn = function(e2, n3, i2) {
  if (void 0 === n3) return false;
  const t4 = { getAncestor: () => {
  }, name: i2 == null ? void 0 : i2.name, serviceIdentifier: e2, tags: /* @__PURE__ */ new Map() };
  void 0 !== (i2 == null ? void 0 : i2.tag) && t4.tags.set(i2.tag.key, i2.tag.value);
  for (const e3 of n3) if (e3.isSatisfiedBy(t4)) return true;
  return false;
};
var _y4, _l2, _a8, _u2, _h4, _z_instances, I_fn, w_fn, n_fn, v_fn2, m_fn;
var z2 = class {
  constructor(e2, n3, i2, t4, r3) {
    __privateAdd(this, _z_instances);
    __privateAdd(this, _y4);
    __privateAdd(this, _l2);
    __privateAdd(this, _a8);
    __privateAdd(this, _u2);
    __privateAdd(this, _h4);
    __privateSet(this, _y4, e2), __privateSet(this, _l2, n3), __privateSet(this, _a8, i2), __privateSet(this, _u2, t4), __privateSet(this, _h4, r3);
  }
  async load(...e2) {
    await Promise.all(__privateMethod(this, _z_instances, n_fn).call(this, ...e2));
  }
  loadSync(...e2) {
    const n3 = __privateMethod(this, _z_instances, n_fn).call(this, ...e2);
    for (const e3 of n3) if (void 0 !== e3) throw new B2(O2.invalidOperation, "Unexpected asynchronous module load. Consider using Container.load() instead.");
  }
  async unload(...e2) {
    await Promise.all(__privateMethod(this, _z_instances, m_fn).call(this, ...e2)), __privateMethod(this, _z_instances, w_fn).call(this, e2);
  }
  unloadSync(...e2) {
    const n3 = __privateMethod(this, _z_instances, m_fn).call(this, ...e2);
    for (const e3 of n3) if (void 0 !== e3) throw new B2(O2.invalidOperation, "Unexpected asynchronous module unload. Consider using Container.unload() instead.");
    __privateMethod(this, _z_instances, w_fn).call(this, e2);
  }
};
_y4 = new WeakMap();
_l2 = new WeakMap();
_a8 = new WeakMap();
_u2 = new WeakMap();
_h4 = new WeakMap();
_z_instances = new WeakSet();
I_fn = function(e2) {
  return { bind: (n3) => new L2((e3) => {
    __privateMethod(this, _z_instances, v_fn2).call(this, e3);
  }, e2, __privateGet(this, _a8), n3), isBound: __privateGet(this, _y4).isBound.bind(__privateGet(this, _y4)), onActivation: (n3, i2) => {
    __privateGet(this, _h4).activationService.add(i2, { moduleId: e2, serviceId: n3 });
  }, onDeactivation: (n3, i2) => {
    __privateGet(this, _h4).deactivationService.add(i2, { moduleId: e2, serviceId: n3 });
  }, rebind: __privateGet(this, _y4).rebind.bind(__privateGet(this, _y4)), rebindSync: __privateGet(this, _y4).rebindSync.bind(__privateGet(this, _y4)), unbind: __privateGet(this, _y4).unbind.bind(__privateGet(this, _y4)), unbindSync: __privateGet(this, _y4).unbindSync.bind(__privateGet(this, _y4)) };
};
w_fn = function(e2) {
  for (const n3 of e2) __privateGet(this, _h4).activationService.removeAllByModuleId(n3.id), __privateGet(this, _h4).bindingService.removeAllByModuleId(n3.id), __privateGet(this, _h4).deactivationService.removeAllByModuleId(n3.id);
  __privateGet(this, _h4).planResultCacheService.clearCache();
};
n_fn = function(...e2) {
  return e2.map((e3) => e3.load(__privateMethod(this, _z_instances, I_fn).call(this, e3.id)));
};
v_fn2 = function(e2) {
  __privateGet(this, _h4).bindingService.set(e2), __privateGet(this, _u2).invalidateService({ binding: e2, kind: ze.bindingAdded });
};
m_fn = function(...e2) {
  return e2.map((e3) => jn(__privateGet(this, _l2), e3.id));
};
var K2 = class {
  constructor(e2) {
    __publicField(this, "deactivationParams");
    this.deactivationParams = function(e3) {
      return { getBindings: e3.bindingService.get.bind(e3.bindingService), getBindingsFromModule: e3.bindingService.getByModuleId.bind(e3.bindingService), getClassMetadata: j, getDeactivations: e3.deactivationService.get.bind(e3.deactivationService) };
    }(e2), e2.onReset(() => {
      !function(e3, n3) {
        n3.getBindings = e3.bindingService.get.bind(e3.bindingService), n3.getBindingsFromModule = e3.bindingService.getByModuleId.bind(e3.bindingService), n3.getDeactivations = e3.deactivationService.get.bind(e3.deactivationService);
      }(e2, this.deactivationParams);
    });
  }
};
var _h5, _X_instances, P_fn, v_fn3;
var X2 = class {
  constructor(e2) {
    __privateAdd(this, _X_instances);
    __publicField(this, "planParamsOperations");
    __privateAdd(this, _h5);
    __privateSet(this, _h5, e2), this.planParamsOperations = { getBindings: __privateGet(this, _h5).bindingService.get.bind(__privateGet(this, _h5).bindingService), getBindingsChained: __privateGet(this, _h5).bindingService.getChained.bind(__privateGet(this, _h5).bindingService), getClassMetadata: j, getPlan: __privateGet(this, _h5).planResultCacheService.get.bind(__privateGet(this, _h5).planResultCacheService), setBinding: __privateMethod(this, _X_instances, v_fn3).bind(this), setNonCachedServiceNode: __privateGet(this, _h5).planResultCacheService.setNonCachedServiceNode.bind(__privateGet(this, _h5).planResultCacheService), setPlan: __privateGet(this, _h5).planResultCacheService.set.bind(__privateGet(this, _h5).planResultCacheService) }, __privateGet(this, _h5).onReset(() => {
      __privateMethod(this, _X_instances, P_fn).call(this);
    });
  }
};
_h5 = new WeakMap();
_X_instances = new WeakSet();
P_fn = function() {
  this.planParamsOperations.getBindings = __privateGet(this, _h5).bindingService.get.bind(__privateGet(this, _h5).bindingService), this.planParamsOperations.getBindingsChained = __privateGet(this, _h5).bindingService.getChained.bind(__privateGet(this, _h5).bindingService), this.planParamsOperations.setBinding = __privateMethod(this, _X_instances, v_fn3).bind(this);
};
v_fn3 = function(e2) {
  __privateGet(this, _h5).bindingService.set(e2), __privateGet(this, _h5).planResultCacheService.invalidateServiceBinding({ binding: e2, kind: ze.bindingAdded, operations: this.planParamsOperations });
};
var _A, _h6;
var J2 = class {
  constructor(e2, n3) {
    __privateAdd(this, _A);
    __privateAdd(this, _h6);
    __privateSet(this, _A, e2), __privateSet(this, _h6, n3);
  }
  invalidateService(e2) {
    __privateGet(this, _h6).planResultCacheService.invalidateServiceBinding({ ...e2, operations: __privateGet(this, _A).planParamsOperations });
  }
};
_A = new WeakMap();
_h6 = new WeakMap();
var _C2, _B2, _O, _h7, _Q_instances, x_fn, k_fn;
var Q2 = class {
  constructor(e2, n3, i2) {
    __privateAdd(this, _Q_instances);
    __privateAdd(this, _C2);
    __privateAdd(this, _B2);
    __privateAdd(this, _O);
    __privateAdd(this, _h7);
    __privateSet(this, _h7, n3), __privateSet(this, _O, i2), __privateSet(this, _C2, __privateMethod(this, _Q_instances, x_fn).call(this, e2)), __privateSet(this, _B2, __privateMethod(this, _Q_instances, k_fn).call(this));
  }
  register(e2, n3) {
    const i2 = new n3(e2, __privateGet(this, _B2));
    if (true !== i2[t3]) throw new B2(O2.invalidOperation, "Invalid plugin. The plugin must extend the Plugin class");
    i2.load(__privateGet(this, _C2));
  }
};
_C2 = new WeakMap();
_B2 = new WeakMap();
_O = new WeakMap();
_h7 = new WeakMap();
_Q_instances = new WeakSet();
x_fn = function(e2) {
  return { define: (n3, i2) => {
    if (Object.prototype.hasOwnProperty.call(e2, n3)) throw new B2(O2.invalidOperation, `Container already has a method named "${String(n3)}"`);
    e2[n3] = i2;
  }, onPlan: __privateGet(this, _O).onPlan.bind(__privateGet(this, _O)) };
};
k_fn = function() {
  const e2 = __privateGet(this, _h7);
  return { get activationService() {
    return e2.activationService;
  }, get bindingService() {
    return e2.bindingService;
  }, get deactivationService() {
    return e2.deactivationService;
  }, get planResultCacheService() {
    return e2.planResultCacheService;
  } };
};
var _N2;
var W2 = class {
  constructor(e2, n3, i2, t4) {
    __publicField(this, "activationService");
    __publicField(this, "bindingService");
    __publicField(this, "deactivationService");
    __publicField(this, "planResultCacheService");
    __privateAdd(this, _N2);
    this.activationService = e2, this.bindingService = n3, this.deactivationService = i2, this.planResultCacheService = t4, __privateSet(this, _N2, []);
  }
  reset(e2, n3, i2) {
    this.activationService = e2, this.bindingService = n3, this.deactivationService = i2, this.planResultCacheService.clearCache();
    for (const e3 of __privateGet(this, _N2)) e3();
  }
  onReset(e2) {
    __privateGet(this, _N2).push(e2);
  }
};
_N2 = new WeakMap();
var _F2, _a9, _U, _D, _j2, _A2, _h8, _Y_instances, P_fn2, L_fn2, $_fn2, q_fn2, V_fn2, T_fn, E_fn2, G_fn2;
var Y2 = class {
  constructor(e2, n3, i2, t4) {
    __privateAdd(this, _Y_instances);
    __privateAdd(this, _F2);
    __privateAdd(this, _a9);
    __privateAdd(this, _U);
    __privateAdd(this, _D);
    __privateAdd(this, _j2);
    __privateAdd(this, _A2);
    __privateAdd(this, _h8);
    __privateSet(this, _A2, e2), __privateSet(this, _h8, n3), __privateSet(this, _D, __privateMethod(this, _Y_instances, T_fn).call(this)), __privateSet(this, _F2, i2), __privateSet(this, _a9, t4), __privateSet(this, _U, (e3) => __privateGet(this, _h8).activationService.get(e3)), __privateSet(this, _j2, []), __privateGet(this, _h8).onReset(() => {
      __privateMethod(this, _Y_instances, P_fn2).call(this);
    });
  }
  get(e2, n3) {
    const i2 = __privateMethod(this, _Y_instances, V_fn2).call(this, false, e2, n3), t4 = __privateMethod(this, _Y_instances, E_fn2).call(this, i2);
    if (e(t4)) throw new B2(O2.invalidOperation, `Unexpected asynchronous service when resolving service "${t(e2)}"`);
    return t4;
  }
  getAll(e2, n3) {
    const i2 = __privateMethod(this, _Y_instances, V_fn2).call(this, true, e2, n3), t4 = __privateMethod(this, _Y_instances, E_fn2).call(this, i2);
    if (e(t4)) throw new B2(O2.invalidOperation, `Unexpected asynchronous service when resolving service "${t(e2)}"`);
    return t4;
  }
  async getAllAsync(e2, n3) {
    const i2 = __privateMethod(this, _Y_instances, V_fn2).call(this, true, e2, n3);
    return __privateMethod(this, _Y_instances, E_fn2).call(this, i2);
  }
  async getAsync(e2, n3) {
    const i2 = __privateMethod(this, _Y_instances, V_fn2).call(this, false, e2, n3);
    return __privateMethod(this, _Y_instances, E_fn2).call(this, i2);
  }
  onPlan(e2) {
    __privateGet(this, _j2).push(e2);
  }
};
_F2 = new WeakMap();
_a9 = new WeakMap();
_U = new WeakMap();
_D = new WeakMap();
_j2 = new WeakMap();
_A2 = new WeakMap();
_h8 = new WeakMap();
_Y_instances = new WeakSet();
P_fn2 = function() {
  __privateSet(this, _D, __privateMethod(this, _Y_instances, T_fn).call(this));
};
L_fn2 = function(e2, n3, i2) {
  const t4 = i2 == null ? void 0 : i2.name, r3 = (i2 == null ? void 0 : i2.optional) ?? false, a2 = i2 == null ? void 0 : i2.tag;
  return e2 ? { chained: (i2 == null ? void 0 : i2.chained) ?? false, isMultiple: e2, name: t4, optional: r3, serviceIdentifier: n3, tag: a2 } : { isMultiple: e2, name: t4, optional: r3, serviceIdentifier: n3, tag: a2 };
};
$_fn2 = function(e2, n3, i2) {
  const t4 = { autobindOptions: (i2 == null ? void 0 : i2.autobind) ?? __privateGet(this, _F2) ? { scope: __privateGet(this, _a9) } : void 0, operations: __privateGet(this, _A2).planParamsOperations, rootConstraints: __privateMethod(this, _Y_instances, q_fn2).call(this, e2, n3, i2), servicesBranch: [] };
  return __privateMethod(this, _Y_instances, G_fn2).call(this, t4, i2), t4;
};
q_fn2 = function(e2, n3, i2) {
  return n3 ? { chained: (i2 == null ? void 0 : i2.chained) ?? false, isMultiple: n3, serviceIdentifier: e2 } : { isMultiple: n3, serviceIdentifier: e2 };
};
V_fn2 = function(e2, n3, i2) {
  const t4 = __privateMethod(this, _Y_instances, L_fn2).call(this, e2, n3, i2), r3 = __privateGet(this, _h8).planResultCacheService.get(t4);
  if (void 0 !== r3) return r3;
  const a2 = Le(__privateMethod(this, _Y_instances, $_fn2).call(this, n3, e2, i2));
  for (const e3 of __privateGet(this, _j2)) e3(t4, a2);
  return a2;
};
T_fn = function() {
  return { get: this.get.bind(this), getAll: this.getAll.bind(this), getAllAsync: this.getAllAsync.bind(this), getAsync: this.getAsync.bind(this) };
};
E_fn2 = function(e2) {
  return In({ context: __privateGet(this, _D), getActivations: __privateGet(this, _U), planResult: e2, requestScopeCache: /* @__PURE__ */ new Map() });
};
G_fn2 = function(e2, n3) {
  void 0 !== n3 && (void 0 !== n3.name && (e2.rootConstraints.name = n3.name), true === n3.optional && (e2.rootConstraints.isOptional = true), void 0 !== n3.tag && (e2.rootConstraints.tag = { key: n3.tag.key, value: n3.tag.value }), e2.rootConstraints.isMultiple && (e2.rootConstraints.chained = (n3 == null ? void 0 : n3.chained) ?? false));
};
var _h9, _H;
var Z2 = class {
  constructor(e2) {
    __privateAdd(this, _h9);
    __privateAdd(this, _H);
    __privateSet(this, _h9, e2), __privateSet(this, _H, []);
  }
  restore() {
    const e2 = __privateGet(this, _H).pop();
    if (void 0 === e2) throw new B2(O2.invalidOperation, "No snapshot available to restore");
    __privateGet(this, _h9).reset(e2.activationService, e2.bindingService, e2.deactivationService);
  }
  snapshot() {
    __privateGet(this, _H).push({ activationService: __privateGet(this, _h9).activationService.clone(), bindingService: __privateGet(this, _h9).bindingService.clone(), deactivationService: __privateGet(this, _h9).deactivationService.clone() });
  }
};
_h9 = new WeakMap();
_H = new WeakMap();
var ee2 = d.Transient;
var _y5, __, _z, _h10, _O2, _K, _ne_instances, X_fn2;
var ne2 = class {
  constructor(e2) {
    __privateAdd(this, _ne_instances);
    __privateAdd(this, _y5);
    __privateAdd(this, __);
    __privateAdd(this, _z);
    __privateAdd(this, _h10);
    __privateAdd(this, _O2);
    __privateAdd(this, _K);
    __privateSet(this, _h10, __privateMethod(this, _ne_instances, X_fn2).call(this, e2));
    const n3 = (e2 == null ? void 0 : e2.autobind) ?? false, i2 = (e2 == null ? void 0 : e2.defaultScope) ?? ee2, t4 = new X2(__privateGet(this, _h10)), r3 = new J2(t4, __privateGet(this, _h10)), a2 = new K2(__privateGet(this, _h10));
    __privateSet(this, _y5, new _2(a2.deactivationParams, i2, r3, __privateGet(this, _h10))), __privateSet(this, __, new z2(__privateGet(this, _y5), a2.deactivationParams, i2, r3, __privateGet(this, _h10))), __privateSet(this, _O2, new Y2(t4, __privateGet(this, _h10), n3, i2)), __privateSet(this, _z, new Q2(this, __privateGet(this, _h10), __privateGet(this, _O2))), __privateSet(this, _K, new Z2(__privateGet(this, _h10)));
  }
  bind(e2) {
    return __privateGet(this, _y5).bind(e2);
  }
  get(e2, n3) {
    return __privateGet(this, _O2).get(e2, n3);
  }
  getAll(e2, n3) {
    return __privateGet(this, _O2).getAll(e2, n3);
  }
  async getAllAsync(e2, n3) {
    return __privateGet(this, _O2).getAllAsync(e2, n3);
  }
  async getAsync(e2, n3) {
    return __privateGet(this, _O2).getAsync(e2, n3);
  }
  isBound(e2, n3) {
    return __privateGet(this, _y5).isBound(e2, n3);
  }
  isCurrentBound(e2, n3) {
    return __privateGet(this, _y5).isCurrentBound(e2, n3);
  }
  async load(...e2) {
    return __privateGet(this, __).load(...e2);
  }
  loadSync(...e2) {
    __privateGet(this, __).loadSync(...e2);
  }
  onActivation(e2, n3) {
    __privateGet(this, _h10).activationService.add(n3, { serviceId: e2 });
  }
  onDeactivation(e2, n3) {
    __privateGet(this, _h10).deactivationService.add(n3, { serviceId: e2 });
  }
  register(e2) {
    __privateGet(this, _z).register(this, e2);
  }
  restore() {
    __privateGet(this, _K).restore();
  }
  async rebind(e2) {
    return __privateGet(this, _y5).rebind(e2);
  }
  rebindSync(e2) {
    return __privateGet(this, _y5).rebindSync(e2);
  }
  snapshot() {
    __privateGet(this, _K).snapshot();
  }
  async unbind(e2) {
    await __privateGet(this, _y5).unbind(e2);
  }
  async unbindAll() {
    return __privateGet(this, _y5).unbindAll();
  }
  unbindSync(e2) {
    __privateGet(this, _y5).unbindSync(e2);
  }
  async unload(...e2) {
    return __privateGet(this, __).unload(...e2);
  }
  unloadSync(...e2) {
    __privateGet(this, __).unloadSync(...e2);
  }
};
_y5 = new WeakMap();
__ = new WeakMap();
_z = new WeakMap();
_h10 = new WeakMap();
_O2 = new WeakMap();
_K = new WeakMap();
_ne_instances = new WeakSet();
X_fn2 = function(e2) {
  if (void 0 === (e2 == null ? void 0 : e2.parent)) return new W2(h.build(() => {
  }), I.build(() => {
  }), b.build(() => {
  }), new He());
  const n3 = new He(), i2 = e2.parent;
  return __privateGet(i2, _h10).planResultCacheService.subscribe(n3), new W2(h.build(() => __privateGet(i2, _h10).activationService), I.build(() => __privateGet(i2, _h10).bindingService), b.build(() => __privateGet(i2, _h10).deactivationService), n3);
};
export {
  ne2 as Container,
  w2 as ContainerModule,
  r as LazyServiceIdentifier,
  d as bindingScopeValues,
  l as bindingTypeValues,
  w as decorate,
  z as inject,
  J as injectFromBase,
  Q as injectFromHierarchy,
  G as injectable,
  Y as multiInject,
  ne as named,
  ie as optional,
  oe as postConstruct,
  re as preDestroy,
  se as tagged,
  de as unmanaged
};
//# sourceMappingURL=inversify.js.map
