import { GridMode } from "/src/lib/domain/enums.ts";
import { resolve } from "/src/lib/services/bootstrap.ts";
import { jsonCache } from "/src/lib/services/positioning/cache/SimpleJsonCache.ts";
import { SpecialPlacementOriKeyGenerator } from "/src/lib/services/positioning/arrows/key_generators/SpecialPlacementOriKeyGenerator.ts";
export class SpecialPlacementService {
  // Structure: [gridMode][oriKey][letter] -> Record<string, unknown>
  specialPlacements = {};
  loadingCache = /* @__PURE__ */ new Set();
  oriKeyGenerator;
  gridModeService = null;
  getGridModeService() {
    if (!this.gridModeService) {
      this.gridModeService = resolve("IGridModeDeriver");
    }
    return this.gridModeService;
  }
  constructor() {
    this.specialPlacements = { diamond: {}, box: {} };
    this.oriKeyGenerator = new SpecialPlacementOriKeyGenerator();
  }
  /**
   * Get special adjustment for arrow based on special placement logic.
   *
   * @param motionData Motion data containing motion information
   * @param pictographData Pictograph data containing letter and context
   * @param arrowColor Color of the arrow ('red' or 'blue') - if not provided, will try to determine from motion
   * @returns Point with special adjustment or null if no special placement found
   */
  async getSpecialAdjustment(motionData, pictographData, arrowColor) {
    if (!motionData || !pictographData.letter) {
      return null;
    }
    const motion = motionData;
    const letter = pictographData.letter;
    const oriKey = this.oriKeyGenerator.generateOrientationKey(
      motion,
      pictographData
    );
    const gridMode = pictographData.motions?.blue && pictographData.motions?.red ? this.getGridModeService().deriveGridMode(
      pictographData.motions.blue,
      pictographData.motions.red
    ) : GridMode.DIAMOND;
    const turnsTuple = this.generateTurnsTuple(pictographData);
    await this.ensureLetterPlacementsLoaded(gridMode, oriKey, letter);
    const letterData = this.specialPlacements[gridMode]?.[oriKey]?.[letter];
    if (!letterData) {
      return null;
    }
    const turnData = letterData?.[turnsTuple];
    if (!turnData) {
      return null;
    }
    let colorKey = "";
    if (arrowColor) {
      colorKey = arrowColor;
    } else if (pictographData.motions?.blue && pictographData.motions.blue === motion) {
      colorKey = "blue";
    } else if (pictographData.motions?.red && pictographData.motions.red === motion) {
      colorKey = "red";
    } else {
      colorKey = "blue";
    }
    if (colorKey in turnData) {
      const adjustmentValues = turnData[colorKey];
      if (Array.isArray(adjustmentValues) && adjustmentValues.length === 2) {
        return { x: adjustmentValues[0], y: adjustmentValues[1] };
      }
    }
    const motionTypeKey = motionData.motionType?.toLowerCase() || "";
    if (motionTypeKey in turnData) {
      const adjustmentValues = turnData[motionTypeKey];
      if (Array.isArray(adjustmentValues) && adjustmentValues.length === 2) {
        return { x: adjustmentValues[0], y: adjustmentValues[1] };
      }
    }
    return null;
  }
  /**
   * Load special placement data from JSON configuration files.
   */
  async ensureLetterPlacementsLoaded(gridMode, oriKey, letter) {
    try {
      if (!this.specialPlacements[gridMode]) {
        this.specialPlacements[gridMode] = {};
      }
      if (!this.specialPlacements[gridMode][oriKey]) {
        this.specialPlacements[gridMode][oriKey] = {};
      }
      if (this.specialPlacements[gridMode][oriKey][letter]) {
        return;
      }
      const cacheKey = `${gridMode}:${oriKey}:${letter}`;
      if (this.loadingCache.has(cacheKey)) {
        return;
      }
      this.loadingCache.add(cacheKey);
      const encodedLetter = encodeURIComponent(letter);
      const basePath = `/data/arrow_placement/${gridMode}/special/${oriKey}/${encodedLetter}_placements.json`;
      try {
        const data = await jsonCache.get(basePath);
        this.specialPlacements[gridMode][oriKey][letter] = data;
      } catch (error) {
        this.specialPlacements[gridMode][oriKey][letter] = {};
      }
    } catch (error) {
      console.error("Error ensuring special placement data:", error);
    }
  }
  /**
   * Generate turns tuple string matching the turns_tuple_generator logic.
   *
   * This creates a string representation of the turn values for lookup in JSON data.
   * Format: "(blue_turns, red_turns)" e.g., "(0, 1.5)", "(1, 0.5)"
   */
  generateTurnsTuple(pictographData) {
    try {
      const blueMotion = pictographData.motions?.blue;
      const redMotion = pictographData.motions?.red;
      if (blueMotion && redMotion) {
        const blueTurns = typeof blueMotion.turns === "number" ? blueMotion.turns : 0;
        const redTurns = typeof redMotion.turns === "number" ? redMotion.turns : 0;
        const blueStr = blueTurns === Math.floor(blueTurns) ? Math.floor(blueTurns).toString() : blueTurns.toString();
        const redStr = redTurns === Math.floor(redTurns) ? Math.floor(redTurns).toString() : redTurns.toString();
        return `(${blueStr}, ${redStr})`;
      }
      return "(0, 0)";
    } catch (error) {
      return "(0, 0)";
    }
  }
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3NlcnZpY2VzL3Bvc2l0aW9uaW5nL2Fycm93cy9wbGFjZW1lbnQvU3BlY2lhbFBsYWNlbWVudFNlcnZpY2UudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogU3BlY2lhbCBQbGFjZW1lbnQgU2VydmljZSBmb3IgTW9kZXJuIEFycm93IFBvc2l0aW9uaW5nXG4gKlxuICogVGhpcyBzZXJ2aWNlIGltcGxlbWVudHMgc3BlY2lhbCBwbGFjZW1lbnQgbG9naWMgdXNpbmcgdGhlIHNhbWUgSlNPTiBjb25maWd1cmF0aW9uIGRhdGEuXG4gKiBJdCBwcm92aWRlcyBwaXhlbC1wZXJmZWN0IHNwZWNpYWwgcGxhY2VtZW50IGFkanVzdG1lbnRzIGZvciBzcGVjaWZpYyBwaWN0b2dyYXBoIGNvbmZpZ3VyYXRpb25zLlxuICpcbiAqIElNUExFTUVOVFMgU1BFQ0lBTCBQTEFDRU1FTlQgUElQRUxJTkU6XG4gKiAtIExvYWRzIHNwZWNpYWwgcGxhY2VtZW50IEpTT04gZmlsZXMgZnJvbSBzdGF0aWMvZGF0YS9hcnJvd19wbGFjZW1lbnQgZGlyZWN0b3J5XG4gKiAtIEdlbmVyYXRlcyBvcmllbnRhdGlvbiBrZXlzIChvcmlfa2V5KSBmb3IgbW90aW9uIGNsYXNzaWZpY2F0aW9uXG4gKiAtIEFwcGxpZXMgbGV0dGVyLXNwZWNpZmljLCB0dXJuLXNwZWNpZmljLCBhbmQgbW90aW9uLXR5cGUtc3BlY2lmaWMgYWRqdXN0bWVudHNcbiAqIC0gSGFuZGxlcyBjb21wbGV4IHBsYWNlbWVudCBydWxlcyBmb3Igc3BlY2lmaWMgcGljdG9ncmFwaCBwYXR0ZXJuc1xuICpcbiAqIERpcmVjdCBUeXBlU2NyaXB0IG1pcnJvciBvZiByZWZlcmVuY2UvbW9kZXJuL2FwcGxpY2F0aW9uL3NlcnZpY2VzL3Bvc2l0aW9uaW5nL2Fycm93cy9wbGFjZW1lbnQvc3BlY2lhbF9wbGFjZW1lbnRfc2VydmljZS5weVxuICovXG5cbmltcG9ydCB0eXBlIHsgTW90aW9uRGF0YSwgUGljdG9ncmFwaERhdGEgfSBmcm9tIFwiJGxpYi9kb21haW5cIjtcbmltcG9ydCB7IEdyaWRNb2RlIH0gZnJvbSBcIiRsaWIvZG9tYWluL2VudW1zXCI7XG5pbXBvcnQgeyByZXNvbHZlIH0gZnJvbSBcIiRsaWIvc2VydmljZXMvYm9vdHN0cmFwXCI7XG5pbXBvcnQgdHlwZSB7IElHcmlkTW9kZURlcml2ZXIgfSBmcm9tIFwiJGxpYi9zZXJ2aWNlcy9pbnRlcmZhY2VzL21vdmVtZW50L0lHcmlkTW9kZURlcml2ZXJcIjtcbmltcG9ydCB7IGpzb25DYWNoZSB9IGZyb20gXCIuLi8uLi9jYWNoZS9TaW1wbGVKc29uQ2FjaGVcIjtcbmltcG9ydCB0eXBlIHsgSVNwZWNpYWxQbGFjZW1lbnRTZXJ2aWNlIH0gZnJvbSBcIi4uLy4uL3BsYWNlbWVudC1zZXJ2aWNlc1wiO1xuaW1wb3J0IHsgU3BlY2lhbFBsYWNlbWVudE9yaUtleUdlbmVyYXRvciB9IGZyb20gXCIuLi9rZXlfZ2VuZXJhdG9ycy9TcGVjaWFsUGxhY2VtZW50T3JpS2V5R2VuZXJhdG9yXCI7XG5cbi8vIERlZmluZSBQb2ludCBpbnRlcmZhY2UgbG9jYWxseSBzaW5jZSBpdCBtaWdodCBub3QgYmUgaW4gZG9tYWluXG5pbnRlcmZhY2UgUG9pbnQge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFNwZWNpYWxQbGFjZW1lbnRTZXJ2aWNlIGltcGxlbWVudHMgSVNwZWNpYWxQbGFjZW1lbnRTZXJ2aWNlIHtcbiAgLy8gU3RydWN0dXJlOiBbZ3JpZE1vZGVdW29yaUtleV1bbGV0dGVyXSAtPiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICBwcml2YXRlIHNwZWNpYWxQbGFjZW1lbnRzOiBSZWNvcmQ8XG4gICAgc3RyaW5nLFxuICAgIFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHVua25vd24+Pj5cbiAgPiA9IHt9O1xuICBwcml2YXRlIGxvYWRpbmdDYWNoZTogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgb3JpS2V5R2VuZXJhdG9yOiBTcGVjaWFsUGxhY2VtZW50T3JpS2V5R2VuZXJhdG9yO1xuICBwcml2YXRlIGdyaWRNb2RlU2VydmljZTogSUdyaWRNb2RlRGVyaXZlciB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgZ2V0R3JpZE1vZGVTZXJ2aWNlKCk6IElHcmlkTW9kZURlcml2ZXIge1xuICAgIGlmICghdGhpcy5ncmlkTW9kZVNlcnZpY2UpIHtcbiAgICAgIHRoaXMuZ3JpZE1vZGVTZXJ2aWNlID0gcmVzb2x2ZTxJR3JpZE1vZGVEZXJpdmVyPihcIklHcmlkTW9kZURlcml2ZXJcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdyaWRNb2RlU2VydmljZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIERlZmVyIGxvYWRpbmc7IHdlJ2xsIGxhemlseSBsb2FkIHBlci1sZXR0ZXIgb24gZGVtYW5kXG4gICAgdGhpcy5zcGVjaWFsUGxhY2VtZW50cyA9IHsgZGlhbW9uZDoge30sIGJveDoge30gfSBhcyBSZWNvcmQ8XG4gICAgICBzdHJpbmcsXG4gICAgICBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4+XG4gICAgPjtcbiAgICB0aGlzLm9yaUtleUdlbmVyYXRvciA9IG5ldyBTcGVjaWFsUGxhY2VtZW50T3JpS2V5R2VuZXJhdG9yKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHNwZWNpYWwgYWRqdXN0bWVudCBmb3IgYXJyb3cgYmFzZWQgb24gc3BlY2lhbCBwbGFjZW1lbnQgbG9naWMuXG4gICAqXG4gICAqIEBwYXJhbSBtb3Rpb25EYXRhIE1vdGlvbiBkYXRhIGNvbnRhaW5pbmcgbW90aW9uIGluZm9ybWF0aW9uXG4gICAqIEBwYXJhbSBwaWN0b2dyYXBoRGF0YSBQaWN0b2dyYXBoIGRhdGEgY29udGFpbmluZyBsZXR0ZXIgYW5kIGNvbnRleHRcbiAgICogQHBhcmFtIGFycm93Q29sb3IgQ29sb3Igb2YgdGhlIGFycm93ICgncmVkJyBvciAnYmx1ZScpIC0gaWYgbm90IHByb3ZpZGVkLCB3aWxsIHRyeSB0byBkZXRlcm1pbmUgZnJvbSBtb3Rpb25cbiAgICogQHJldHVybnMgUG9pbnQgd2l0aCBzcGVjaWFsIGFkanVzdG1lbnQgb3IgbnVsbCBpZiBubyBzcGVjaWFsIHBsYWNlbWVudCBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0U3BlY2lhbEFkanVzdG1lbnQoXG4gICAgbW90aW9uRGF0YTogTW90aW9uRGF0YSxcbiAgICBwaWN0b2dyYXBoRGF0YTogUGljdG9ncmFwaERhdGEsXG4gICAgYXJyb3dDb2xvcj86IHN0cmluZ1xuICApOiBQcm9taXNlPFBvaW50IHwgbnVsbD4ge1xuICAgIGlmICghbW90aW9uRGF0YSB8fCAhcGljdG9ncmFwaERhdGEubGV0dGVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBtb3Rpb24gPSBtb3Rpb25EYXRhO1xuICAgIGNvbnN0IGxldHRlciA9IHBpY3RvZ3JhcGhEYXRhLmxldHRlcjtcblxuICAgIC8vIEdlbmVyYXRlIG9yaWVudGF0aW9uIGtleSB1c2luZyB2YWxpZGF0ZWQgbG9naWNcbiAgICBjb25zdCBvcmlLZXkgPSB0aGlzLm9yaUtleUdlbmVyYXRvci5nZW5lcmF0ZU9yaWVudGF0aW9uS2V5KFxuICAgICAgbW90aW9uLFxuICAgICAgcGljdG9ncmFwaERhdGFcbiAgICApO1xuXG4gICAgLy8gR2V0IGdyaWQgbW9kZSAtIGNvbXB1dGUgZnJvbSBtb3Rpb24gZGF0YVxuICAgIGNvbnN0IGdyaWRNb2RlID1cbiAgICAgIHBpY3RvZ3JhcGhEYXRhLm1vdGlvbnM/LmJsdWUgJiYgcGljdG9ncmFwaERhdGEubW90aW9ucz8ucmVkXG4gICAgICAgID8gdGhpcy5nZXRHcmlkTW9kZVNlcnZpY2UoKS5kZXJpdmVHcmlkTW9kZShcbiAgICAgICAgICAgIHBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMuYmx1ZSxcbiAgICAgICAgICAgIHBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMucmVkXG4gICAgICAgICAgKVxuICAgICAgICA6IEdyaWRNb2RlLkRJQU1PTkQ7XG5cbiAgICAvLyBHZW5lcmF0ZSB0dXJucyB0dXBsZSBmb3IgbG9va3VwXG4gICAgY29uc3QgdHVybnNUdXBsZSA9IHRoaXMuZ2VuZXJhdGVUdXJuc1R1cGxlKHBpY3RvZ3JhcGhEYXRhKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgbGV0dGVyLXNwZWNpZmljIHNwZWNpYWwgcGxhY2VtZW50IGRhdGEgaXMgbG9hZGVkIGxhemlseVxuICAgIGF3YWl0IHRoaXMuZW5zdXJlTGV0dGVyUGxhY2VtZW50c0xvYWRlZChncmlkTW9kZSwgb3JpS2V5LCBsZXR0ZXIpO1xuXG4gICAgLy8gTG9vayB1cCBzcGVjaWFsIHBsYWNlbWVudCBkYXRhXG4gICAgY29uc3QgbGV0dGVyRGF0YSA9IHRoaXMuc3BlY2lhbFBsYWNlbWVudHNbZ3JpZE1vZGVdPy5bb3JpS2V5XT8uW2xldHRlcl0gYXNcbiAgICAgIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICAgIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKCFsZXR0ZXJEYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBHZXQgdHVybi1zcGVjaWZpYyBkYXRhXG4gICAgY29uc3QgdHVybkRhdGEgPSBsZXR0ZXJEYXRhPy5bdHVybnNUdXBsZV0gYXNcbiAgICAgIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICAgIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKCF0dXJuRGF0YSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gRmlyc3QsIHRyeSBkaXJlY3QgY29sb3ItYmFzZWQgY29vcmRpbmF0ZSBsb29rdXAgKG1vc3QgY29tbW9uIGNhc2UpXG4gICAgbGV0IGNvbG9yS2V5ID0gXCJcIjtcbiAgICBpZiAoYXJyb3dDb2xvcikge1xuICAgICAgLy8gVXNlIHByb3ZpZGVkIGFycm93IGNvbG9yIGRpcmVjdGx5XG4gICAgICBjb2xvcktleSA9IGFycm93Q29sb3I7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHBpY3RvZ3JhcGhEYXRhLm1vdGlvbnM/LmJsdWUgJiZcbiAgICAgIHBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMuYmx1ZSA9PT0gbW90aW9uXG4gICAgKSB7XG4gICAgICBjb2xvcktleSA9IFwiYmx1ZVwiO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBwaWN0b2dyYXBoRGF0YS5tb3Rpb25zPy5yZWQgJiZcbiAgICAgIHBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMucmVkID09PSBtb3Rpb25cbiAgICApIHtcbiAgICAgIGNvbG9yS2V5ID0gXCJyZWRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2s6IHRyeSB0byBkZXRlcm1pbmUgZnJvbSBtb3Rpb24gZGF0YVxuICAgICAgY29sb3JLZXkgPSBcImJsdWVcIjsgLy8gRGVmYXVsdCBmYWxsYmFja1xuICAgIH1cblxuICAgIGlmIChjb2xvcktleSBpbiB0dXJuRGF0YSkge1xuICAgICAgY29uc3QgYWRqdXN0bWVudFZhbHVlcyA9IHR1cm5EYXRhW2NvbG9yS2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFkanVzdG1lbnRWYWx1ZXMpICYmIGFkanVzdG1lbnRWYWx1ZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7IHg6IGFkanVzdG1lbnRWYWx1ZXNbMF0sIHk6IGFkanVzdG1lbnRWYWx1ZXNbMV0gfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZWNvbmQsIHRyeSBtb3Rpb24tdHlwZS1zcGVjaWZpYyBhZGp1c3RtZW50IChmb3IgbGV0dGVycyBsaWtlIEkpXG4gICAgY29uc3QgbW90aW9uVHlwZUtleSA9IG1vdGlvbkRhdGEubW90aW9uVHlwZT8udG9Mb3dlckNhc2UoKSB8fCBcIlwiO1xuXG4gICAgaWYgKG1vdGlvblR5cGVLZXkgaW4gdHVybkRhdGEpIHtcbiAgICAgIGNvbnN0IGFkanVzdG1lbnRWYWx1ZXMgPSB0dXJuRGF0YVttb3Rpb25UeXBlS2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFkanVzdG1lbnRWYWx1ZXMpICYmIGFkanVzdG1lbnRWYWx1ZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7IHg6IGFkanVzdG1lbnRWYWx1ZXNbMF0sIHk6IGFkanVzdG1lbnRWYWx1ZXNbMV0gfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHNwZWNpYWwgcGxhY2VtZW50IGRhdGEgZnJvbSBKU09OIGNvbmZpZ3VyYXRpb24gZmlsZXMuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGVuc3VyZUxldHRlclBsYWNlbWVudHNMb2FkZWQoXG4gICAgZ3JpZE1vZGU6IHN0cmluZyxcbiAgICBvcmlLZXk6IHN0cmluZyxcbiAgICBsZXR0ZXI6IHN0cmluZ1xuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLnNwZWNpYWxQbGFjZW1lbnRzW2dyaWRNb2RlXSkge1xuICAgICAgICB0aGlzLnNwZWNpYWxQbGFjZW1lbnRzW2dyaWRNb2RlXSA9IHt9IGFzIFJlY29yZDxcbiAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+XG4gICAgICAgID47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3BlY2lhbFBsYWNlbWVudHNbZ3JpZE1vZGVdW29yaUtleV0pIHtcbiAgICAgICAgdGhpcy5zcGVjaWFsUGxhY2VtZW50c1tncmlkTW9kZV1bb3JpS2V5XSA9IHt9IGFzIFJlY29yZDxcbiAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICAgICAgPjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNwZWNpYWxQbGFjZW1lbnRzW2dyaWRNb2RlXVtvcmlLZXldW2xldHRlcl0pIHtcbiAgICAgICAgcmV0dXJuOyAvLyBhbHJlYWR5IGxvYWRlZFxuICAgICAgfVxuXG4gICAgICBjb25zdCBjYWNoZUtleSA9IGAke2dyaWRNb2RlfToke29yaUtleX06JHtsZXR0ZXJ9YDtcbiAgICAgIGlmICh0aGlzLmxvYWRpbmdDYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICAgIHJldHVybjsgLy8gbG9hZGluZyBpbiBwcm9ncmVzcyBvciBhbHJlYWR5IGF0dGVtcHRlZFxuICAgICAgfVxuICAgICAgdGhpcy5sb2FkaW5nQ2FjaGUuYWRkKGNhY2hlS2V5KTtcblxuICAgICAgLy8gRmlsZXMgYXJlIHNlcnZlZCB1bmRlciAvZGF0YS8uLi4gaW4gdGhlIHdlYiBhcHBcbiAgICAgIC8vIEV4YW1wbGUgcGF0aDogL2RhdGEvYXJyb3dfcGxhY2VtZW50L2RpYW1vbmQvc3BlY2lhbC9mcm9tX2xheWVyMS9BX3BsYWNlbWVudHMuanNvblxuICAgICAgY29uc3QgZW5jb2RlZExldHRlciA9IGVuY29kZVVSSUNvbXBvbmVudChsZXR0ZXIpO1xuICAgICAgY29uc3QgYmFzZVBhdGggPSBgL2RhdGEvYXJyb3dfcGxhY2VtZW50LyR7Z3JpZE1vZGV9L3NwZWNpYWwvJHtvcmlLZXl9LyR7ZW5jb2RlZExldHRlcn1fcGxhY2VtZW50cy5qc29uYDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAoYXdhaXQganNvbkNhY2hlLmdldChiYXNlUGF0aCkpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgICB0aGlzLnNwZWNpYWxQbGFjZW1lbnRzW2dyaWRNb2RlXVtvcmlLZXldW2xldHRlcl0gPSBkYXRhO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5zcGVjaWFsUGxhY2VtZW50c1tncmlkTW9kZV1bb3JpS2V5XVtsZXR0ZXJdID0ge307XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBlbnN1cmluZyBzcGVjaWFsIHBsYWNlbWVudCBkYXRhOlwiLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHR1cm5zIHR1cGxlIHN0cmluZyBtYXRjaGluZyB0aGUgdHVybnNfdHVwbGVfZ2VuZXJhdG9yIGxvZ2ljLlxuICAgKlxuICAgKiBUaGlzIGNyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHR1cm4gdmFsdWVzIGZvciBsb29rdXAgaW4gSlNPTiBkYXRhLlxuICAgKiBGb3JtYXQ6IFwiKGJsdWVfdHVybnMsIHJlZF90dXJucylcIiBlLmcuLCBcIigwLCAxLjUpXCIsIFwiKDEsIDAuNSlcIlxuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZVR1cm5zVHVwbGUocGljdG9ncmFwaERhdGE6IFBpY3RvZ3JhcGhEYXRhKTogc3RyaW5nIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYmx1ZU1vdGlvbiA9IHBpY3RvZ3JhcGhEYXRhLm1vdGlvbnM/LmJsdWU7XG4gICAgICBjb25zdCByZWRNb3Rpb24gPSBwaWN0b2dyYXBoRGF0YS5tb3Rpb25zPy5yZWQ7XG5cbiAgICAgIGlmIChibHVlTW90aW9uICYmIHJlZE1vdGlvbikge1xuICAgICAgICBjb25zdCBibHVlVHVybnMgPVxuICAgICAgICAgIHR5cGVvZiBibHVlTW90aW9uLnR1cm5zID09PSBcIm51bWJlclwiID8gYmx1ZU1vdGlvbi50dXJucyA6IDA7XG4gICAgICAgIGNvbnN0IHJlZFR1cm5zID1cbiAgICAgICAgICB0eXBlb2YgcmVkTW90aW9uLnR1cm5zID09PSBcIm51bWJlclwiID8gcmVkTW90aW9uLnR1cm5zIDogMDtcblxuICAgICAgICBjb25zdCBibHVlU3RyID1cbiAgICAgICAgICBibHVlVHVybnMgPT09IE1hdGguZmxvb3IoYmx1ZVR1cm5zKVxuICAgICAgICAgICAgPyBNYXRoLmZsb29yKGJsdWVUdXJucykudG9TdHJpbmcoKVxuICAgICAgICAgICAgOiBibHVlVHVybnMudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgcmVkU3RyID1cbiAgICAgICAgICByZWRUdXJucyA9PT0gTWF0aC5mbG9vcihyZWRUdXJucylcbiAgICAgICAgICAgID8gTWF0aC5mbG9vcihyZWRUdXJucykudG9TdHJpbmcoKVxuICAgICAgICAgICAgOiByZWRUdXJucy50b1N0cmluZygpO1xuXG4gICAgICAgIHJldHVybiBgKCR7Ymx1ZVN0cn0sICR7cmVkU3RyfSlgO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCIoMCwgMClcIjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIFwiKDAsIDApXCI7XG4gICAgfVxuICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiQUFnQkEsU0FBUyxnQkFBZ0I7QUFDekIsU0FBUyxlQUFlO0FBRXhCLFNBQVMsaUJBQWlCO0FBRTFCLFNBQVMsdUNBQXVDO0FBUXpDLGFBQU0sd0JBQTREO0FBQUE7QUFBQSxFQUUvRCxvQkFHSixDQUFDO0FBQUEsRUFDRyxlQUE0QixvQkFBSSxJQUFJO0FBQUEsRUFDcEM7QUFBQSxFQUNBLGtCQUEyQztBQUFBLEVBRTNDLHFCQUF1QztBQUM3QyxRQUFJLENBQUMsS0FBSyxpQkFBaUI7QUFDekIsV0FBSyxrQkFBa0IsUUFBMEIsa0JBQWtCO0FBQUEsSUFDckU7QUFDQSxXQUFPLEtBQUs7QUFBQSxFQUNkO0FBQUEsRUFFQSxjQUFjO0FBRVosU0FBSyxvQkFBb0IsRUFBRSxTQUFTLENBQUMsR0FBRyxLQUFLLENBQUMsRUFBRTtBQUloRCxTQUFLLGtCQUFrQixJQUFJLGdDQUFnQztBQUFBLEVBQzdEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBVUEsTUFBTSxxQkFDSixZQUNBLGdCQUNBLFlBQ3VCO0FBQ3ZCLFFBQUksQ0FBQyxjQUFjLENBQUMsZUFBZSxRQUFRO0FBQ3pDLGFBQU87QUFBQSxJQUNUO0FBRUEsVUFBTSxTQUFTO0FBQ2Ys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
