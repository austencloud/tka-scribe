import { createHotContext as __vite__createHotContext } from "/@vite/client";import.meta.hot = __vite__createHotContext("/src/lib/components/codex/CodexPictographGrid.svelte");import "/node_modules/.vite/deps/svelte_internal_disclose-version.js?v=608ae08a";

CodexPictographGrid[$.FILENAME] = 'src/lib/components/codex/CodexPictographGrid.svelte';

import * as $ from "/node_modules/.vite/deps/svelte_internal_client.js?v=608ae08a";
import Pictograph from "/src/lib/components/pictograph/Pictograph.svelte";

var root_3 = $.add_locations($.from_html(`<div class="section-header s-f3QsQI1qpFaR"><div class="section-header-container s-f3QsQI1qpFaR"><span class="section-text s-f3QsQI1qpFaR"><span class="section-type s-f3QsQI1qpFaR"> </span> <!></span></div></div>`), CodexPictographGrid[$.FILENAME], [[114, 8, [[115, 10, [[116, 12, [[117, 14]]]]]]]]);
var on_click = (_, isPlaceholder, handlePictographClick, pictograph) => !$.get(isPlaceholder) && handlePictographClick($.get(pictograph));
var root_5 = $.add_locations($.from_html(`<span class="placeholder-letter s-f3QsQI1qpFaR"> </span>`), CodexPictographGrid[$.FILENAME], [[140, 12]]);
var root_4 = $.add_locations($.from_html(`<button><!></button>`), CodexPictographGrid[$.FILENAME], [[131, 8]]);
var root_1 = $.add_locations($.from_html(`<!> <div class="pictograph-row s-f3QsQI1qpFaR"></div>`, 1), CodexPictographGrid[$.FILENAME], [[125, 4]]);
var root = $.add_locations($.from_html(`<div class="codex-pictograph-grid s-f3QsQI1qpFaR"></div>`), CodexPictographGrid[$.FILENAME], [[108, 0]]);

function CodexPictographGrid($$anchor, $$props) {
	$.check_target(new.target);
	$.push($$props, true, CodexPictographGrid);

	let pictographSize = $.prop($$props, 'pictographSize', 3, 80);

	function handlePictographClick(pictograph) {
		$$props.onPictographClick?.(pictograph);
	}

	function createPlaceholder(letter) {
		return { id: `placeholder-${letter}`, motions: {} };
	}

	const letterTypeSections = [
		{
			name: "Type 1",
			description: "Dual-Shift",
			startRow: 0,
			endRow: 3,
			primaryColor: "#36c3ff",
			secondaryColor: "#6F2DA8"
		},

		// A-V (rows 0-3)
		{
			name: "Type 2",
			description: "Shift",
			startRow: 4,
			endRow: 5,
			primaryColor: "#6F2DA8",
			secondaryColor: "#6F2DA8"
		},

		// W,X,Y,Z,Σ,Δ,θ,Ω (rows 4-5)
		{
			name: "Type 3",
			description: "Cross-Shift",
			startRow: 6,
			endRow: 7,
			primaryColor: "#26e600",
			secondaryColor: "#6F2DA8"
		},

		// W-,X-,Y-,Z-,Σ-,Δ-,θ-,Ω- (rows 6-7)
		{
			name: "Type 4",
			description: "Dash",
			startRow: 8,
			endRow: 8,
			primaryColor: "#26e600",
			secondaryColor: "#26e600"
		},

		// Φ,Ψ,Λ (row 8)
		{
			name: "Type 5",
			description: "Dual-Dash",
			startRow: 9,
			endRow: 9,
			primaryColor: "#00b3ff",
			secondaryColor: "#26e600"
		},

		// Φ-,Ψ-,Λ- (row 9)
		{
			name: "Type 6",
			description: "Static",
			startRow: 10,
			endRow: 10,
			primaryColor: "#eb7d00",
			secondaryColor: "#eb7d00"
		}

		// α,β,Γ (row 10)
	];

	function getSectionForRow(rowIndex) {
		return letterTypeSections.find((section) => rowIndex >= section.startRow && rowIndex <= section.endRow);
	}

	function isFirstRowOfSection(rowIndex) {
		return letterTypeSections.some((section) => $.strict_equals(section.startRow, rowIndex));
	}

	function getColoredText(description) {
		const colors = {
			Shift: "#6F2DA8",
			Dual: "#00b3ff",
			Dash: "#26e600",
			Cross: "#26e600",
			Static: "#eb7d00",
			"-": "#000000"
		};

		let coloredText = description;

		Object.entries(colors).forEach(([word, color]) => {
			const regex = new RegExp(`\\b${word}\\b`, "gi");

			coloredText = coloredText.replace(regex, `<span style="color: ${color};">${word}</span>`);
		});

		return coloredText;
	}

	var div = root();

	$.add_svelte_meta(
		() => $.each(div, 21, () => $$props.letterRows, $.index, ($$anchor, row, rowIndex) => {
			var fragment = root_1();
			var node = $.first_child(fragment);

			{
				var consequent_1 = ($$anchor) => {
					const section = $.tag($.derived(() => getSectionForRow(rowIndex)), 'section');

					$.get(section);

					var fragment_1 = $.comment();
					var node_1 = $.first_child(fragment_1);

					{
						var consequent = ($$anchor) => {
							var div_1 = root_3();
							var div_2 = $.child(div_1);
							var span = $.child(div_2);
							var span_1 = $.child(span);
							var text = $.child(span_1);

							$.reset(span_1);

							var node_2 = $.sibling(span_1, 2);

							$.html(node_2, () => getColoredText($.get(section).description));
							$.reset(span);
							$.reset(div_2);
							$.reset(div_1);
							$.template_effect(() => $.set_text(text, `${$.get(section).name ?? ''}:`));
							$.append($$anchor, div_1);
						};

						$.add_svelte_meta(
							() => $.if(node_1, ($$render) => {
								if ($.get(section)) $$render(consequent);
							}),
							'if',
							CodexPictographGrid,
							113,
							6
						);
					}

					$.append($$anchor, fragment_1);
				};

				$.add_svelte_meta(
					() => $.if(node, ($$render) => {
						if (isFirstRowOfSection(rowIndex)) $$render(consequent_1);
					}),
					'if',
					CodexPictographGrid,
					111,
					4
				);
			}

			var div_3 = $.sibling(node, 2);

			$.set_attribute(div_3, 'data-row', rowIndex);

			$.add_svelte_meta(
				() => $.each(div_3, 21, () => $.get(row), $.index, ($$anchor, letter) => {
					const pictograph = $.tag($.derived(() => $$props.pictographsByLetter[$.get(letter)] || createPlaceholder($.get(letter))), 'pictograph');

					$.get(pictograph);

					const isPlaceholder = $.tag($.derived(() => !$$props.pictographsByLetter[$.get(letter)]), 'isPlaceholder');

					$.get(isPlaceholder);

					var button = root_4();
					let classes;

					button.__click = [on_click, isPlaceholder, handlePictographClick, pictograph];

					var node_3 = $.child(button);

					{
						var consequent_2 = ($$anchor) => {
							var span_2 = root_5();
							var text_1 = $.child(span_2, true);

							$.reset(span_2);
							$.template_effect(() => $.set_text(text_1, $.get(letter)));
							$.append($$anchor, span_2);
						};

						var alternate = ($$anchor) => {
							var fragment_2 = $.comment();
							var node_4 = $.first_child(fragment_2);

							$.add_svelte_meta(
								() => Pictograph(node_4, {
									get pictographData() {
										return $.get(pictograph);
									}
								}),
								'component',
								CodexPictographGrid,
								143,
								12,
								{ componentTag: 'Pictograph' }
							);

							$.append($$anchor, fragment_2);
						};

						$.add_svelte_meta(
							() => $.if(node_3, ($$render) => {
								if ($.get(isPlaceholder)) $$render(consequent_2); else $$render(alternate, false);
							}),
							'if',
							CodexPictographGrid,
							138,
							10
						);
					}

					$.reset(button);

					$.template_effect(
						($0) => {
							classes = $.set_class(button, 1, 'pictograph-item s-f3QsQI1qpFaR', null, classes, $0);
							$.set_attribute(button, 'title', $.get(letter));
							button.disabled = $.get(isPlaceholder);
						},
						[() => ({ placeholder: $.get(isPlaceholder) })]
					);

					$.append($$anchor, button);
				}),
				'each',
				CodexPictographGrid,
				126,
				6
			);

			$.reset(div_3);
			$.append($$anchor, fragment);
		}),
		'each',
		CodexPictographGrid,
		109,
		2
	);

	$.reset(div);
	$.append($$anchor, div);

	return $.pop({ ...$.legacy_api() });
}

if (import.meta.hot) {
	CodexPictographGrid = $.hmr(CodexPictographGrid, () => CodexPictographGrid[$.HMR].source);

	import.meta.hot.acceptExports(["default"],(module) => {
		$.cleanup_styles('s-f3QsQI1qpFaR');
		module.default[$.HMR].source = CodexPictographGrid[$.HMR].source;
		$.set(CodexPictographGrid[$.HMR].source, module.default[$.HMR].original);
	});
}

export default CodexPictographGrid;

$.delegate(['click']);
import "/src/lib/components/codex/CodexPictographGrid.svelte?svelte&type=style&lang.css";

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6Ijs7Ozs7T0FrQk07OzsrRUErSm9CLGFBQVk7Ozs7OztnREFqTHRDLENBQUM7Ozs7S0FvQ0M7O1VBUUksc0JBQVU7OEJBQ0Y7Q0FBQTs7VUFHVjtXQUVFLG1CQUFNLFVBQ047Q0FDVTs7T0FJWjs7R0FFRSxNQUFNO0dBQ04sYUFBYTtHQUNiLFVBQVU7R0FDVixRQUFRO0dBQ1IsY0FBYztHQUNkLGdCQUFnQjs7Ozs7R0FFbEI7R0FDRSxhQUFNO0dBQ047R0FDQSxRQUFVO0dBQ1YsY0FBUTtHQUNSLGdCQUFjOzs7OztHQUVoQjtHQUNBO0dBQ0UsVUFBTTtHQUNOO0dBQ0EsY0FBVTtHQUNWLGdCQUFROzs7OztHQUdWO0dBQUE7R0FDQTtHQUNFLFFBQU07R0FDTixjQUFhO0dBQ2IsZ0JBQVU7Ozs7O0dBR1Y7R0FDRjtHQUFBO0dBQ0Y7R0FHQSxjQUFTO0dBQ1AsZ0JBQU87Ozs7O0dBR1Q7R0FHQSxhQUFTO0dBQ1AsVUFBTztHQUNUO0dBR0EsY0FBUztHQUNQLGdCQUFlOzs7Ozs7VUFLYixpQkFBUTtTQUNILHlCQUNQO0NBS0E7O1VBR0k7U0FDQSxtQkFBdUIsTUFBSyw0QkFBVTtDQUFBOztVQUs1QztRQUNNOztHQUVILE1BQU87R0FDUixNQUFLO0dBQ0gsT0FBTztHQUNQLFFBQUc7R0FDSCxLQUFFOzs7TUFHUixjQUFzQjs7RUFHdEIsZUFBZ0IsTUFBSyxZQUFlLE1BQU8sS0FBQztTQUNoQyxZQUFNOztHQUNsQixjQUFlLG9CQUNQLDhCQUNFOzs7U0FJRjtDQUNSOzs7OztzRUFJUzs7Ozs7O1dBR0MsT0FBVyx5QkFBRyxnQkFBZ0IsQ0FBQyxRQUFFOztXQUFqQyxPQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs0QkFNSCxjQUFPLE9BQVcsT0FBTyxFQUFDLFdBQVc7Ozs7eURBRGQsYUFBYTs7Ozs7O2tCQUo1QyxPQUFPOzs7Ozs7Ozs7Ozs7OztVQUZqQixtQkFBNEIsQ0FBQzs7Ozs7Ozs7Ozs7c0NBY3BCOzs7d0NBQ0Q7V0FDSDs7V0FBQTs7V0FFQzs7V0FBQTs7Ozs7Ozs7Ozs7Ozs7O3dEQVdxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JBRmhCLGFBQU87Ozs7Ozs7Ozs7Ozs7OzhDQUhGOytCQUNkOzttQ0FIcUIsYUFBZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTNCdkMiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIkNvZGV4UGljdG9ncmFwaEdyaWQuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjwhLS1cblx0Q29kZXggUGljdG9ncmFwaCBHcmlkIENvbXBvbmVudFxuXG5cdE9yZ2FuaXplcyBwaWN0b2dyYXBocyBpbiByb3dzL3NlY3Rpb25zIGZvbGxvd2luZyB0aGUgZGVza3RvcCBsYXlvdXQuXG5cdE1hdGNoZXMgZGVza3RvcCBDb2RleFBpY3RvZ3JhcGhHcmlkIGZ1bmN0aW9uYWxpdHkgd2l0aCBwcm9wZXIgcm93IG9yZ2FuaXphdGlvbi5cbi0tPlxuPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgaW1wb3J0IFBpY3RvZ3JhcGggZnJvbSBcIiRsaWIvY29tcG9uZW50cy9waWN0b2dyYXBoL1BpY3RvZ3JhcGguc3ZlbHRlXCI7XG4gIGltcG9ydCB0eXBlIHsgUGljdG9ncmFwaERhdGEgfSBmcm9tIFwiJGxpYi9kb21haW4vUGljdG9ncmFwaERhdGFcIjtcblxuICAvLyBQcm9wc1xuICBpbnRlcmZhY2UgUHJvcHMge1xuICAgIHBpY3RvZ3JhcGhzQnlMZXR0ZXI6IFJlY29yZDxzdHJpbmcsIFBpY3RvZ3JhcGhEYXRhIHwgbnVsbD47XG4gICAgbGV0dGVyUm93czogc3RyaW5nW11bXTtcbiAgICBwaWN0b2dyYXBoU2l6ZT86IG51bWJlcjtcbiAgICBvblBpY3RvZ3JhcGhDbGljaz86IChwaWN0b2dyYXBoOiBQaWN0b2dyYXBoRGF0YSkgPT4gdm9pZDtcbiAgfVxuXG4gIGxldCB7XG4gICAgcGljdG9ncmFwaHNCeUxldHRlcixcbiAgICBsZXR0ZXJSb3dzLFxuICAgIHBpY3RvZ3JhcGhTaXplID0gODAsXG4gICAgb25QaWN0b2dyYXBoQ2xpY2ssXG4gIH06IFByb3BzID0gJHByb3BzKCk7XG5cbiAgLy8gSGFuZGxlIHBpY3RvZ3JhcGggY2xpY2tcbiAgZnVuY3Rpb24gaGFuZGxlUGljdG9ncmFwaENsaWNrKHBpY3RvZ3JhcGg6IFBpY3RvZ3JhcGhEYXRhKSB7XG4gICAgb25QaWN0b2dyYXBoQ2xpY2s/LihwaWN0b2dyYXBoKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBwbGFjZWhvbGRlciBmb3IgbWlzc2luZyBwaWN0b2dyYXBoc1xuICBmdW5jdGlvbiBjcmVhdGVQbGFjZWhvbGRlcihsZXR0ZXI6IHN0cmluZykge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogYHBsYWNlaG9sZGVyLSR7bGV0dGVyfWAsXG4gICAgICBtb3Rpb25zOiB7fSxcbiAgICB9IGFzIFBpY3RvZ3JhcGhEYXRhO1xuICB9XG5cbiAgLy8gRGVmaW5lIGxldHRlciB0eXBlIHNlY3Rpb25zIHdpdGggdGhlaXIgcm93IHJhbmdlcywgZGVzY3JpcHRpb25zLCBhbmQgY29sb3JzXG4gIC8vIEJhc2VkIG9uIHRoZSBkZXNrdG9wIExFVFRFUl9ST1dTIHN0cnVjdHVyZSBhbmQgT3B0aW9uUGlja2VyU2VjdGlvbkhlYWRlciBjb2xvcnNcbiAgY29uc3QgbGV0dGVyVHlwZVNlY3Rpb25zID0gW1xuICAgIHtcbiAgICAgIG5hbWU6IFwiVHlwZSAxXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJEdWFsLVNoaWZ0XCIsXG4gICAgICBzdGFydFJvdzogMCxcbiAgICAgIGVuZFJvdzogMyxcbiAgICAgIHByaW1hcnlDb2xvcjogXCIjMzZjM2ZmXCIsXG4gICAgICBzZWNvbmRhcnlDb2xvcjogXCIjNkYyREE4XCIsXG4gICAgfSwgLy8gQS1WIChyb3dzIDAtMylcbiAgICB7XG4gICAgICBuYW1lOiBcIlR5cGUgMlwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiU2hpZnRcIixcbiAgICAgIHN0YXJ0Um93OiA0LFxuICAgICAgZW5kUm93OiA1LFxuICAgICAgcHJpbWFyeUNvbG9yOiBcIiM2RjJEQThcIixcbiAgICAgIHNlY29uZGFyeUNvbG9yOiBcIiM2RjJEQThcIixcbiAgICB9LCAvLyBXLFgsWSxaLM6jLM6ULM64LM6pIChyb3dzIDQtNSlcbiAgICB7XG4gICAgICBuYW1lOiBcIlR5cGUgM1wiLFxuICAgICAgZGVzY3JpcHRpb246IFwiQ3Jvc3MtU2hpZnRcIixcbiAgICAgIHN0YXJ0Um93OiA2LFxuICAgICAgZW5kUm93OiA3LFxuICAgICAgcHJpbWFyeUNvbG9yOiBcIiMyNmU2MDBcIixcbiAgICAgIHNlY29uZGFyeUNvbG9yOiBcIiM2RjJEQThcIixcbiAgICB9LCAvLyBXLSxYLSxZLSxaLSzOoy0szpQtLM64LSzOqS0gKHJvd3MgNi03KVxuICAgIHtcbiAgICAgIG5hbWU6IFwiVHlwZSA0XCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJEYXNoXCIsXG4gICAgICBzdGFydFJvdzogOCxcbiAgICAgIGVuZFJvdzogOCxcbiAgICAgIHByaW1hcnlDb2xvcjogXCIjMjZlNjAwXCIsXG4gICAgICBzZWNvbmRhcnlDb2xvcjogXCIjMjZlNjAwXCIsXG4gICAgfSwgLy8gzqYszqgszpsgKHJvdyA4KVxuICAgIHtcbiAgICAgIG5hbWU6IFwiVHlwZSA1XCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJEdWFsLURhc2hcIixcbiAgICAgIHN0YXJ0Um93OiA5LFxuICAgICAgZW5kUm93OiA5LFxuICAgICAgcHJpbWFyeUNvbG9yOiBcIiMwMGIzZmZcIixcbiAgICAgIHNlY29uZGFyeUNvbG9yOiBcIiMyNmU2MDBcIixcbiAgICB9LCAvLyDOpi0szqgtLM6bLSAocm93IDkpXG4gICAge1xuICAgICAgbmFtZTogXCJUeXBlIDZcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlN0YXRpY1wiLFxuICAgICAgc3RhcnRSb3c6IDEwLFxuICAgICAgZW5kUm93OiAxMCxcbiAgICAgIHByaW1hcnlDb2xvcjogXCIjZWI3ZDAwXCIsXG4gICAgICBzZWNvbmRhcnlDb2xvcjogXCIjZWI3ZDAwXCIsXG4gICAgfSwgLy8gzrEszrIszpMgKHJvdyAxMClcbiAgXTtcblxuICAvLyBGdW5jdGlvbiB0byBnZXQgc2VjdGlvbiBmb3IgYSBnaXZlbiByb3cgaW5kZXhcbiAgZnVuY3Rpb24gZ2V0U2VjdGlvbkZvclJvdyhyb3dJbmRleDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIGxldHRlclR5cGVTZWN0aW9ucy5maW5kKFxuICAgICAgKHNlY3Rpb24pID0+IHJvd0luZGV4ID49IHNlY3Rpb24uc3RhcnRSb3cgJiYgcm93SW5kZXggPD0gc2VjdGlvbi5lbmRSb3dcbiAgICApO1xuICB9XG5cbiAgLy8gRnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhpcyBpcyB0aGUgZmlyc3Qgcm93IG9mIGEgc2VjdGlvblxuICBmdW5jdGlvbiBpc0ZpcnN0Um93T2ZTZWN0aW9uKHJvd0luZGV4OiBudW1iZXIpIHtcbiAgICByZXR1cm4gbGV0dGVyVHlwZVNlY3Rpb25zLnNvbWUoKHNlY3Rpb24pID0+IHNlY3Rpb24uc3RhcnRSb3cgPT09IHJvd0luZGV4KTtcbiAgfVxuXG4gIC8vIEZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNvbG9yZWQgSFRNTCB0ZXh0IGxpa2UgZGVza3RvcCBMZXR0ZXJUeXBlVGV4dFBhaW50ZXJcbiAgZnVuY3Rpb24gZ2V0Q29sb3JlZFRleHQoZGVzY3JpcHRpb246IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgY29sb3JzID0ge1xuICAgICAgU2hpZnQ6IFwiIzZGMkRBOFwiLFxuICAgICAgRHVhbDogXCIjMDBiM2ZmXCIsXG4gICAgICBEYXNoOiBcIiMyNmU2MDBcIixcbiAgICAgIENyb3NzOiBcIiMyNmU2MDBcIixcbiAgICAgIFN0YXRpYzogXCIjZWI3ZDAwXCIsXG4gICAgICBcIi1cIjogXCIjMDAwMDAwXCIsXG4gICAgfTtcblxuICAgIGxldCBjb2xvcmVkVGV4dCA9IGRlc2NyaXB0aW9uO1xuXG4gICAgLy8gQXBwbHkgY29sb3JzIHRvIGVhY2ggd29yZFxuICAgIE9iamVjdC5lbnRyaWVzKGNvbG9ycykuZm9yRWFjaCgoW3dvcmQsIGNvbG9yXSkgPT4ge1xuICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBcXFxcYiR7d29yZH1cXFxcYmAsIFwiZ2lcIik7XG4gICAgICBjb2xvcmVkVGV4dCA9IGNvbG9yZWRUZXh0LnJlcGxhY2UoXG4gICAgICAgIHJlZ2V4LFxuICAgICAgICBgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcn07XCI+JHt3b3JkfTwvc3Bhbj5gXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbG9yZWRUZXh0O1xuICB9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImNvZGV4LXBpY3RvZ3JhcGgtZ3JpZFwiPlxuICB7I2VhY2ggbGV0dGVyUm93cyBhcyByb3csIHJvd0luZGV4fVxuICAgIDwhLS0gQWRkIHNlY3Rpb24gaGVhZGVyIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHJvdyBvZiBhIHNlY3Rpb24gLS0+XG4gICAgeyNpZiBpc0ZpcnN0Um93T2ZTZWN0aW9uKHJvd0luZGV4KX1cbiAgICAgIHtAY29uc3Qgc2VjdGlvbiA9IGdldFNlY3Rpb25Gb3JSb3cocm93SW5kZXgpfVxuICAgICAgeyNpZiBzZWN0aW9ufVxuICAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1oZWFkZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1oZWFkZXItY29udGFpbmVyXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNlY3Rpb24tdGV4dFwiPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNlY3Rpb24tdHlwZVwiPntzZWN0aW9uLm5hbWV9Ojwvc3Bhbj5cbiAgICAgICAgICAgICAge0BodG1sIGdldENvbG9yZWRUZXh0KHNlY3Rpb24uZGVzY3JpcHRpb24pfVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIHsvaWZ9XG4gICAgey9pZn1cblxuICAgIDxkaXYgY2xhc3M9XCJwaWN0b2dyYXBoLXJvd1wiIGRhdGEtcm93PXtyb3dJbmRleH0+XG4gICAgICB7I2VhY2ggcm93IGFzIGxldHRlcn1cbiAgICAgICAge0Bjb25zdCBwaWN0b2dyYXBoID1cbiAgICAgICAgICBwaWN0b2dyYXBoc0J5TGV0dGVyW2xldHRlcl0gfHwgY3JlYXRlUGxhY2Vob2xkZXIobGV0dGVyKX1cbiAgICAgICAge0Bjb25zdCBpc1BsYWNlaG9sZGVyID0gIXBpY3RvZ3JhcGhzQnlMZXR0ZXJbbGV0dGVyXX1cblxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3M9XCJwaWN0b2dyYXBoLWl0ZW1cIlxuICAgICAgICAgIGNsYXNzOnBsYWNlaG9sZGVyPXtpc1BsYWNlaG9sZGVyfVxuICAgICAgICAgIG9uY2xpY2s9eygpID0+ICFpc1BsYWNlaG9sZGVyICYmIGhhbmRsZVBpY3RvZ3JhcGhDbGljayhwaWN0b2dyYXBoKX1cbiAgICAgICAgICB0aXRsZT17bGV0dGVyfVxuICAgICAgICAgIGRpc2FibGVkPXtpc1BsYWNlaG9sZGVyfVxuICAgICAgICA+XG4gICAgICAgICAgeyNpZiBpc1BsYWNlaG9sZGVyfVxuICAgICAgICAgICAgPCEtLSBQbGFjZWhvbGRlciBmb3IgbWlzc2luZyBwaWN0b2dyYXBocyAtLT5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicGxhY2Vob2xkZXItbGV0dGVyXCI+e2xldHRlcn08L3NwYW4+XG4gICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgPCEtLSBBY3R1YWwgcGljdG9ncmFwaCAtIHNpbXBsaWZpZWQgY29udGFpbmVyIHN0cnVjdHVyZSAtLT5cbiAgICAgICAgICAgIDxQaWN0b2dyYXBoIHBpY3RvZ3JhcGhEYXRhPXtwaWN0b2dyYXBofSAvPlxuICAgICAgICAgIHsvaWZ9XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgey9lYWNofVxuICAgIDwvZGl2PlxuICB7L2VhY2h9XG48L2Rpdj5cblxuPHN0eWxlPlxuICAuY29kZXgtcGljdG9ncmFwaC1ncmlkIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgZ2FwOiB2YXIoLS1kZXNrdG9wLXNwYWNpbmctbWQpOyAvKiBTbGlnaHRseSB0aWdodGVyIHNwYWNpbmcgKi9cbiAgICBwYWRkaW5nOiB2YXIoLS1kZXNrdG9wLXNwYWNpbmctbGcpO1xuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICB9XG5cbiAgLnNlY3Rpb24taGVhZGVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIG1hcmdpbjogdmFyKC0tZGVza3RvcC1zcGFjaW5nLWxnKSAwIHZhcigtLWRlc2t0b3Atc3BhY2luZy1tZCkgMDtcbiAgfVxuXG4gIC5zZWN0aW9uLWhlYWRlcjpmaXJzdC1jaGlsZCB7XG4gICAgbWFyZ2luLXRvcDogMDtcbiAgfVxuXG4gIC5zZWN0aW9uLWhlYWRlci1jb250YWluZXIge1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tZGVza3RvcC1ib3JkZXItcmFkaXVzKTtcbiAgICBwYWRkaW5nOiB2YXIoLS1kZXNrdG9wLXNwYWNpbmctc20pIHZhcigtLWRlc2t0b3Atc3BhY2luZy1sZyk7XG4gICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDEwcHgpO1xuICAgIGJveC1zaGFkb3c6IHZhcigtLWRlc2t0b3Atc2hhZG93LXNtKTtcbiAgICB0cmFuc2l0aW9uOiBhbGwgdmFyKC0tZGVza3RvcC10cmFuc2l0aW9uLW5vcm1hbCk7XG4gIH1cblxuICAuc2VjdGlvbi1oZWFkZXItY29udGFpbmVyOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMjUpO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC40KTtcbiAgICBib3gtc2hhZG93OiB2YXIoLS1kZXNrdG9wLXNoYWRvdy1tZCk7XG4gIH1cblxuICAuc2VjdGlvbi10ZXh0IHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWRlc2t0b3AtZm9udC1mYW1pbHkpO1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tZGVza3RvcC1mb250LXNpemUtYmFzZSk7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICBsaW5lLWhlaWdodDogMS4yO1xuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gIH1cblxuICAuc2VjdGlvbi10eXBlIHtcbiAgICBjb2xvcjogIzAwMDAwMDsgLyogQmxhY2sgZm9yIFwiVHlwZSAxOlwiIHBhcnQgKi9cbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgfVxuXG4gIC5waWN0b2dyYXBoLXJvdyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGdhcDogdmFyKC0tZGVza3RvcC1zcGFjaW5nLW1kKTtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gIH1cblxuICAucGljdG9ncmFwaC1pdGVtIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBnYXA6IHZhcigtLWRlc2t0b3Atc3BhY2luZy14cyk7IC8qIFJlZHVjZWQgZ2FwICovXG4gICAgcGFkZGluZzogdmFyKC0tZGVza3RvcC1zcGFjaW5nLXhzKTsgLyogUmVkdWNlZCBwYWRkaW5nICovXG4gICAgYmFja2dyb3VuZDogdmFyKC0tZGVza3RvcC1iZy10ZXJ0aWFyeSk7IC8qIEJhY2sgdG8gdHJhbnNwYXJlbnQgYmFja2dyb3VuZCAqL1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWRlc2t0b3AtYm9yZGVyLXRlcnRpYXJ5KTtcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1kZXNrdG9wLWJvcmRlci1yYWRpdXMtc20pO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB0cmFuc2l0aW9uOiBhbGwgdmFyKC0tZGVza3RvcC10cmFuc2l0aW9uLW5vcm1hbCk7XG4gICAgbWluLXdpZHRoOiBmaXQtY29udGVudDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgfVxuXG4gIC5waWN0b2dyYXBoLWl0ZW06bm90KC5wbGFjZWhvbGRlcik6aG92ZXIge1xuICAgIGJhY2tncm91bmQ6IHZhcigtLWRlc2t0b3AtYmctc2Vjb25kYXJ5KTtcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWRlc2t0b3AtYm9yZGVyLXByaW1hcnkpO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMnB4KTtcbiAgICBib3gtc2hhZG93OiAwIDRweCAxMnB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgfVxuXG4gIC5waWN0b2dyYXBoLWl0ZW06bm90KC5wbGFjZWhvbGRlcik6YWN0aXZlIHtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XG4gICAgYm94LXNoYWRvdzogMCAycHggNnB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgfVxuXG4gIC5waWN0b2dyYXBoLWl0ZW0ucGxhY2Vob2xkZXIge1xuICAgIGN1cnNvcjogZGVmYXVsdDtcbiAgICBvcGFjaXR5OiAwLjY7XG4gICAgYmFja2dyb3VuZDogdmFyKC0tZGVza3RvcC1iZy1xdWF0ZXJuYXJ5KTtcbiAgICBib3JkZXItc3R5bGU6IGRhc2hlZDtcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWRlc2t0b3AtYm9yZGVyLWRpc2FibGVkKTtcbiAgfVxuXG4gIC5wbGFjZWhvbGRlci1sZXR0ZXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYmFja2dyb3VuZDogdmFyKC0tZGVza3RvcC1iZy1xdWF0ZXJuYXJ5KTtcbiAgICBib3JkZXI6IDFweCBkYXNoZWQgdmFyKC0tZGVza3RvcC1ib3JkZXItZGlzYWJsZWQpO1xuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLWRlc2t0b3AtYm9yZGVyLXJhZGl1cy14cyk7XG4gICAgY29sb3I6IHZhcigtLWRlc2t0b3AtdGV4dC1kaXNhYmxlZCk7XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgZm9udC1zaXplOiB2YXIoLS1kZXNrdG9wLWZvbnQtc2l6ZS1zbSk7XG4gIH1cblxuICAvKiBSb3ctc3BlY2lmaWMgc3R5bGluZyAqL1xuICAucGljdG9ncmFwaC1yb3dbZGF0YS1yb3c9XCIwXCJdIC5waWN0b2dyYXBoLWl0ZW06aG92ZXIge1xuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tZGVza3RvcC1wcmltYXJ5LWJsdWUtYm9yZGVyKTtcbiAgfVxuXG4gIC5waWN0b2dyYXBoLXJvd1tkYXRhLXJvdz1cIjFcIl0gLnBpY3RvZ3JhcGgtaXRlbTpob3ZlciB7XG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1kZXNrdG9wLXByaW1hcnktZ3JlZW4tYm9yZGVyKTtcbiAgfVxuXG4gIC5waWN0b2dyYXBoLXJvd1tkYXRhLXJvdz1cIjJcIl0gLnBpY3RvZ3JhcGgtaXRlbTpob3ZlciB7XG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1kZXNrdG9wLXByaW1hcnktcHVycGxlLWJvcmRlcik7XG4gIH1cblxuICAucGljdG9ncmFwaC1yb3dbZGF0YS1yb3c9XCIzXCJdIC5waWN0b2dyYXBoLWl0ZW06aG92ZXIge1xuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tZGVza3RvcC1wcmltYXJ5LW9yYW5nZS1ib3JkZXIpO1xuICB9XG5cbiAgLnBpY3RvZ3JhcGgtcm93W2RhdGEtcm93PVwiNFwiXSAucGljdG9ncmFwaC1pdGVtOmhvdmVyIHtcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWRlc2t0b3AtcHJpbWFyeS1yZWQtYm9yZGVyKTtcbiAgfVxuXG4gIC8qIEFuaW1hdGlvbiBmb3IgbG9hZGluZyAqL1xuICAucGljdG9ncmFwaC1pdGVtOm5vdCgucGxhY2Vob2xkZXIpIHtcbiAgICBhbmltYXRpb246IGZhZGVJblVwIDAuM3MgZWFzZS1vdXQ7XG4gIH1cblxuICBAa2V5ZnJhbWVzIGZhZGVJblVwIHtcbiAgICBmcm9tIHtcbiAgICAgIG9wYWNpdHk6IDA7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMTBweCk7XG4gICAgfVxuICAgIHRvIHtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XG4gICAgfVxuICB9XG5cbiAgLyogUmVzcG9uc2l2ZSBkZXNpZ24gKi9cbiAgQG1lZGlhIChtYXgtd2lkdGg6IDc2OHB4KSB7XG4gICAgLmNvZGV4LXBpY3RvZ3JhcGgtZ3JpZCB7XG4gICAgICBwYWRkaW5nOiB2YXIoLS1kZXNrdG9wLXNwYWNpbmctbWQpO1xuICAgICAgZ2FwOiB2YXIoLS1kZXNrdG9wLXNwYWNpbmctbWQpO1xuICAgIH1cblxuICAgIC5waWN0b2dyYXBoLXJvdyB7XG4gICAgICBnYXA6IHZhcigtLWRlc2t0b3Atc3BhY2luZy1zbSk7XG4gICAgfVxuXG4gICAgLnBpY3RvZ3JhcGgtaXRlbSB7XG4gICAgICBwYWRkaW5nOiB2YXIoLS1kZXNrdG9wLXNwYWNpbmcteHMpO1xuICAgIH1cbiAgfVxuXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA0ODBweCkge1xuICAgIC5waWN0b2dyYXBoLXJvdyB7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICB9XG5cbiAgICAucGljdG9ncmFwaC1pdGVtIHtcbiAgICAgIG1pbi13aWR0aDogNjBweDtcbiAgICB9XG4gIH1cbjwvc3R5bGU+XG4iXSwiZmlsZSI6IkM6L1RLQS93ZWIvc3JjL2xpYi9jb21wb25lbnRzL2NvZGV4L0NvZGV4UGljdG9ncmFwaEdyaWQuc3ZlbHRlIn0=