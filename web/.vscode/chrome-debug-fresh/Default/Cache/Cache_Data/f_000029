import { ArrowAdjustmentProcessor } from "/src/lib/services/positioning/arrows/orchestration/ArrowAdjustmentProcessor.ts";
import { ArrowCoordinateTransformer } from "/src/lib/services/positioning/arrows/orchestration/ArrowCoordinateTransformer.ts";
import { ArrowDataProcessor } from "/src/lib/services/positioning/arrows/orchestration/ArrowDataProcessor.ts";
export class ArrowPositionCalculator {
  locationCalculator;
  rotationCalculator;
  adjustmentCalculator;
  coordinateSystem;
  adjustmentProcessor;
  coordinateTransformer;
  dataProcessor;
  constructor(locationCalculator, rotationCalculator, adjustmentCalculator, coordinateSystem) {
    this.locationCalculator = locationCalculator;
    this.rotationCalculator = rotationCalculator;
    this.adjustmentCalculator = adjustmentCalculator;
    this.coordinateSystem = coordinateSystem;
    this.adjustmentProcessor = new ArrowAdjustmentProcessor();
    this.coordinateTransformer = new ArrowCoordinateTransformer();
    this.dataProcessor = new ArrowDataProcessor(coordinateSystem);
  }
  async calculateArrowPosition(arrowData, pictographData, motionData) {
    try {
      const motion = motionData;
      if (!motion) {
        const center = this.coordinateSystem.getSceneCenter();
        return [center.x, center.y, 0];
      }
      const location = this.locationCalculator.calculateLocation(
        motion,
        pictographData
      );
      const initialPosition = this.coordinateSystem.getInitialPosition(
        motion,
        location
      );
      const validPosition = this.dataProcessor.ensureValidPosition(initialPosition);
      const rotation = this.rotationCalculator.calculateRotation(
        motion,
        location
      );
      const adjustment = await this.adjustmentCalculator.calculateAdjustment(
        pictographData,
        motion,
        motion.color,
        // ✅ FIXED: Use color from MotionData
        location
      );
      const [adjustmentX, adjustmentY] = this.dataProcessor.extractAdjustmentValues(adjustment);
      const [transformedAdjustmentX, transformedAdjustmentY] = this.coordinateTransformer.transformAdjustmentByRotation(
        adjustmentX,
        adjustmentY,
        rotation
      );
      const finalX = validPosition.x + transformedAdjustmentX;
      const finalY = validPosition.y + transformedAdjustmentY;
      return [finalX, finalY, rotation];
    } catch (error) {
      console.error("Arrow positioning calculation failed:", error);
      const center = this.coordinateSystem.getSceneCenter();
      return [center.x, center.y, 0];
    }
  }
  async updateArrowPosition(pictographData, color, _motionData) {
    try {
      const motionData = pictographData.motions?.[color];
      const arrowData = motionData?.arrowPlacementData;
      if (!arrowData) {
        console.warn(`No arrow data found for color: ${color}`);
        return pictographData;
      }
      const [x, y, rotation] = await this.calculateArrowPosition(
        arrowData,
        pictographData,
        motionData
      );
      const shouldMirror = this.shouldMirrorArrow(arrowData, pictographData);
      const updates = {
        positionX: x,
        positionY: y,
        rotationAngle: rotation,
        svgMirrored: shouldMirror
        // ✅ FIXED: Use correct property name
      };
      return this.dataProcessor.updateArrowInPictograph(
        pictographData,
        color,
        updates
      );
    } catch (error) {
      console.error("Arrow position update failed:", error);
      return pictographData;
    }
  }
  async calculateAllArrowPositions(pictographData) {
    try {
      if (!pictographData.motions) {
        return pictographData;
      }
      let updatedPictograph = { ...pictographData };
      for (const color of Object.keys(pictographData.motions)) {
        const motionData = pictographData.motions[color];
        const arrowData = motionData?.arrowPlacementData;
        if (arrowData) {
          const [x, y, rotation] = await this.calculateArrowPosition(
            arrowData,
            updatedPictograph
          );
          const currentMotionData = updatedPictograph.motions?.[color];
          const shouldMirror = this.shouldMirrorArrow(
            arrowData,
            updatedPictograph,
            currentMotionData
          );
          const updates = {
            positionX: x,
            positionY: y,
            rotationAngle: rotation,
            svgMirrored: shouldMirror
            // ✅ FIXED: Use correct property name
          };
          updatedPictograph = this.dataProcessor.updateArrowInPictograph(
            updatedPictograph,
            color,
            updates
          );
        }
      }
      return updatedPictograph;
    } catch (error) {
      console.error("Failed to calculate all arrow positions:", error);
      return pictographData;
    }
  }
  shouldMirrorArrow(_arrowData, pictographData, motionData) {
    if (!pictographData?.motions || !motionData) {
      return false;
    }
    const motionType = motionData.motionType?.toLowerCase();
    const propRotDir = motionData.rotationDirection?.toLowerCase();
    if (!motionType || !propRotDir) {
      return false;
    }
    const mirrorConditions = {
      anti: { cw: true, ccw: false },
      other: { cw: false, ccw: true }
    };
    const conditionKey = motionType === "anti" ? "anti" : "other";
    const shouldMirror = mirrorConditions[conditionKey][propRotDir] ?? false;
    return shouldMirror;
  }
  applyMirrorTransform(arrowItem, shouldMirror) {
    if (shouldMirror) {
      arrowItem.style.transform = `${arrowItem.style.transform || ""} scaleX(-1)`;
    } else {
      const transform = arrowItem.style.transform || "";
      arrowItem.style.transform = transform.replace(/scaleX\(-1\)\s*/g, "").trim();
    }
  }
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3NlcnZpY2VzL3Bvc2l0aW9uaW5nL2Fycm93cy9vcmNoZXN0cmF0aW9uL0Fycm93UG9zaXRpb25DYWxjdWxhdG9yLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIEFycm93IFBvc2l0aW9uIENhbGN1bGF0b3JcbiAqXG4gKiBIYW5kbGVzIHRoZSBtYWluIGFycm93IHBvc2l0aW9uaW5nIGNhbGN1bGF0aW9uIGxvZ2ljLlxuICogQ29vcmRpbmF0ZXMgd2l0aCBvdGhlciBzZXJ2aWNlcyB0byBjb21wdXRlIGZpbmFsIGFycm93IHBvc2l0aW9ucy5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7XG4gIEFycm93UGxhY2VtZW50RGF0YSxcbiAgTW90aW9uRGF0YSxcbiAgUGljdG9ncmFwaERhdGEsXG59IGZyb20gXCIkbGliL2RvbWFpblwiO1xuaW1wb3J0IHR5cGUge1xuICBJQXJyb3dBZGp1c3RtZW50Q2FsY3VsYXRvcixcbiAgSUFycm93Q29vcmRpbmF0ZVN5c3RlbVNlcnZpY2UsXG4gIElBcnJvd0xvY2F0aW9uQ2FsY3VsYXRvcixcbiAgSUFycm93UG9zaXRpb25pbmdPcmNoZXN0cmF0b3IsXG4gIElBcnJvd1JvdGF0aW9uQ2FsY3VsYXRvcixcbn0gZnJvbSBcIi4uLy4uL2NvcmUtc2VydmljZXNcIjtcbmltcG9ydCB7IEFycm93QWRqdXN0bWVudFByb2Nlc3NvciB9IGZyb20gXCIuL0Fycm93QWRqdXN0bWVudFByb2Nlc3NvclwiO1xuaW1wb3J0IHsgQXJyb3dDb29yZGluYXRlVHJhbnNmb3JtZXIgfSBmcm9tIFwiLi9BcnJvd0Nvb3JkaW5hdGVUcmFuc2Zvcm1lclwiO1xuaW1wb3J0IHsgQXJyb3dEYXRhUHJvY2Vzc29yIH0gZnJvbSBcIi4vQXJyb3dEYXRhUHJvY2Vzc29yXCI7XG5cbmV4cG9ydCBjbGFzcyBBcnJvd1Bvc2l0aW9uQ2FsY3VsYXRvciBpbXBsZW1lbnRzIElBcnJvd1Bvc2l0aW9uaW5nT3JjaGVzdHJhdG9yIHtcbiAgcHJpdmF0ZSBsb2NhdGlvbkNhbGN1bGF0b3I6IElBcnJvd0xvY2F0aW9uQ2FsY3VsYXRvcjtcbiAgcHJpdmF0ZSByb3RhdGlvbkNhbGN1bGF0b3I6IElBcnJvd1JvdGF0aW9uQ2FsY3VsYXRvcjtcbiAgcHJpdmF0ZSBhZGp1c3RtZW50Q2FsY3VsYXRvcjogSUFycm93QWRqdXN0bWVudENhbGN1bGF0b3I7XG4gIHByaXZhdGUgY29vcmRpbmF0ZVN5c3RlbTogSUFycm93Q29vcmRpbmF0ZVN5c3RlbVNlcnZpY2U7XG5cbiAgcHJpdmF0ZSBhZGp1c3RtZW50UHJvY2Vzc29yOiBBcnJvd0FkanVzdG1lbnRQcm9jZXNzb3I7XG4gIHByaXZhdGUgY29vcmRpbmF0ZVRyYW5zZm9ybWVyOiBBcnJvd0Nvb3JkaW5hdGVUcmFuc2Zvcm1lcjtcbiAgcHJpdmF0ZSBkYXRhUHJvY2Vzc29yOiBBcnJvd0RhdGFQcm9jZXNzb3I7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbG9jYXRpb25DYWxjdWxhdG9yOiBJQXJyb3dMb2NhdGlvbkNhbGN1bGF0b3IsXG4gICAgcm90YXRpb25DYWxjdWxhdG9yOiBJQXJyb3dSb3RhdGlvbkNhbGN1bGF0b3IsXG4gICAgYWRqdXN0bWVudENhbGN1bGF0b3I6IElBcnJvd0FkanVzdG1lbnRDYWxjdWxhdG9yLFxuICAgIGNvb3JkaW5hdGVTeXN0ZW06IElBcnJvd0Nvb3JkaW5hdGVTeXN0ZW1TZXJ2aWNlXG4gICkge1xuICAgIHRoaXMubG9jYXRpb25DYWxjdWxhdG9yID0gbG9jYXRpb25DYWxjdWxhdG9yO1xuICAgIHRoaXMucm90YXRpb25DYWxjdWxhdG9yID0gcm90YXRpb25DYWxjdWxhdG9yO1xuICAgIHRoaXMuYWRqdXN0bWVudENhbGN1bGF0b3IgPSBhZGp1c3RtZW50Q2FsY3VsYXRvcjtcbiAgICB0aGlzLmNvb3JkaW5hdGVTeXN0ZW0gPSBjb29yZGluYXRlU3lzdGVtO1xuXG4gICAgdGhpcy5hZGp1c3RtZW50UHJvY2Vzc29yID0gbmV3IEFycm93QWRqdXN0bWVudFByb2Nlc3NvcigpO1xuICAgIHRoaXMuY29vcmRpbmF0ZVRyYW5zZm9ybWVyID0gbmV3IEFycm93Q29vcmRpbmF0ZVRyYW5zZm9ybWVyKCk7XG4gICAgdGhpcy5kYXRhUHJvY2Vzc29yID0gbmV3IEFycm93RGF0YVByb2Nlc3Nvcihjb29yZGluYXRlU3lzdGVtKTtcbiAgfVxuXG4gIGFzeW5jIGNhbGN1bGF0ZUFycm93UG9zaXRpb24oXG4gICAgYXJyb3dEYXRhOiBBcnJvd1BsYWNlbWVudERhdGEsXG4gICAgcGljdG9ncmFwaERhdGE6IFBpY3RvZ3JhcGhEYXRhLFxuICAgIG1vdGlvbkRhdGE/OiBNb3Rpb25EYXRhXG4gICk6IFByb21pc2U8W251bWJlciwgbnVtYmVyLCBudW1iZXJdPiB7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGFycm93IHBvc2l0aW9uIGFzeW5jaHJvbm91c2x5IHdpdGggZnVsbCBzZXJ2aWNlIGNvb3JkaW5hdGlvbi5cbiAgICAgKi9cbiAgICB0cnkge1xuICAgICAgLy8gU1RFUCAxOiBFeHRyYWN0IG9yIHVzZSBwcm92aWRlZCBtb3Rpb24gZGF0YVxuICAgICAgLy8g4pyFIEZJWEVEOiBQYXNzIGNvbG9yIGRpcmVjdGx5IHNpbmNlIEFycm93UGxhY2VtZW50RGF0YSBubyBsb25nZXIgaGFzIGNvbG9yXG4gICAgICBjb25zdCBtb3Rpb24gPSBtb3Rpb25EYXRhO1xuICAgICAgaWYgKCFtb3Rpb24pIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhpcy5jb29yZGluYXRlU3lzdGVtLmdldFNjZW5lQ2VudGVyKCk7XG4gICAgICAgIHJldHVybiBbY2VudGVyLngsIGNlbnRlci55LCAwXTtcbiAgICAgIH1cblxuICAgICAgLy8gU1RFUCAyOiBDYWxjdWxhdGUgbG9jYXRpb24gYW5kIGluaXRpYWwgcG9zaXRpb25cbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5sb2NhdGlvbkNhbGN1bGF0b3IuY2FsY3VsYXRlTG9jYXRpb24oXG4gICAgICAgIG1vdGlvbixcbiAgICAgICAgcGljdG9ncmFwaERhdGFcbiAgICAgICk7XG4gICAgICBjb25zdCBpbml0aWFsUG9zaXRpb24gPSB0aGlzLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0SW5pdGlhbFBvc2l0aW9uKFxuICAgICAgICBtb3Rpb24sXG4gICAgICAgIGxvY2F0aW9uXG4gICAgICApO1xuICAgICAgY29uc3QgdmFsaWRQb3NpdGlvbiA9XG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3Nvci5lbnN1cmVWYWxpZFBvc2l0aW9uKGluaXRpYWxQb3NpdGlvbik7XG5cbiAgICAgIC8vIFNURVAgMzogQ2FsY3VsYXRlIHJvdGF0aW9uXG4gICAgICBjb25zdCByb3RhdGlvbiA9IHRoaXMucm90YXRpb25DYWxjdWxhdG9yLmNhbGN1bGF0ZVJvdGF0aW9uKFxuICAgICAgICBtb3Rpb24sXG4gICAgICAgIGxvY2F0aW9uXG4gICAgICApO1xuXG4gICAgICAvLyBTVEVQIDQ6IENhbGN1bGF0ZSBhZGp1c3RtZW50IHVzaW5nIHNvcGhpc3RpY2F0ZWQgc2VydmljZVxuICAgICAgY29uc3QgYWRqdXN0bWVudCA9IGF3YWl0IHRoaXMuYWRqdXN0bWVudENhbGN1bGF0b3IuY2FsY3VsYXRlQWRqdXN0bWVudChcbiAgICAgICAgcGljdG9ncmFwaERhdGEsXG4gICAgICAgIG1vdGlvbixcbiAgICAgICAgbW90aW9uLmNvbG9yLCAvLyDinIUgRklYRUQ6IFVzZSBjb2xvciBmcm9tIE1vdGlvbkRhdGFcbiAgICAgICAgbG9jYXRpb25cbiAgICAgICk7XG4gICAgICBjb25zdCBbYWRqdXN0bWVudFgsIGFkanVzdG1lbnRZXSA9XG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3Nvci5leHRyYWN0QWRqdXN0bWVudFZhbHVlcyhhZGp1c3RtZW50KTtcblxuICAgICAgLy8gU1RFUCA1OiBBcHBseSByb3RhdGlvbiB0cmFuc2Zvcm1hdGlvbiB0byBhZGp1c3RtZW50IGNvb3JkaW5hdGVzXG4gICAgICBjb25zdCBbdHJhbnNmb3JtZWRBZGp1c3RtZW50WCwgdHJhbnNmb3JtZWRBZGp1c3RtZW50WV0gPVxuICAgICAgICB0aGlzLmNvb3JkaW5hdGVUcmFuc2Zvcm1lci50cmFuc2Zvcm1BZGp1c3RtZW50QnlSb3RhdGlvbihcbiAgICAgICAgICBhZGp1c3RtZW50WCxcbiAgICAgICAgICBhZGp1c3RtZW50WSxcbiAgICAgICAgICByb3RhdGlvblxuICAgICAgICApO1xuXG4gICAgICAvLyBTVEVQIDY6IENvbWJpbmUgYWxsIHBvc2l0aW9uaW5nIGNhbGN1bGF0aW9uc1xuICAgICAgY29uc3QgZmluYWxYID0gdmFsaWRQb3NpdGlvbi54ICsgdHJhbnNmb3JtZWRBZGp1c3RtZW50WDtcbiAgICAgIGNvbnN0IGZpbmFsWSA9IHZhbGlkUG9zaXRpb24ueSArIHRyYW5zZm9ybWVkQWRqdXN0bWVudFk7XG5cbiAgICAgIHJldHVybiBbZmluYWxYLCBmaW5hbFksIHJvdGF0aW9uXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkFycm93IHBvc2l0aW9uaW5nIGNhbGN1bGF0aW9uIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgY29uc3QgY2VudGVyID0gdGhpcy5jb29yZGluYXRlU3lzdGVtLmdldFNjZW5lQ2VudGVyKCk7XG4gICAgICByZXR1cm4gW2NlbnRlci54LCBjZW50ZXIueSwgMF07XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgdXBkYXRlQXJyb3dQb3NpdGlvbihcbiAgICBwaWN0b2dyYXBoRGF0YTogUGljdG9ncmFwaERhdGEsXG4gICAgY29sb3I6IHN0cmluZyxcbiAgICBfbW90aW9uRGF0YT86IE1vdGlvbkRhdGFcbiAgKTogUHJvbWlzZTxQaWN0b2dyYXBoRGF0YT4ge1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhcnJvdyBwb3NpdGlvbiBpbiBwaWN0b2dyYXBoIGRhdGEuXG4gICAgICovXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1vdGlvbkRhdGEgPVxuICAgICAgICBwaWN0b2dyYXBoRGF0YS5tb3Rpb25zPy5bY29sb3IgYXMga2V5b2YgdHlwZW9mIHBpY3RvZ3JhcGhEYXRhLm1vdGlvbnNdO1xuICAgICAgY29uc3QgYXJyb3dEYXRhID0gbW90aW9uRGF0YT8uYXJyb3dQbGFjZW1lbnREYXRhO1xuICAgICAgaWYgKCFhcnJvd0RhdGEpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBObyBhcnJvdyBkYXRhIGZvdW5kIGZvciBjb2xvcjogJHtjb2xvcn1gKTtcbiAgICAgICAgcmV0dXJuIHBpY3RvZ3JhcGhEYXRhO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBbeCwgeSwgcm90YXRpb25dID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVBcnJvd1Bvc2l0aW9uKFxuICAgICAgICBhcnJvd0RhdGEsXG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhLFxuICAgICAgICBtb3Rpb25EYXRhXG4gICAgICApO1xuXG4gICAgICAvLyBDUklUSUNBTDogQWxzbyBjYWxjdWxhdGUgbWlycm9yaW5nIGZvciB0aGlzIGFycm93XG4gICAgICBjb25zdCBzaG91bGRNaXJyb3IgPSB0aGlzLnNob3VsZE1pcnJvckFycm93KGFycm93RGF0YSwgcGljdG9ncmFwaERhdGEpO1xuXG4gICAgICBjb25zdCB1cGRhdGVzOiBQYXJ0aWFsPEFycm93UGxhY2VtZW50RGF0YT4gPSB7XG4gICAgICAgIHBvc2l0aW9uWDogeCxcbiAgICAgICAgcG9zaXRpb25ZOiB5LFxuICAgICAgICByb3RhdGlvbkFuZ2xlOiByb3RhdGlvbixcbiAgICAgICAgc3ZnTWlycm9yZWQ6IHNob3VsZE1pcnJvciwgLy8g4pyFIEZJWEVEOiBVc2UgY29ycmVjdCBwcm9wZXJ0eSBuYW1lXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YVByb2Nlc3Nvci51cGRhdGVBcnJvd0luUGljdG9ncmFwaChcbiAgICAgICAgcGljdG9ncmFwaERhdGEsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICB1cGRhdGVzXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQXJyb3cgcG9zaXRpb24gdXBkYXRlIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHBpY3RvZ3JhcGhEYXRhO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNhbGN1bGF0ZUFsbEFycm93UG9zaXRpb25zKFxuICAgIHBpY3RvZ3JhcGhEYXRhOiBQaWN0b2dyYXBoRGF0YVxuICApOiBQcm9taXNlPFBpY3RvZ3JhcGhEYXRhPiB7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHBvc2l0aW9ucyBmb3IgYWxsIGFycm93cyBpbiB0aGUgcGljdG9ncmFwaC5cbiAgICAgKi9cbiAgICB0cnkge1xuICAgICAgaWYgKCFwaWN0b2dyYXBoRGF0YS5tb3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBwaWN0b2dyYXBoRGF0YTtcbiAgICAgIH1cblxuICAgICAgbGV0IHVwZGF0ZWRQaWN0b2dyYXBoID0geyAuLi5waWN0b2dyYXBoRGF0YSB9O1xuXG4gICAgICBmb3IgKGNvbnN0IGNvbG9yIG9mIE9iamVjdC5rZXlzKHBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMpKSB7XG4gICAgICAgIGNvbnN0IG1vdGlvbkRhdGEgPVxuICAgICAgICAgIHBpY3RvZ3JhcGhEYXRhLm1vdGlvbnNbY29sb3IgYXMga2V5b2YgdHlwZW9mIHBpY3RvZ3JhcGhEYXRhLm1vdGlvbnNdO1xuICAgICAgICBjb25zdCBhcnJvd0RhdGEgPSBtb3Rpb25EYXRhPy5hcnJvd1BsYWNlbWVudERhdGE7XG4gICAgICAgIGlmIChhcnJvd0RhdGEpIHtcbiAgICAgICAgICBjb25zdCBbeCwgeSwgcm90YXRpb25dID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVBcnJvd1Bvc2l0aW9uKFxuICAgICAgICAgICAgYXJyb3dEYXRhLFxuICAgICAgICAgICAgdXBkYXRlZFBpY3RvZ3JhcGhcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gQ1JJVElDQUw6IEFsc28gY2FsY3VsYXRlIG1pcnJvcmluZyBmb3IgdGhpcyBhcnJvd1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRNb3Rpb25EYXRhID1cbiAgICAgICAgICAgIHVwZGF0ZWRQaWN0b2dyYXBoLm1vdGlvbnM/LltcbiAgICAgICAgICAgICAgY29sb3IgYXMga2V5b2YgdHlwZW9mIHVwZGF0ZWRQaWN0b2dyYXBoLm1vdGlvbnNcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgY29uc3Qgc2hvdWxkTWlycm9yID0gdGhpcy5zaG91bGRNaXJyb3JBcnJvdyhcbiAgICAgICAgICAgIGFycm93RGF0YSxcbiAgICAgICAgICAgIHVwZGF0ZWRQaWN0b2dyYXBoLFxuICAgICAgICAgICAgY3VycmVudE1vdGlvbkRhdGFcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY29uc3QgdXBkYXRlczogUGFydGlhbDxBcnJvd1BsYWNlbWVudERhdGE+ID0ge1xuICAgICAgICAgICAgcG9zaXRpb25YOiB4LFxuICAgICAgICAgICAgcG9zaXRpb25ZOiB5LFxuICAgICAgICAgICAgcm90YXRpb25BbmdsZTogcm90YXRpb24sXG4gICAgICAgICAgICBzdmdNaXJyb3JlZDogc2hvdWxkTWlycm9yLCAvLyDinIUgRklYRUQ6IFVzZSBjb3JyZWN0IHByb3BlcnR5IG5hbWVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdXBkYXRlZFBpY3RvZ3JhcGggPSB0aGlzLmRhdGFQcm9jZXNzb3IudXBkYXRlQXJyb3dJblBpY3RvZ3JhcGgoXG4gICAgICAgICAgICB1cGRhdGVkUGljdG9ncmFwaCxcbiAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgdXBkYXRlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZWRQaWN0b2dyYXBoO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNhbGN1bGF0ZSBhbGwgYXJyb3cgcG9zaXRpb25zOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gcGljdG9ncmFwaERhdGE7XG4gICAgfVxuICB9XG5cbiAgc2hvdWxkTWlycm9yQXJyb3coXG4gICAgX2Fycm93RGF0YTogQXJyb3dQbGFjZW1lbnREYXRhLFxuICAgIHBpY3RvZ3JhcGhEYXRhPzogUGljdG9ncmFwaERhdGEsXG4gICAgbW90aW9uRGF0YT86IE1vdGlvbkRhdGFcbiAgKTogYm9vbGVhbiB7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIGFycm93IHNob3VsZCBiZSBtaXJyb3JlZCBiYXNlZCBvbiBtb3Rpb24gdHlwZSBhbmQgcHJvcCByb3RhdGlvbiBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBNaXJyb3IgY29uZGl0aW9ucyAobWF0Y2hpbmcgZGVza3RvcCBsb2dpYyk6XG4gICAgICogLSBBbnRpIG1vdGlvbiArIGNsb2Nrd2lzZSDihpIgTWlycm9yID0gVHJ1ZVxuICAgICAqIC0gQW50aSBtb3Rpb24gKyBjb3VudGVyY2xvY2t3aXNlIOKGkiBNaXJyb3IgPSBGYWxzZVxuICAgICAqIC0gUHJvIG1vdGlvbiArIGNsb2Nrd2lzZSDihpIgTWlycm9yID0gRmFsc2VcbiAgICAgKiAtIFBybyBtb3Rpb24gKyBjb3VudGVyY2xvY2t3aXNlIOKGkiBNaXJyb3IgPSBUcnVlXG4gICAgICogLSBPdGhlciBtb3Rpb25zIGZvbGxvdyBcInByb1wiIHJ1bGVzXG4gICAgICovXG5cbiAgICAvLyBHZXQgbW90aW9uIGRhdGEgZm9yIHRoaXMgYXJyb3cncyBjb2xvclxuICAgIGlmICghcGljdG9ncmFwaERhdGE/Lm1vdGlvbnMgfHwgIW1vdGlvbkRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBtb3Rpb25UeXBlID0gbW90aW9uRGF0YS5tb3Rpb25UeXBlPy50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHByb3BSb3REaXIgPSBtb3Rpb25EYXRhLnJvdGF0aW9uRGlyZWN0aW9uPy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKCFtb3Rpb25UeXBlIHx8ICFwcm9wUm90RGlyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTWlycm9yIGNvbmRpdGlvbnMgbWF0Y2hpbmcgZGVza3RvcCBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IG1pcnJvckNvbmRpdGlvbnMgPSB7XG4gICAgICBhbnRpOiB7IGN3OiB0cnVlLCBjY3c6IGZhbHNlIH0sXG4gICAgICBvdGhlcjogeyBjdzogZmFsc2UsIGNjdzogdHJ1ZSB9LFxuICAgIH07XG5cbiAgICAvLyBVc2UgXCJhbnRpXCIgY29uZGl0aW9ucyBmb3IgYW50aSBtb3Rpb24sIFwib3RoZXJcIiBmb3IgZXZlcnl0aGluZyBlbHNlIChwcm8sIHN0YXRpYywgZGFzaCwgZmxvYXQpXG4gICAgY29uc3QgY29uZGl0aW9uS2V5ID0gbW90aW9uVHlwZSA9PT0gXCJhbnRpXCIgPyBcImFudGlcIiA6IFwib3RoZXJcIjtcbiAgICBjb25zdCBzaG91bGRNaXJyb3IgPVxuICAgICAgbWlycm9yQ29uZGl0aW9uc1tjb25kaXRpb25LZXldW1xuICAgICAgICBwcm9wUm90RGlyIGFzIGtleW9mIHR5cGVvZiBtaXJyb3JDb25kaXRpb25zLmFudGlcbiAgICAgIF0gPz8gZmFsc2U7XG5cbiAgICByZXR1cm4gc2hvdWxkTWlycm9yO1xuICB9XG5cbiAgYXBwbHlNaXJyb3JUcmFuc2Zvcm0oXG4gICAgYXJyb3dJdGVtOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsXG4gICAgc2hvdWxkTWlycm9yOiBib29sZWFuXG4gICk6IHZvaWQge1xuICAgIC8qKlxuICAgICAqIEFwcGx5IG1pcnJvciB0cmFuc2Zvcm1hdGlvbiB0byBhcnJvdyBncmFwaGljcyBpdGVtLlxuICAgICAqL1xuICAgIGlmIChzaG91bGRNaXJyb3IpIHtcbiAgICAgIGFycm93SXRlbS5zdHlsZS50cmFuc2Zvcm0gPSBgJHthcnJvd0l0ZW0uc3R5bGUudHJhbnNmb3JtIHx8IFwiXCJ9IHNjYWxlWCgtMSlgO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgbWlycm9yIHRyYW5zZm9ybWF0aW9uXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBhcnJvd0l0ZW0uc3R5bGUudHJhbnNmb3JtIHx8IFwiXCI7XG4gICAgICBhcnJvd0l0ZW0uc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4gICAgICAgIC5yZXBsYWNlKC9zY2FsZVhcXCgtMVxcKVxccyovZywgXCJcIilcbiAgICAgICAgLnRyaW0oKTtcbiAgICB9XG4gIH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICJBQW1CQSxTQUFTLGdDQUFnQztBQUN6QyxTQUFTLGtDQUFrQztBQUMzQyxTQUFTLDBCQUEwQjtBQUU1QixhQUFNLHdCQUFpRTtBQUFBLEVBQ3BFO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFFQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFFUixZQUNFLG9CQUNBLG9CQUNBLHNCQUNBLGtCQUNBO0FBQ0EsU0FBSyxxQkFBcUI7QUFDMUIsU0FBSyxxQkFBcUI7QUFDMUIsU0FBSyx1QkFBdUI7QUFDNUIsU0FBSyxtQkFBbUI7QUFFeEIsU0FBSyxzQkFBc0IsSUFBSSx5QkFBeUI7QUFDeEQsU0FBSyx3QkFBd0IsSUFBSSwyQkFBMkI7QUFDNUQsU0FBSyxnQkFBZ0IsSUFBSSxtQkFBbUIsZ0JBQWdCO0FBQUEsRUFDOUQ7QUFBQSxFQUVBLE1BQU0sdUJBQ0osV0FDQSxnQkFDQSxZQUNtQztBQUluQyxRQUFJO0FBR0YsWUFBTSxTQUFTO0FBQ2YsVUFBSSxDQUFDLFFBQVE7QUFDWCxjQUFNLFNBQVMsS0FBSyxpQkFBaUIsZUFBZTtBQUNwRCxlQUFPLENBQUMsT0FBTyxHQUFHLE9BQU8sR0FBRyxDQUFDO0FBQUEsTUFDL0I7QUFHQSxZQUFNLFdBQVcsS0FBSyxtQkFBbUI7QUFBQSxRQUN2QztBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBQ0EsWUFBTSxrQkFBa0IsS0FBSyxpQkFBaUI7QUFBQSxRQUM1QztBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBQ0EsWUFBTSxnQkFDSixL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
