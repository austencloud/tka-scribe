import {
  MotionType,
  Orientation,
  RotationDirection,
  Location,
  MotionColor
} from "/src/lib/domain/enums.ts";
import { createMotionData } from "/src/lib/domain/MotionData.ts";
export class MotionParameterService {
  // Helper function to determine motion type based on start/end locations
  getMotionType(startLocation, endLocation) {
    if (startLocation === endLocation) {
      return MotionType.STATIC;
    }
    const opposites = [
      [Location.NORTH, Location.SOUTH],
      [Location.SOUTH, Location.NORTH],
      [Location.EAST, Location.WEST],
      [Location.WEST, Location.EAST],
      [Location.NORTHEAST, Location.SOUTHWEST],
      [Location.SOUTHWEST, Location.NORTHEAST],
      [Location.NORTHWEST, Location.SOUTHEAST],
      [Location.SOUTHEAST, Location.NORTHWEST]
    ];
    for (const [startOpp, endOpp] of opposites) {
      if (startLocation === startOpp && endLocation === endOpp) {
        return MotionType.DASH;
      }
    }
    return MotionType.PRO;
  }
  // Helper function to get available motion types for a start/end pair
  getAvailableMotionTypes(startLocation, endLocation) {
    const motionType = this.getMotionType(startLocation, endLocation);
    if (motionType === MotionType.STATIC) {
      return [MotionType.STATIC];
    } else if (motionType === MotionType.DASH) {
      return [MotionType.DASH];
    } else {
      return [MotionType.PRO, MotionType.ANTI, MotionType.FLOAT];
    }
  }
  // Helper function to calculate rotation direction based on motion type and locations
  calculateRotationDirection(motionType, startLocation, endLocation) {
    const locationOrder = [
      Location.NORTH,
      Location.EAST,
      Location.SOUTH,
      Location.WEST
    ];
    const startIndex = locationOrder.indexOf(startLocation);
    const endIndex = locationOrder.indexOf(endLocation);
    if (motionType === MotionType.STATIC) {
      return RotationDirection.NO_ROTATION;
    }
    if (motionType === MotionType.DASH) {
      return RotationDirection.NO_ROTATION;
    }
    if (startIndex === -1 || endIndex === -1) {
      return RotationDirection.CLOCKWISE;
    }
    const clockwiseDistance = (endIndex - startIndex + 4) % 4;
    const counterClockwiseDistance = (startIndex - endIndex + 4) % 4;
    const handPathIsClockwise = clockwiseDistance < counterClockwiseDistance;
    let result;
    if (motionType === MotionType.PRO) {
      result = handPathIsClockwise ? RotationDirection.CLOCKWISE : RotationDirection.COUNTER_CLOCKWISE;
    } else if (motionType === MotionType.ANTI) {
      result = handPathIsClockwise ? RotationDirection.COUNTER_CLOCKWISE : RotationDirection.CLOCKWISE;
    } else {
      result = RotationDirection.CLOCKWISE;
    }
    console.log(
      `ðŸ”„ Rotation direction for ${startLocation}â†’${endLocation} (${motionType}): ${result}`
    );
    return result;
  }
  // No more string-to-enum mapping needed - we use enums directly!
  // Helper function to convert MotionTestParams to PropAttributes
  convertMotionTestParamsToPropAttributes(params) {
    return {
      startLocation: params.startLocation,
      endLocation: params.endLocation,
      motionType: params.motionType,
      turns: params.turns,
      rotationDirection: params.rotationDirection,
      startOrientation: params.startOrientation,
      endOrientation: params.endOrientation
    };
  }
  // Create default motion parameters
  createDefaultParams() {
    return {
      startLocation: Location.NORTH,
      endLocation: Location.EAST,
      motionType: MotionType.PRO,
      turns: 0,
      rotationDirection: RotationDirection.CLOCKWISE,
      startOrientation: Orientation.IN,
      endOrientation: Orientation.IN
    };
  }
  // Update motion type when locations change
  updateMotionTypeForLocations(params) {
    const availableTypes = this.getAvailableMotionTypes(
      params.startLocation,
      params.endLocation
    );
    if (!availableTypes.includes(params.motionType)) {
      return {
        ...params,
        motionType: availableTypes[0]
      };
    }
    return params;
  }
  // Convert MotionTestParams to MotionData - no mapping needed, already enums!
  convertToMotionData(params, color) {
    return createMotionData({
      motionType: params.motionType,
      rotationDirection: params.rotationDirection,
      startLocation: params.startLocation,
      endLocation: params.endLocation,
      turns: typeof params.turns === "string" ? -0.5 : params.turns,
      // Handle "fl" float turns
      startOrientation: params.startOrientation,
      endOrientation: params.endOrientation,
      isVisible: true,
      color
    });
  }
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvcm91dGVzL21vdGlvbi10ZXN0ZXIvc2VydmljZXMvTW90aW9uUGFyYW1ldGVyU2VydmljZS50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHtcbiAgTW90aW9uVHlwZSxcbiAgT3JpZW50YXRpb24sXG4gIFJvdGF0aW9uRGlyZWN0aW9uLFxuICBMb2NhdGlvbixcbiAgTW90aW9uQ29sb3IsXG59IGZyb20gXCIkbGliL2RvbWFpbi9lbnVtc1wiO1xuaW1wb3J0IHR5cGUgeyBNb3Rpb25EYXRhIH0gZnJvbSBcIiRsaWIvZG9tYWluL01vdGlvbkRhdGFcIjtcbmltcG9ydCB7IGNyZWF0ZU1vdGlvbkRhdGEgfSBmcm9tIFwiJGxpYi9kb21haW4vTW90aW9uRGF0YVwiO1xuaW1wb3J0IHR5cGUgeyBJTW90aW9uUGFyYW1ldGVyU2VydmljZSB9IGZyb20gXCIuL2ludGVyZmFjZXNcIjtcblxuLyoqXG4gKiBNb3Rpb24gVGVzdCBQYXJhbWV0ZXJzIC0gVXNpbmcgcHJvcGVyIGVudW1zIGZvciB0eXBlIHNhZmV0eVxuICogTm8gbW9yZSBzdHJpbmctYmFzZWQgcGFyYW1ldGVycyB0aGF0IGNhdXNlIHR5cGUgaXNzdWVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTW90aW9uVGVzdFBhcmFtcyB7XG4gIHN0YXJ0TG9jYXRpb246IExvY2F0aW9uO1xuICBlbmRMb2NhdGlvbjogTG9jYXRpb247XG4gIG1vdGlvblR5cGU6IE1vdGlvblR5cGU7XG4gIHR1cm5zOiBudW1iZXIgfCBcImZsXCI7IC8vIFN1cHBvcnQgYm90aCBudW1lcmljIHR1cm5zIGFuZCBmbG9hdFxuICByb3RhdGlvbkRpcmVjdGlvbjogUm90YXRpb25EaXJlY3Rpb247XG4gIHN0YXJ0T3JpZW50YXRpb246IE9yaWVudGF0aW9uO1xuICBlbmRPcmllbnRhdGlvbjogT3JpZW50YXRpb247XG59XG5cbmV4cG9ydCBjbGFzcyBNb3Rpb25QYXJhbWV0ZXJTZXJ2aWNlIGltcGxlbWVudHMgSU1vdGlvblBhcmFtZXRlclNlcnZpY2Uge1xuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIG1vdGlvbiB0eXBlIGJhc2VkIG9uIHN0YXJ0L2VuZCBsb2NhdGlvbnNcbiAgZ2V0TW90aW9uVHlwZShzdGFydExvY2F0aW9uOiBMb2NhdGlvbiwgZW5kTG9jYXRpb246IExvY2F0aW9uKTogTW90aW9uVHlwZSB7XG4gICAgaWYgKHN0YXJ0TG9jYXRpb24gPT09IGVuZExvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gTW90aW9uVHlwZS5TVEFUSUM7IC8vIFNhbWUgbG9jYXRpb24gPSBzdGF0aWNcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBpdCdzIGEgZGFzaCBtb3Rpb24gKG9wcG9zaXRlIGxvY2F0aW9ucylcbiAgICBjb25zdCBvcHBvc2l0ZXMgPSBbXG4gICAgICBbTG9jYXRpb24uTk9SVEgsIExvY2F0aW9uLlNPVVRIXSxcbiAgICAgIFtMb2NhdGlvbi5TT1VUSCwgTG9jYXRpb24uTk9SVEhdLFxuICAgICAgW0xvY2F0aW9uLkVBU1QsIExvY2F0aW9uLldFU1RdLFxuICAgICAgW0xvY2F0aW9uLldFU1QsIExvY2F0aW9uLkVBU1RdLFxuICAgICAgW0xvY2F0aW9uLk5PUlRIRUFTVCwgTG9jYXRpb24uU09VVEhXRVNUXSxcbiAgICAgIFtMb2NhdGlvbi5TT1VUSFdFU1QsIExvY2F0aW9uLk5PUlRIRUFTVF0sXG4gICAgICBbTG9jYXRpb24uTk9SVEhXRVNULCBMb2NhdGlvbi5TT1VUSEVBU1RdLFxuICAgICAgW0xvY2F0aW9uLlNPVVRIRUFTVCwgTG9jYXRpb24uTk9SVEhXRVNUXSxcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCBbc3RhcnRPcHAsIGVuZE9wcF0gb2Ygb3Bwb3NpdGVzKSB7XG4gICAgICBpZiAoc3RhcnRMb2NhdGlvbiA9PT0gc3RhcnRPcHAgJiYgZW5kTG9jYXRpb24gPT09IGVuZE9wcCkge1xuICAgICAgICByZXR1cm4gTW90aW9uVHlwZS5EQVNIO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkamFjZW50IGxvY2F0aW9ucyA9IHNoaWZ0IG1vdGlvbiAoZGVmYXVsdCB0byBQUk8pXG4gICAgcmV0dXJuIE1vdGlvblR5cGUuUFJPO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhdmFpbGFibGUgbW90aW9uIHR5cGVzIGZvciBhIHN0YXJ0L2VuZCBwYWlyXG4gIGdldEF2YWlsYWJsZU1vdGlvblR5cGVzKFxuICAgIHN0YXJ0TG9jYXRpb246IExvY2F0aW9uLFxuICAgIGVuZExvY2F0aW9uOiBMb2NhdGlvblxuICApOiBNb3Rpb25UeXBlW10ge1xuICAgIGNvbnN0IG1vdGlvblR5cGUgPSB0aGlzLmdldE1vdGlvblR5cGUoc3RhcnRMb2NhdGlvbiwgZW5kTG9jYXRpb24pO1xuXG4gICAgaWYgKG1vdGlvblR5cGUgPT09IE1vdGlvblR5cGUuU1RBVElDKSB7XG4gICAgICByZXR1cm4gW01vdGlvblR5cGUuU1RBVElDXTtcbiAgICB9IGVsc2UgaWYgKG1vdGlvblR5cGUgPT09IE1vdGlvblR5cGUuREFTSCkge1xuICAgICAgcmV0dXJuIFtNb3Rpb25UeXBlLkRBU0hdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTaGlmdCBtb3Rpb25zIGNhbiBiZSBwcm8sIGFudGksIG9yIGZsb2F0XG4gICAgICByZXR1cm4gW01vdGlvblR5cGUuUFJPLCBNb3Rpb25UeXBlLkFOVEksIE1vdGlvblR5cGUuRkxPQVRdO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgcm90YXRpb24gZGlyZWN0aW9uIGJhc2VkIG9uIG1vdGlvbiB0eXBlIGFuZCBsb2NhdGlvbnNcbiAgY2FsY3VsYXRlUm90YXRpb25EaXJlY3Rpb24oXG4gICAgbW90aW9uVHlwZTogTW90aW9uVHlwZSxcbiAgICBzdGFydExvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBlbmRMb2NhdGlvbjogTG9jYXRpb25cbiAgKTogUm90YXRpb25EaXJlY3Rpb24ge1xuICAgIC8vIExvY2F0aW9uIG9yZGVyIGZvciBjbG9ja3dpc2UgbW92ZW1lbnQ6IE4gLT4gRSAtPiBTIC0+IFcgLT4gTlxuICAgIGNvbnN0IGxvY2F0aW9uT3JkZXIgPSBbXG4gICAgICBMb2NhdGlvbi5OT1JUSCxcbiAgICAgIExvY2F0aW9uLkVBU1QsXG4gICAgICBMb2NhdGlvbi5TT1VUSCxcbiAgICAgIExvY2F0aW9uLldFU1QsXG4gICAgXTtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gbG9jYXRpb25PcmRlci5pbmRleE9mKHN0YXJ0TG9jYXRpb24pO1xuICAgIGNvbnN0IGVuZEluZGV4ID0gbG9jYXRpb25PcmRlci5pbmRleE9mKGVuZExvY2F0aW9uKTtcblxuICAgIC8vIEZvciBzdGF0aWMgbW90aW9ucywgbm8gcm90YXRpb25cbiAgICBpZiAobW90aW9uVHlwZSA9PT0gTW90aW9uVHlwZS5TVEFUSUMpIHtcbiAgICAgIHJldHVybiBSb3RhdGlvbkRpcmVjdGlvbi5OT19ST1RBVElPTjtcbiAgICB9XG5cbiAgICAvLyBGb3IgZGFzaCBtb3Rpb25zLCB0eXBpY2FsbHkgbm8gcm90YXRpb24gdW5sZXNzIHNwZWNpZmllZFxuICAgIGlmIChtb3Rpb25UeXBlID09PSBNb3Rpb25UeXBlLkRBU0gpIHtcbiAgICAgIHJldHVybiBSb3RhdGlvbkRpcmVjdGlvbi5OT19ST1RBVElPTjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZGlhZ29uYWwgbG9jYXRpb25zIC0gZGVmYXVsdCB0byBjbG9ja3dpc2VcbiAgICBpZiAoc3RhcnRJbmRleCA9PT0gLTEgfHwgZW5kSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gUm90YXRpb25EaXJlY3Rpb24uQ0xPQ0tXSVNFO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgaGFuZCBwYXRoIGRpcmVjdGlvbiAoY2xvY2t3aXNlIG9yIGNvdW50ZXJjbG9ja3dpc2UpXG4gICAgY29uc3QgY2xvY2t3aXNlRGlzdGFuY2UgPSAoZW5kSW5kZXggLSBzdGFydEluZGV4ICsgNCkgJSA0O1xuICAgIGNvbnN0IGNvdW50ZXJDbG9ja3dpc2VEaXN0YW5jZSA9IChzdGFydEluZGV4IC0gZW5kSW5kZXggKyA0KSAlIDQ7XG5cbiAgICAvLyBEZXRlcm1pbmUgaGFuZCBwYXRoIGRpcmVjdGlvbiAoc2hvcnRlciBkaXN0YW5jZSB3aW5zKVxuICAgIGNvbnN0IGhhbmRQYXRoSXNDbG9ja3dpc2UgPSBjbG9ja3dpc2VEaXN0YW5jZSA8IGNvdW50ZXJDbG9ja3dpc2VEaXN0YW5jZTtcblxuICAgIC8vIEZvciBQUk86IHByb3Agcm90YXRpb24gbWF0Y2hlcyBoYW5kIHBhdGggZGlyZWN0aW9uXG4gICAgLy8gRm9yIEFOVEk6IHByb3Agcm90YXRpb24gb3Bwb3NlcyBoYW5kIHBhdGggZGlyZWN0aW9uXG4gICAgbGV0IHJlc3VsdDogUm90YXRpb25EaXJlY3Rpb247XG4gICAgaWYgKG1vdGlvblR5cGUgPT09IE1vdGlvblR5cGUuUFJPKSB7XG4gICAgICByZXN1bHQgPSBoYW5kUGF0aElzQ2xvY2t3aXNlXG4gICAgICAgID8gUm90YXRpb25EaXJlY3Rpb24uQ0xPQ0tXSVNFXG4gICAgICAgIDogUm90YXRpb25EaXJlY3Rpb24uQ09VTlRFUl9DTE9DS1dJU0U7XG4gICAgfSBlbHNlIGlmIChtb3Rpb25UeXBlID09PSBNb3Rpb25UeXBlLkFOVEkpIHtcbiAgICAgIHJlc3VsdCA9IGhhbmRQYXRoSXNDbG9ja3dpc2VcbiAgICAgICAgPyBSb3RhdGlvbkRpcmVjdGlvbi5DT1VOVEVSX0NMT0NLV0lTRVxuICAgICAgICA6IFJvdGF0aW9uRGlyZWN0aW9uLkNMT0NLV0lTRTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gUm90YXRpb25EaXJlY3Rpb24uQ0xPQ0tXSVNFOyAvLyBEZWZhdWx0IGZvciBvdGhlciBtb3Rpb24gdHlwZXNcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGDwn5SEIFJvdGF0aW9uIGRpcmVjdGlvbiBmb3IgJHtzdGFydExvY2F0aW9ufeKGkiR7ZW5kTG9jYXRpb259ICgke21vdGlvblR5cGV9KTogJHtyZXN1bHR9YFxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gTm8gbW9yZSBzdHJpbmctdG8tZW51bSBtYXBwaW5nIG5lZWRlZCAtIHdlIHVzZSBlbnVtcyBkaXJlY3RseSFcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBNb3Rpb25UZXN0UGFyYW1zIHRvIFByb3BBdHRyaWJ1dGVzXG4gIGNvbnZlcnRNb3Rpb25UZXN0UGFyYW1zVG9Qcm9wQXR0cmlidXRlcyhwYXJhbXM6IE1vdGlvblRlc3RQYXJhbXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRMb2NhdGlvbjogcGFyYW1zLnN0YXJ0TG9jYXRpb24sXG4gICAgICBlbmRMb2NhdGlvbjogcGFyYW1zLmVuZExvY2F0aW9uLFxuICAgICAgbW90aW9uVHlwZTogcGFyYW1zLm1vdGlvblR5cGUgYXMgTW90aW9uVHlwZSxcbiAgICAgIHR1cm5zOiBwYXJhbXMudHVybnMsXG4gICAgICByb3RhdGlvbkRpcmVjdGlvbjogcGFyYW1zLnJvdGF0aW9uRGlyZWN0aW9uIGFzIFJvdGF0aW9uRGlyZWN0aW9uLFxuICAgICAgc3RhcnRPcmllbnRhdGlvbjogcGFyYW1zLnN0YXJ0T3JpZW50YXRpb24gYXMgT3JpZW50YXRpb24sXG4gICAgICBlbmRPcmllbnRhdGlvbjogcGFyYW1zLmVuZE9yaWVudGF0aW9uIGFzIE9yaWVudGF0aW9uLFxuICAgIH07XG4gIH1cblxuICAvLyBDcmVhdGUgZGVmYXVsdCBtb3Rpb24gcGFyYW1ldGVyc1xuICBjcmVhdGVEZWZhdWx0UGFyYW1zKCk6IE1vdGlvblRlc3RQYXJhbXMge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydExvY2F0aW9uOiBMb2NhdGlvbi5OT1JUSCxcbiAgICAgIGVuZExvY2F0aW9uOiBMb2NhdGlvbi5FQVNULFxuICAgICAgbW90aW9uVHlwZTogTW90aW9uVHlwZS5QUk8sXG4gICAgICB0dXJuczogMCxcbiAgICAgIHJvdGF0aW9uRGlyZWN0aW9uOiBSb3RhdGlvbkRpcmVjdGlvbi5DTE9DS1dJU0UsXG4gICAgICBzdGFydE9yaWVudGF0aW9uOiBPcmllbnRhdGlvbi5JTixcbiAgICAgIGVuZE9yaWVudGF0aW9uOiBPcmllbnRhdGlvbi5JTixcbiAgICB9O1xuICB9XG5cbiAgLy8gVXBkYXRlIG1vdGlvbiB0eXBlIHdoZW4gbG9jYXRpb25zIGNoYW5nZVxuICB1cGRhdGVNb3Rpb25UeXBlRm9yTG9jYXRpb25zKHBhcmFtczogTW90aW9uVGVzdFBhcmFtcyk6IE1vdGlvblRlc3RQYXJhbXMge1xuICAgIGNvbnN0IGF2YWlsYWJsZVR5cGVzID0gdGhpcy5nZXRBdmFpbGFibGVNb3Rpb25UeXBlcyhcbiAgICAgIHBhcmFtcy5zdGFydExvY2F0aW9uLFxuICAgICAgcGFyYW1zLmVuZExvY2F0aW9uXG4gICAgKTtcblxuICAgIC8vIElmIGN1cnJlbnQgbW90aW9uIHR5cGUgaXMgbm90IGF2YWlsYWJsZSwgc3dpdGNoIHRvIHRoZSBmaXJzdCBhdmFpbGFibGVcbiAgICBpZiAoIWF2YWlsYWJsZVR5cGVzLmluY2x1ZGVzKHBhcmFtcy5tb3Rpb25UeXBlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICBtb3Rpb25UeXBlOiBhdmFpbGFibGVUeXBlc1swXSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8vIENvbnZlcnQgTW90aW9uVGVzdFBhcmFtcyB0byBNb3Rpb25EYXRhIC0gbm8gbWFwcGluZyBuZWVkZWQsIGFscmVhZHkgZW51bXMhXG4gIGNvbnZlcnRUb01vdGlvbkRhdGEoXG4gICAgcGFyYW1zOiBNb3Rpb25UZXN0UGFyYW1zLFxuICAgIGNvbG9yOiBNb3Rpb25Db2xvclxuICApOiBNb3Rpb25EYXRhIHtcbiAgICByZXR1cm4gY3JlYXRlTW90aW9uRGF0YSh7XG4gICAgICBtb3Rpb25UeXBlOiBwYXJhbXMubW90aW9uVHlwZSxcbiAgICAgIHJvdGF0aW9uRGlyZWN0aW9uOiBwYXJhbXMucm90YXRpb25EaXJlY3Rpb24sXG4gICAgICBzdGFydExvY2F0aW9uOiBwYXJhbXMuc3RhcnRMb2NhdGlvbixcbiAgICAgIGVuZExvY2F0aW9uOiBwYXJhbXMuZW5kTG9jYXRpb24sXG4gICAgICB0dXJuczogdHlwZW9mIHBhcmFtcy50dXJucyA9PT0gXCJzdHJpbmdcIiA/IC0wLjUgOiBwYXJhbXMudHVybnMsIC8vIEhhbmRsZSBcImZsXCIgZmxvYXQgdHVybnNcbiAgICAgIHN0YXJ0T3JpZW50YXRpb246IHBhcmFtcy5zdGFydE9yaWVudGF0aW9uLFxuICAgICAgZW5kT3JpZW50YXRpb246IHBhcmFtcy5lbmRPcmllbnRhdGlvbixcbiAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgIGNvbG9yLFxuICAgIH0pO1xuICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiQUFBQTtBQUFBLEVBQ0U7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsT0FDSztBQUVQLFNBQVMsd0JBQXdCO0FBaUIxQixhQUFNLHVCQUEwRDtBQUFBO0FBQUEsRUFFckUsY0FBYyxlQUF5QixhQUFtQztBQUN4RSxRQUFJLGtCQUFrQixhQUFhO0FBQ2pDLGFBQU8sV0FBVztBQUFBLElBQ3BCO0FBR0EsVUFBTSxZQUFZO0FBQUEsTUFDaEIsQ0FBQyxTQUFTLE9BQU8sU0FBUyxLQUFLO0FBQUEsTUFDL0IsQ0FBQyxTQUFTLE9BQU8sU0FBUyxLQUFLO0FBQUEsTUFDL0IsQ0FBQyxTQUFTLE1BQU0sU0FBUyxJQUFJO0FBQUEsTUFDN0IsQ0FBQyxTQUFTLE1BQU0sU0FBUyxJQUFJO0FBQUEsTUFDN0IsQ0FBQyxTQUFTLFdBQVcsU0FBUyxTQUFTO0FBQUEsTUFDdkMsQ0FBQyxTQUFTLFdBQVcsU0FBUyxTQUFTO0FBQUEsTUFDdkMsQ0FBQyxTQUFTLFdBQVcsU0FBUyxTQUFTO0FBQUEsTUFDdkMsQ0FBQyxTQUFT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
