import { createPictographData } from "/src/lib/domain/PictographData.ts";
import { Letter } from "/src/lib/domain/index.ts";
import { MotionColor } from "/src/lib/domain/enums.ts";
import { createMotionData } from "/src/lib/domain/MotionData.ts";
import { pictographDataDebugger } from "/src/lib/services/debug/PictographDataDebugger.ts";
export class PictographTransformationService {
  constructor(enumMappingService) {
    this.enumMappingService = enumMappingService;
  }
  /**
   * Convert CSV row to PictographData - main public interface
   */
  convertCsvRowToPictographData(row, gridMode, index) {
    try {
      const identifier = `${row.letter || "unknown"}_${index || Date.now()}`;
      pictographDataDebugger.startTrace(identifier);
      pictographDataDebugger.addTraceStep(identifier, "CSV_INPUT", row);
      const result = this.createPictographFromCSVRow(row, gridMode);
      if (result) {
        pictographDataDebugger.addTraceStep(
          identifier,
          "PICTOGRAPH_CREATED",
          result
        );
        pictographDataDebugger.getPictographDebugInfo(result, row);
      } else {
        pictographDataDebugger.addTraceStep(
          identifier,
          "CONVERSION_FAILED",
          null,
          ["Failed to create pictograph"]
        );
      }
      return result;
    } catch (error) {
      console.warn(
        `âš ï¸ Failed to convert CSV row ${index || "unknown"} to pictograph:`,
        error
      );
      return null;
    }
  }
  /**
   * Create PictographData from CSV row with comprehensive error handling
   */
  createPictographFromCSVRow(row, _gridMode) {
    try {
      const validation = this.validateCSVRow(row);
      if (!validation.isValid) {
        console.warn("âš ï¸ CSV row validation failed:", validation.errors);
        return null;
      }
      const letter = row.letter;
      if (!letter) {
        console.warn("âš ï¸ Missing letter in CSV row");
        return null;
      }
      if (letter === "G" || letter === "g") {
        console.log(`ðŸ”§ [G DEBUG] CSV row data:`, {
          letter: row.letter,
          blueStartLocation: row.blueStartLocation || row.blueStartLoc,
          blueEndLocation: row.blueEndLocation || row.blueendLocation,
          redStartLocation: row.redStartLocation || row.redStartLoc,
          redEndLocation: row.redEndLocation || row.redendLocation,
          fullRow: row
        });
      }
      const blueMotion = createMotionData({
        motionType: this.enumMappingService.mapMotionType(row.blueMotionType),
        rotationDirection: this.enumMappingService.mapRotationDirection(
          row.blueRotationDirection
        ),
        startLocation: this.enumMappingService.mapLocation(
          row.blueStartLocation || row.blueStartLoc
        ),
        endLocation: this.enumMappingService.mapLocation(
          row.blueEndLocation || row.blueendLocation
        ),
        turns: 0,
        isVisible: true,
        color: MotionColor.BLUE
        // âœ… Explicitly set blue color
      });
      const redMotion = createMotionData({
        motionType: this.enumMappingService.mapMotionType(row.redMotionType),
        rotationDirection: this.enumMappingService.mapRotationDirection(
          row.redRotationDirection
        ),
        startLocation: this.enumMappingService.mapLocation(
          row.redStartLocation || row.redStartLoc
        ),
        endLocation: this.enumMappingService.mapLocation(
          row.redEndLocation || row.redendLocation
        ),
        turns: 0,
        isVisible: true,
        color: MotionColor.RED
        // âœ… Explicitly set red color
      });
      return createPictographData({
        letter,
        motions: {
          blue: blueMotion,
          red: redMotion
        }
      });
    } catch (error) {
      console.warn("âš ï¸ Failed to create pictograph from CSV row:", error);
      return null;
    }
  }
  /**
   * Validate CSV row has required fields
   */
  validateCSVRow(row) {
    const errors = [];
    const requiredFields = [
      "letter",
      "startPosition",
      "endPosition",
      "blueMotionType",
      "redMotionType"
    ];
    for (const field of requiredFields) {
      if (!row[field] || row[field].trim() === "") {
        errors.push(`Missing required field: ${field}`);
      }
    }
    const blueStartLoc = row.blueStartLocation || row.blueStartLoc;
    const blueEndLoc = row.blueEndLocation || row.blueendLocation;
    const redStartLoc = row.redStartLocation || row.redStartLoc;
    const redEndLoc = row.redEndLocation || row.redendLocation;
    if (!blueStartLoc) errors.push("Missing blue start location");
    if (!blueEndLoc) errors.push("Missing blue end location");
    if (!redStartLoc) errors.push("Missing red start location");
    if (!redEndLoc) errors.push("Missing red end location");
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  /**
   * Batch convert multiple CSV rows to PictographData
   */
  convertMultipleRows(rows, gridMode) {
    const successful = [];
    const failed = [];
    rows.forEach((row, index) => {
      try {
        const pictograph = this.convertCsvRowToPictographData(
          row,
          gridMode,
          index
        );
        if (pictograph) {
          successful.push(pictograph);
        } else {
          failed.push({
            index,
            row,
            error: "Conversion returned null"
          });
        }
      } catch (error) {
        failed.push({
          index,
          row,
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
    return { successful, failed };
  }
  /**
   * Get transformation statistics for debugging
   */
  getTransformationStats(rows, _gridMode) {
    const stats = {
      totalRows: rows.length,
      validRows: 0,
      invalidRows: 0,
      validationErrors: []
    };
    rows.forEach((row, index) => {
      const validation = this.validateCSVRow(row);
      if (validation.isValid) {
        stats.validRows++;
      } else {
        stats.invalidRows++;
        stats.validationErrors.push({
          index,
          errors: validation.errors
        });
      }
    });
    return stats;
  }
  /**
   * Create pictograph with custom metadata
   */
  createPictographWithMetadata(row, gridMode, _additionalMetadata = {}) {
    const pictograph = this.createPictographFromCSVRow(row, gridMode);
    if (!pictograph) return null;
    return {
      ...pictograph
    };
  }
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3NlcnZpY2VzL2ltcGxlbWVudGF0aW9ucy9kYXRhL1BpY3RvZ3JhcGhUcmFuc2Zvcm1hdGlvblNlcnZpY2UudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogUGljdG9ncmFwaFRyYW5zZm9ybWF0aW9uU2VydmljZSAtIENlbnRyYWxpemVkIHBpY3RvZ3JhcGggZGF0YSB0cmFuc2Zvcm1hdGlvblxuICpcbiAqIEhhbmRsZXMgY29udmVyc2lvbiBmcm9tIENTViByb3dzIHRvIFBpY3RvZ3JhcGhEYXRhIG9iamVjdHMgdXNpbmcgc2hhcmVkIHV0aWxpdGllcy5cbiAqIEVsaW1pbmF0ZXMgZHVwbGljYXRpb24gb2YgdHJhbnNmb3JtYXRpb24gbG9naWMgYWNyb3NzIHNlcnZpY2VzLlxuICovXG5cbmltcG9ydCB0eXBlIHsgUGljdG9ncmFwaERhdGEgfSBmcm9tIFwiJGxpYi9kb21haW4vUGljdG9ncmFwaERhdGFcIjtcbmltcG9ydCB7IGNyZWF0ZVBpY3RvZ3JhcGhEYXRhIH0gZnJvbSBcIiRsaWIvZG9tYWluL1BpY3RvZ3JhcGhEYXRhXCI7XG5cbmltcG9ydCB7IExldHRlciB9IGZyb20gXCIkbGliL2RvbWFpblwiO1xuaW1wb3J0IHsgTW90aW9uQ29sb3IgfSBmcm9tIFwiJGxpYi9kb21haW4vZW51bXNcIjtcbmltcG9ydCB7IGNyZWF0ZU1vdGlvbkRhdGEgfSBmcm9tIFwiJGxpYi9kb21haW4vTW90aW9uRGF0YVwiO1xuaW1wb3J0IHsgcGljdG9ncmFwaERhdGFEZWJ1Z2dlciB9IGZyb20gXCIuLi8uLi9kZWJ1Zy9QaWN0b2dyYXBoRGF0YURlYnVnZ2VyXCI7XG5pbXBvcnQgdHlwZSB7IElFbnVtTWFwcGluZ1NlcnZpY2UgfSBmcm9tIFwiLi4vLi4vaW50ZXJmYWNlcy9hcHBsaWNhdGlvbi1pbnRlcmZhY2VzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVBpY3RvZ3JhcGhUcmFuc2Zvcm1hdGlvblNlcnZpY2Uge1xuICBjb252ZXJ0Q3N2Um93VG9QaWN0b2dyYXBoRGF0YShcbiAgICByb3c6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gICAgZ3JpZE1vZGU6IHN0cmluZyxcbiAgICBpbmRleD86IG51bWJlclxuICApOiBQaWN0b2dyYXBoRGF0YSB8IG51bGw7XG5cbiAgY3JlYXRlUGljdG9ncmFwaEZyb21DU1ZSb3coXG4gICAgcm93OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGdyaWRNb2RlOiBzdHJpbmdcbiAgKTogUGljdG9ncmFwaERhdGEgfCBudWxsO1xuXG4gIHZhbGlkYXRlQ1NWUm93KHJvdzogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IHtcbiAgICBpc1ZhbGlkOiBib29sZWFuO1xuICAgIGVycm9yczogc3RyaW5nW107XG4gIH07XG59XG5cbmV4cG9ydCBjbGFzcyBQaWN0b2dyYXBoVHJhbnNmb3JtYXRpb25TZXJ2aWNlXG4gIGltcGxlbWVudHMgSVBpY3RvZ3JhcGhUcmFuc2Zvcm1hdGlvblNlcnZpY2VcbntcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbnVtTWFwcGluZ1NlcnZpY2U6IElFbnVtTWFwcGluZ1NlcnZpY2UpIHt9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgQ1NWIHJvdyB0byBQaWN0b2dyYXBoRGF0YSAtIG1haW4gcHVibGljIGludGVyZmFjZVxuICAgKi9cbiAgY29udmVydENzdlJvd1RvUGljdG9ncmFwaERhdGEoXG4gICAgcm93OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGdyaWRNb2RlOiBzdHJpbmcsXG4gICAgaW5kZXg/OiBudW1iZXJcbiAgKTogUGljdG9ncmFwaERhdGEgfCBudWxsIHtcbiAgICB0cnkge1xuICAgICAgLy8gU3RhcnQgZGVidWdnaW5nIHRyYWNlXG4gICAgICBjb25zdCBpZGVudGlmaWVyID0gYCR7cm93LmxldHRlciB8fCBcInVua25vd25cIn1fJHtpbmRleCB8fCBEYXRlLm5vdygpfWA7XG4gICAgICBwaWN0b2dyYXBoRGF0YURlYnVnZ2VyLnN0YXJ0VHJhY2UoaWRlbnRpZmllcik7XG4gICAgICBwaWN0b2dyYXBoRGF0YURlYnVnZ2VyLmFkZFRyYWNlU3RlcChpZGVudGlmaWVyLCBcIkNTVl9JTlBVVFwiLCByb3cpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZVBpY3RvZ3JhcGhGcm9tQ1NWUm93KHJvdywgZ3JpZE1vZGUpO1xuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhRGVidWdnZXIuYWRkVHJhY2VTdGVwKFxuICAgICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgICAgXCJQSUNUT0dSQVBIX0NSRUFURURcIixcbiAgICAgICAgICByZXN1bHRcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBHZXQgY29tcHJlaGVuc2l2ZSBkZWJ1ZyBpbmZvIC0gYnV0IGRvbid0IG1vZGlmeSB0aGUgcmVzdWx0XG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhRGVidWdnZXIuZ2V0UGljdG9ncmFwaERlYnVnSW5mbyhyZXN1bHQsIHJvdyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaWN0b2dyYXBoRGF0YURlYnVnZ2VyLmFkZFRyYWNlU3RlcChcbiAgICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICAgIFwiQ09OVkVSU0lPTl9GQUlMRURcIixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIFtcIkZhaWxlZCB0byBjcmVhdGUgcGljdG9ncmFwaFwiXVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGDimqDvuI8gRmFpbGVkIHRvIGNvbnZlcnQgQ1NWIHJvdyAke2luZGV4IHx8IFwidW5rbm93blwifSB0byBwaWN0b2dyYXBoOmAsXG4gICAgICAgIGVycm9yXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBQaWN0b2dyYXBoRGF0YSBmcm9tIENTViByb3cgd2l0aCBjb21wcmVoZW5zaXZlIGVycm9yIGhhbmRsaW5nXG4gICAqL1xuICBjcmVhdGVQaWN0b2dyYXBoRnJvbUNTVlJvdyhcbiAgICByb3c6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gICAgX2dyaWRNb2RlOiBzdHJpbmdcbiAgKTogUGljdG9ncmFwaERhdGEgfCBudWxsIHtcbiAgICB0cnkge1xuICAgICAgLy8gVmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZUNTVlJvdyhyb3cpO1xuICAgICAgaWYgKCF2YWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIENTViByb3cgdmFsaWRhdGlvbiBmYWlsZWQ6XCIsIHZhbGlkYXRpb24uZXJyb3JzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxldHRlciA9IHJvdy5sZXR0ZXI7XG4gICAgICBpZiAoIWxldHRlcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gTWlzc2luZyBsZXR0ZXIgaW4gQ1NWIHJvd1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIERFQlVHOiBMb2cgQ1NWIHJvdyBkYXRhIGZvciBHIHBpY3RvZ3JhcGhzXG4gICAgICBpZiAobGV0dGVyID09PSBcIkdcIiB8fCBsZXR0ZXIgPT09IFwiZ1wiKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SnIFtHIERFQlVHXSBDU1Ygcm93IGRhdGE6YCwge1xuICAgICAgICAgIGxldHRlcjogcm93LmxldHRlcixcbiAgICAgICAgICBibHVlU3RhcnRMb2NhdGlvbjogcm93LmJsdWVTdGFydExvY2F0aW9uIHx8IHJvdy5ibHVlU3RhcnRMb2MsXG4gICAgICAgICAgYmx1ZUVuZExvY2F0aW9uOiByb3cuYmx1ZUVuZExvY2F0aW9uIHx8IHJvdy5ibHVlZW5kTG9jYXRpb24sXG4gICAgICAgICAgcmVkU3RhcnRMb2NhdGlvbjogcm93LnJlZFN0YXJ0TG9jYXRpb24gfHwgcm93LnJlZFN0YXJ0TG9jLFxuICAgICAgICAgIHJlZEVuZExvY2F0aW9uOiByb3cucmVkRW5kTG9jYXRpb24gfHwgcm93LnJlZGVuZExvY2F0aW9uLFxuICAgICAgICAgIGZ1bGxSb3c6IHJvdyxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBibHVlIG1vdGlvbiBkYXRhXG4gICAgICBjb25zdCBibHVlTW90aW9uID0gY3JlYXRlTW90aW9uRGF0YSh7XG4gICAgICAgIG1vdGlvblR5cGU6IHRoaXMuZW51bU1hcHBpbmdTZXJ2aWNlLm1hcE1vdGlvblR5cGUocm93LmJsdWVNb3Rpb25UeXBlKSxcbiAgICAgICAgcm90YXRpb25EaXJlY3Rpb246IHRoaXMuZW51bU1hcHBpbmdTZXJ2aWNlLm1hcFJvdGF0aW9uRGlyZWN0aW9uKFxuICAgICAgICAgIHJvdy5ibHVlUm90YXRpb25EaXJlY3Rpb25cbiAgICAgICAgKSxcbiAgICAgICAgc3RhcnRMb2NhdGlvbjogdGhpcy5lbnVtTWFwcGluZ1NlcnZpY2UubWFwTG9jYXRpb24oXG4gICAgICAgICAgcm93LmJsdWVTdGFydExvY2F0aW9uIHx8IHJvdy5ibHVlU3RhcnRMb2NcbiAgICAgICAgKSxcbiAgICAgICAgZW5kTG9jYXRpb246IHRoaXMuZW51bU1hcHBpbmdTZXJ2aWNlLm1hcExvY2F0aW9uKFxuICAgICAgICAgIHJvdy5ibHVlRW5kTG9jYXRpb24gfHwgcm93LmJsdWVlbmRMb2NhdGlvblxuICAgICAgICApLFxuICAgICAgICB0dXJuczogMCxcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICBjb2xvcjogTW90aW9uQ29sb3IuQkxVRSwgLy8g4pyFIEV4cGxpY2l0bHkgc2V0IGJsdWUgY29sb3JcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgcmVkIG1vdGlvbiBkYXRhXG4gICAgICBjb25zdCByZWRNb3Rpb24gPSBjcmVhdGVNb3Rpb25EYXRhKHtcbiAgICAgICAgbW90aW9uVHlwZTogdGhpcy5lbnVtTWFwcGluZ1NlcnZpY2UubWFwTW90aW9uVHlwZShyb3cucmVkTW90aW9uVHlwZSksXG4gICAgICAgIHJvdGF0aW9uRGlyZWN0aW9uOiB0aGlzLmVudW1NYXBwaW5nU2VydmljZS5tYXBSb3RhdGlvbkRpcmVjdGlvbihcbiAgICAgICAgICByb3cucmVkUm90YXRpb25EaXJlY3Rpb25cbiAgICAgICAgKSxcbiAgICAgICAgc3RhcnRMb2NhdGlvbjogdGhpcy5lbnVtTWFwcGluZ1NlcnZpY2UubWFwTG9jYXRpb24oXG4gICAgICAgICAgcm93LnJlZFN0YXJ0TG9jYXRpb24gfHwgcm93LnJlZFN0YXJ0TG9jXG4gICAgICAgICksXG4gICAgICAgIGVuZExvY2F0aW9uOiB0aGlzLmVudW1NYXBwaW5nU2VydmljZS5tYXBMb2NhdGlvbihcbiAgICAgICAgICByb3cucmVkRW5kTG9jYXRpb24gfHwgcm93LnJlZGVuZExvY2F0aW9uXG4gICAgICAgICksXG4gICAgICAgIHR1cm5zOiAwLFxuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIGNvbG9yOiBNb3Rpb25Db2xvci5SRUQsIC8vIOKchSBFeHBsaWNpdGx5IHNldCByZWQgY29sb3JcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgcGljdG9ncmFwaCBkYXRhXG4gICAgICByZXR1cm4gY3JlYXRlUGljdG9ncmFwaERhdGEoe1xuICAgICAgICBsZXR0ZXI6IGxldHRlciBhcyBMZXR0ZXIsXG4gICAgICAgIG1vdGlvbnM6IHtcbiAgICAgICAgICBibHVlOiBibHVlTW90aW9uLFxuICAgICAgICAgIHJlZDogcmVkTW90aW9uLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBGYWlsZWQgdG8gY3JlYXRlIHBpY3RvZ3JhcGggZnJvbSBDU1Ygcm93OlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgQ1NWIHJvdyBoYXMgcmVxdWlyZWQgZmllbGRzXG4gICAqL1xuICB2YWxpZGF0ZUNTVlJvdyhyb3c6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiB7XG4gICAgaXNWYWxpZDogYm9vbGVhbjtcbiAgICBlcnJvcnM6IHN0cmluZ1tdO1xuICB9IHtcbiAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgcmVxdWlyZWRGaWVsZHMgPSBbXG4gICAgICBcImxldHRlclwiLFxuICAgICAgXCJzdGFydFBvc2l0aW9uXCIsXG4gICAgICBcImVuZFBvc2l0aW9uXCIsXG4gICAgICBcImJsdWVNb3Rpb25UeXBlXCIsXG4gICAgICBcInJlZE1vdGlvblR5cGVcIixcbiAgICBdO1xuXG4gICAgLy8gQ2hlY2sgcmVxdWlyZWQgZmllbGRzXG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiByZXF1aXJlZEZpZWxkcykge1xuICAgICAgaWYgKCFyb3dbZmllbGRdIHx8IHJvd1tmaWVsZF0udHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGBNaXNzaW5nIHJlcXVpcmVkIGZpZWxkOiAke2ZpZWxkfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGxvY2F0aW9uIGZpZWxkcyAod2l0aCBmYWxsYmFja3MpXG4gICAgY29uc3QgYmx1ZVN0YXJ0TG9jID0gcm93LmJsdWVTdGFydExvY2F0aW9uIHx8IHJvdy5ibHVlU3RhcnRMb2M7XG4gICAgY29uc3QgYmx1ZUVuZExvYyA9IHJvdy5ibHVlRW5kTG9jYXRpb24gfHwgcm93LmJsdWVlbmRMb2NhdGlvbjtcbiAgICBjb25zdCByZWRTdGFydExvYyA9IHJvdy5yZWRTdGFydExvY2F0aW9uIHx8IHJvdy5yZWRTdGFydExvYztcbiAgICBjb25zdCByZWRFbmRMb2MgPSByb3cucmVkRW5kTG9jYXRpb24gfHwgcm93LnJlZGVuZExvY2F0aW9uO1xuXG4gICAgaWYgKCFibHVlU3RhcnRMb2MpIGVycm9ycy5wdXNoKFwiTWlzc2luZyBibHVlIHN0YXJ0IGxvY2F0aW9uXCIpO1xuICAgIGlmICghYmx1ZUVuZExvYykgZXJyb3JzLnB1c2goXCJNaXNzaW5nIGJsdWUgZW5kIGxvY2F0aW9uXCIpO1xuICAgIGlmICghcmVkU3RhcnRMb2MpIGVycm9ycy5wdXNoKFwiTWlzc2luZyByZWQgc3RhcnQgbG9jYXRpb25cIik7XG4gICAgaWYgKCFyZWRFbmRMb2MpIGVycm9ycy5wdXNoKFwiTWlzc2luZyByZWQgZW5kIGxvY2F0aW9uXCIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgICBlcnJvcnMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXRjaCBjb252ZXJ0IG11bHRpcGxlIENTViByb3dzIHRvIFBpY3RvZ3JhcGhEYXRhXG4gICAqL1xuICBjb252ZXJ0TXVsdGlwbGVSb3dzKFxuICAgIHJvd3M6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5bXSxcbiAgICBncmlkTW9kZTogc3RyaW5nXG4gICk6IHtcbiAgICBzdWNjZXNzZnVsOiBQaWN0b2dyYXBoRGF0YVtdO1xuICAgIGZhaWxlZDogQXJyYXk8e1xuICAgICAgaW5kZXg6IG51bWJlcjtcbiAgICAgIHJvdzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICAgIGVycm9yOiBzdHJpbmc7XG4gICAgfT47XG4gIH0ge1xuICAgIGNvbnN0IHN1Y2Nlc3NmdWw6IFBpY3RvZ3JhcGhEYXRhW10gPSBbXTtcbiAgICBjb25zdCBmYWlsZWQ6IEFycmF5PHtcbiAgICAgIGluZGV4OiBudW1iZXI7XG4gICAgICByb3c6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgICBlcnJvcjogc3RyaW5nO1xuICAgIH0+ID0gW107XG5cbiAgICByb3dzLmZvckVhY2goKHJvdywgaW5kZXgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBpY3RvZ3JhcGggPSB0aGlzLmNvbnZlcnRDc3ZSb3dUb1BpY3RvZ3JhcGhEYXRhKFxuICAgICAgICAgIHJvdyxcbiAgICAgICAgICBncmlkTW9kZSxcbiAgICAgICAgICBpbmRleFxuICAgICAgICApO1xuICAgICAgICBpZiAocGljdG9ncmFwaCkge1xuICAgICAgICAgIHN1Y2Nlc3NmdWwucHVzaChwaWN0b2dyYXBoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmYWlsZWQucHVzaCh7XG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgIGVycm9yOiBcIkNvbnZlcnNpb24gcmV0dXJuZWQgbnVsbFwiLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBmYWlsZWQucHVzaCh7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcm93LFxuICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7IHN1Y2Nlc3NmdWwsIGZhaWxlZCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0cmFuc2Zvcm1hdGlvbiBzdGF0aXN0aWNzIGZvciBkZWJ1Z2dpbmdcbiAgICovXG4gIGdldFRyYW5zZm9ybWF0aW9uU3RhdHMoXG4gICAgcm93czogUmVjb3JkPHN0cmluZywgc3RyaW5nPltdLFxuICAgIF9ncmlkTW9kZTogc3RyaW5nXG4gICk6IHtcbiAgICB0b3RhbFJvd3M6IG51bWJlcjtcbiAgICB2YWxpZFJvd3M6IG51bWJlcjtcbiAgICBpbnZhbGlkUm93czogbnVtYmVyO1xuICAgIHZhbGlkYXRpb25FcnJvcnM6IEFycmF5PHsgaW5kZXg6IG51bWJlcjsgZXJyb3JzOiBzdHJpbmdbXSB9PjtcbiAgfSB7XG4gICAgY29uc3Qgc3RhdHMgPSB7XG4gICAgICB0b3RhbFJvd3M6IHJvd3MubGVuZ3RoLFxuICAgICAgdmFsaWRSb3dzOiAwLFxuICAgICAgaW52YWxpZFJvd3M6IDAsXG4gICAgICB2YWxpZGF0aW9uRXJyb3JzOiBbXSBhcyBBcnJheTx7IGluZGV4OiBudW1iZXI7IGVycm9yczogc3RyaW5nW10gfT4sXG4gICAgfTtcblxuICAgIHJvd3MuZm9yRWFjaCgocm93LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVDU1ZSb3cocm93KTtcbiAgICAgIGlmICh2YWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgc3RhdHMudmFsaWRSb3dzKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0cy5pbnZhbGlkUm93cysrO1xuICAgICAgICBzdGF0cy52YWxpZGF0aW9uRXJyb3JzLnB1c2goe1xuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIGVycm9yczogdmFsaWRhdGlvbi5lcnJvcnMsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0YXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBwaWN0b2dyYXBoIHdpdGggY3VzdG9tIG1ldGFkYXRhXG4gICAqL1xuICBjcmVhdGVQaWN0b2dyYXBoV2l0aE1ldGFkYXRhKFxuICAgIHJvdzogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgICBncmlkTW9kZTogc3RyaW5nLFxuICAgIF9hZGRpdGlvbmFsTWV0YWRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge31cbiAgKTogUGljdG9ncmFwaERhdGEgfCBudWxsIHtcbiAgICBjb25zdCBwaWN0b2dyYXBoID0gdGhpcy5jcmVhdGVQaWN0b2dyYXBoRnJvbUNTVlJvdyhyb3csIGdyaWRNb2RlKTtcblxuICAgIGlmICghcGljdG9ncmFwaCkgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGljdG9ncmFwaCxcbiAgICB9O1xuICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiQUFRQSxTQUFTLDRCQUE0QjtBQUVyQyxTQUFTLGNBQWM7QUFDdkIsU0FBUyxtQkFBbUI7QUFDNUIsU0FBUyx3QkFBd0I7QUFDakMsU0FBUyw4QkFBOEI7QUFxQmhDLGFBQU0sZ0NBRWI7QUFBQSxFQUNFLFlBQW9CLG9CQUF5QztBQUF6QztBQUFBLEVBQTBDO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLOUQsOEJBQ0UsS0FDQSxVQUNBLE9BQ3VCO0FBQ3ZCLFFBQUk7QUFFRixZQUFNLGFBQWEsR0FBRyxJQUFJLFVBQVUsU0FBUyxJQUFJLFNBQVMsS0FBSyxJQUFJLENBQUM7QUFDcEUsNkJBQXVCLFdBQVcsVUFBVTtBQUM1Qyw2QkFBdUIsYUFBYSxZQUFZLGFBQWEsR0FBRztBQUVoRSxZQUFNLFNBQVMsS0FBSywyQkFBMkIsS0FBSyxRQUFRO0FBRTVELFVBQUksUUFBUTtBQUNWLCtCQUF1QjtBQUFBLFVBQ3JCO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBR0EsK0JBQXVCLHVCQUF1QixRQUFRLEdBQUc7QUFBQSxNQUMzRCxPQUFPO0FBQ0wsK0JBQXVCO0FBQUEsVUFDckI7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0EsQ0FBQyw2QkFBNkI7QUFBQSxRQUNoQztBQUFBLE1BQ0Y7QUFFQSxhQUFPO0FBQUEsSUFDVCxTQUFTLE9BQU87QUFDZCxjQUFRO0FBQUEsUUFDTixnQ0FBZ0MsU0FBUyxTQUFTO0FBQUEsUUFDbEQ7QUFBQSxNQUNGO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFBQSxFQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSwyQkFDRSxLQUNBLFdBQ3VCO0FBQ3ZCLFFBQUk7QUFFRixZQUFNLGFBQWEsS0FBSyxlQUFlLEdBQUc7QUFDMUMsVUFBSSxDQUFDLFdBQVcsU0FBUztBQUN2QixnQkFBUSxLQUFLLGlDQUFpQyxXQUFXLE1BQU07QUFD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
