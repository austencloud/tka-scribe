import { resolve } from "/src/lib/services/bootstrap.ts";
import { endsWithBeta } from "/src/lib/utils/betaDetection.ts";
export class PictographDataDebugger {
  traces = /* @__PURE__ */ new Map();
  debugEnabled = true;
  /**
   * Enable or disable debugging
   */
  setDebugEnabled(enabled) {
    this.debugEnabled = enabled;
  }
  /**
   * Start a new data flow trace
   */
  startTrace(identifier) {
    if (!this.debugEnabled) return;
    this.traces.set(identifier, []);
  }
  /**
   * Add a step to the trace
   */
  addTraceStep(identifier, step, data, errors, warnings) {
    if (!this.debugEnabled) return;
    const trace = this.traces.get(identifier) || [];
    trace.push({
      step,
      timestamp: Date.now(),
      data: this.sanitizeDataForLogging(data),
      errors,
      warnings
    });
    this.traces.set(identifier, trace);
  }
  /**
   * Get complete debug info for a pictograph
   */
  getPictographDebugInfo(pictographData, csvRow) {
    const identifier = `${pictographData.letter}_${Date.now()}`;
    const endsWithBetaPosition = endsWithBeta(pictographData);
    const hasValidMotionData = this.validateMotionData(pictographData);
    const hasValidPropPlacementData = this.validatePropPlacementData(pictographData);
    const propLocations = {};
    const motionEndLocations = {};
    if (pictographData.motions) {
      Object.entries(pictographData.motions).forEach(([color, motionData]) => {
        if (motionData) {
          propLocations[color] = motionData.endLocation || "unknown";
        }
      });
    }
    if (pictographData.motions) {
      Object.entries(pictographData.motions).forEach(([color, motion]) => {
        motionEndLocations[color] = motion.endLocation || "unknown";
      });
    }
    const gridModeService = resolve("IGridModeDeriver");
    const gridMode = pictographData.motions?.blue && pictographData.motions?.red ? gridModeService.deriveGridMode(
      pictographData.motions.blue,
      pictographData.motions.red
    ) : "unknown";
    const debugInfo = {
      letter: pictographData.letter || "unknown",
      gridMode: gridMode.toString(),
      endsWithBeta: endsWithBetaPosition,
      hasValidMotionData,
      hasValidPropPlacementData,
      propLocations,
      motionEndLocations,
      dataFlowTrace: this.traces.get(identifier) || [],
      csvRowData: csvRow
    };
    this.logDebugInfo(debugInfo);
    return debugInfo;
  }
  /**
   * Validate motion data completeness
   */
  validateMotionData(pictographData) {
    if (!pictographData.motions) return false;
    return Object.values(pictographData.motions).every(
      (motion) => motion.startLocation && motion.endLocation && motion.motionType !== void 0 && motion.rotationDirection !== void 0
    );
  }
  /**
   * Validate prop data completeness
   */
  validatePropPlacementData(pictographData) {
    if (!pictographData.motions) return false;
    return Object.values(pictographData.motions).every(
      (motion) => motion && motion.propType && motion.endLocation && motion.color
    );
  }
  /**
   * Log comprehensive debug information
   */
  logDebugInfo(debugInfo) {
    if (!this.debugEnabled) return;
    console.group(`ðŸ” Pictograph Debug: ${debugInfo.letter}`);
    console.log("ðŸ“Š Overview:", {
      letter: debugInfo.letter,
      gridMode: debugInfo.gridMode,
      endsWithBeta: debugInfo.endsWithBeta,
      hasValidMotionData: debugInfo.hasValidMotionData,
      hasValidPropPlacementData: debugInfo.hasValidPropPlacementData
    });
    console.log("ðŸ“ Prop Locations:", debugInfo.propLocations);
    console.log("ðŸŽ¯ Motion End Locations:", debugInfo.motionEndLocations);
    if (debugInfo.csvRowData) {
      console.log("ðŸ“„ CSV Row Data:", debugInfo.csvRowData);
    }
    const mismatches = [];
    Object.entries(debugInfo.propLocations).forEach(([color, propLoc]) => {
      const motionEndLoc = debugInfo.motionEndLocations[color];
      if (propLoc !== motionEndLoc && propLoc !== "unknown" && motionEndLoc !== "unknown") {
        mismatches.push(
          `${color}: prop(${propLoc}) != motion(${motionEndLoc})`
        );
      }
    });
    if (mismatches.length > 0) {
      console.warn("âš ï¸ Location Mismatches:", mismatches);
    }
    if (debugInfo.dataFlowTrace.length > 0) {
      console.log("ðŸ”„ Data Flow Trace:");
      debugInfo.dataFlowTrace.forEach((trace, index) => {
        console.log(`  ${index + 1}. ${trace.step}`, trace.data);
        if (trace.warnings?.length) {
          console.warn(`     Warnings:`, trace.warnings);
        }
        if (trace.errors?.length) {
          console.error(`     Errors:`, trace.errors);
        }
      });
    }
    console.groupEnd();
  }
  /**
   * Sanitize data for logging to prevent circular references
   */
  sanitizeDataForLogging(data) {
    if (data === null || data === void 0) return data;
    if (typeof data === "object") {
      if (Array.isArray(data)) {
        return data.map((item) => this.sanitizeDataForLogging(item));
      }
      const sanitized = {};
      Object.entries(data).forEach(([key, value]) => {
        if (typeof value === "function") {
          sanitized[key] = "[Function]";
        } else if (typeof value === "object" && value !== null) {
          sanitized[key] = JSON.parse(JSON.stringify(value, null, 2));
        } else {
          sanitized[key] = value;
        }
      });
      return sanitized;
    }
    return data;
  }
  /**
   * Clear all traces (useful for cleanup)
   */
  clearTraces() {
    this.traces.clear();
  }
  /**
   * Export debug data as JSON for external analysis
   */
  exportDebugData() {
    const allTraces = {};
    this.traces.forEach((trace, identifier) => {
      allTraces[identifier] = trace;
    });
    return JSON.stringify(
      {
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        traces: allTraces
      },
      null,
      2
    );
  }
}
export const pictographDataDebugger = new PictographDataDebugger();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3NlcnZpY2VzL2RlYnVnL1BpY3RvZ3JhcGhEYXRhRGVidWdnZXIudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogUGljdG9ncmFwaERhdGFEZWJ1Z2dlciAtIENvbXByZWhlbnNpdmUgZGVidWdnaW5nIGZvciBwaWN0b2dyYXBoIGRhdGEgZmxvd1xuICpcbiAqIFRoaXMgc2VydmljZSBoZWxwcyB0cmFjZSBkYXRhIGZyb20gQ1NWIOKGkiBQaWN0b2dyYXBoRGF0YSDihpIgUHJvcFBsYWNlbWVudERhdGEgdG8gaWRlbnRpZnlcbiAqIHdoZXJlIGRhdGEgY29ycnVwdGlvbiBvciBtaXNzaW5nIGluZm9ybWF0aW9uIG9jY3Vycy5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7IFBpY3RvZ3JhcGhEYXRhIH0gZnJvbSBcIiRsaWIvZG9tYWluL1BpY3RvZ3JhcGhEYXRhXCI7XG5pbXBvcnQgeyByZXNvbHZlIH0gZnJvbSBcIiRsaWIvc2VydmljZXMvYm9vdHN0cmFwXCI7XG5pbXBvcnQgdHlwZSB7IElHcmlkTW9kZURlcml2ZXIgfSBmcm9tIFwiJGxpYi9zZXJ2aWNlcy9pbnRlcmZhY2VzL21vdmVtZW50L0lHcmlkTW9kZURlcml2ZXJcIjtcbmltcG9ydCB7IGVuZHNXaXRoQmV0YSB9IGZyb20gXCIkbGliL3V0aWxzL2JldGFEZXRlY3Rpb25cIjtcblxuZXhwb3J0IGludGVyZmFjZSBEYXRhRmxvd1RyYWNlIHtcbiAgc3RlcDogc3RyaW5nO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgZGF0YTogdW5rbm93bjtcbiAgZXJyb3JzPzogc3RyaW5nW107XG4gIHdhcm5pbmdzPzogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGljdG9ncmFwaERlYnVnSW5mbyB7XG4gIGxldHRlcjogc3RyaW5nO1xuICBncmlkTW9kZTogc3RyaW5nO1xuICBlbmRzV2l0aEJldGE6IGJvb2xlYW47XG4gIGhhc1ZhbGlkTW90aW9uRGF0YTogYm9vbGVhbjtcbiAgaGFzVmFsaWRQcm9wUGxhY2VtZW50RGF0YTogYm9vbGVhbjtcbiAgcHJvcExvY2F0aW9uczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgbW90aW9uRW5kTG9jYXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBkYXRhRmxvd1RyYWNlOiBEYXRhRmxvd1RyYWNlW107XG4gIGNzdlJvd0RhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufVxuXG5leHBvcnQgY2xhc3MgUGljdG9ncmFwaERhdGFEZWJ1Z2dlciB7XG4gIHByaXZhdGUgdHJhY2VzOiBNYXA8c3RyaW5nLCBEYXRhRmxvd1RyYWNlW10+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIGRlYnVnRW5hYmxlZCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGRlYnVnZ2luZ1xuICAgKi9cbiAgc2V0RGVidWdFbmFibGVkKGVuYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLmRlYnVnRW5hYmxlZCA9IGVuYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBuZXcgZGF0YSBmbG93IHRyYWNlXG4gICAqL1xuICBzdGFydFRyYWNlKGlkZW50aWZpZXI6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5kZWJ1Z0VuYWJsZWQpIHJldHVybjtcbiAgICB0aGlzLnRyYWNlcy5zZXQoaWRlbnRpZmllciwgW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHN0ZXAgdG8gdGhlIHRyYWNlXG4gICAqL1xuICBhZGRUcmFjZVN0ZXAoXG4gICAgaWRlbnRpZmllcjogc3RyaW5nLFxuICAgIHN0ZXA6IHN0cmluZyxcbiAgICBkYXRhOiB1bmtub3duLFxuICAgIGVycm9ycz86IHN0cmluZ1tdLFxuICAgIHdhcm5pbmdzPzogc3RyaW5nW11cbiAgKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmRlYnVnRW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgdHJhY2UgPSB0aGlzLnRyYWNlcy5nZXQoaWRlbnRpZmllcikgfHwgW107XG4gICAgdHJhY2UucHVzaCh7XG4gICAgICBzdGVwLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgZGF0YTogdGhpcy5zYW5pdGl6ZURhdGFGb3JMb2dnaW5nKGRhdGEpLFxuICAgICAgZXJyb3JzLFxuICAgICAgd2FybmluZ3MsXG4gICAgfSk7XG4gICAgdGhpcy50cmFjZXMuc2V0KGlkZW50aWZpZXIsIHRyYWNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY29tcGxldGUgZGVidWcgaW5mbyBmb3IgYSBwaWN0b2dyYXBoXG4gICAqL1xuICBnZXRQaWN0b2dyYXBoRGVidWdJbmZvKFxuICAgIHBpY3RvZ3JhcGhEYXRhOiBQaWN0b2dyYXBoRGF0YSxcbiAgICBjc3ZSb3c/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICk6IFBpY3RvZ3JhcGhEZWJ1Z0luZm8ge1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBgJHtwaWN0b2dyYXBoRGF0YS5sZXR0ZXJ9XyR7RGF0ZS5ub3coKX1gO1xuXG4gICAgLy8gQW5hbHl6ZSB0aGUgcGljdG9ncmFwaCBkYXRhIHVzaW5nIHRoZSBuZXcgYmV0YSBkZXRlY3Rpb25cbiAgICBjb25zdCBlbmRzV2l0aEJldGFQb3NpdGlvbiA9IGVuZHNXaXRoQmV0YShwaWN0b2dyYXBoRGF0YSk7XG4gICAgY29uc3QgaGFzVmFsaWRNb3Rpb25EYXRhID0gdGhpcy52YWxpZGF0ZU1vdGlvbkRhdGEocGljdG9ncmFwaERhdGEpO1xuICAgIGNvbnN0IGhhc1ZhbGlkUHJvcFBsYWNlbWVudERhdGEgPVxuICAgICAgdGhpcy52YWxpZGF0ZVByb3BQbGFjZW1lbnREYXRhKHBpY3RvZ3JhcGhEYXRhKTtcblxuICAgIC8vIEV4dHJhY3QgbG9jYXRpb24gaW5mb3JtYXRpb25cbiAgICBjb25zdCBwcm9wTG9jYXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgY29uc3QgbW90aW9uRW5kTG9jYXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgICBpZiAocGljdG9ncmFwaERhdGEubW90aW9ucykge1xuICAgICAgT2JqZWN0LmVudHJpZXMocGljdG9ncmFwaERhdGEubW90aW9ucykuZm9yRWFjaCgoW2NvbG9yLCBtb3Rpb25EYXRhXSkgPT4ge1xuICAgICAgICBpZiAobW90aW9uRGF0YSkge1xuICAgICAgICAgIHByb3BMb2NhdGlvbnNbY29sb3JdID0gbW90aW9uRGF0YS5lbmRMb2NhdGlvbiB8fCBcInVua25vd25cIjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMpLmZvckVhY2goKFtjb2xvciwgbW90aW9uXSkgPT4ge1xuICAgICAgICBtb3Rpb25FbmRMb2NhdGlvbnNbY29sb3JdID0gbW90aW9uLmVuZExvY2F0aW9uIHx8IFwidW5rbm93blwiO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBncmlkTW9kZSBmcm9tIG1vdGlvbiBkYXRhXG4gICAgY29uc3QgZ3JpZE1vZGVTZXJ2aWNlID0gcmVzb2x2ZTxJR3JpZE1vZGVEZXJpdmVyPihcIklHcmlkTW9kZURlcml2ZXJcIik7XG4gICAgY29uc3QgZ3JpZE1vZGUgPVxuICAgICAgcGljdG9ncmFwaERhdGEubW90aW9ucz8uYmx1ZSAmJiBwaWN0b2dyYXBoRGF0YS5tb3Rpb25zPy5yZWRcbiAgICAgICAgPyBncmlkTW9kZVNlcnZpY2UuZGVyaXZlR3JpZE1vZGUoXG4gICAgICAgICAgICBwaWN0b2dyYXBoRGF0YS5tb3Rpb25zLmJsdWUsXG4gICAgICAgICAgICBwaWN0b2dyYXBoRGF0YS5tb3Rpb25zLnJlZFxuICAgICAgICAgIClcbiAgICAgICAgOiBcInVua25vd25cIjtcblxuICAgIGNvbnN0IGRlYnVnSW5mbzogUGljdG9ncmFwaERlYnVnSW5mbyA9IHtcbiAgICAgIGxldHRlcjogcGljdG9ncmFwaERhdGEubGV0dGVyIHx8IFwidW5rbm93blwiLFxuICAgICAgZ3JpZE1vZGU6IGdyaWRNb2RlLnRvU3RyaW5nKCksXG4gICAgICBlbmRzV2l0aEJldGE6IGVuZHNXaXRoQmV0YVBvc2l0aW9uLFxuICAgICAgaGFzVmFsaWRNb3Rpb25EYXRhLFxuICAgICAgaGFzVmFsaWRQcm9wUGxhY2VtZW50RGF0YSxcbiAgICAgIHByb3BMb2NhdGlvbnMsXG4gICAgICBtb3Rpb25FbmRMb2NhdGlvbnMsXG4gICAgICBkYXRhRmxvd1RyYWNlOiB0aGlzLnRyYWNlcy5nZXQoaWRlbnRpZmllcikgfHwgW10sXG4gICAgICBjc3ZSb3dEYXRhOiBjc3ZSb3csXG4gICAgfTtcblxuICAgIHRoaXMubG9nRGVidWdJbmZvKGRlYnVnSW5mbyk7XG4gICAgcmV0dXJuIGRlYnVnSW5mbztcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBtb3Rpb24gZGF0YSBjb21wbGV0ZW5lc3NcbiAgICovXG4gIHByaXZhdGUgdmFsaWRhdGVNb3Rpb25EYXRhKHBpY3RvZ3JhcGhEYXRhOiBQaWN0b2dyYXBoRGF0YSk6IGJvb2xlYW4ge1xuICAgIGlmICghcGljdG9ncmFwaERhdGEubW90aW9ucykgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocGljdG9ncmFwaERhdGEubW90aW9ucykuZXZlcnkoXG4gICAgICAobW90aW9uKSA9PlxuICAgICAgICBtb3Rpb24uc3RhcnRMb2NhdGlvbiAmJlxuICAgICAgICBtb3Rpb24uZW5kTG9jYXRpb24gJiZcbiAgICAgICAgbW90aW9uLm1vdGlvblR5cGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBtb3Rpb24ucm90YXRpb25EaXJlY3Rpb24gIT09IHVuZGVmaW5lZFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgcHJvcCBkYXRhIGNvbXBsZXRlbmVzc1xuICAgKi9cbiAgcHJpdmF0ZSB2YWxpZGF0ZVByb3BQbGFjZW1lbnREYXRhKHBpY3RvZ3JhcGhEYXRhOiBQaWN0b2dyYXBoRGF0YSk6IGJvb2xlYW4ge1xuICAgIGlmICghcGljdG9ncmFwaERhdGEubW90aW9ucykgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocGljdG9ncmFwaERhdGEubW90aW9ucykuZXZlcnkoXG4gICAgICAobW90aW9uKSA9PlxuICAgICAgICBtb3Rpb24gJiYgbW90aW9uLnByb3BUeXBlICYmIG1vdGlvbi5lbmRMb2NhdGlvbiAmJiBtb3Rpb24uY29sb3JcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZyBjb21wcmVoZW5zaXZlIGRlYnVnIGluZm9ybWF0aW9uXG4gICAqL1xuICBwcml2YXRlIGxvZ0RlYnVnSW5mbyhkZWJ1Z0luZm86IFBpY3RvZ3JhcGhEZWJ1Z0luZm8pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuZGVidWdFbmFibGVkKSByZXR1cm47XG5cbiAgICBjb25zb2xlLmdyb3VwKGDwn5SNIFBpY3RvZ3JhcGggRGVidWc6ICR7ZGVidWdJbmZvLmxldHRlcn1gKTtcblxuICAgIGNvbnNvbGUubG9nKFwi8J+TiiBPdmVydmlldzpcIiwge1xuICAgICAgbGV0dGVyOiBkZWJ1Z0luZm8ubGV0dGVyLFxuICAgICAgZ3JpZE1vZGU6IGRlYnVnSW5mby5ncmlkTW9kZSxcbiAgICAgIGVuZHNXaXRoQmV0YTogZGVidWdJbmZvLmVuZHNXaXRoQmV0YSxcbiAgICAgIGhhc1ZhbGlkTW90aW9uRGF0YTogZGVidWdJbmZvLmhhc1ZhbGlkTW90aW9uRGF0YSxcbiAgICAgIGhhc1ZhbGlkUHJvcFBsYWNlbWVudERhdGE6IGRlYnVnSW5mby5oYXNWYWxpZFByb3BQbGFjZW1lbnREYXRhLFxuICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coXCLwn5ONIFByb3AgTG9jYXRpb25zOlwiLCBkZWJ1Z0luZm8ucHJvcExvY2F0aW9ucyk7XG4gICAgY29uc29sZS5sb2coXCLwn46vIE1vdGlvbiBFbmQgTG9jYXRpb25zOlwiLCBkZWJ1Z0luZm8ubW90aW9uRW5kTG9jYXRpb25zKTtcblxuICAgIGlmIChkZWJ1Z0luZm8uY3N2Um93RGF0YSkge1xuICAgICAgY29uc29sZS5sb2coXCLwn5OEIENTViBSb3cgRGF0YTpcIiwgZGVidWdJbmZvLmNzdlJvd0RhdGEpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBkYXRhIG1pc21hdGNoZXNcbiAgICBjb25zdCBtaXNtYXRjaGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIE9iamVjdC5lbnRyaWVzKGRlYnVnSW5mby5wcm9wTG9jYXRpb25zKS5mb3JFYWNoKChbY29sb3IsIHByb3BMb2NdKSA9PiB7XG4gICAgICBjb25zdCBtb3Rpb25FbmRMb2MgPSBkZWJ1Z0luZm8ubW90aW9uRW5kTG9jYXRpb25zW2NvbG9yXTtcbiAgICAgIGlmIChcbiAgICAgICAgcHJvcExvYyAhPT0gbW90aW9uRW5kTG9jICYmXG4gICAgICAgIHByb3BMb2MgIT09IFwidW5rbm93blwiICYmXG4gICAgICAgIG1vdGlvbkVuZExvYyAhPT0gXCJ1bmtub3duXCJcbiAgICAgICkge1xuICAgICAgICBtaXNtYXRjaGVzLnB1c2goXG4gICAgICAgICAgYCR7Y29sb3J9OiBwcm9wKCR7cHJvcExvY30pICE9IG1vdGlvbigke21vdGlvbkVuZExvY30pYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG1pc21hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIExvY2F0aW9uIE1pc21hdGNoZXM6XCIsIG1pc21hdGNoZXMpO1xuICAgIH1cblxuICAgIGlmIChkZWJ1Z0luZm8uZGF0YUZsb3dUcmFjZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIvCflIQgRGF0YSBGbG93IFRyYWNlOlwiKTtcbiAgICAgIGRlYnVnSW5mby5kYXRhRmxvd1RyYWNlLmZvckVhY2goKHRyYWNlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhgICAke2luZGV4ICsgMX0uICR7dHJhY2Uuc3RlcH1gLCB0cmFjZS5kYXRhKTtcbiAgICAgICAgaWYgKHRyYWNlLndhcm5pbmdzPy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYCAgICAgV2FybmluZ3M6YCwgdHJhY2Uud2FybmluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZS5lcnJvcnM/Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCAgICAgRXJyb3JzOmAsIHRyYWNlLmVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYW5pdGl6ZSBkYXRhIGZvciBsb2dnaW5nIHRvIHByZXZlbnQgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgKi9cbiAgcHJpdmF0ZSBzYW5pdGl6ZURhdGFGb3JMb2dnaW5nKGRhdGE6IHVua25vd24pOiB1bmtub3duIHtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB1bmRlZmluZWQpIHJldHVybiBkYXRhO1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICByZXR1cm4gZGF0YS5tYXAoKGl0ZW0pID0+IHRoaXMuc2FuaXRpemVEYXRhRm9yTG9nZ2luZyhpdGVtKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNhbml0aXplZDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGRhdGEpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBzYW5pdGl6ZWRba2V5XSA9IFwiW0Z1bmN0aW9uXVwiO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIExpbWl0IGRlcHRoIHRvIHByZXZlbnQgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgICAgICAgIHNhbml0aXplZFtrZXldID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgMikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNhbml0aXplZFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNhbml0aXplZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgdHJhY2VzICh1c2VmdWwgZm9yIGNsZWFudXApXG4gICAqL1xuICBjbGVhclRyYWNlcygpOiB2b2lkIHtcbiAgICB0aGlzLnRyYWNlcy5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydCBkZWJ1ZyBkYXRhIGFzIEpTT04gZm9yIGV4dGVybmFsIGFuYWx5c2lzXG4gICAqL1xuICBleHBvcnREZWJ1Z0RhdGEoKTogc3RyaW5nIHtcbiAgICBjb25zdCBhbGxUcmFjZXM6IFJlY29yZDxzdHJpbmcsIERhdGFGbG93VHJhY2VbXT4gPSB7fTtcbiAgICB0aGlzLnRyYWNlcy5mb3JFYWNoKCh0cmFjZSwgaWRlbnRpZmllcikgPT4ge1xuICAgICAgYWxsVHJhY2VzW2lkZW50aWZpZXJdID0gdHJhY2U7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXG4gICAgICB7XG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB0cmFjZXM6IGFsbFRyYWNlcyxcbiAgICAgIH0sXG4gICAgICBudWxsLFxuICAgICAgMlxuICAgICk7XG4gIH1cbn1cblxuLy8gU2luZ2xldG9uIGluc3RhbmNlIGZvciBnbG9iYWwgZGVidWdnaW5nXG5leHBvcnQgY29uc3QgcGljdG9ncmFwaERhdGFEZWJ1Z2dlciA9IG5ldyBQaWN0b2dyYXBoRGF0YURlYnVnZ2VyKCk7XG4iXSwKICAibWFwcGluZ3MiOiAiQUFRQSxTQUFTLGVBQWU7QUFFeEIsU0FBUyxvQkFBb0I7QUFzQnRCLGFBQU0sdUJBQXVCO0FBQUEsRUFDMUIsU0FBdUMsb0JBQUksSUFBSTtBQUFBLEVBQy9DLGVBQWU7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUt2QixnQkFBZ0IsU0FBd0I7QUFDdEMsU0FBSyxlQUFlO0FBQUEsRUFDdEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLFdBQVcsWUFBMEI7QUFDbkMsUUFBSSxDQUFDLEtBQUssYUFBYztBQUN4QixTQUFLLE9BQU8sSUFBSSxZQUFZLENBQUMsQ0FBQztBQUFBLEVBQ2hDO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxhQUNFLFlBQ0EsTUFDQSxNQUNBLFFBQ0EsVUFDTTtBQUNOLFFBQUksQ0FBQyxLQUFLLGFBQWM7QUFFeEIsVUFBTSxRQUFRLEtBQUssT0FBTyxJQUFJLFVBQVUsS0FBSyxDQUFDO0FBQzlDLFVBQU0sS0FBSztBQUFBLE1BQ1Q7QUFBQSxNQUNBLFdBQVcsS0FBSyxJQUFJO0FBQUEsTUFDcEIsTUFBTSxLQUFLLHVCQUF1QixJQUFJO0FBQUEsTUFDdEM7QUFBQSxNQUNBO0FBQUEsSUFDRixDQUFDO0FBQ0QsU0FBSyxPQUFPLElBQUksWUFBWSxLQUFLO0FBQUEsRUFDbkM7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLHVCQUNFLGdCQUNBLFFBQ3FCO0FBQ3JCLFVBQU0sYUFBYSxHQUFHLGVBQWUsTUFBTSxJQUFJLEtBQUssSUFBSSxDQUFDO0FBR3pELFVBQU0sdUJBQXVCLGFBQWEsY0FBYztBQUN4RCxVQUFNLHFCQUFxQixLQUFLLG1CQUFtQixjQUFjO0FBQ2pFLFVBQU0sNEJBQ0osS0FBSywwQkFBMEIsY0FBYztBQUcvQyxVQUFNLGdCQUF3QyxDQUFDO0FBQy9DLFVBQU0scUJBQTZDLENBQUM7QUFF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
