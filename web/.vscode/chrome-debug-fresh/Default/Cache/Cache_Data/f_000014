var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
var __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);
import { MotionColor } from "/src/lib/domain/index.ts";
import { GridMode } from "/src/lib/domain/enums.ts";
import { TYPES } from "/src/lib/services/inversify/types.ts";
import { inject, injectable } from "/node_modules/.vite/deps/inversify.js?v=608ae08a";
import { ArrowPlacementKeyService } from "/src/lib/services/implementations/positioning/ArrowPlacementKeyService.ts";
import { AttributeKeyGenerator } from "/src/lib/services/positioning/arrows/key_generators/AttributeKeyGenerator.ts";
import { SpecialPlacementOriKeyGenerator } from "/src/lib/services/positioning/arrows/key_generators/SpecialPlacementOriKeyGenerator.ts";
import { TurnsTupleKeyGenerator } from "/src/lib/services/positioning/arrows/key_generators/TurnsTupleKeyGenerator.ts";
import { DefaultPlacementService } from "/src/lib/services/positioning/arrows/placement/DefaultPlacementService.ts";
import { SpecialPlacementService } from "/src/lib/services/positioning/arrows/placement/SpecialPlacementService.ts";
import {
  DirectionalTupleCalculator,
  DirectionalTupleProcessor,
  QuadrantIndexCalculator
} from "/src/lib/services/positioning/arrows/processors/DirectionalTupleProcessor.ts";
export let ArrowAdjustmentCalculator = class {
  /**
   * Consolidated service combining lookup and calculation logic.
   * Eliminates the pure delegation layer while maintaining identical behavior.
   */
  // Lookup services (previously in ArrowAdjustmentLookup)
  specialPlacementService;
  defaultPlacementService;
  orientationKeyService;
  placementKeyService;
  turnsTupleService;
  attributeKeyService;
  // Processing services
  tupleProcessor;
  gridModeService;
  constructor(gridModeService, options) {
    this.gridModeService = gridModeService;
    this.specialPlacementService = options?.specialPlacementService || new SpecialPlacementService();
    this.defaultPlacementService = options?.defaultPlacementService || new DefaultPlacementService();
    this.orientationKeyService = options?.orientationKeyService || new SpecialPlacementOriKeyGenerator();
    this.placementKeyService = options?.placementKeyService || new ArrowPlacementKeyService();
    this.turnsTupleService = options?.turnsTupleService || new TurnsTupleKeyGenerator();
    this.attributeKeyService = options?.attributeKeyService || new AttributeKeyGenerator();
    this.tupleProcessor = options?.tupleProcessor || this.createDefaultTupleProcessor();
  }
  async calculateAdjustment(pictographData, motionData, letter, location, arrowColor) {
    try {
      return await this.calculateAdjustmentResult(
        pictographData,
        motionData,
        letter,
        location,
        arrowColor
      );
    } catch (error) {
      console.error(`Adjustment calculation failed: ${error}`);
      return { x: 0, y: 0 };
    }
  }
  async calculateAdjustmentResult(pictographData, motionData, letter, location, arrowColor) {
    try {
      const baseAdjustment = await this.getBaseAdjustment(
        pictographData,
        motionData,
        letter,
        arrowColor
      );
      const finalAdjustment = this.tupleProcessor.processDirectionalTuples(
        baseAdjustment,
        motionData,
        location
      );
      return finalAdjustment;
    } catch (error) {
      console.error(
        `Adjustment calculation failed for letter ${letter}: ${error}`
      );
      throw new Error(`Arrow adjustment calculation failed: ${error}`);
    }
  }
  // === PRIVATE METHODS - Consolidated from ArrowAdjustmentLookup ===
  async getBaseAdjustment(pictographData, motionData, letter, arrowColor) {
    if (!motionData || !letter) {
      throw new Error("Missing motion or letter data for adjustment lookup");
    }
    try {
      const [oriKey, turnsTuple, attrKey] = this.generateLookupKeys(
        pictographData,
        motionData
      );
      console.debug(
        `Generated keys - ori: ${oriKey}, turns: ${turnsTuple}, attr: ${attrKey}`
      );
      try {
        const specialAdjustment = await this.lookupSpecialPlacement(
          motionData,
          pictographData,
          arrowColor
        );
        if (specialAdjustment) {
          return specialAdjustment;
        }
        console.debug("No special placement found, falling back to default");
      } catch {
        console.debug(
          "Error in special placement lookup, falling back to default"
        );
      }
      const defaultAdjustment = await this.calculateDefaultAdjustment(
        motionData,
        pictographData
      );
      console.debug(
        `Using default adjustment: (${defaultAdjustment.x.toFixed(1)}, ${defaultAdjustment.y.toFixed(1)})`
      );
      return defaultAdjustment;
    } catch (error) {
      console.error("Error in base adjustment lookup:", error);
      throw new Error(`Arrow adjustment lookup failed: ${error}`);
    }
  }
  generateLookupKeys(pictographData, motionData) {
    try {
      const oriKey = this.orientationKeyService.generateOrientationKey(
        motionData,
        pictographData
      );
      const turnsTuple = this.turnsTupleService.generateTurnsTuple(pictographData);
      const color = MotionColor.BLUE;
      const tempArrow = {
        id: "temp",
        arrowLocation: null,
        positionX: 0,
        positionY: 0,
        rotationAngle: 0,
        // âœ… FIXED: Added missing rotationAngle property
        coordinates: { x: 0, y: 0 },
        svgCenter: { x: 0, y: 0 },
        svgMirrored: false,
        isVisible: true,
        isSelected: false
      };
      const attrKey = this.attributeKeyService.getKeyFromArrow(
        tempArrow,
        pictographData,
        color
      );
      return [oriKey, turnsTuple.join(","), attrKey];
    } catch (error) {
      console.error("Failed to generate lookup keys:", error);
      throw new Error(`Key generation failed: ${error}`);
    }
  }
  async lookupSpecialPlacement(motionData, pictographData, arrowColor) {
    try {
      const adjustment = await this.specialPlacementService.getSpecialAdjustment(
        motionData,
        pictographData,
        arrowColor
      );
      if (adjustment) {
        return adjustment;
      }
      return null;
    } catch (error) {
      console.error("Error in special placement lookup:", error);
      return null;
    }
  }
  async calculateDefaultAdjustment(motionData, pictographData) {
    try {
      const derivedGridMode = pictographData.motions?.blue && pictographData.motions?.red ? this.gridModeService.deriveGridMode(
        pictographData.motions.blue,
        pictographData.motions.red
      ) : GridMode.DIAMOND;
      const keys = await this.defaultPlacementService.getAvailablePlacementKeys(
        motionData.motionType,
        derivedGridMode
      );
      const defaultPlacements = Object.fromEntries(
        (keys || []).map((k) => [k, true])
      );
      const availableKeys = Object.keys(defaultPlacements || []);
      const placementKey = this.placementKeyService.generatePlacementKey(
        motionData,
        pictographData,
        availableKeys
      );
      const adjustmentPoint = await this.defaultPlacementService.getDefaultAdjustment(
        placementKey,
        motionData.turns || 0,
        motionData.motionType,
        derivedGridMode
      );
      return adjustmentPoint;
    } catch (error) {
      console.error("Error calculating default adjustment:", error);
      throw new Error(`Default adjustment calculation failed: ${error}`);
    }
  }
  createDefaultTupleProcessor() {
    return new DirectionalTupleProcessor(
      new DirectionalTupleCalculator(),
      new QuadrantIndexCalculator()
    );
  }
};
ArrowAdjustmentCalculator = __decorateClass([
  injectable(),
  __decorateParam(0, inject(TYPES.IGridModeDeriver))
], ArrowAdjustmentCalculator);
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3NlcnZpY2VzL3Bvc2l0aW9uaW5nL2Fycm93cy9jYWxjdWxhdGlvbi9BcnJvd0FkanVzdG1lbnRDYWxjdWxhdG9yLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIEFycm93IEFkanVzdG1lbnQgQ2FsY3VsYXRvciAtIENvbnNvbGlkYXRlZCBTZXJ2aWNlXG4gKlxuICogQ29uc29saWRhdGVkIHNlcnZpY2UgdGhhdCBjb21iaW5lcyBBcnJvd0FkanVzdG1lbnRDYWxjdWxhdG9yIGFuZCBBcnJvd0FkanVzdG1lbnRMb29rdXBcbiAqIHRvIGVsaW1pbmF0ZSBwdXJlIGRlbGVnYXRpb24gbGF5ZXIuIE1haW50YWlucyBleGFjdCBzYW1lIGludGVyZmFjZSBhbmQgYmVoYXZpb3IuXG4gKlxuICogQ09OU09MSURBVElPTiBCRU5FRklUUzpcbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSBkZWxlZ2F0aW9uIGxheWVyXG4gKiAtIE1haW50YWlucyBpZGVudGljYWwgbG9naWMgYW5kIHJlc3VsdHNcbiAqIC0gUHJlc2VydmVzIGFsbCBleGlzdGluZyBpbnRlcmZhY2VzIGFuZCB0ZXN0IGNvbXBhdGliaWxpdHlcbiAqIC0gQmV0dGVyIFR5cGVTY3JpcHQgb3JnYW5pemF0aW9uXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBNb3Rpb25EYXRhLCBQaWN0b2dyYXBoRGF0YSB9IGZyb20gXCIkbGliL2RvbWFpblwiO1xuaW1wb3J0IHsgTW90aW9uQ29sb3IgfSBmcm9tIFwiJGxpYi9kb21haW5cIjtcbmltcG9ydCB7IEdyaWRNb2RlIH0gZnJvbSBcIiRsaWIvZG9tYWluL2VudW1zXCI7XG5pbXBvcnQgdHlwZSB7IElHcmlkTW9kZURlcml2ZXIgfSBmcm9tIFwiJGxpYi9zZXJ2aWNlcy9pbnRlcmZhY2VzL21vdmVtZW50L0lHcmlkTW9kZURlcml2ZXJcIjtcbmltcG9ydCB7IFRZUEVTIH0gZnJvbSBcIiRsaWIvc2VydmljZXMvaW52ZXJzaWZ5L3R5cGVzXCI7XG5pbXBvcnQgeyBpbmplY3QsIGluamVjdGFibGUgfSBmcm9tIFwiaW52ZXJzaWZ5XCI7XG5pbXBvcnQgeyBBcnJvd1BsYWNlbWVudEtleVNlcnZpY2UgfSBmcm9tIFwiLi4vLi4vLi4vaW1wbGVtZW50YXRpb25zL3Bvc2l0aW9uaW5nL0Fycm93UGxhY2VtZW50S2V5U2VydmljZVwiO1xuaW1wb3J0IHR5cGUgeyBJQXJyb3dBZGp1c3RtZW50Q2FsY3VsYXRvciB9IGZyb20gXCIuLi8uLi9jb3JlLXNlcnZpY2VzXCI7XG5pbXBvcnQgdHlwZSB7XG4gIElBdHRyaWJ1dGVLZXlHZW5lcmF0b3IsXG4gIElTcGVjaWFsUGxhY2VtZW50T3JpS2V5R2VuZXJhdG9yLFxuICBJVHVybnNUdXBsZUtleUdlbmVyYXRvcixcbn0gZnJvbSBcIi4uLy4uL2RhdGEtc2VydmljZXNcIjtcbmltcG9ydCB0eXBlIHtcbiAgSURlZmF1bHRQbGFjZW1lbnRTZXJ2aWNlLFxuICBJU3BlY2lhbFBsYWNlbWVudFNlcnZpY2UsXG59IGZyb20gXCIuLi8uLi9wbGFjZW1lbnQtc2VydmljZXNcIjtcbmltcG9ydCB0eXBlIHtcbiAgTG9jYXRpb24sXG4gIE1vdGlvblR5cGUgYXMgTW90aW9uVHlwZVR5cGUsXG4gIFBvaW50LFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCB7IEF0dHJpYnV0ZUtleUdlbmVyYXRvciB9IGZyb20gXCIuLi9rZXlfZ2VuZXJhdG9ycy9BdHRyaWJ1dGVLZXlHZW5lcmF0b3JcIjtcbmltcG9ydCB7IFNwZWNpYWxQbGFjZW1lbnRPcmlLZXlHZW5lcmF0b3IgfSBmcm9tIFwiLi4va2V5X2dlbmVyYXRvcnMvU3BlY2lhbFBsYWNlbWVudE9yaUtleUdlbmVyYXRvclwiO1xuaW1wb3J0IHsgVHVybnNUdXBsZUtleUdlbmVyYXRvciB9IGZyb20gXCIuLi9rZXlfZ2VuZXJhdG9ycy9UdXJuc1R1cGxlS2V5R2VuZXJhdG9yXCI7XG5pbXBvcnQgeyBEZWZhdWx0UGxhY2VtZW50U2VydmljZSB9IGZyb20gXCIuLi9wbGFjZW1lbnQvRGVmYXVsdFBsYWNlbWVudFNlcnZpY2VcIjtcbmltcG9ydCB7IFNwZWNpYWxQbGFjZW1lbnRTZXJ2aWNlIH0gZnJvbSBcIi4uL3BsYWNlbWVudC9TcGVjaWFsUGxhY2VtZW50U2VydmljZVwiO1xuaW1wb3J0IHtcbiAgRGlyZWN0aW9uYWxUdXBsZUNhbGN1bGF0b3IsXG4gIERpcmVjdGlvbmFsVHVwbGVQcm9jZXNzb3IsXG4gIFF1YWRyYW50SW5kZXhDYWxjdWxhdG9yLFxuICB0eXBlIElEaXJlY3Rpb25hbFR1cGxlUHJvY2Vzc29yLFxufSBmcm9tIFwiLi4vcHJvY2Vzc29ycy9EaXJlY3Rpb25hbFR1cGxlUHJvY2Vzc29yXCI7XG5cbkBpbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBcnJvd0FkanVzdG1lbnRDYWxjdWxhdG9yIGltcGxlbWVudHMgSUFycm93QWRqdXN0bWVudENhbGN1bGF0b3Ige1xuICAvKipcbiAgICogQ29uc29saWRhdGVkIHNlcnZpY2UgY29tYmluaW5nIGxvb2t1cCBhbmQgY2FsY3VsYXRpb24gbG9naWMuXG4gICAqIEVsaW1pbmF0ZXMgdGhlIHB1cmUgZGVsZWdhdGlvbiBsYXllciB3aGlsZSBtYWludGFpbmluZyBpZGVudGljYWwgYmVoYXZpb3IuXG4gICAqL1xuXG4gIC8vIExvb2t1cCBzZXJ2aWNlcyAocHJldmlvdXNseSBpbiBBcnJvd0FkanVzdG1lbnRMb29rdXApXG4gIHByaXZhdGUgc3BlY2lhbFBsYWNlbWVudFNlcnZpY2U6IElTcGVjaWFsUGxhY2VtZW50U2VydmljZTtcbiAgcHJpdmF0ZSBkZWZhdWx0UGxhY2VtZW50U2VydmljZTogSURlZmF1bHRQbGFjZW1lbnRTZXJ2aWNlO1xuICBwcml2YXRlIG9yaWVudGF0aW9uS2V5U2VydmljZTogSVNwZWNpYWxQbGFjZW1lbnRPcmlLZXlHZW5lcmF0b3I7XG4gIHByaXZhdGUgcGxhY2VtZW50S2V5U2VydmljZTogQXJyb3dQbGFjZW1lbnRLZXlTZXJ2aWNlO1xuICBwcml2YXRlIHR1cm5zVHVwbGVTZXJ2aWNlOiBJVHVybnNUdXBsZUtleUdlbmVyYXRvcjtcbiAgcHJpdmF0ZSBhdHRyaWJ1dGVLZXlTZXJ2aWNlOiBJQXR0cmlidXRlS2V5R2VuZXJhdG9yO1xuXG4gIC8vIFByb2Nlc3Npbmcgc2VydmljZXNcbiAgcHJpdmF0ZSB0dXBsZVByb2Nlc3NvcjogSURpcmVjdGlvbmFsVHVwbGVQcm9jZXNzb3I7XG4gIHByaXZhdGUgZ3JpZE1vZGVTZXJ2aWNlOiBJR3JpZE1vZGVEZXJpdmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBpbmplY3QoVFlQRVMuSUdyaWRNb2RlRGVyaXZlcikgZ3JpZE1vZGVTZXJ2aWNlOiBJR3JpZE1vZGVEZXJpdmVyLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICBzcGVjaWFsUGxhY2VtZW50U2VydmljZT86IElTcGVjaWFsUGxhY2VtZW50U2VydmljZTtcbiAgICAgIGRlZmF1bHRQbGFjZW1lbnRTZXJ2aWNlPzogSURlZmF1bHRQbGFjZW1lbnRTZXJ2aWNlO1xuICAgICAgb3JpZW50YXRpb25LZXlTZXJ2aWNlPzogSVNwZWNpYWxQbGFjZW1lbnRPcmlLZXlHZW5lcmF0b3I7XG4gICAgICBwbGFjZW1lbnRLZXlTZXJ2aWNlPzogQXJyb3dQbGFjZW1lbnRLZXlTZXJ2aWNlO1xuICAgICAgdHVybnNUdXBsZVNlcnZpY2U/OiBJVHVybnNUdXBsZUtleUdlbmVyYXRvcjtcbiAgICAgIGF0dHJpYnV0ZUtleVNlcnZpY2U/OiBJQXR0cmlidXRlS2V5R2VuZXJhdG9yO1xuICAgICAgdHVwbGVQcm9jZXNzb3I/OiBJRGlyZWN0aW9uYWxUdXBsZVByb2Nlc3NvcjtcbiAgICB9XG4gICkge1xuICAgIC8vIFN0b3JlIGluamVjdGVkIHNlcnZpY2VcbiAgICB0aGlzLmdyaWRNb2RlU2VydmljZSA9IGdyaWRNb2RlU2VydmljZTtcblxuICAgIC8vIEluaXRpYWxpemUgc2VydmljZXMgd2l0aCBkZWZhdWx0cyBpZiBub3QgcHJvdmlkZWRcbiAgICB0aGlzLnNwZWNpYWxQbGFjZW1lbnRTZXJ2aWNlID1cbiAgICAgIG9wdGlvbnM/LnNwZWNpYWxQbGFjZW1lbnRTZXJ2aWNlIHx8IG5ldyBTcGVjaWFsUGxhY2VtZW50U2VydmljZSgpO1xuICAgIHRoaXMuZGVmYXVsdFBsYWNlbWVudFNlcnZpY2UgPVxuICAgICAgb3B0aW9ucz8uZGVmYXVsdFBsYWNlbWVudFNlcnZpY2UgfHwgbmV3IERlZmF1bHRQbGFjZW1lbnRTZXJ2aWNlKCk7XG4gICAgdGhpcy5vcmllbnRhdGlvbktleVNlcnZpY2UgPVxuICAgICAgb3B0aW9ucz8ub3JpZW50YXRpb25LZXlTZXJ2aWNlIHx8IG5ldyBTcGVjaWFsUGxhY2VtZW50T3JpS2V5R2VuZXJhdG9yKCk7XG4gICAgdGhpcy5wbGFjZW1lbnRLZXlTZXJ2aWNlID1cbiAgICAgIG9wdGlvbnM/LnBsYWNlbWVudEtleVNlcnZpY2UgfHwgbmV3IEFycm93UGxhY2VtZW50S2V5U2VydmljZSgpO1xuICAgIHRoaXMudHVybnNUdXBsZVNlcnZpY2UgPVxuICAgICAgb3B0aW9ucz8udHVybnNUdXBsZVNlcnZpY2UgfHwgbmV3IFR1cm5zVHVwbGVLZXlHZW5lcmF0b3IoKTtcbiAgICB0aGlzLmF0dHJpYnV0ZUtleVNlcnZpY2UgPVxuICAgICAgb3B0aW9ucz8uYXR0cmlidXRlS2V5U2VydmljZSB8fCBuZXcgQXR0cmlidXRlS2V5R2VuZXJhdG9yKCk7XG4gICAgdGhpcy50dXBsZVByb2Nlc3NvciA9XG4gICAgICBvcHRpb25zPy50dXBsZVByb2Nlc3NvciB8fCB0aGlzLmNyZWF0ZURlZmF1bHRUdXBsZVByb2Nlc3NvcigpO1xuICB9XG5cbiAgYXN5bmMgY2FsY3VsYXRlQWRqdXN0bWVudChcbiAgICBwaWN0b2dyYXBoRGF0YTogUGljdG9ncmFwaERhdGEsXG4gICAgbW90aW9uRGF0YTogTW90aW9uRGF0YSxcbiAgICBsZXR0ZXI6IHN0cmluZyxcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgYXJyb3dDb2xvcj86IHN0cmluZ1xuICApOiBQcm9taXNlPFBvaW50PiB7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGFycm93IHBvc2l0aW9uIGFkanVzdG1lbnQgLSBJREVOVElDQUwgbG9naWMgdG8gb3JpZ2luYWwuXG4gICAgICovXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNhbGN1bGF0ZUFkanVzdG1lbnRSZXN1bHQoXG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhLFxuICAgICAgICBtb3Rpb25EYXRhLFxuICAgICAgICBsZXR0ZXIsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBhcnJvd0NvbG9yXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBMb2cgZXJyb3IgYW5kIHJldHVybiBkZWZhdWx0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICBjb25zb2xlLmVycm9yKGBBZGp1c3RtZW50IGNhbGN1bGF0aW9uIGZhaWxlZDogJHtlcnJvcn1gKTtcbiAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjYWxjdWxhdGVBZGp1c3RtZW50UmVzdWx0KFxuICAgIHBpY3RvZ3JhcGhEYXRhOiBQaWN0b2dyYXBoRGF0YSxcbiAgICBtb3Rpb25EYXRhOiBNb3Rpb25EYXRhLFxuICAgIGxldHRlcjogc3RyaW5nLFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBhcnJvd0NvbG9yPzogc3RyaW5nXG4gICk6IFByb21pc2U8UG9pbnQ+IHtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgYXJyb3cgcG9zaXRpb24gYWRqdXN0bWVudCB3aXRoIHByb3BlciBlcnJvciBoYW5kbGluZy5cbiAgICAgKiBJREVOVElDQUwgbG9naWMgdG8gb3JpZ2luYWwgQXJyb3dBZGp1c3RtZW50Q2FsY3VsYXRvci5cbiAgICAgKi9cbiAgICB0cnkge1xuICAgICAgLy8gU1RFUCAxOiBMb29rIHVwIGJhc2UgYWRqdXN0bWVudCAoc3BlY2lhbCDihpIgZGVmYXVsdCkgLSBFWEFDVExZIGxpa2UgbGVnYWN5XG4gICAgICBjb25zdCBiYXNlQWRqdXN0bWVudCA9IGF3YWl0IHRoaXMuZ2V0QmFzZUFkanVzdG1lbnQoXG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhLFxuICAgICAgICBtb3Rpb25EYXRhLFxuICAgICAgICBsZXR0ZXIsXG4gICAgICAgIGFycm93Q29sb3JcbiAgICAgICk7XG5cbiAgICAgIC8vIFNURVAgMjogUHJvY2VzcyBkaXJlY3Rpb25hbCB0dXBsZXMgLSBFWEFDVExZIGxpa2UgbGVnYWN5XG4gICAgICBjb25zdCBmaW5hbEFkanVzdG1lbnQgPSB0aGlzLnR1cGxlUHJvY2Vzc29yLnByb2Nlc3NEaXJlY3Rpb25hbFR1cGxlcyhcbiAgICAgICAgYmFzZUFkanVzdG1lbnQsXG4gICAgICAgIG1vdGlvbkRhdGEsXG4gICAgICAgIGxvY2F0aW9uXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gZmluYWxBZGp1c3RtZW50O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgQWRqdXN0bWVudCBjYWxjdWxhdGlvbiBmYWlsZWQgZm9yIGxldHRlciAke2xldHRlcn06ICR7ZXJyb3J9YFxuICAgICAgKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXJyb3cgYWRqdXN0bWVudCBjYWxjdWxhdGlvbiBmYWlsZWQ6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gPT09IFBSSVZBVEUgTUVUSE9EUyAtIENvbnNvbGlkYXRlZCBmcm9tIEFycm93QWRqdXN0bWVudExvb2t1cCA9PT1cblxuICBwcml2YXRlIGFzeW5jIGdldEJhc2VBZGp1c3RtZW50KFxuICAgIHBpY3RvZ3JhcGhEYXRhOiBQaWN0b2dyYXBoRGF0YSxcbiAgICBtb3Rpb25EYXRhOiBNb3Rpb25EYXRhLFxuICAgIGxldHRlcjogc3RyaW5nLFxuICAgIGFycm93Q29sb3I/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxQb2ludD4ge1xuICAgIC8qKlxuICAgICAqIEdldCBiYXNlIGFkanVzdG1lbnQgdXNpbmcgc3RyZWFtbGluZWQgbG9va3VwIGxvZ2ljLlxuICAgICAqIElERU5USUNBTCB0byBBcnJvd0FkanVzdG1lbnRMb29rdXAuZ2V0QmFzZUFkanVzdG1lbnQoKVxuICAgICAqL1xuICAgIGlmICghbW90aW9uRGF0YSB8fCAhbGV0dGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIG1vdGlvbiBvciBsZXR0ZXIgZGF0YSBmb3IgYWRqdXN0bWVudCBsb29rdXBcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdlbmVyYXRlIHJlcXVpcmVkIGtleXMgZm9yIHNwZWNpYWwgcGxhY2VtZW50IGxvb2t1cFxuICAgICAgY29uc3QgW29yaUtleSwgdHVybnNUdXBsZSwgYXR0cktleV0gPSB0aGlzLmdlbmVyYXRlTG9va3VwS2V5cyhcbiAgICAgICAgcGljdG9ncmFwaERhdGEsXG4gICAgICAgIG1vdGlvbkRhdGFcbiAgICAgICk7XG5cbiAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgIGBHZW5lcmF0ZWQga2V5cyAtIG9yaTogJHtvcmlLZXl9LCB0dXJuczogJHt0dXJuc1R1cGxlfSwgYXR0cjogJHthdHRyS2V5fWBcbiAgICAgICk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNwZWNpYWxBZGp1c3RtZW50ID0gYXdhaXQgdGhpcy5sb29rdXBTcGVjaWFsUGxhY2VtZW50KFxuICAgICAgICAgIG1vdGlvbkRhdGEsXG4gICAgICAgICAgcGljdG9ncmFwaERhdGEsXG4gICAgICAgICAgYXJyb3dDb2xvclxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChzcGVjaWFsQWRqdXN0bWVudCkge1xuICAgICAgICAgIHJldHVybiBzcGVjaWFsQWRqdXN0bWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vIHNwZWNpYWwgcGxhY2VtZW50IGZvdW5kIC0gZmFsbCBiYWNrIHRvIGRlZmF1bHRcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhcIk5vIHNwZWNpYWwgcGxhY2VtZW50IGZvdW5kLCBmYWxsaW5nIGJhY2sgdG8gZGVmYXVsdFwiKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBFcnJvciBpbiBzcGVjaWFsIHBsYWNlbWVudCBsb29rdXAgLSBmYWxsIGJhY2sgdG8gZGVmYXVsdFxuICAgICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgIFwiRXJyb3IgaW4gc3BlY2lhbCBwbGFjZW1lbnQgbG9va3VwLCBmYWxsaW5nIGJhY2sgdG8gZGVmYXVsdFwiXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNURVAgMjogRmFsbCBiYWNrIHRvIGRlZmF1bHQgY2FsY3VsYXRpb25cbiAgICAgIGNvbnN0IGRlZmF1bHRBZGp1c3RtZW50ID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVEZWZhdWx0QWRqdXN0bWVudChcbiAgICAgICAgbW90aW9uRGF0YSxcbiAgICAgICAgcGljdG9ncmFwaERhdGFcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICBgVXNpbmcgZGVmYXVsdCBhZGp1c3RtZW50OiAoJHtkZWZhdWx0QWRqdXN0bWVudC54LnRvRml4ZWQoMSl9LCAke2RlZmF1bHRBZGp1c3RtZW50LnkudG9GaXhlZCgxKX0pYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkZWZhdWx0QWRqdXN0bWVudDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGJhc2UgYWRqdXN0bWVudCBsb29rdXA6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXJyb3cgYWRqdXN0bWVudCBsb29rdXAgZmFpbGVkOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVMb29rdXBLZXlzKFxuICAgIHBpY3RvZ3JhcGhEYXRhOiBQaWN0b2dyYXBoRGF0YSxcbiAgICBtb3Rpb25EYXRhOiBNb3Rpb25EYXRhXG4gICk6IFtzdHJpbmcsIHN0cmluZywgc3RyaW5nXSB7XG4gICAgLyoqR2VuZXJhdGUgYWxsIHJlcXVpcmVkIGtleXMgZm9yIHNwZWNpYWwgcGxhY2VtZW50IGxvb2t1cC4qL1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvcmlLZXkgPSB0aGlzLm9yaWVudGF0aW9uS2V5U2VydmljZS5nZW5lcmF0ZU9yaWVudGF0aW9uS2V5KFxuICAgICAgICBtb3Rpb25EYXRhLFxuICAgICAgICBwaWN0b2dyYXBoRGF0YVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHR1cm5zVHVwbGUgPVxuICAgICAgICB0aGlzLnR1cm5zVHVwbGVTZXJ2aWNlLmdlbmVyYXRlVHVybnNUdXBsZShwaWN0b2dyYXBoRGF0YSk7XG5cbiAgICAgIC8vIOKchSBGSVhFRDogQ3JlYXRlIHByb3BlciBBcnJvd1BsYWNlbWVudERhdGEgYW5kIHBhc3MgY29sb3Igc2VwYXJhdGVseVxuICAgICAgY29uc3QgY29sb3IgPSBNb3Rpb25Db2xvci5CTFVFO1xuICAgICAgY29uc3QgdGVtcEFycm93ID0ge1xuICAgICAgICBpZDogXCJ0ZW1wXCIsXG4gICAgICAgIGFycm93TG9jYXRpb246IG51bGwsXG4gICAgICAgIHBvc2l0aW9uWDogMCxcbiAgICAgICAgcG9zaXRpb25ZOiAwLFxuICAgICAgICByb3RhdGlvbkFuZ2xlOiAwLCAvLyDinIUgRklYRUQ6IEFkZGVkIG1pc3Npbmcgcm90YXRpb25BbmdsZSBwcm9wZXJ0eVxuICAgICAgICBjb29yZGluYXRlczogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgIHN2Z0NlbnRlcjogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgIHN2Z01pcnJvcmVkOiBmYWxzZSxcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICBpc1NlbGVjdGVkOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGF0dHJLZXkgPSB0aGlzLmF0dHJpYnV0ZUtleVNlcnZpY2UuZ2V0S2V5RnJvbUFycm93KFxuICAgICAgICB0ZW1wQXJyb3csXG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhLFxuICAgICAgICBjb2xvclxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIFtvcmlLZXksIHR1cm5zVHVwbGUuam9pbihcIixcIiksIGF0dHJLZXldO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGdlbmVyYXRlIGxvb2t1cCBrZXlzOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSBnZW5lcmF0aW9uIGZhaWxlZDogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvb2t1cFNwZWNpYWxQbGFjZW1lbnQoXG4gICAgbW90aW9uRGF0YTogTW90aW9uRGF0YSxcbiAgICBwaWN0b2dyYXBoRGF0YTogUGljdG9ncmFwaERhdGEsXG4gICAgYXJyb3dDb2xvcj86IHN0cmluZ1xuICApOiBQcm9taXNlPFBvaW50IHwgbnVsbD4ge1xuICAgIC8qKlxuICAgICAqIExvb2sgdXAgc3BlY2lhbCBwbGFjZW1lbnQgdXNpbmcgZXhhY3QgbGVnYWN5IGxvZ2ljLlxuICAgICAqIElERU5USUNBTCB0byBBcnJvd0FkanVzdG1lbnRMb29rdXAubG9va3VwU3BlY2lhbFBsYWNlbWVudCgpXG4gICAgICovXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFkanVzdG1lbnQgPVxuICAgICAgICBhd2FpdCB0aGlzLnNwZWNpYWxQbGFjZW1lbnRTZXJ2aWNlLmdldFNwZWNpYWxBZGp1c3RtZW50KFxuICAgICAgICAgIG1vdGlvbkRhdGEsXG4gICAgICAgICAgcGljdG9ncmFwaERhdGEsXG4gICAgICAgICAgYXJyb3dDb2xvclxuICAgICAgICApO1xuXG4gICAgICBpZiAoYWRqdXN0bWVudCkge1xuICAgICAgICByZXR1cm4gYWRqdXN0bWVudDtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIG51bGwgaW5zdGVhZCBvZiB0aHJvd2luZyB3aGVuIG5vIHNwZWNpYWwgcGxhY2VtZW50IGZvdW5kXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHNwZWNpYWwgcGxhY2VtZW50IGxvb2t1cDpcIiwgZXJyb3IpO1xuICAgICAgLy8gUmV0dXJuIG51bGwgb24gZXJyb3IgdG8gYWxsb3cgZmFsbGJhY2sgdG8gZGVmYXVsdCBhZGp1c3RtZW50XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNhbGN1bGF0ZURlZmF1bHRBZGp1c3RtZW50KFxuICAgIG1vdGlvbkRhdGE6IE1vdGlvbkRhdGEsXG4gICAgcGljdG9ncmFwaERhdGE6IFBpY3RvZ3JhcGhEYXRhXG4gICk6IFByb21pc2U8UG9pbnQ+IHtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgZGVmYXVsdCBhZGp1c3RtZW50IC0gSURFTlRJQ0FMIHRvIEFycm93QWRqdXN0bWVudExvb2t1cC5cbiAgICAgKi9cbiAgICB0cnkge1xuICAgICAgLy8gQ29tcHV0ZSBncmlkTW9kZSBmcm9tIG1vdGlvbiBkYXRhXG4gICAgICBjb25zdCBkZXJpdmVkR3JpZE1vZGUgPVxuICAgICAgICBwaWN0b2dyYXBoRGF0YS5tb3Rpb25zPy5ibHVlICYmIHBpY3RvZ3JhcGhEYXRhLm1vdGlvbnM/LnJlZFxuICAgICAgICAgID8gdGhpcy5ncmlkTW9kZVNlcnZpY2UuZGVyaXZlR3JpZE1vZGUoXG4gICAgICAgICAgICAgIHBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMuYmx1ZSxcbiAgICAgICAgICAgICAgcGljdG9ncmFwaERhdGEubW90aW9ucy5yZWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IEdyaWRNb2RlLkRJQU1PTkQ7XG5cbiAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCB0aGlzLmRlZmF1bHRQbGFjZW1lbnRTZXJ2aWNlLmdldEF2YWlsYWJsZVBsYWNlbWVudEtleXMoXG4gICAgICAgIG1vdGlvbkRhdGEubW90aW9uVHlwZSBhcyBNb3Rpb25UeXBlVHlwZSxcbiAgICAgICAgZGVyaXZlZEdyaWRNb2RlIGFzIEdyaWRNb2RlXG4gICAgICApO1xuICAgICAgY29uc3QgZGVmYXVsdFBsYWNlbWVudHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAoa2V5cyB8fCBbXSkubWFwKChrKSA9PiBbaywgdHJ1ZV0pXG4gICAgICApO1xuXG4gICAgICBjb25zdCBhdmFpbGFibGVLZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdFBsYWNlbWVudHMgfHwgW10pO1xuXG4gICAgICBjb25zdCBwbGFjZW1lbnRLZXkgPSB0aGlzLnBsYWNlbWVudEtleVNlcnZpY2UuZ2VuZXJhdGVQbGFjZW1lbnRLZXkoXG4gICAgICAgIG1vdGlvbkRhdGEsXG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhLFxuICAgICAgICBhdmFpbGFibGVLZXlzXG4gICAgICApO1xuXG4gICAgICBjb25zdCBhZGp1c3RtZW50UG9pbnQgPVxuICAgICAgICBhd2FpdCB0aGlzLmRlZmF1bHRQbGFjZW1lbnRTZXJ2aWNlLmdldERlZmF1bHRBZGp1c3RtZW50KFxuICAgICAgICAgIHBsYWNlbWVudEtleSxcbiAgICAgICAgICBtb3Rpb25EYXRhLnR1cm5zIHx8IDAsXG4gICAgICAgICAgbW90aW9uRGF0YS5tb3Rpb25UeXBlIGFzIE1vdGlvblR5cGVUeXBlLFxuICAgICAgICAgIGRlcml2ZWRHcmlkTW9kZSBhcyBHcmlkTW9kZVxuICAgICAgICApO1xuXG4gICAgICByZXR1cm4gYWRqdXN0bWVudFBvaW50O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FsY3VsYXRpbmcgZGVmYXVsdCBhZGp1c3RtZW50OlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERlZmF1bHQgYWRqdXN0bWVudCBjYWxjdWxhdGlvbiBmYWlsZWQ6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVEZWZhdWx0VHVwbGVQcm9jZXNzb3IoKTogSURpcmVjdGlvbmFsVHVwbGVQcm9jZXNzb3Ige1xuICAgIC8qKkNyZWF0ZSB0dXBsZSBwcm9jZXNzb3Igd2l0aCBkZWZhdWx0IGRlcGVuZGVuY2llcy4qL1xuICAgIHJldHVybiBuZXcgRGlyZWN0aW9uYWxUdXBsZVByb2Nlc3NvcihcbiAgICAgIG5ldyBEaXJlY3Rpb25hbFR1cGxlQ2FsY3VsYXRvcigpLFxuICAgICAgbmV3IFF1YWRyYW50SW5kZXhDYWxjdWxhdG9yKClcbiAgICApO1xuICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7OztBQWNBLFNBQVMsbUJBQW1CO0FBQzVCLFNBQVMsZ0JBQWdCO0FBRXpCLFNBQVMsYUFBYTtBQUN0QixTQUFTLFFBQVEsa0JBQWtCO0FBQ25DLFNBQVMsZ0NBQWdDO0FBZ0J6QyxTQUFTLDZCQUE2QjtBQUN0QyxTQUFTLHVDQUF1QztBQUNoRCxTQUFTLDhCQUE4QjtBQUN2QyxTQUFTLCtCQUErQjtBQUN4QyxTQUFTLCtCQUErQjtBQUN4QztBQUFBLEVBQ0U7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLE9BRUs7QUFHQSxXQUFNLDRCQUFOLE1BQXNFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT25FO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQTtBQUFBLEVBR0E7QUFBQSxFQUNBO0FBQUEsRUFFUixZQUNrQyxpQkFDaEMsU0FTQTtBQUVBLFNBQUssa0JBQWtCO0FBR3ZCLFNBQUssMEJBQ0gsU0FBUywyQkFBMkIsSUFBSSx3QkFBd0I7QUFDbEUsU0FBSywwQkFDSCxTQUFTLDJCQUEyQixJQUFJLHdCQUF3QjtBQUNsRSxTQUFLLHdCQUNILFNBQVMseUJBQXlCLElBQUksZ0NBQWdDO0FBQ3hFLFNBQUssc0JBQ0gsU0FBUyx1QkFBdUIsSUFBSSx5QkFBeUI7QUFDL0QsU0FBSyxvQkFDSCxTQUFTLHFCQUFxQixJQUFJLHVCQUF1QjtBQUMzRCxTQUFLLHNCQUNILFNBQVMsdUJBQXVCLElBQUksc0JBQXNCO0FBQzVELFNBQUssaUJBQ0gsU0FBUyxrQkFBa0IsS0FBSyw0QkFBNEI7QUFBQSxFQUNoRTtBQUFBLEVBRUEsTUFBTSxvQkFDSixnQkFDQSxZQUNBLFFBQ0EsVUFDQSxZQUNnQjtBQUloQixRQUFJO0FBQ0YsYUFBTyxNQUFNLEtBQUs7QUFBQSxRQUNoQjtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBQUEsSUFDRixTQUFTLE9BQU87QUFFZCxjQUFRLE1BQU0sa0NBQWtDLEtBQUssRUFBRTtBQUN2RCxhQUFPLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRTtBQUFBLElBQ3RCO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBTSwwQkFDSixnQkFDQSxZQUNBLFFBQ0EsVUFDQSxZQUNnQjtBQUtoQixRQUFJO0FBRUYsWUFBTSxpQkFBaUIsTUFBTSxLQUFLO0FBQUEsUUFDaEM7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBR0EsWUFBTSxrQkFBa0IsS0FBSyxlQUFlO0FBQUEsUUFDMUM7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLE1BQ0Y7QUFFQSxhQUFPO0FBQUEsSUFDVCxTQUFTLE9BQU87QUFDZCxjQUFRO0FBQUEsUUFDTiw0Q0FBNEMsTUFBTSxLQUFLLEtBQUs7QUFBQSxNQUM5RDtBQUNBLFlBQU0sSUFBSSxNQUFNLHdDQUF3QyxLQUFLLEVBQUU7QUFBQSxJQUNqRTtBQUFBLEVBQ0Y7QUFBQTtBQUFBLEVBSUEsTUFBYyxrQkFDWixnQkFDQSxZQUNBLFFBQ0EsWUFDZ0I7QUFLaEIsUUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRO0FBQzFCLFlBQU0sSUFBSSxNQUFNLHFEQUFxRDtBQUFBLElBQ3ZFO0FBRUEsUUFBSTtBQUVGLFlBQU0sQ0FBQyxRQUFRLFlBQVksT0FBTyxJQUFJLEtBQUs7QUFBQSxRQUN6QztBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBRUEsY0FBUTtBQUFBLFFBQ04seUJBQXlCLE1BQU0sWUFBWSxVQUFVLFdBQVcsT0FBTztBQUFBLE1BQ3pFO0FBRUEsVUFBSTtBQUNGLGNBQU0sb0JBQW9CLE1BQU0sS0FBSztBQUFBLFVBQ25DO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBRUEsWUFBSSxtQkFBbUI7QUFDckIsaUJBQU87QUFBQSxRQUNUO0FBR0EsZ0JBQVEsTUFBTSxxREFBcUQ7QUFBQSxNQUNyRSxRQUFRO0FBRU4sZ0JBQVE7QUFBQSxVQUNOO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFHQSxZQUFNLG9CQUFvQixNQUFNLEtBQUs7QUFBQSxRQUNuQztBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBQ0EsY0FBUTtBQUFBLFFBQ04sOEJBQThCLGtCQUFrQixFQUFFLFFBQVEsQ0FBQyxDQUFDLEtBQUssa0JBQWtCLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFBQSxNQUNqRztBQUNBLGFBQU87QUFBQSxJQUNULFNBQVMsT0FBTztBQUNkLGNBQVEsTUFBTSxvQ0FBb0MsS0FBSztBQUN2RCxZQUFNLElBQUksTUFBTSxtQ0FBbUMsS0FBSyxFQUFFO0FBQUEsSUFDNUQ7QUFBQSxFQUNGO0FBQUEsRUFFUSxtQkFDTixnQkFDQSxZQUMwQjtBQUUxQixRQUFJO0FBQ0YsWUFBTSxTQUFTLEtBQUssc0JBQXNCO0FBQUEsUUFDeEM7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUNBLFlBQU0sYUFDSixLQUFLLGtCQUFrQixtQkFBbUIsY0FBYztBQUcxRCxZQUFNLFFBQVEsWUFBWTtBQUMxQixZQUFNLFlBQVk7QUFBQSxRQUNoQixJQUFJO0FBQUEsUUFDSixlQUFlO0FBQUEsUUFDZixXQUFXO0FBQUEsUUFDWCxXQUFXO0FBQUEsUUFDWCxlQUFlO0FBQUE7QUFBQSxRQUNmLGFBQWEsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFO0FBQUEsUUFDMUIsV0FBVyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUU7QUFBQSxRQUN4QixhQUFhO0FBQUEsUUFDYixXQUFXO0FBQUEsUUFDWCxZQUFZO0FBQUEsTUFDZDtBQUVBLFlBQU0sVUFBVSxLQUFLLG9CQUFvQjtBQUFBLFFBQ3ZDO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBRUEsYUFBTyxDQUFDLFFBQVEsV0FBVyxLQUFLLEdBQUcsR0FBRyxPQUFPO0FBQUEsSUFDL0MsU0FBUyxPQUFPO0FBQ2QsY0FBUSxNQUFNLG1DQUFtQyxLQUFLO0FBQ3RELFlBQU0sSUFBSSxNQUFNLDBCQUEwQixLQUFLLEVBQUU7QUFBQSxJQUNuRDtBQUFBLEVBQ0Y7QUFBQSxFQUVBLE1BQWMsdUJBQ1osWUFDQSxnQkFDQSxZQUN1QjtBQUt2QixRQUFJO0FBQ0YsWUFBTSxhQUNKLE1BQU0sS0FBSyx3QkFBd0I7QUFBQSxRQUNqQztBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUVGLFVBQUksWUFBWTtBQUNkLGVBQU87QUFBQSxNQUNUO0FBR0EsYUFBTztBQUFBLElBQ1QsU0FBUyxPQUFPO0FBQ2QsY0FBUSxNQUFNLHNDQUFzQyxLQUFLO0FBRXpELGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBYywyQkFDWixZQUNBLGdCQUNnQjtBQUloQixRQUFJO0FBRUYsWUFBTSxrQkFDSixlQUFlLFNBQVMsUUFBUSxlQUFlLFNBQVMsTUFDcEQsS0FBSyxnQkFBZ0I7QUFBQSxRQUNuQixlQUFlLFFBQVE7QUFBQSxRQUN2QixlQUFlLFFBQVE7QUFBQSxNQUN6QixJQUNBLFNBQVM7QUFFZixZQUFNLE9BQU8sTUFBTSxLQUFLLHdCQUF3QjtBQUFBLFFBQzlDLFdBQVc7QUFBQSxRQUNYO0FBQUEsTUFDRjtBQUNBLFlBQU0sb0JBQTZDLE9BQU87QUFBQSxTQUN2RCxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQUEsTUFDbkM7QUFFQSxZQUFNLGdCQUFnQixPQUFPLEtBQUsscUJBQXFCLENBQUMsQ0FBQztBQUV6RCxZQUFNLGVBQWUsS0FBSyxvQkFBb0I7QUFBQSxRQUM1QztBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUVBLFlBQU0sa0JBQ0osTUFBTSxLQUFLLHdCQUF3QjtBQUFBLFFBQ2pDO0FBQUEsUUFDQSxXQUFXLFNBQVM7QUFBQSxRQUNwQixXQUFXO0FBQUEsUUFDWDtBQUFBLE1BQ0Y7QUFFRixhQUFPO0FBQUEsSUFDVCxTQUFTLE9BQU87QUFDZCxjQUFRLE1BQU0seUNBQXlDLEtBQUs7QUFDNUQsWUFBTSxJQUFJLE1BQU0sMENBQTBDLEtBQUssRUFBRTtBQUFBLElBQ25FO0FBQUEsRUFDRjtBQUFBLEVBRVEsOEJBQTBEO0FBRWhFLFdBQU8sSUFBSTtBQUFBLE1BQ1QsSUFBSSwyQkFBMkI7QUFBQSxNQUMvQixJQUFJLHdCQUF3QjtBQUFBLElBQzlCO0FBQUEsRUFDRjtBQUNGO0FBM1NhLDRCQUFOO0FBQUEsRUFETixXQUFXO0FBQUEsRUFvQlAsMEJBQU8sTUFBTSxnQkFBZ0I7QUFBQSxHQW5CckI7IiwKICAibmFtZXMiOiBbXQp9Cg==
