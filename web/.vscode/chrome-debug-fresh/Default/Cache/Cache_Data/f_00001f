var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
import { GridMode, GridPositionGroup, PropType } from "/src/lib/domain/index.ts";
import { injectable } from "/node_modules/.vite/deps/inversify.js?v=608ae08a";
import { createSequenceData } from "/src/lib/domain/SequenceData.ts";
import {
  FilterType as FilterTypeEnum,
  SortMethod as SortMethodEnum
} from "/src/lib/domain/browse/index.ts";
export let BrowseService = class {
  cachedSequences = null;
  /**
   * âœ… PERMANENT: Validate sequence metadata to prevent malformed data
   */
  isValidSequenceMetadata(sequence) {
    const word = sequence.word || sequence.name || sequence.id || "";
    return word.length > 0 && word.length <= 200 && // Increased limit for complex sequences
    !word.toLowerCase().includes("test");
  }
  async loadSequenceMetadata() {
    console.log("ðŸ” BrowseService.loadSequenceMetadata() called");
    if (this.cachedSequences !== null) {
      console.log(
        "ðŸ“¦ Returning cached sequences:",
        this.cachedSequences.length,
        "items"
      );
      return this.cachedSequences;
    }
    try {
      console.log("ðŸ”„ Loading from sequence index...");
      const sequences = await this.loadFromSequenceIndex();
      console.log(
        "âœ… Successfully loaded from sequence index:",
        sequences.length,
        "sequences"
      );
      console.log(
        "ðŸ“‹ Sequence IDs:",
        sequences.map((s) => s.id)
      );
      const validSequences = sequences.filter((seq) => {
        const isValid = this.isValidSequenceMetadata(seq);
        if (!isValid) {
          console.warn(
            `Filtered out invalid sequence: ${seq.word || seq.name || seq.id}`
          );
        }
        return isValid;
      });
      console.log(
        `ðŸ” Filtered ${sequences.length - validSequences.length} invalid sequences`
      );
      this.cachedSequences = validSequences;
      return validSequences;
    } catch (error) {
      console.warn(
        "âŒ Failed to load sequence index, generating from dictionary:",
        error
      );
      const sequences = await this.generateSequenceIndex();
      console.log(
        "ðŸ”§ Generated sequences as fallback:",
        sequences.length,
        "sequences"
      );
      this.cachedSequences = sequences;
      return sequences;
    }
  }
  async applyFilter(sequences, filterType, filterValue) {
    console.log("ðŸ” BrowseService.applyFilter() called with:");
    console.log("  - filterType:", filterType);
    console.log("  - filterValue:", filterValue);
    console.log("  - input sequences:", sequences.length, "items");
    if (filterType === FilterTypeEnum.ALL_SEQUENCES) {
      console.log(
        "âœ… ALL_SEQUENCES filter detected - returning all sequences:",
        sequences.length
      );
      return sequences;
    }
    console.log("ðŸ”„ Applying specific filter...");
    let filtered;
    switch (filterType) {
      case FilterTypeEnum.STARTING_LETTER:
        filtered = this.filterByStartingLetter(sequences, filterValue);
        break;
      case FilterTypeEnum.CONTAINS_LETTERS:
        filtered = this.filterByContainsLetters(sequences, filterValue);
        break;
      case FilterTypeEnum.LENGTH:
        filtered = this.filterByLength(sequences, filterValue);
        break;
      case FilterTypeEnum.DIFFICULTY:
        filtered = this.filterByDifficulty(sequences, filterValue);
        break;
      case FilterTypeEnum.startPosition:
        filtered = this.filterByStartingPosition(sequences, filterValue);
        break;
      case FilterTypeEnum.AUTHOR:
        filtered = this.filterByAuthor(sequences, filterValue);
        break;
      case FilterTypeEnum.GRID_MODE:
        filtered = this.filterByGridMode(sequences, filterValue);
        break;
      case FilterTypeEnum.FAVORITES:
        filtered = sequences.filter((s) => s.isFavorite);
        break;
      case FilterTypeEnum.RECENT:
        filtered = this.filterByRecent(sequences);
        break;
      default:
        console.log("âš ï¸ Unknown filter type, returning all sequences");
        filtered = sequences;
    }
    console.log(
      "ðŸ“Š Filter result:",
      filtered.length,
      "sequences after filtering"
    );
    return filtered;
  }
  async sortSequences(sequences, sortMethod) {
    const sorted = [...sequences];
    switch (sortMethod) {
      case SortMethodEnum.ALPHABETICAL:
        return sorted.sort((a, b) => a.word.localeCompare(b.word));
      case SortMethodEnum.dateAdded:
        return sorted.sort((a, b) => {
          const dateA = a.dateAdded || /* @__PURE__ */ new Date(0);
          const dateB = b.dateAdded || /* @__PURE__ */ new Date(0);
          return dateB.getTime() - dateA.getTime();
        });
      case SortMethodEnum.difficultyLevel:
        return sorted.sort((a, b) => {
          const levelA = this.getDifficultyOrder(a.difficultyLevel);
          const levelB = this.getDifficultyOrder(b.difficultyLevel);
          return levelA - levelB;
        });
      case SortMethodEnum.sequenceLength:
        return sorted.sort(
          (a, b) => (a.sequenceLength || 0) - (b.sequenceLength || 0)
        );
      case SortMethodEnum.AUTHOR:
        return sorted.sort(
          (a, b) => (a.author || "").localeCompare(b.author || "")
        );
      case SortMethodEnum.POPULARITY:
        return sorted.sort(
          (a, b) => Number(b.isFavorite) - Number(a.isFavorite)
        );
      default:
        return sorted;
    }
  }
  async groupSequencesIntoSections(sequences, sortMethod) {
    const sections = {};
    for (const sequence of sequences) {
      const sectionKey = this.getSectionKey(sequence, sortMethod);
      if (!sections[sectionKey]) {
        sections[sectionKey] = [];
      }
      sections[sectionKey].push(sequence);
    }
    return sections;
  }
  async getUniqueValues(field) {
    const sequences = await this.loadSequenceMetadata();
    const values = /* @__PURE__ */ new Set();
    for (const sequence of sequences) {
      const value = sequence[field];
      if (value != null) {
        values.add(String(value));
      }
    }
    return Array.from(values).sort();
  }
  async getFilterOptions(filterType) {
    switch (filterType) {
      case FilterTypeEnum.STARTING_LETTER:
        return ["A-D", "E-H", "I-L", "M-P", "Q-T", "U-Z"];
      case FilterTypeEnum.LENGTH:
        return ["3", "4", "5", "6", "7", "8+"];
      case FilterTypeEnum.DIFFICULTY:
        return ["beginner", "intermediate", "advanced"];
      case FilterTypeEnum.AUTHOR:
        return this.getUniqueValues("author");
      case FilterTypeEnum.GRID_MODE:
        return [GridMode.DIAMOND, GridMode.BOX];
      default:
        return [];
    }
  }
  // Private helper methods
  async loadFromSequenceIndex() {
    console.log("ðŸŒ Fetching sequence-index.json...");
    const response = await fetch("/sequence-index.json");
    console.log("ðŸŒ Response status:", response.status, response.statusText);
    if (!response.ok) {
      throw new Error(`Failed to load sequence index: ${response.status}`);
    }
    const data = await response.json();
    console.log("ðŸ“„ Loaded sequence index data:", data);
    console.log("ðŸ“„ Total sequences in index:", data.totalSequences);
    console.log("ðŸ“„ Sequences array length:", data.sequences?.length || 0);
    const rawSequences = data.sequences || [];
    const sequences = rawSequences.filter((seq) => {
      const word = seq.word || seq.name || seq.id;
      if (!word || typeof word === "string" && word.length === 0) {
        console.warn(
          `ðŸš« Filtering sequence with no word: ${JSON.stringify(seq)}`
        );
        return false;
      }
      return true;
    }).map((seq) => {
      let gridMode = seq.gridMode;
      if (typeof gridMode === "string") {
        if (gridMode === "GridMode.DIAMOND" || gridMode === "diamond") {
          gridMode = GridMode.DIAMOND;
        } else if (gridMode === "GridMode.BOX" || gridMode === "box") {
          gridMode = GridMode.BOX;
        }
      }
      let dateAdded = seq.dateAdded;
      if (typeof dateAdded === "string") {
        dateAdded = new Date(dateAdded);
      }
      const result = createSequenceData({
        id: String(seq.id || seq.word || seq.name),
        name: String(seq.name || `${seq.word} Sequence`),
        word: String(seq.word || seq.name || seq.id),
        beats: [],
        // BrowseService doesn't load full beat data
        thumbnails: Array.isArray(seq.thumbnails) ? seq.thumbnails : [],
        isFavorite: Boolean(seq.isFavorite),
        isCircular: Boolean(seq.isCircular),
        tags: Array.isArray(seq.tags) ? seq.tags : ["flow", "practice"],
        metadata: typeof seq.metadata === "object" && seq.metadata !== null ? seq.metadata : { source: "tka_dictionary" },
        // Optional properties
        ...seq.author && typeof seq.author === "string" ? { author: seq.author } : {},
        ...gridMode && typeof gridMode === "string" ? { gridMode } : {},
        ...seq.difficultyLevel && typeof seq.difficultyLevel === "string" ? {
          difficultyLevel: seq.difficultyLevel
        } : {},
        ...seq.sequenceLength && typeof seq.sequenceLength === "number" ? {
          sequenceLength: seq.sequenceLength
        } : {},
        ...seq.level && typeof seq.level === "number" ? { level: seq.level } : {},
        ...dateAdded instanceof Date ? { dateAdded } : {},
        ...seq.propType && typeof seq.propType === "string" ? { propType: seq.propType } : {},
        ...seq.startingPosition && typeof seq.startingPosition === "string" ? {
          startingPositionGroup: seq.startingPosition
        } : {}
      });
      return result;
    });
    console.log(
      `ðŸ“¦ Processed ${sequences.length} real sequences from dictionary`
    );
    console.log(
      "ðŸ“‹ Sample sequence IDs:",
      sequences.slice(0, 10).map((s) => s.id)
    );
    return sequences;
  }
  async generateSequenceIndex() {
    console.log("ðŸ”§ Scanning dictionary folder to generate sequence index...");
    try {
      const sequences = [];
      console.warn(
        "âš ï¸ Dictionary scanning not implemented - please ensure sequence-index.json is up to date"
      );
      return sequences;
    } catch (error) {
      console.error("âŒ Failed to scan dictionary folder:", error);
      return [];
    }
  }
  filterByStartingLetter(sequences, filterValue) {
    if (!filterValue || typeof filterValue !== "string") return sequences;
    if (filterValue.includes("-")) {
      const [start, end] = filterValue.split("-");
      return sequences.filter((s) => {
        const firstLetter = s.word[0]?.toUpperCase();
        return firstLetter && start && end && firstLetter >= start && firstLetter <= end;
      });
    }
    return sequences.filter(
      (s) => s.word[0]?.toUpperCase() === filterValue.toUpperCase()
    );
  }
  filterByContainsLetters(sequences, filterValue) {
    if (!filterValue || typeof filterValue !== "string") return sequences;
    return sequences.filter(
      (s) => s.word.toLowerCase().includes(filterValue.toLowerCase())
    );
  }
  filterByLength(sequences, filterValue) {
    if (!filterValue) return sequences;
    if (filterValue === "8+") {
      return sequences.filter((s) => (s.sequenceLength || 0) >= 8);
    }
    const length = parseInt(String(filterValue));
    if (isNaN(length)) return sequences;
    return sequences.filter((s) => s.sequenceLength === length);
  }
  filterByDifficulty(sequences, filterValue) {
    if (!filterValue) return sequences;
    return sequences.filter((s) => s.difficultyLevel === filterValue);
  }
  filterByStartingPosition(sequences, filterValue) {
    if (!filterValue) return sequences;
    return sequences.filter((s) => s.startingPositionGroup === filterValue);
  }
  filterByAuthor(sequences, filterValue) {
    if (!filterValue) return sequences;
    return sequences.filter((s) => s.author === filterValue);
  }
  filterByGridMode(sequences, filterValue) {
    if (!filterValue) return sequences;
    return sequences.filter((s) => s.gridMode === filterValue);
  }
  filterByRecent(sequences) {
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3);
    return sequences.filter((s) => {
      const dateAdded = s.dateAdded || /* @__PURE__ */ new Date(0);
      return dateAdded >= thirtyDaysAgo;
    });
  }
  getDifficultyOrder(difficulty) {
    switch (difficulty) {
      case "beginner":
        return 1;
      case "intermediate":
        return 2;
      case "advanced":
        return 3;
      default:
        return 0;
    }
  }
  getSectionKey(sequence, sortMethod) {
    switch (sortMethod) {
      case SortMethodEnum.ALPHABETICAL:
        return sequence.word[0]?.toUpperCase() || "#";
      case SortMethodEnum.difficultyLevel:
        return sequence.difficultyLevel || "Unknown";
      case SortMethodEnum.AUTHOR:
        return sequence.author || "Unknown";
      case SortMethodEnum.sequenceLength: {
        const length = sequence.sequenceLength || 0;
        if (length <= 4) return "3-4 beats";
        if (length <= 6) return "5-6 beats";
        if (length <= 8) return "7-8 beats";
        return "9+ beats";
      }
      default:
        return "All";
    }
  }
  clearCache() {
    this.cachedSequences = null;
  }
};
BrowseService = __decorateClass([
  injectable()
], BrowseService);
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3NlcnZpY2VzL2ltcGxlbWVudGF0aW9ucy9icm93c2UvQnJvd3NlU2VydmljZS50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyoqXG4gKiBCcm93c2UgU2VydmljZSBJbXBsZW1lbnRhdGlvblxuICpcbiAqIEhhbmRsZXMgbG9hZGluZywgZmlsdGVyaW5nLCBhbmQgc29ydGluZyBvZiBzZXF1ZW5jZSBtZXRhZGF0YSBmb3IgdGhlIGJyb3dzZSB0YWIuXG4gKiBQb3J0ZWQgYW5kIGFkYXB0ZWQgZnJvbSBkZXNrdG9wIGFwcCdzIEJyb3dzZVNlcnZpY2UuXG4gKi9cblxuaW1wb3J0IHsgR3JpZE1vZGUsIEdyaWRQb3NpdGlvbkdyb3VwLCBQcm9wVHlwZSB9IGZyb20gXCIkbGliL2RvbWFpblwiO1xuaW1wb3J0IHsgaW5qZWN0YWJsZSB9IGZyb20gXCJpbnZlcnNpZnlcIjtcbmltcG9ydCB0eXBlIHsgU2VxdWVuY2VEYXRhIH0gZnJvbSBcIiRsaWIvZG9tYWluL1NlcXVlbmNlRGF0YVwiO1xuaW1wb3J0IHsgY3JlYXRlU2VxdWVuY2VEYXRhIH0gZnJvbSBcIiRsaWIvZG9tYWluL1NlcXVlbmNlRGF0YVwiO1xuaW1wb3J0IHtcbiAgRmlsdGVyVHlwZSBhcyBGaWx0ZXJUeXBlRW51bSxcbiAgU29ydE1ldGhvZCBhcyBTb3J0TWV0aG9kRW51bSxcbn0gZnJvbSBcIiRsaWIvZG9tYWluL2Jyb3dzZVwiO1xuaW1wb3J0IHR5cGUge1xuICBGaWx0ZXJUeXBlLFxuICBGaWx0ZXJWYWx1ZSxcbiAgU29ydE1ldGhvZCxcbn0gZnJvbSBcIiRsaWIvc2VydmljZXMvaW50ZXJmYWNlcy9kb21haW4tdHlwZXNcIjtcbmltcG9ydCB0eXBlIHsgSUJyb3dzZVNlcnZpY2UgfSBmcm9tIFwiJGxpYi9zZXJ2aWNlcy9pbnRlcmZhY2VzL2Jyb3dzZS1pbnRlcmZhY2VzXCI7XG5cbkBpbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBCcm93c2VTZXJ2aWNlIGltcGxlbWVudHMgSUJyb3dzZVNlcnZpY2Uge1xuICBwcml2YXRlIGNhY2hlZFNlcXVlbmNlczogU2VxdWVuY2VEYXRhW10gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICog4pyFIFBFUk1BTkVOVDogVmFsaWRhdGUgc2VxdWVuY2UgbWV0YWRhdGEgdG8gcHJldmVudCBtYWxmb3JtZWQgZGF0YVxuICAgKi9cbiAgcHJpdmF0ZSBpc1ZhbGlkU2VxdWVuY2VNZXRhZGF0YShzZXF1ZW5jZTogU2VxdWVuY2VEYXRhKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgd29yZCA9IHNlcXVlbmNlLndvcmQgfHwgc2VxdWVuY2UubmFtZSB8fCBzZXF1ZW5jZS5pZCB8fCBcIlwiO1xuXG4gICAgLy8gQmFzaWMgdmFsaWRhdGlvbiBmb3IgcmVhbCBkaWN0aW9uYXJ5IHNlcXVlbmNlc1xuICAgIHJldHVybiAoXG4gICAgICB3b3JkLmxlbmd0aCA+IDAgJiZcbiAgICAgIHdvcmQubGVuZ3RoIDw9IDIwMCAmJiAvLyBJbmNyZWFzZWQgbGltaXQgZm9yIGNvbXBsZXggc2VxdWVuY2VzXG4gICAgICAhd29yZC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwidGVzdFwiKSAvLyBObyB0ZXN0IHNlcXVlbmNlc1xuICAgICk7XG4gIH1cblxuICBhc3luYyBsb2FkU2VxdWVuY2VNZXRhZGF0YSgpOiBQcm9taXNlPFNlcXVlbmNlRGF0YVtdPiB7XG4gICAgY29uc29sZS5sb2coXCLwn5SNIEJyb3dzZVNlcnZpY2UubG9hZFNlcXVlbmNlTWV0YWRhdGEoKSBjYWxsZWRcIik7XG5cbiAgICBpZiAodGhpcy5jYWNoZWRTZXF1ZW5jZXMgIT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBcIvCfk6YgUmV0dXJuaW5nIGNhY2hlZCBzZXF1ZW5jZXM6XCIsXG4gICAgICAgIHRoaXMuY2FjaGVkU2VxdWVuY2VzLmxlbmd0aCxcbiAgICAgICAgXCJpdGVtc1wiXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkU2VxdWVuY2VzO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgdG8gbG9hZCBmcm9tIHNlcXVlbmNlIGluZGV4IGZpcnN0XG4gICAgICBjb25zb2xlLmxvZyhcIvCflIQgTG9hZGluZyBmcm9tIHNlcXVlbmNlIGluZGV4Li4uXCIpO1xuICAgICAgY29uc3Qgc2VxdWVuY2VzID0gYXdhaXQgdGhpcy5sb2FkRnJvbVNlcXVlbmNlSW5kZXgoKTtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBcIuKchSBTdWNjZXNzZnVsbHkgbG9hZGVkIGZyb20gc2VxdWVuY2UgaW5kZXg6XCIsXG4gICAgICAgIHNlcXVlbmNlcy5sZW5ndGgsXG4gICAgICAgIFwic2VxdWVuY2VzXCJcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgXCLwn5OLIFNlcXVlbmNlIElEczpcIixcbiAgICAgICAgc2VxdWVuY2VzLm1hcCgocykgPT4gcy5pZClcbiAgICAgICk7XG5cbiAgICAgIC8vIOKchSBQRVJNQU5FTlQ6IEZpbHRlciBvdXQgaW52YWxpZCBzZXF1ZW5jZXNcbiAgICAgIGNvbnN0IHZhbGlkU2VxdWVuY2VzID0gc2VxdWVuY2VzLmZpbHRlcigoc2VxKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSB0aGlzLmlzVmFsaWRTZXF1ZW5jZU1ldGFkYXRhKHNlcSk7XG4gICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBGaWx0ZXJlZCBvdXQgaW52YWxpZCBzZXF1ZW5jZTogJHtzZXEud29yZCB8fCBzZXEubmFtZSB8fCBzZXEuaWR9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGDwn5SNIEZpbHRlcmVkICR7c2VxdWVuY2VzLmxlbmd0aCAtIHZhbGlkU2VxdWVuY2VzLmxlbmd0aH0gaW52YWxpZCBzZXF1ZW5jZXNgXG4gICAgICApO1xuXG4gICAgICB0aGlzLmNhY2hlZFNlcXVlbmNlcyA9IHZhbGlkU2VxdWVuY2VzO1xuICAgICAgcmV0dXJuIHZhbGlkU2VxdWVuY2VzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwi4p2MIEZhaWxlZCB0byBsb2FkIHNlcXVlbmNlIGluZGV4LCBnZW5lcmF0aW5nIGZyb20gZGljdGlvbmFyeTpcIixcbiAgICAgICAgZXJyb3JcbiAgICAgICk7XG4gICAgICAvLyBGYWxsYmFjayB0byBzY2FubmluZyBkaWN0aW9uYXJ5IGZvbGRlcnNcbiAgICAgIGNvbnN0IHNlcXVlbmNlcyA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVTZXF1ZW5jZUluZGV4KCk7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgXCLwn5SnIEdlbmVyYXRlZCBzZXF1ZW5jZXMgYXMgZmFsbGJhY2s6XCIsXG4gICAgICAgIHNlcXVlbmNlcy5sZW5ndGgsXG4gICAgICAgIFwic2VxdWVuY2VzXCJcbiAgICAgICk7XG4gICAgICB0aGlzLmNhY2hlZFNlcXVlbmNlcyA9IHNlcXVlbmNlcztcbiAgICAgIHJldHVybiBzZXF1ZW5jZXM7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgYXBwbHlGaWx0ZXIoXG4gICAgc2VxdWVuY2VzOiBTZXF1ZW5jZURhdGFbXSxcbiAgICBmaWx0ZXJUeXBlOiBGaWx0ZXJUeXBlLFxuICAgIGZpbHRlclZhbHVlOiBGaWx0ZXJWYWx1ZVxuICApOiBQcm9taXNlPFNlcXVlbmNlRGF0YVtdPiB7XG4gICAgY29uc29sZS5sb2coXCLwn5SNIEJyb3dzZVNlcnZpY2UuYXBwbHlGaWx0ZXIoKSBjYWxsZWQgd2l0aDpcIik7XG4gICAgY29uc29sZS5sb2coXCIgIC0gZmlsdGVyVHlwZTpcIiwgZmlsdGVyVHlwZSk7XG4gICAgY29uc29sZS5sb2coXCIgIC0gZmlsdGVyVmFsdWU6XCIsIGZpbHRlclZhbHVlKTtcbiAgICBjb25zb2xlLmxvZyhcIiAgLSBpbnB1dCBzZXF1ZW5jZXM6XCIsIHNlcXVlbmNlcy5sZW5ndGgsIFwiaXRlbXNcIik7XG5cbiAgICBpZiAoZmlsdGVyVHlwZSA9PT0gRmlsdGVyVHlwZUVudW0uQUxMX1NFUVVFTkNFUykge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIFwi4pyFIEFMTF9TRVFVRU5DRVMgZmlsdGVyIGRldGVjdGVkIC0gcmV0dXJuaW5nIGFsbCBzZXF1ZW5jZXM6XCIsXG4gICAgICAgIHNlcXVlbmNlcy5sZW5ndGhcbiAgICAgICk7XG4gICAgICByZXR1cm4gc2VxdWVuY2VzO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFwi8J+UhCBBcHBseWluZyBzcGVjaWZpYyBmaWx0ZXIuLi5cIik7XG4gICAgbGV0IGZpbHRlcmVkOiBTZXF1ZW5jZURhdGFbXTtcblxuICAgIHN3aXRjaCAoZmlsdGVyVHlwZSkge1xuICAgICAgY2FzZSBGaWx0ZXJUeXBlRW51bS5TVEFSVElOR19MRVRURVI6XG4gICAgICAgIGZpbHRlcmVkID0gdGhpcy5maWx0ZXJCeVN0YXJ0aW5nTGV0dGVyKHNlcXVlbmNlcywgZmlsdGVyVmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRmlsdGVyVHlwZUVudW0uQ09OVEFJTlNfTEVUVEVSUzpcbiAgICAgICAgZmlsdGVyZWQgPSB0aGlzLmZpbHRlckJ5Q29udGFpbnNMZXR0ZXJzKHNlcXVlbmNlcywgZmlsdGVyVmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRmlsdGVyVHlwZUVudW0uTEVOR1RIOlxuICAgICAgICBmaWx0ZXJlZCA9IHRoaXMuZmlsdGVyQnlMZW5ndGgoc2VxdWVuY2VzLCBmaWx0ZXJWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGaWx0ZXJUeXBlRW51bS5ESUZGSUNVTFRZOlxuICAgICAgICBmaWx0ZXJlZCA9IHRoaXMuZmlsdGVyQnlEaWZmaWN1bHR5KHNlcXVlbmNlcywgZmlsdGVyVmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRmlsdGVyVHlwZUVudW0uc3RhcnRQb3NpdGlvbjpcbiAgICAgICAgZmlsdGVyZWQgPSB0aGlzLmZpbHRlckJ5U3RhcnRpbmdQb3NpdGlvbihzZXF1ZW5jZXMsIGZpbHRlclZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZpbHRlclR5cGVFbnVtLkFVVEhPUjpcbiAgICAgICAgZmlsdGVyZWQgPSB0aGlzLmZpbHRlckJ5QXV0aG9yKHNlcXVlbmNlcywgZmlsdGVyVmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRmlsdGVyVHlwZUVudW0uR1JJRF9NT0RFOlxuICAgICAgICBmaWx0ZXJlZCA9IHRoaXMuZmlsdGVyQnlHcmlkTW9kZShzZXF1ZW5jZXMsIGZpbHRlclZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZpbHRlclR5cGVFbnVtLkZBVk9SSVRFUzpcbiAgICAgICAgZmlsdGVyZWQgPSBzZXF1ZW5jZXMuZmlsdGVyKChzKSA9PiBzLmlzRmF2b3JpdGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRmlsdGVyVHlwZUVudW0uUkVDRU5UOlxuICAgICAgICBmaWx0ZXJlZCA9IHRoaXMuZmlsdGVyQnlSZWNlbnQoc2VxdWVuY2VzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLmxvZyhcIuKaoO+4jyBVbmtub3duIGZpbHRlciB0eXBlLCByZXR1cm5pbmcgYWxsIHNlcXVlbmNlc1wiKTtcbiAgICAgICAgZmlsdGVyZWQgPSBzZXF1ZW5jZXM7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coXG4gICAgICBcIvCfk4ogRmlsdGVyIHJlc3VsdDpcIixcbiAgICAgIGZpbHRlcmVkLmxlbmd0aCxcbiAgICAgIFwic2VxdWVuY2VzIGFmdGVyIGZpbHRlcmluZ1wiXG4gICAgKTtcbiAgICByZXR1cm4gZmlsdGVyZWQ7XG4gIH1cblxuICBhc3luYyBzb3J0U2VxdWVuY2VzKFxuICAgIHNlcXVlbmNlczogU2VxdWVuY2VEYXRhW10sXG4gICAgc29ydE1ldGhvZDogU29ydE1ldGhvZFxuICApOiBQcm9taXNlPFNlcXVlbmNlRGF0YVtdPiB7XG4gICAgY29uc3Qgc29ydGVkID0gWy4uLnNlcXVlbmNlc107XG5cbiAgICBzd2l0Y2ggKHNvcnRNZXRob2QpIHtcbiAgICAgIGNhc2UgU29ydE1ldGhvZEVudW0uQUxQSEFCRVRJQ0FMOlxuICAgICAgICByZXR1cm4gc29ydGVkLnNvcnQoKGEsIGIpID0+IGEud29yZC5sb2NhbGVDb21wYXJlKGIud29yZCkpO1xuICAgICAgY2FzZSBTb3J0TWV0aG9kRW51bS5kYXRlQWRkZWQ6XG4gICAgICAgIHJldHVybiBzb3J0ZWQuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGVBID0gYS5kYXRlQWRkZWQgfHwgbmV3IERhdGUoMCk7XG4gICAgICAgICAgY29uc3QgZGF0ZUIgPSBiLmRhdGVBZGRlZCB8fCBuZXcgRGF0ZSgwKTtcbiAgICAgICAgICByZXR1cm4gZGF0ZUIuZ2V0VGltZSgpIC0gZGF0ZUEuZ2V0VGltZSgpO1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgU29ydE1ldGhvZEVudW0uZGlmZmljdWx0eUxldmVsOlxuICAgICAgICByZXR1cm4gc29ydGVkLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICBjb25zdCBsZXZlbEEgPSB0aGlzLmdldERpZmZpY3VsdHlPcmRlcihhLmRpZmZpY3VsdHlMZXZlbCk7XG4gICAgICAgICAgY29uc3QgbGV2ZWxCID0gdGhpcy5nZXREaWZmaWN1bHR5T3JkZXIoYi5kaWZmaWN1bHR5TGV2ZWwpO1xuICAgICAgICAgIHJldHVybiBsZXZlbEEgLSBsZXZlbEI7XG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBTb3J0TWV0aG9kRW51bS5zZXF1ZW5jZUxlbmd0aDpcbiAgICAgICAgcmV0dXJuIHNvcnRlZC5zb3J0KFxuICAgICAgICAgIChhLCBiKSA9PiAoYS5zZXF1ZW5jZUxlbmd0aCB8fCAwKSAtIChiLnNlcXVlbmNlTGVuZ3RoIHx8IDApXG4gICAgICAgICk7XG4gICAgICBjYXNlIFNvcnRNZXRob2RFbnVtLkFVVEhPUjpcbiAgICAgICAgcmV0dXJuIHNvcnRlZC5zb3J0KChhLCBiKSA9PlxuICAgICAgICAgIChhLmF1dGhvciB8fCBcIlwiKS5sb2NhbGVDb21wYXJlKGIuYXV0aG9yIHx8IFwiXCIpXG4gICAgICAgICk7XG4gICAgICBjYXNlIFNvcnRNZXRob2RFbnVtLlBPUFVMQVJJVFk6XG4gICAgICAgIHJldHVybiBzb3J0ZWQuc29ydChcbiAgICAgICAgICAoYSwgYikgPT4gTnVtYmVyKGIuaXNGYXZvcml0ZSkgLSBOdW1iZXIoYS5pc0Zhdm9yaXRlKVxuICAgICAgICApO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHNvcnRlZDtcbiAgICB9XG4gIH1cblxuICBhc3luYyBncm91cFNlcXVlbmNlc0ludG9TZWN0aW9ucyhcbiAgICBzZXF1ZW5jZXM6IFNlcXVlbmNlRGF0YVtdLFxuICAgIHNvcnRNZXRob2Q6IFNvcnRNZXRob2RcbiAgKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBTZXF1ZW5jZURhdGFbXT4+IHtcbiAgICBjb25zdCBzZWN0aW9uczogUmVjb3JkPHN0cmluZywgU2VxdWVuY2VEYXRhW10+ID0ge307XG5cbiAgICBmb3IgKGNvbnN0IHNlcXVlbmNlIG9mIHNlcXVlbmNlcykge1xuICAgICAgY29uc3Qgc2VjdGlvbktleSA9IHRoaXMuZ2V0U2VjdGlvbktleShzZXF1ZW5jZSwgc29ydE1ldGhvZCk7XG4gICAgICBpZiAoIXNlY3Rpb25zW3NlY3Rpb25LZXldKSB7XG4gICAgICAgIHNlY3Rpb25zW3NlY3Rpb25LZXldID0gW107XG4gICAgICB9XG4gICAgICBzZWN0aW9uc1tzZWN0aW9uS2V5XS5wdXNoKHNlcXVlbmNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvbnM7XG4gIH1cblxuICBhc3luYyBnZXRVbmlxdWVWYWx1ZXMoZmllbGQ6IGtleW9mIFNlcXVlbmNlRGF0YSk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCBzZXF1ZW5jZXMgPSBhd2FpdCB0aGlzLmxvYWRTZXF1ZW5jZU1ldGFkYXRhKCk7XG4gICAgY29uc3QgdmFsdWVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgICBmb3IgKGNvbnN0IHNlcXVlbmNlIG9mIHNlcXVlbmNlcykge1xuICAgICAgY29uc3QgdmFsdWUgPSBzZXF1ZW5jZVtmaWVsZF07XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YWx1ZXMuYWRkKFN0cmluZyh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBBcnJheS5mcm9tKHZhbHVlcykuc29ydCgpO1xuICB9XG5cbiAgYXN5bmMgZ2V0RmlsdGVyT3B0aW9ucyhmaWx0ZXJUeXBlOiBGaWx0ZXJUeXBlKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHN3aXRjaCAoZmlsdGVyVHlwZSkge1xuICAgICAgY2FzZSBGaWx0ZXJUeXBlRW51bS5TVEFSVElOR19MRVRURVI6XG4gICAgICAgIHJldHVybiBbXCJBLURcIiwgXCJFLUhcIiwgXCJJLUxcIiwgXCJNLVBcIiwgXCJRLVRcIiwgXCJVLVpcIl07XG4gICAgICBjYXNlIEZpbHRlclR5cGVFbnVtLkxFTkdUSDpcbiAgICAgICAgcmV0dXJuIFtcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOCtcIl07XG4gICAgICBjYXNlIEZpbHRlclR5cGVFbnVtLkRJRkZJQ1VMVFk6XG4gICAgICAgIHJldHVybiBbXCJiZWdpbm5lclwiLCBcImludGVybWVkaWF0ZVwiLCBcImFkdmFuY2VkXCJdO1xuICAgICAgY2FzZSBGaWx0ZXJUeXBlRW51bS5BVVRIT1I6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVuaXF1ZVZhbHVlcyhcImF1dGhvclwiKTtcbiAgICAgIGNhc2UgRmlsdGVyVHlwZUVudW0uR1JJRF9NT0RFOlxuICAgICAgICByZXR1cm4gW0dyaWRNb2RlLkRJQU1PTkQsIEdyaWRNb2RlLkJPWF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLy8gUHJpdmF0ZSBoZWxwZXIgbWV0aG9kc1xuICBwcml2YXRlIGFzeW5jIGxvYWRGcm9tU2VxdWVuY2VJbmRleCgpOiBQcm9taXNlPFNlcXVlbmNlRGF0YVtdPiB7XG4gICAgY29uc29sZS5sb2coXCLwn4yQIEZldGNoaW5nIHNlcXVlbmNlLWluZGV4Lmpzb24uLi5cIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9zZXF1ZW5jZS1pbmRleC5qc29uXCIpO1xuICAgIGNvbnNvbGUubG9nKFwi8J+MkCBSZXNwb25zZSBzdGF0dXM6XCIsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHNlcXVlbmNlIGluZGV4OiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnNvbGUubG9nKFwi8J+ThCBMb2FkZWQgc2VxdWVuY2UgaW5kZXggZGF0YTpcIiwgZGF0YSk7XG4gICAgY29uc29sZS5sb2coXCLwn5OEIFRvdGFsIHNlcXVlbmNlcyBpbiBpbmRleDpcIiwgZGF0YS50b3RhbFNlcXVlbmNlcyk7XG4gICAgY29uc29sZS5sb2coXCLwn5OEIFNlcXVlbmNlcyBhcnJheSBsZW5ndGg6XCIsIGRhdGEuc2VxdWVuY2VzPy5sZW5ndGggfHwgMCk7XG5cbiAgICBjb25zdCByYXdTZXF1ZW5jZXMgPSBkYXRhLnNlcXVlbmNlcyB8fCBbXTtcblxuICAgIC8vIOKchSBGSVhFRDogUHJvY2VzcyByZWFsIHNlcXVlbmNlcyBhbmQgZml4IGFueSBkYXRhIGZvcm1hdCBpc3N1ZXNcbiAgICBjb25zdCBzZXF1ZW5jZXMgPSByYXdTZXF1ZW5jZXNcbiAgICAgIC5maWx0ZXIoKHNlcTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pID0+IHtcbiAgICAgICAgY29uc3Qgd29yZCA9IHNlcS53b3JkIHx8IHNlcS5uYW1lIHx8IHNlcS5pZDtcblxuICAgICAgICAvLyBPbmx5IGZpbHRlciBvdXQgc2VxdWVuY2VzIHRoYXQgYXJlIGNsZWFybHkgaW52YWxpZFxuICAgICAgICBpZiAoIXdvcmQgfHwgKHR5cGVvZiB3b3JkID09PSBcInN0cmluZ1wiICYmIHdvcmQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGDwn5qrIEZpbHRlcmluZyBzZXF1ZW5jZSB3aXRoIG5vIHdvcmQ6ICR7SlNPTi5zdHJpbmdpZnkoc2VxKX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pXG4gICAgICAubWFwKChzZXE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSA9PiB7XG4gICAgICAgIC8vIEZpeCBHcmlkTW9kZSByZWZlcmVuY2VzIHRoYXQgbWlnaHQgYmUgc3RyaW5nc1xuICAgICAgICBsZXQgZ3JpZE1vZGUgPSBzZXEuZ3JpZE1vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgZ3JpZE1vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAoZ3JpZE1vZGUgPT09IFwiR3JpZE1vZGUuRElBTU9ORFwiIHx8IGdyaWRNb2RlID09PSBcImRpYW1vbmRcIikge1xuICAgICAgICAgICAgZ3JpZE1vZGUgPSBHcmlkTW9kZS5ESUFNT05EO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZ3JpZE1vZGUgPT09IFwiR3JpZE1vZGUuQk9YXCIgfHwgZ3JpZE1vZGUgPT09IFwiYm94XCIpIHtcbiAgICAgICAgICAgIGdyaWRNb2RlID0gR3JpZE1vZGUuQk9YO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpeCBkYXRlIHN0cmluZ3MgdG8gRGF0ZSBvYmplY3RzXG4gICAgICAgIGxldCBkYXRlQWRkZWQgPSBzZXEuZGF0ZUFkZGVkO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGVBZGRlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGRhdGVBZGRlZCA9IG5ldyBEYXRlKGRhdGVBZGRlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBjcmVhdGVTZXF1ZW5jZURhdGEoe1xuICAgICAgICAgIGlkOiBTdHJpbmcoc2VxLmlkIHx8IHNlcS53b3JkIHx8IHNlcS5uYW1lKSxcbiAgICAgICAgICBuYW1lOiBTdHJpbmcoc2VxLm5hbWUgfHwgYCR7c2VxLndvcmR9IFNlcXVlbmNlYCksXG4gICAgICAgICAgd29yZDogU3RyaW5nKHNlcS53b3JkIHx8IHNlcS5uYW1lIHx8IHNlcS5pZCksXG4gICAgICAgICAgYmVhdHM6IFtdLCAvLyBCcm93c2VTZXJ2aWNlIGRvZXNuJ3QgbG9hZCBmdWxsIGJlYXQgZGF0YVxuICAgICAgICAgIHRodW1ibmFpbHM6IEFycmF5LmlzQXJyYXkoc2VxLnRodW1ibmFpbHMpXG4gICAgICAgICAgICA/IChzZXEudGh1bWJuYWlscyBhcyBzdHJpbmdbXSlcbiAgICAgICAgICAgIDogW10sXG4gICAgICAgICAgaXNGYXZvcml0ZTogQm9vbGVhbihzZXEuaXNGYXZvcml0ZSksXG4gICAgICAgICAgaXNDaXJjdWxhcjogQm9vbGVhbihzZXEuaXNDaXJjdWxhciksXG4gICAgICAgICAgdGFnczogQXJyYXkuaXNBcnJheShzZXEudGFncylcbiAgICAgICAgICAgID8gKHNlcS50YWdzIGFzIHN0cmluZ1tdKVxuICAgICAgICAgICAgOiBbXCJmbG93XCIsIFwicHJhY3RpY2VcIl0sXG4gICAgICAgICAgbWV0YWRhdGE6XG4gICAgICAgICAgICB0eXBlb2Ygc2VxLm1ldGFkYXRhID09PSBcIm9iamVjdFwiICYmIHNlcS5tZXRhZGF0YSAhPT0gbnVsbFxuICAgICAgICAgICAgICA/IChzZXEubWV0YWRhdGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pXG4gICAgICAgICAgICAgIDogeyBzb3VyY2U6IFwidGthX2RpY3Rpb25hcnlcIiB9LFxuICAgICAgICAgIC8vIE9wdGlvbmFsIHByb3BlcnRpZXNcbiAgICAgICAgICAuLi4oc2VxLmF1dGhvciAmJiB0eXBlb2Ygc2VxLmF1dGhvciA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyB7IGF1dGhvcjogc2VxLmF1dGhvciB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAuLi4oZ3JpZE1vZGUgJiYgdHlwZW9mIGdyaWRNb2RlID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IHsgZ3JpZE1vZGU6IGdyaWRNb2RlIGFzIEdyaWRNb2RlIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgIC4uLihzZXEuZGlmZmljdWx0eUxldmVsICYmIHR5cGVvZiBzZXEuZGlmZmljdWx0eUxldmVsID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBkaWZmaWN1bHR5TGV2ZWw6IHNlcS5kaWZmaWN1bHR5TGV2ZWwsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgIC4uLihzZXEuc2VxdWVuY2VMZW5ndGggJiYgdHlwZW9mIHNlcS5zZXF1ZW5jZUxlbmd0aCA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgc2VxdWVuY2VMZW5ndGg6IHNlcS5zZXF1ZW5jZUxlbmd0aCxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgLi4uKHNlcS5sZXZlbCAmJiB0eXBlb2Ygc2VxLmxldmVsID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICA/IHsgbGV2ZWw6IHNlcS5sZXZlbCB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAuLi4oZGF0ZUFkZGVkIGluc3RhbmNlb2YgRGF0ZSA/IHsgZGF0ZUFkZGVkIH0gOiB7fSksXG4gICAgICAgICAgLi4uKHNlcS5wcm9wVHlwZSAmJiB0eXBlb2Ygc2VxLnByb3BUeXBlID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IHsgcHJvcFR5cGU6IHNlcS5wcm9wVHlwZSBhcyBQcm9wVHlwZSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAuLi4oc2VxLnN0YXJ0aW5nUG9zaXRpb24gJiYgdHlwZW9mIHNlcS5zdGFydGluZ1Bvc2l0aW9uID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBzdGFydGluZ1Bvc2l0aW9uR3JvdXA6XG4gICAgICAgICAgICAgICAgICBzZXEuc3RhcnRpbmdQb3NpdGlvbiBhcyBHcmlkUG9zaXRpb25Hcm91cCxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYPCfk6YgUHJvY2Vzc2VkICR7c2VxdWVuY2VzLmxlbmd0aH0gcmVhbCBzZXF1ZW5jZXMgZnJvbSBkaWN0aW9uYXJ5YFxuICAgICk7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBcIvCfk4sgU2FtcGxlIHNlcXVlbmNlIElEczpcIixcbiAgICAgIHNlcXVlbmNlcy5zbGljZSgwLCAxMCkubWFwKChzOiBTZXF1ZW5jZURhdGEpID0+IHMuaWQpXG4gICAgKTtcblxuICAgIHJldHVybiBzZXF1ZW5jZXM7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlU2VxdWVuY2VJbmRleCgpOiBQcm9taXNlPFNlcXVlbmNlRGF0YVtdPiB7XG4gICAgY29uc29sZS5sb2coXCLwn5SnIFNjYW5uaW5nIGRpY3Rpb25hcnkgZm9sZGVyIHRvIGdlbmVyYXRlIHNlcXVlbmNlIGluZGV4Li4uXCIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFNjYW4gdGhlIGRpY3Rpb25hcnkgZm9sZGVyIGZvciByZWFsIHNlcXVlbmNlc1xuICAgICAgY29uc3Qgc2VxdWVuY2VzOiBTZXF1ZW5jZURhdGFbXSA9IFtdO1xuXG4gICAgICAvLyBUaGlzIGlzIGEgZmFsbGJhY2sgbWV0aG9kIC0gaW4gcHJvZHVjdGlvbiwgeW91IHNob3VsZCByZWdlbmVyYXRlIHRoZSBzZXF1ZW5jZS1pbmRleC5qc29uXG4gICAgICAvLyBGb3Igbm93LCByZXR1cm4gZW1wdHkgYXJyYXkgdG8gZm9yY2UgdXNpbmcgdGhlIHJlYWwgc2VxdWVuY2UtaW5kZXguanNvblxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIuKaoO+4jyBEaWN0aW9uYXJ5IHNjYW5uaW5nIG5vdCBpbXBsZW1lbnRlZCAtIHBsZWFzZSBlbnN1cmUgc2VxdWVuY2UtaW5kZXguanNvbiBpcyB1cCB0byBkYXRlXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gc2VxdWVuY2VzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEZhaWxlZCB0byBzY2FuIGRpY3Rpb25hcnkgZm9sZGVyOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmaWx0ZXJCeVN0YXJ0aW5nTGV0dGVyKFxuICAgIHNlcXVlbmNlczogU2VxdWVuY2VEYXRhW10sXG4gICAgZmlsdGVyVmFsdWU6IEZpbHRlclZhbHVlXG4gICk6IFNlcXVlbmNlRGF0YVtdIHtcbiAgICBpZiAoIWZpbHRlclZhbHVlIHx8IHR5cGVvZiBmaWx0ZXJWYWx1ZSAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIHNlcXVlbmNlcztcblxuICAgIGlmIChmaWx0ZXJWYWx1ZS5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IGZpbHRlclZhbHVlLnNwbGl0KFwiLVwiKTtcbiAgICAgIHJldHVybiBzZXF1ZW5jZXMuZmlsdGVyKChzKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpcnN0TGV0dGVyID0gcy53b3JkWzBdPy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGZpcnN0TGV0dGVyICYmXG4gICAgICAgICAgc3RhcnQgJiZcbiAgICAgICAgICBlbmQgJiZcbiAgICAgICAgICBmaXJzdExldHRlciA+PSBzdGFydCAmJlxuICAgICAgICAgIGZpcnN0TGV0dGVyIDw9IGVuZFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlcXVlbmNlcy5maWx0ZXIoXG4gICAgICAocykgPT4gcy53b3JkWzBdPy50b1VwcGVyQ2FzZSgpID09PSBmaWx0ZXJWYWx1ZS50b1VwcGVyQ2FzZSgpXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgZmlsdGVyQnlDb250YWluc0xldHRlcnMoXG4gICAgc2VxdWVuY2VzOiBTZXF1ZW5jZURhdGFbXSxcbiAgICBmaWx0ZXJWYWx1ZTogRmlsdGVyVmFsdWVcbiAgKTogU2VxdWVuY2VEYXRhW10ge1xuICAgIGlmICghZmlsdGVyVmFsdWUgfHwgdHlwZW9mIGZpbHRlclZhbHVlICE9PSBcInN0cmluZ1wiKSByZXR1cm4gc2VxdWVuY2VzO1xuICAgIHJldHVybiBzZXF1ZW5jZXMuZmlsdGVyKChzKSA9PlxuICAgICAgcy53b3JkLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZmlsdGVyVmFsdWUudG9Mb3dlckNhc2UoKSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBmaWx0ZXJCeUxlbmd0aChcbiAgICBzZXF1ZW5jZXM6IFNlcXVlbmNlRGF0YVtdLFxuICAgIGZpbHRlclZhbHVlOiBGaWx0ZXJWYWx1ZVxuICApOiBTZXF1ZW5jZURhdGFbXSB7XG4gICAgaWYgKCFmaWx0ZXJWYWx1ZSkgcmV0dXJuIHNlcXVlbmNlcztcblxuICAgIGlmIChmaWx0ZXJWYWx1ZSA9PT0gXCI4K1wiKSB7XG4gICAgICByZXR1cm4gc2VxdWVuY2VzLmZpbHRlcigocykgPT4gKHMuc2VxdWVuY2VMZW5ndGggfHwgMCkgPj0gOCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoU3RyaW5nKGZpbHRlclZhbHVlKSk7XG4gICAgaWYgKGlzTmFOKGxlbmd0aCkpIHJldHVybiBzZXF1ZW5jZXM7XG5cbiAgICByZXR1cm4gc2VxdWVuY2VzLmZpbHRlcigocykgPT4gcy5zZXF1ZW5jZUxlbmd0aCA9PT0gbGVuZ3RoKTtcbiAgfVxuXG4gIHByaXZhdGUgZmlsdGVyQnlEaWZmaWN1bHR5KFxuICAgIHNlcXVlbmNlczogU2VxdWVuY2VEYXRhW10sXG4gICAgZmlsdGVyVmFsdWU6IEZpbHRlclZhbHVlXG4gICk6IFNlcXVlbmNlRGF0YVtdIHtcbiAgICBpZiAoIWZpbHRlclZhbHVlKSByZXR1cm4gc2VxdWVuY2VzO1xuICAgIHJldHVybiBzZXF1ZW5jZXMuZmlsdGVyKChzKSA9PiBzLmRpZmZpY3VsdHlMZXZlbCA9PT0gZmlsdGVyVmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBmaWx0ZXJCeVN0YXJ0aW5nUG9zaXRpb24oXG4gICAgc2VxdWVuY2VzOiBTZXF1ZW5jZURhdGFbXSxcbiAgICBmaWx0ZXJWYWx1ZTogRmlsdGVyVmFsdWVcbiAgKTogU2VxdWVuY2VEYXRhW10ge1xuICAgIGlmICghZmlsdGVyVmFsdWUpIHJldHVybiBzZXF1ZW5jZXM7XG4gICAgcmV0dXJuIHNlcXVlbmNlcy5maWx0ZXIoKHMpID0+IHMuc3RhcnRpbmdQb3NpdGlvbkdyb3VwID09PSBmaWx0ZXJWYWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIGZpbHRlckJ5QXV0aG9yKFxuICAgIHNlcXVlbmNlczogU2VxdWVuY2VEYXRhW10sXG4gICAgZmlsdGVyVmFsdWU6IEZpbHRlclZhbHVlXG4gICk6IFNlcXVlbmNlRGF0YVtdIHtcbiAgICBpZiAoIWZpbHRlclZhbHVlKSByZXR1cm4gc2VxdWVuY2VzO1xuICAgIHJldHVybiBzZXF1ZW5jZXMuZmlsdGVyKChzKSA9PiBzLmF1dGhvciA9PT0gZmlsdGVyVmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBmaWx0ZXJCeUdyaWRNb2RlKFxuICAgIHNlcXVlbmNlczogU2VxdWVuY2VEYXRhW10sXG4gICAgZmlsdGVyVmFsdWU6IEZpbHRlclZhbHVlXG4gICk6IFNlcXVlbmNlRGF0YVtdIHtcbiAgICBpZiAoIWZpbHRlclZhbHVlKSByZXR1cm4gc2VxdWVuY2VzO1xuICAgIHJldHVybiBzZXF1ZW5jZXMuZmlsdGVyKChzKSA9PiBzLmdyaWRNb2RlID09PSBmaWx0ZXJWYWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIGZpbHRlckJ5UmVjZW50KHNlcXVlbmNlczogU2VxdWVuY2VEYXRhW10pOiBTZXF1ZW5jZURhdGFbXSB7XG4gICAgY29uc3QgdGhpcnR5RGF5c0FnbyA9IG5ldyBEYXRlKERhdGUubm93KCkgLSAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDApO1xuICAgIHJldHVybiBzZXF1ZW5jZXMuZmlsdGVyKChzKSA9PiB7XG4gICAgICBjb25zdCBkYXRlQWRkZWQgPSBzLmRhdGVBZGRlZCB8fCBuZXcgRGF0ZSgwKTtcbiAgICAgIHJldHVybiBkYXRlQWRkZWQgPj0gdGhpcnR5RGF5c0FnbztcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGlmZmljdWx0eU9yZGVyKGRpZmZpY3VsdHk/OiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHN3aXRjaCAoZGlmZmljdWx0eSkge1xuICAgICAgY2FzZSBcImJlZ2lubmVyXCI6XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBcImludGVybWVkaWF0ZVwiOlxuICAgICAgICByZXR1cm4gMjtcbiAgICAgIGNhc2UgXCJhZHZhbmNlZFwiOlxuICAgICAgICByZXR1cm4gMztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0U2VjdGlvbktleShcbiAgICBzZXF1ZW5jZTogU2VxdWVuY2VEYXRhLFxuICAgIHNvcnRNZXRob2Q6IFNvcnRNZXRob2RcbiAgKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKHNvcnRNZXRob2QpIHtcbiAgICAgIGNhc2UgU29ydE1ldGhvZEVudW0uQUxQSEFCRVRJQ0FMOlxuICAgICAgICByZXR1cm4gc2VxdWVuY2Uud29yZFswXT8udG9VcHBlckNhc2UoKSB8fCBcIiNcIjtcbiAgICAgIGNhc2UgU29ydE1ldGhvZEVudW0uZGlmZmljdWx0eUxldmVsOlxuICAgICAgICByZXR1cm4gc2VxdWVuY2UuZGlmZmljdWx0eUxldmVsIHx8IFwiVW5rbm93blwiO1xuICAgICAgY2FzZSBTb3J0TWV0aG9kRW51bS5BVVRIT1I6XG4gICAgICAgIHJldHVybiBzZXF1ZW5jZS5hdXRob3IgfHwgXCJVbmtub3duXCI7XG4gICAgICBjYXNlIFNvcnRNZXRob2RFbnVtLnNlcXVlbmNlTGVuZ3RoOiB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHNlcXVlbmNlLnNlcXVlbmNlTGVuZ3RoIHx8IDA7XG4gICAgICAgIGlmIChsZW5ndGggPD0gNCkgcmV0dXJuIFwiMy00IGJlYXRzXCI7XG4gICAgICAgIGlmIChsZW5ndGggPD0gNikgcmV0dXJuIFwiNS02IGJlYXRzXCI7XG4gICAgICAgIGlmIChsZW5ndGggPD0gOCkgcmV0dXJuIFwiNy04IGJlYXRzXCI7XG4gICAgICAgIHJldHVybiBcIjkrIGJlYXRzXCI7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJBbGxcIjtcbiAgICB9XG4gIH1cblxuICBjbGVhckNhY2hlKCk6IHZvaWQge1xuICAgIHRoaXMuY2FjaGVkU2VxdWVuY2VzID0gbnVsbDtcbiAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7OztBQU9BLFNBQVMsVUFBVSxtQkFBbUIsZ0JBQWdCO0FBQ3RELFNBQVMsa0JBQWtCO0FBRTNCLFNBQVMsMEJBQTBCO0FBQ25DO0FBQUEsRUFDRSxjQUFjO0FBQUEsRUFDZCxjQUFjO0FBQUEsT0FDVDtBQVNBLFdBQU0sZ0JBQU4s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
