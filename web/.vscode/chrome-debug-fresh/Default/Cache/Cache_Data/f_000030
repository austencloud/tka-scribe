import { createSequenceData } from "/src/lib/domain/index.ts";
import { GridMode, PropType } from "/src/lib/domain/index.ts";
import { createMotionData } from "/src/lib/domain/MotionData.ts";
import {
  MotionType,
  RotationDirection,
  Location,
  Orientation,
  DifficultyLevel,
  PropContinuity,
  GenerationMode
} from "/src/lib/domain/enums.ts";
const ROTATION_DIRS = {
  CLOCKWISE: RotationDirection.CLOCKWISE,
  COUNTER_CLOCKWISE: RotationDirection.COUNTER_CLOCKWISE,
  noRotation: RotationDirection.NO_ROTATION
};
const MOTION_TYPES = {
  PRO: MotionType.PRO,
  ANTI: MotionType.ANTI,
  FLOAT: MotionType.FLOAT,
  DASH: MotionType.DASH,
  STATIC: MotionType.STATIC
};
export class SequenceGenerationService {
  constructor(letterQueryService, orientationCalculationService) {
    this.letterQueryService = letterQueryService;
    this.orientationCalculationService = orientationCalculationService;
  }
  /**
   * Generate freeform sequence - exact port of legacy build_sequence()
   */
  async generateSequence(options) {
    try {
      console.log("ðŸŽ¯ Starting freeform generation with options:", options);
      const sequence = [];
      let blueRotationDirection;
      let redRotationDirection;
      if (options.propContinuity === PropContinuity.CONTINUOUS) {
        blueRotationDirection = this.randomChoice([
          ROTATION_DIRS.CLOCKWISE,
          ROTATION_DIRS.COUNTER_CLOCKWISE
        ]);
        redRotationDirection = this.randomChoice([
          ROTATION_DIRS.CLOCKWISE,
          ROTATION_DIRS.COUNTER_CLOCKWISE
        ]);
      } else {
        blueRotationDirection = "";
        redRotationDirection = "";
      }
      console.log("ðŸ”„ Rotation directions:", {
        blueRotationDirection,
        redRotationDirection,
        propContinuity: options.propContinuity
      });
      const lengthOfSequenceUponStart = Math.max(0, sequence.length - 2);
      const beatsToGenerate = options.length - lengthOfSequenceUponStart;
      console.log(
        `ðŸ“Š Generating ${beatsToGenerate} beats (requested: ${options.length}, existing: ${lengthOfSequenceUponStart})`
      );
      if (beatsToGenerate <= 0) {
        throw new Error(
          "No beats to generate - sequence may already be complete"
        );
      }
      const level = this.mapDifficultyToLevel(options.difficulty);
      const turnIntensity = options.turnIntensity || 1;
      const totalTurns = Math.floor(turnIntensity * beatsToGenerate);
      const turnAllocation = {
        blue: Array(beatsToGenerate).fill(0).map((_, i) => i < totalTurns / 2 ? 1 : 0),
        red: Array(beatsToGenerate).fill(0).map((_, i) => i < totalTurns / 2 ? 1 : 0)
      };
      console.log("ðŸŽ² Turn allocation:", turnAllocation);
      const generatedBeats = [];
      for (let i = 0; i < beatsToGenerate; i++) {
        console.log(`âš¡ Generating beat ${i + 1}/${beatsToGenerate}`);
        try {
          const nextPictograph = await this._generateNextPictograph(
            sequence,
            level,
            turnAllocation.blue[i],
            turnAllocation.red[i],
            options.propContinuity || PropContinuity.CONTINUOUS,
            blueRotationDirection,
            redRotationDirection,
            options.letterTypes || ["Dual-Shift"]
            // Default to Type1 if not specified
          );
          sequence.push(nextPictograph);
          generatedBeats.push(nextPictograph);
          console.log(
            `âœ… Generated beat ${i + 1}: ${nextPictograph.pictographData?.letter}`
          );
        } catch (beatError) {
          console.error(`âŒ Failed to generate beat ${i + 1}:`, beatError);
          throw new Error(
            `Beat generation failed at position ${i + 1}: ${beatError instanceof Error ? beatError.message : "Unknown error"}`
          );
        }
      }
      const generatedSequence = createSequenceData({
        name: this.generateSequenceName(options),
        word: "",
        // Will be calculated from beats
        beats: generatedBeats,
        gridMode: options.gridMode,
        propType: options.propType,
        difficultyLevel: options.difficulty,
        isFavorite: false,
        isCircular: false,
        tags: [],
        metadata: {
          generated: true,
          generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          algorithm: "freeform",
          beatsGenerated: generatedBeats.length,
          propContinuity: options.propContinuity,
          blueRotationDirection,
          redRotationDirection,
          turnIntensity,
          level
        }
      });
      console.log("ðŸŽ‰ Sequence generation complete:", {
        id: generatedSequence.id,
        beats: generatedBeats.length,
        name: generatedSequence.name
      });
      return generatedSequence;
    } catch (error) {
      console.error("âŒ Sequence generation failed:", error);
      throw new Error(
        `Sequence generation failed: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Generate next pictograph - exact port of legacy _generate_next_pictograph()
   */
  async _generateNextPictograph(sequence, level, turnBlue, turnRed, propContinuity, blueRotationDirection, redRotationDirection, _letterTypes) {
    try {
      const optionDicts = await this.letterQueryService.getAllCodexPictographs(
        GridMode.DIAMOND
      );
      console.log(`ðŸ“‹ Loaded ${optionDicts.length} option dicts`);
      if (optionDicts.length === 0) {
        throw new Error("No pictographs available from option service");
      }
      console.log(
        `ðŸ” Using all ${optionDicts.length} options (filtering not yet implemented)`
      );
      console.log(`ðŸ”„ Rotation filtering not yet implemented`);
      if (optionDicts.length === 0) {
        throw new Error("No valid options available after filtering");
      }
      const selectedOption = this.randomChoice(optionDicts);
      console.log(`ðŸŽ¯ Selected option: ${selectedOption.letter}`);
      let nextBeat = this.convertPictographToBeat(
        selectedOption,
        sequence.length + 1
      );
      if (level === 2 || level === 3) {
        this.setTurns(nextBeat, turnBlue, turnRed);
        console.log(`ðŸŽ² Set turns: blue=${turnBlue}, red=${turnRed}`);
      }
      if (sequence.length > 0) {
        nextBeat = this.orientationCalculationService.updateStartOrientations(
          nextBeat,
          sequence[sequence.length - 1]
        );
      }
      this.updateDashStaticRotationDirections(
        nextBeat,
        propContinuity,
        blueRotationDirection,
        redRotationDirection
      );
      nextBeat = this.orientationCalculationService.updateEndOrientations(nextBeat);
      console.log(`ðŸ§­ Updated orientations for beat ${nextBeat.beatNumber}`);
      return nextBeat;
    } catch (error) {
      console.error(`âŒ Failed to generate pictograph:`, error);
      throw error;
    }
  }
  /**
   * Convert PictographData to BeatData - creates proper domain object
   */
  convertPictographToBeat(pictograph, beatNumber) {
    const motions = {
      blue: pictograph.motions.blue || createMotionData({
        motionType: MotionType.STATIC,
        rotationDirection: RotationDirection.NO_ROTATION,
        startLocation: Location.NORTH,
        endLocation: Location.NORTH,
        turns: 0,
        startOrientation: Orientation.IN,
        endOrientation: Orientation.IN
      }),
      red: pictograph.motions.red || createMotionData({
        motionType: MotionType.STATIC,
        rotationDirection: RotationDirection.NO_ROTATION,
        startLocation: Location.NORTH,
        endLocation: Location.NORTH,
        turns: 0,
        startOrientation: Orientation.IN,
        endOrientation: Orientation.IN
      }),
      ...pictograph.motions
    };
    return {
      id: crypto.randomUUID(),
      beatNumber,
      duration: 1,
      blueReversal: false,
      redReversal: false,
      isBlank: false,
      pictographData: {
        ...pictograph,
        motions
      }
    };
  }
  /**
   * Set turns - exact port from legacy set_turns()
   */
  setTurns(beat, turnBlue, turnRed) {
    if (!beat.pictographData) return;
    if (turnBlue === "fl") {
      if (beat.pictographData.motions.blue?.motionType === MotionType.PRO || beat.pictographData.motions.blue?.motionType === MotionType.ANTI) {
        if (beat.pictographData.motions.blue) {
          beat.pictographData.motions.blue = {
            ...beat.pictographData.motions.blue,
            turns: "fl",
            prefloatMotionType: beat.pictographData.motions.blue.motionType,
            prefloatRotationDirection: beat.pictographData.motions.blue.rotationDirection,
            motionType: MotionType.FLOAT,
            rotationDirection: RotationDirection.NO_ROTATION
          };
        }
      } else {
        if (beat.pictographData.motions.blue) {
          beat.pictographData.motions.blue = {
            ...beat.pictographData.motions.blue,
            turns: 0
          };
        }
      }
    } else {
      if (beat.pictographData.motions.blue) {
        beat.pictographData.motions.blue = {
          ...beat.pictographData.motions.blue,
          turns: turnBlue
        };
      }
    }
    if (turnRed === "fl") {
      if (beat.pictographData.motions.red?.motionType === MotionType.PRO || beat.pictographData.motions.red?.motionType === MotionType.ANTI) {
        if (beat.pictographData.motions.red) {
          beat.pictographData.motions.red = {
            ...beat.pictographData.motions.red,
            turns: "fl",
            prefloatMotionType: beat.pictographData.motions.red.motionType,
            prefloatRotationDirection: beat.pictographData.motions.red.rotationDirection,
            motionType: MotionType.FLOAT,
            rotationDirection: RotationDirection.NO_ROTATION
          };
        }
      } else {
        if (beat.pictographData.motions.red) {
          beat.pictographData.motions.red = {
            ...beat.pictographData.motions.red,
            turns: 0
          };
        }
      }
    } else {
      if (beat.pictographData.motions.red) {
        beat.pictographData.motions.red = {
          ...beat.pictographData.motions.red,
          turns: turnRed
        };
      }
    }
  }
  /**
   * Update dash/static prop rotation directions - exact port from legacy
   */
  updateDashStaticRotationDirections(beat, propContinuity, blueRotationDirection, redRotationDirection) {
    if (!beat.pictographData) return;
    if (beat.pictographData.motions.blue?.motionType === MOTION_TYPES.DASH || beat.pictographData.motions.blue?.motionType === MOTION_TYPES.STATIC) {
      const turns = beat.pictographData.motions.blue.turns || 0;
      if (propContinuity === PropContinuity.CONTINUOUS) {
        const newRotationDirection = typeof turns === "number" && turns > 0 ? blueRotationDirection : ROTATION_DIRS.noRotation;
        beat.pictographData.motions.blue = {
          ...beat.pictographData.motions.blue,
          rotationDirection: newRotationDirection
        };
      } else if (typeof turns === "number" && turns > 0) {
        const newRotationDirection = this.randomChoice([
          ROTATION_DIRS.CLOCKWISE,
          ROTATION_DIRS.COUNTER_CLOCKWISE
        ]);
        beat.pictographData.motions.blue = {
          ...beat.pictographData.motions.blue,
          rotationDirection: newRotationDirection
        };
      } else {
        beat.pictographData.motions.blue = {
          ...beat.pictographData.motions.blue,
          rotationDirection: ROTATION_DIRS.noRotation
        };
      }
    }
    if (beat.pictographData.motions.red?.motionType === MOTION_TYPES.DASH || beat.pictographData.motions.red?.motionType === MOTION_TYPES.STATIC) {
      const turns = beat.pictographData.motions.red.turns || 0;
      if (propContinuity === PropContinuity.CONTINUOUS) {
        const newRotationDirection = typeof turns === "number" && turns > 0 ? redRotationDirection : ROTATION_DIRS.noRotation;
        beat.pictographData.motions.red = {
          ...beat.pictographData.motions.red,
          rotationDirection: newRotationDirection
        };
      } else if (typeof turns === "number" && turns > 0) {
        const newRotationDirection = this.randomChoice([
          ROTATION_DIRS.CLOCKWISE,
          ROTATION_DIRS.COUNTER_CLOCKWISE
        ]);
        beat.pictographData.motions.red = {
          ...beat.pictographData.motions.red,
          rotationDirection: newRotationDirection
        };
      } else {
        beat.pictographData.motions.red = {
          ...beat.pictographData.motions.red,
          rotationDirection: ROTATION_DIRS.noRotation
        };
      }
    }
  }
  /**
   * Random choice helper - exact behavior from legacy random.choice()
   */
  randomChoice(array) {
    if (array.length === 0) {
      throw new Error("Cannot choose from empty array");
    }
    return array[Math.floor(Math.random() * array.length)];
  }
  /**
   * Map difficulty to level - legacy mapping
   */
  mapDifficultyToLevel(difficulty) {
    switch (difficulty) {
      case DifficultyLevel.BEGINNER:
        return 1;
      case DifficultyLevel.INTERMEDIATE:
        return 2;
      case DifficultyLevel.ADVANCED:
        return 3;
      default:
        return 2;
    }
  }
  /**
   * Generate sequence name based on options - matches legacy pattern
   */
  generateSequenceName(options) {
    const timestamp = (/* @__PURE__ */ new Date()).toLocaleString("en-US", {
      month: "short",
      day: "numeric",
      hour: "numeric",
      minute: "2-digit"
    });
    const difficulty = options.difficulty.charAt(0).toUpperCase() + options.difficulty.slice(1);
    return `${difficulty} ${options.length}-Beat (${timestamp})`;
  }
  /**
   * Generate circular sequence - not implemented in Phase 1
   */
  async generatePatternSequence(pattern, _options) {
    throw new Error(`${pattern} generation not implemented yet`);
  }
  /**
   * Get generation statistics - not implemented in Phase 1
   */
  getGenerationStats() {
    return {
      totalGenerated: 0,
      averageGenerationTime: 0,
      lastGenerated: null
    };
  }
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3NlcnZpY2VzL2ltcGxlbWVudGF0aW9ucy9nZW5lcmF0aW9uL1NlcXVlbmNlR2VuZXJhdGlvblNlcnZpY2UudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogU2VxdWVuY2UgR2VuZXJhdGlvbiBTZXJ2aWNlIC0gQ29tcGxldGUgcG9ydCBvZiBsZWdhY3kgZnJlZWZvcm0gYWxnb3JpdGhtXG4gKlxuICogRXhhY3QgaW1wbGVtZW50YXRpb24gb2YgRnJlZUZvcm1TZXF1ZW5jZUJ1aWxkZXIuYnVpbGRfc2VxdWVuY2UoKSBhbmQgX2dlbmVyYXRlX25leHRfcGljdG9ncmFwaCgpLlxuICogTm8gcGxhY2Vob2xkZXJzLCBubyBzaW1wbGlmaWVkIHZlcnNpb25zIC0gY29tcGxldGUgYWxnb3JpdGhtIGZyb20gbGVnYWN5IGRlc2t0b3AgYXBwLlxuICovXG5cbmltcG9ydCB0eXBlIHsgQmVhdERhdGEsIFNlcXVlbmNlRGF0YSB9IGZyb20gXCIkbGliL2RvbWFpblwiO1xuaW1wb3J0IHsgY3JlYXRlU2VxdWVuY2VEYXRhIH0gZnJvbSBcIiRsaWIvZG9tYWluXCI7XG5pbXBvcnQgeyBHcmlkTW9kZSwgUHJvcFR5cGUgfSBmcm9tIFwiJGxpYi9kb21haW5cIjtcbmltcG9ydCB0eXBlIHtcbiAgR2VuZXJhdGlvbk9wdGlvbnMsXG4gIElTZXF1ZW5jZUdlbmVyYXRpb25TZXJ2aWNlLFxuICBJT3JpZW50YXRpb25DYWxjdWxhdGlvblNlcnZpY2UsXG59IGZyb20gXCIuLi8uLi9pbnRlcmZhY2VzL2dlbmVyYXRpb24taW50ZXJmYWNlc1wiO1xuaW1wb3J0IHR5cGUgeyBJTGV0dGVyUXVlcnlTZXJ2aWNlIH0gZnJvbSBcIi4uL2RhdGEvTGV0dGVyUXVlcnlTZXJ2aWNlXCI7XG5cbmltcG9ydCB0eXBlIHsgUGljdG9ncmFwaERhdGEgfSBmcm9tIFwiJGxpYi9kb21haW4vUGljdG9ncmFwaERhdGFcIjtcbmltcG9ydCB7IGNyZWF0ZU1vdGlvbkRhdGEgfSBmcm9tIFwiJGxpYi9kb21haW4vTW90aW9uRGF0YVwiO1xuaW1wb3J0IHtcbiAgTW90aW9uVHlwZSxcbiAgUm90YXRpb25EaXJlY3Rpb24sXG4gIExvY2F0aW9uLFxuICBPcmllbnRhdGlvbixcbiAgRGlmZmljdWx0eUxldmVsLFxuICBQcm9wQ29udGludWl0eSxcbiAgR2VuZXJhdGlvbk1vZGUsXG59IGZyb20gXCIkbGliL2RvbWFpbi9lbnVtc1wiO1xuXG4vLyBMZWdhY3kgY29uc3RhbnRzIGZvciByb3RhdGlvbiBkaXJlY3Rpb25zIC0gdXNpbmcgZW51bSB2YWx1ZXNcbmNvbnN0IFJPVEFUSU9OX0RJUlMgPSB7XG4gIENMT0NLV0lTRTogUm90YXRpb25EaXJlY3Rpb24uQ0xPQ0tXSVNFLFxuICBDT1VOVEVSX0NMT0NLV0lTRTogUm90YXRpb25EaXJlY3Rpb24uQ09VTlRFUl9DTE9DS1dJU0UsXG4gIG5vUm90YXRpb246IFJvdGF0aW9uRGlyZWN0aW9uLk5PX1JPVEFUSU9OLFxufSBhcyBjb25zdDtcblxuY29uc3QgTU9USU9OX1RZUEVTID0ge1xuICBQUk86IE1vdGlvblR5cGUuUFJPLFxuICBBTlRJOiBNb3Rpb25UeXBlLkFOVEksXG4gIEZMT0FUOiBNb3Rpb25UeXBlLkZMT0FULFxuICBEQVNIOiBNb3Rpb25UeXBlLkRBU0gsXG4gIFNUQVRJQzogTW90aW9uVHlwZS5TVEFUSUMsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY2xhc3MgU2VxdWVuY2VHZW5lcmF0aW9uU2VydmljZSBpbXBsZW1lbnRzIElTZXF1ZW5jZUdlbmVyYXRpb25TZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBsZXR0ZXJRdWVyeVNlcnZpY2U6IElMZXR0ZXJRdWVyeVNlcnZpY2UsXG4gICAgcHJpdmF0ZSBvcmllbnRhdGlvbkNhbGN1bGF0aW9uU2VydmljZTogSU9yaWVudGF0aW9uQ2FsY3VsYXRpb25TZXJ2aWNlXG4gICkge31cblxuICAvKipcbiAgICogR2VuZXJhdGUgZnJlZWZvcm0gc2VxdWVuY2UgLSBleGFjdCBwb3J0IG9mIGxlZ2FjeSBidWlsZF9zZXF1ZW5jZSgpXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZVNlcXVlbmNlKG9wdGlvbnM6IEdlbmVyYXRpb25PcHRpb25zKTogUHJvbWlzZTxTZXF1ZW5jZURhdGE+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coXCLwn46vIFN0YXJ0aW5nIGZyZWVmb3JtIGdlbmVyYXRpb24gd2l0aCBvcHRpb25zOlwiLCBvcHRpb25zKTtcblxuICAgICAgLy8gU3RlcCAxOiBJbml0aWFsaXplIHNlcXVlbmNlIChsZWdhY3k6IHNlbGYuaW5pdGlhbGl6ZV9zZXF1ZW5jZSlcbiAgICAgIC8vIFRPRE86IEluIGZ1bGwgaW1wbGVtZW50YXRpb24sIHRoaXMgc2hvdWxkIGxvYWQgY3VycmVudCBzZXF1ZW5jZSBmcm9tIHdvcmtiZW5jaFxuICAgICAgLy8gRm9yIG5vdywgc3RhcnQgd2l0aCBlbXB0eSBzZXF1ZW5jZVxuICAgICAgY29uc3Qgc2VxdWVuY2U6IEJlYXREYXRhW10gPSBbXTtcblxuICAgICAgLy8gU3RlcCAyOiBTZXQgcm90YXRpb24gZGlyZWN0aW9ucyBiYXNlZCBvbiBwcm9wIGNvbnRpbnVpdHkgKGxlZ2FjeSBsaW5lcyAzMS0zNSlcbiAgICAgIGxldCBibHVlUm90YXRpb25EaXJlY3Rpb246IHN0cmluZztcbiAgICAgIGxldCByZWRSb3RhdGlvbkRpcmVjdGlvbjogc3RyaW5nO1xuXG4gICAgICBpZiAob3B0aW9ucy5wcm9wQ29udGludWl0eSA9PT0gUHJvcENvbnRpbnVpdHkuQ09OVElOVU9VUykge1xuICAgICAgICBibHVlUm90YXRpb25EaXJlY3Rpb24gPSB0aGlzLnJhbmRvbUNob2ljZShbXG4gICAgICAgICAgUk9UQVRJT05fRElSUy5DTE9DS1dJU0UsXG4gICAgICAgICAgUk9UQVRJT05fRElSUy5DT1VOVEVSX0NMT0NLV0lTRSxcbiAgICAgICAgXSk7XG4gICAgICAgIHJlZFJvdGF0aW9uRGlyZWN0aW9uID0gdGhpcy5yYW5kb21DaG9pY2UoW1xuICAgICAgICAgIFJPVEFUSU9OX0RJUlMuQ0xPQ0tXSVNFLFxuICAgICAgICAgIFJPVEFUSU9OX0RJUlMuQ09VTlRFUl9DTE9DS1dJU0UsXG4gICAgICAgIF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmFuZG9tIHByb3AgY29udGludWl0eSAtIHRoZXNlIHdpbGwgYmUgc2V0IHBlciBtb3Rpb25cbiAgICAgICAgYmx1ZVJvdGF0aW9uRGlyZWN0aW9uID0gXCJcIjtcbiAgICAgICAgcmVkUm90YXRpb25EaXJlY3Rpb24gPSBcIlwiO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhcIvCflIQgUm90YXRpb24gZGlyZWN0aW9uczpcIiwge1xuICAgICAgICBibHVlUm90YXRpb25EaXJlY3Rpb24sXG4gICAgICAgIHJlZFJvdGF0aW9uRGlyZWN0aW9uLFxuICAgICAgICBwcm9wQ29udGludWl0eTogb3B0aW9ucy5wcm9wQ29udGludWl0eSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTdGVwIDM6IENhbGN1bGF0ZSBiZWF0cyB0byBnZW5lcmF0ZSAobGVnYWN5IGxvZ2ljKVxuICAgICAgY29uc3QgbGVuZ3RoT2ZTZXF1ZW5jZVVwb25TdGFydCA9IE1hdGgubWF4KDAsIHNlcXVlbmNlLmxlbmd0aCAtIDIpO1xuICAgICAgY29uc3QgYmVhdHNUb0dlbmVyYXRlID0gb3B0aW9ucy5sZW5ndGggLSBsZW5ndGhPZlNlcXVlbmNlVXBvblN0YXJ0O1xuXG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYPCfk4ogR2VuZXJhdGluZyAke2JlYXRzVG9HZW5lcmF0ZX0gYmVhdHMgKHJlcXVlc3RlZDogJHtvcHRpb25zLmxlbmd0aH0sIGV4aXN0aW5nOiAke2xlbmd0aE9mU2VxdWVuY2VVcG9uU3RhcnR9KWBcbiAgICAgICk7XG5cbiAgICAgIGlmIChiZWF0c1RvR2VuZXJhdGUgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJObyBiZWF0cyB0byBnZW5lcmF0ZSAtIHNlcXVlbmNlIG1heSBhbHJlYWR5IGJlIGNvbXBsZXRlXCJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RlcCA0OiBBbGxvY2F0ZSB0dXJucyB1c2luZyBUdXJuSW50ZW5zaXR5TWFuYWdlciAobGVnYWN5IGxpbmVzIDM5LTQwKVxuICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLm1hcERpZmZpY3VsdHlUb0xldmVsKG9wdGlvbnMuZGlmZmljdWx0eSk7XG4gICAgICBjb25zdCB0dXJuSW50ZW5zaXR5ID0gb3B0aW9ucy50dXJuSW50ZW5zaXR5IHx8IDE7XG5cbiAgICAgIC8vIFNpbXBsZSB0dXJuIGFsbG9jYXRpb24gZm9yIG5vdyAoY2FuIGJlIGVuaGFuY2VkIGxhdGVyKVxuICAgICAgY29uc3QgdG90YWxUdXJucyA9IE1hdGguZmxvb3IodHVybkludGVuc2l0eSAqIGJlYXRzVG9HZW5lcmF0ZSk7XG4gICAgICBjb25zdCB0dXJuQWxsb2NhdGlvbiA9IHtcbiAgICAgICAgYmx1ZTogQXJyYXkoYmVhdHNUb0dlbmVyYXRlKVxuICAgICAgICAgIC5maWxsKDApXG4gICAgICAgICAgLm1hcCgoXywgaSkgPT4gKGkgPCB0b3RhbFR1cm5zIC8gMiA/IDEgOiAwKSksXG4gICAgICAgIHJlZDogQXJyYXkoYmVhdHNUb0dlbmVyYXRlKVxuICAgICAgICAgIC5maWxsKDApXG4gICAgICAgICAgLm1hcCgoXywgaSkgPT4gKGkgPCB0b3RhbFR1cm5zIC8gMiA/IDEgOiAwKSksXG4gICAgICB9O1xuICAgICAgY29uc29sZS5sb2coXCLwn46yIFR1cm4gYWxsb2NhdGlvbjpcIiwgdHVybkFsbG9jYXRpb24pO1xuXG4gICAgICAvLyBTdGVwIDU6IEdlbmVyYXRpb24gbG9vcCAobGVnYWN5IGxpbmVzIDQyLTU4KVxuICAgICAgY29uc3QgZ2VuZXJhdGVkQmVhdHM6IEJlYXREYXRhW10gPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiZWF0c1RvR2VuZXJhdGU7IGkrKykge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pqhIEdlbmVyYXRpbmcgYmVhdCAke2kgKyAxfS8ke2JlYXRzVG9HZW5lcmF0ZX1gKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG5leHRQaWN0b2dyYXBoID0gYXdhaXQgdGhpcy5fZ2VuZXJhdGVOZXh0UGljdG9ncmFwaChcbiAgICAgICAgICAgIHNlcXVlbmNlLFxuICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICB0dXJuQWxsb2NhdGlvbi5ibHVlW2ldLFxuICAgICAgICAgICAgdHVybkFsbG9jYXRpb24ucmVkW2ldLFxuICAgICAgICAgICAgb3B0aW9ucy5wcm9wQ29udGludWl0eSB8fCBQcm9wQ29udGludWl0eS5DT05USU5VT1VTLFxuICAgICAgICAgICAgYmx1ZVJvdGF0aW9uRGlyZWN0aW9uLFxuICAgICAgICAgICAgcmVkUm90YXRpb25EaXJlY3Rpb24sXG4gICAgICAgICAgICBvcHRpb25zLmxldHRlclR5cGVzIHx8IFtcIkR1YWwtU2hpZnRcIl0gLy8gRGVmYXVsdCB0byBUeXBlMSBpZiBub3Qgc3BlY2lmaWVkXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIEFkZCB0byBzZXF1ZW5jZSBmb3IgbmV4dCBpdGVyYXRpb24gKGxlZ2FjeSBsb2dpYylcbiAgICAgICAgICBzZXF1ZW5jZS5wdXNoKG5leHRQaWN0b2dyYXBoKTtcbiAgICAgICAgICBnZW5lcmF0ZWRCZWF0cy5wdXNoKG5leHRQaWN0b2dyYXBoKTtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYOKchSBHZW5lcmF0ZWQgYmVhdCAke2kgKyAxfTogJHtuZXh0UGljdG9ncmFwaC5waWN0b2dyYXBoRGF0YT8ubGV0dGVyfWBcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChiZWF0RXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgRmFpbGVkIHRvIGdlbmVyYXRlIGJlYXQgJHtpICsgMX06YCwgYmVhdEVycm9yKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQmVhdCBnZW5lcmF0aW9uIGZhaWxlZCBhdCBwb3NpdGlvbiAke2kgKyAxfTogJHtiZWF0RXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGJlYXRFcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU3RlcCA2OiBDcmVhdGUgc2VxdWVuY2UgZGF0YSBzdHJ1Y3R1cmVcbiAgICAgIGNvbnN0IGdlbmVyYXRlZFNlcXVlbmNlOiBTZXF1ZW5jZURhdGEgPSBjcmVhdGVTZXF1ZW5jZURhdGEoe1xuICAgICAgICBuYW1lOiB0aGlzLmdlbmVyYXRlU2VxdWVuY2VOYW1lKG9wdGlvbnMpLFxuICAgICAgICB3b3JkOiBcIlwiLCAvLyBXaWxsIGJlIGNhbGN1bGF0ZWQgZnJvbSBiZWF0c1xuICAgICAgICBiZWF0czogZ2VuZXJhdGVkQmVhdHMsXG4gICAgICAgIGdyaWRNb2RlOiBvcHRpb25zLmdyaWRNb2RlLFxuICAgICAgICBwcm9wVHlwZTogb3B0aW9ucy5wcm9wVHlwZSBhcyBQcm9wVHlwZSxcbiAgICAgICAgZGlmZmljdWx0eUxldmVsOiBvcHRpb25zLmRpZmZpY3VsdHksXG4gICAgICAgIGlzRmF2b3JpdGU6IGZhbHNlLFxuICAgICAgICBpc0NpcmN1bGFyOiBmYWxzZSxcbiAgICAgICAgdGFnczogW10sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgZ2VuZXJhdGVkOiB0cnVlLFxuICAgICAgICAgIGdlbmVyYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgYWxnb3JpdGhtOiBcImZyZWVmb3JtXCIsXG4gICAgICAgICAgYmVhdHNHZW5lcmF0ZWQ6IGdlbmVyYXRlZEJlYXRzLmxlbmd0aCxcbiAgICAgICAgICBwcm9wQ29udGludWl0eTogb3B0aW9ucy5wcm9wQ29udGludWl0eSxcbiAgICAgICAgICBibHVlUm90YXRpb25EaXJlY3Rpb24sXG4gICAgICAgICAgcmVkUm90YXRpb25EaXJlY3Rpb24sXG4gICAgICAgICAgdHVybkludGVuc2l0eSxcbiAgICAgICAgICBsZXZlbCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIvCfjokgU2VxdWVuY2UgZ2VuZXJhdGlvbiBjb21wbGV0ZTpcIiwge1xuICAgICAgICBpZDogZ2VuZXJhdGVkU2VxdWVuY2UuaWQsXG4gICAgICAgIGJlYXRzOiBnZW5lcmF0ZWRCZWF0cy5sZW5ndGgsXG4gICAgICAgIG5hbWU6IGdlbmVyYXRlZFNlcXVlbmNlLm5hbWUsXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGdlbmVyYXRlZFNlcXVlbmNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIFNlcXVlbmNlIGdlbmVyYXRpb24gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBTZXF1ZW5jZSBnZW5lcmF0aW9uIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIG5leHQgcGljdG9ncmFwaCAtIGV4YWN0IHBvcnQgb2YgbGVnYWN5IF9nZW5lcmF0ZV9uZXh0X3BpY3RvZ3JhcGgoKVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZ2VuZXJhdGVOZXh0UGljdG9ncmFwaChcbiAgICBzZXF1ZW5jZTogQmVhdERhdGFbXSxcbiAgICBsZXZlbDogbnVtYmVyLFxuICAgIHR1cm5CbHVlOiBudW1iZXIgfCBcImZsXCIsXG4gICAgdHVyblJlZDogbnVtYmVyIHwgXCJmbFwiLFxuICAgIHByb3BDb250aW51aXR5OiBQcm9wQ29udGludWl0eSxcbiAgICBibHVlUm90YXRpb25EaXJlY3Rpb246IHN0cmluZyxcbiAgICByZWRSb3RhdGlvbkRpcmVjdGlvbjogc3RyaW5nLFxuICAgIF9sZXR0ZXJUeXBlczogc3RyaW5nW11cbiAgKTogUHJvbWlzZTxCZWF0RGF0YT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBTdGVwIDE6IEdldCBvcHRpb24gZGljdHMgKGxlZ2FjeTogc2VsZi5fZ2V0X29wdGlvbl9kaWN0cygpKVxuICAgICAgLy8gTGV0dGVyUXVlcnlTZXJ2aWNlIGluaXRpYWxpemVzIGF1dG9tYXRpY2FsbHkgd2hlbiBmaXJzdCB1c2VkXG4gICAgICBjb25zdCBvcHRpb25EaWN0cyA9IGF3YWl0IHRoaXMubGV0dGVyUXVlcnlTZXJ2aWNlLmdldEFsbENvZGV4UGljdG9ncmFwaHMoXG4gICAgICAgIEdyaWRNb2RlLkRJQU1PTkRcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZyhg8J+TiyBMb2FkZWQgJHtvcHRpb25EaWN0cy5sZW5ndGh9IG9wdGlvbiBkaWN0c2ApO1xuXG4gICAgICBpZiAob3B0aW9uRGljdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHBpY3RvZ3JhcGhzIGF2YWlsYWJsZSBmcm9tIG9wdGlvbiBzZXJ2aWNlXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYPCflI0gVXNpbmcgYWxsICR7b3B0aW9uRGljdHMubGVuZ3RofSBvcHRpb25zIChmaWx0ZXJpbmcgbm90IHlldCBpbXBsZW1lbnRlZClgXG4gICAgICApO1xuICAgICAgY29uc29sZS5sb2coYPCflIQgUm90YXRpb24gZmlsdGVyaW5nIG5vdCB5ZXQgaW1wbGVtZW50ZWRgKTtcblxuICAgICAgaWYgKG9wdGlvbkRpY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCBvcHRpb25zIGF2YWlsYWJsZSBhZnRlciBmaWx0ZXJpbmdcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0ZXAgNDogUmFuZG9tIHNlbGVjdGlvbiAobGVnYWN5OiByYW5kb20uY2hvaWNlKG9wdGlvbl9kaWN0cykpXG4gICAgICBjb25zdCBzZWxlY3RlZE9wdGlvbiA9IHRoaXMucmFuZG9tQ2hvaWNlKG9wdGlvbkRpY3RzKTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn46vIFNlbGVjdGVkIG9wdGlvbjogJHtzZWxlY3RlZE9wdGlvbi5sZXR0ZXJ9YCk7XG5cbiAgICAgIC8vIFN0ZXAgNTogQ29udmVydCB0byBCZWF0RGF0YVxuICAgICAgbGV0IG5leHRCZWF0ID0gdGhpcy5jb252ZXJ0UGljdG9ncmFwaFRvQmVhdChcbiAgICAgICAgc2VsZWN0ZWRPcHRpb24sXG4gICAgICAgIHNlcXVlbmNlLmxlbmd0aCArIDFcbiAgICAgICk7XG5cbiAgICAgIC8vIFN0ZXAgNjogU2V0IHR1cm5zIGlmIGxldmVsIDIgb3IgMyAobGVnYWN5OiBzZWxmLnNldF90dXJucygpKVxuICAgICAgaWYgKGxldmVsID09PSAyIHx8IGxldmVsID09PSAzKSB7XG4gICAgICAgIHRoaXMuc2V0VHVybnMobmV4dEJlYXQsIHR1cm5CbHVlLCB0dXJuUmVkKTtcbiAgICAgICAgY29uc29sZS5sb2coYPCfjrIgU2V0IHR1cm5zOiBibHVlPSR7dHVybkJsdWV9LCByZWQ9JHt0dXJuUmVkfWApO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGVwIDc6IFVwZGF0ZSBvcmllbnRhdGlvbnMgKGV4YWN0IGxlZ2FjeSBzZXF1ZW5jZSlcbiAgICAgIGlmIChzZXF1ZW5jZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5leHRCZWF0ID0gdGhpcy5vcmllbnRhdGlvbkNhbGN1bGF0aW9uU2VydmljZS51cGRhdGVTdGFydE9yaWVudGF0aW9ucyhcbiAgICAgICAgICBuZXh0QmVhdCxcbiAgICAgICAgICBzZXF1ZW5jZVtzZXF1ZW5jZS5sZW5ndGggLSAxXVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZURhc2hTdGF0aWNSb3RhdGlvbkRpcmVjdGlvbnMoXG4gICAgICAgIG5leHRCZWF0LFxuICAgICAgICBwcm9wQ29udGludWl0eSxcbiAgICAgICAgYmx1ZVJvdGF0aW9uRGlyZWN0aW9uLFxuICAgICAgICByZWRSb3RhdGlvbkRpcmVjdGlvblxuICAgICAgKTtcbiAgICAgIG5leHRCZWF0ID1cbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbkNhbGN1bGF0aW9uU2VydmljZS51cGRhdGVFbmRPcmllbnRhdGlvbnMobmV4dEJlYXQpO1xuXG4gICAgICBjb25zb2xlLmxvZyhg8J+nrSBVcGRhdGVkIG9yaWVudGF0aW9ucyBmb3IgYmVhdCAke25leHRCZWF0LmJlYXROdW1iZXJ9YCk7XG5cbiAgICAgIHJldHVybiBuZXh0QmVhdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEZhaWxlZCB0byBnZW5lcmF0ZSBwaWN0b2dyYXBoOmAsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IFBpY3RvZ3JhcGhEYXRhIHRvIEJlYXREYXRhIC0gY3JlYXRlcyBwcm9wZXIgZG9tYWluIG9iamVjdFxuICAgKi9cbiAgcHJpdmF0ZSBjb252ZXJ0UGljdG9ncmFwaFRvQmVhdChcbiAgICBwaWN0b2dyYXBoOiBQaWN0b2dyYXBoRGF0YSxcbiAgICBiZWF0TnVtYmVyOiBudW1iZXJcbiAgKTogQmVhdERhdGEge1xuICAgIC8vIEVuc3VyZSBtb3Rpb25zIGV4aXN0IGZvciBibHVlIGFuZCByZWRcbiAgICBjb25zdCBtb3Rpb25zID0ge1xuICAgICAgYmx1ZTpcbiAgICAgICAgcGljdG9ncmFwaC5tb3Rpb25zLmJsdWUgfHxcbiAgICAgICAgY3JlYXRlTW90aW9uRGF0YSh7XG4gICAgICAgICAgbW90aW9uVHlwZTogTW90aW9uVHlwZS5TVEFUSUMsXG4gICAgICAgICAgcm90YXRpb25EaXJlY3Rpb246IFJvdGF0aW9uRGlyZWN0aW9uLk5PX1JPVEFUSU9OLFxuICAgICAgICAgIHN0YXJ0TG9jYXRpb246IExvY2F0aW9uLk5PUlRILFxuICAgICAgICAgIGVuZExvY2F0aW9uOiBMb2NhdGlvbi5OT1JUSCxcbiAgICAgICAgICB0dXJuczogMCxcbiAgICAgICAgICBzdGFydE9yaWVudGF0aW9uOiBPcmllbnRhdGlvbi5JTixcbiAgICAgICAgICBlbmRPcmllbnRhdGlvbjogT3JpZW50YXRpb24uSU4sXG4gICAgICAgIH0pLFxuICAgICAgcmVkOlxuICAgICAgICBwaWN0b2dyYXBoLm1vdGlvbnMucmVkIHx8XG4gICAgICAgIGNyZWF0ZU1vdGlvbkRhdGEoe1xuICAgICAgICAgIG1vdGlvblR5cGU6IE1vdGlvblR5cGUuU1RBVElDLFxuICAgICAgICAgIHJvdGF0aW9uRGlyZWN0aW9uOiBSb3RhdGlvbkRpcmVjdGlvbi5OT19ST1RBVElPTixcbiAgICAgICAgICBzdGFydExvY2F0aW9uOiBMb2NhdGlvbi5OT1JUSCxcbiAgICAgICAgICBlbmRMb2NhdGlvbjogTG9jYXRpb24uTk9SVEgsXG4gICAgICAgICAgdHVybnM6IDAsXG4gICAgICAgICAgc3RhcnRPcmllbnRhdGlvbjogT3JpZW50YXRpb24uSU4sXG4gICAgICAgICAgZW5kT3JpZW50YXRpb246IE9yaWVudGF0aW9uLklOLFxuICAgICAgICB9KSxcbiAgICAgIC4uLnBpY3RvZ3JhcGgubW90aW9ucyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgYmVhdE51bWJlcjogYmVhdE51bWJlcixcbiAgICAgIGR1cmF0aW9uOiAxLjAsXG4gICAgICBibHVlUmV2ZXJzYWw6IGZhbHNlLFxuICAgICAgcmVkUmV2ZXJzYWw6IGZhbHNlLFxuICAgICAgaXNCbGFuazogZmFsc2UsXG4gICAgICBwaWN0b2dyYXBoRGF0YToge1xuICAgICAgICAuLi5waWN0b2dyYXBoLFxuICAgICAgICBtb3Rpb25zLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0dXJucyAtIGV4YWN0IHBvcnQgZnJvbSBsZWdhY3kgc2V0X3R1cm5zKClcbiAgICovXG4gIHByaXZhdGUgc2V0VHVybnMoXG4gICAgYmVhdDogQmVhdERhdGEsXG4gICAgdHVybkJsdWU6IG51bWJlciB8IFwiZmxcIixcbiAgICB0dXJuUmVkOiBudW1iZXIgfCBcImZsXCJcbiAgKTogdm9pZCB7XG4gICAgaWYgKCFiZWF0LnBpY3RvZ3JhcGhEYXRhKSByZXR1cm47XG5cbiAgICAvLyBIYW5kbGUgYmx1ZSB0dXJucyAtIGV4YWN0IGxlZ2FjeSBsb2dpY1xuICAgIGlmICh0dXJuQmx1ZSA9PT0gXCJmbFwiKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGJlYXQucGljdG9ncmFwaERhdGEubW90aW9ucy5ibHVlPy5tb3Rpb25UeXBlID09PSBNb3Rpb25UeXBlLlBSTyB8fFxuICAgICAgICBiZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMuYmx1ZT8ubW90aW9uVHlwZSA9PT0gTW90aW9uVHlwZS5BTlRJXG4gICAgICApIHtcbiAgICAgICAgaWYgKGJlYXQucGljdG9ncmFwaERhdGEubW90aW9ucy5ibHVlKSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIHVwZGF0ZWQgbW90aW9uIHdpdGggZmxvYXQgcHJvcGVydGllc1xuICAgICAgICAgIGJlYXQucGljdG9ncmFwaERhdGEubW90aW9ucy5ibHVlID0ge1xuICAgICAgICAgICAgLi4uYmVhdC5waWN0b2dyYXBoRGF0YS5tb3Rpb25zLmJsdWUsXG4gICAgICAgICAgICB0dXJuczogXCJmbFwiLFxuICAgICAgICAgICAgcHJlZmxvYXRNb3Rpb25UeXBlOiBiZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMuYmx1ZS5tb3Rpb25UeXBlLFxuICAgICAgICAgICAgcHJlZmxvYXRSb3RhdGlvbkRpcmVjdGlvbjpcbiAgICAgICAgICAgICAgYmVhdC5waWN0b2dyYXBoRGF0YS5tb3Rpb25zLmJsdWUucm90YXRpb25EaXJlY3Rpb24sXG4gICAgICAgICAgICBtb3Rpb25UeXBlOiBNb3Rpb25UeXBlLkZMT0FULFxuICAgICAgICAgICAgcm90YXRpb25EaXJlY3Rpb246IFJvdGF0aW9uRGlyZWN0aW9uLk5PX1JPVEFUSU9OLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChiZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMuYmx1ZSkge1xuICAgICAgICAgIGJlYXQucGljdG9ncmFwaERhdGEubW90aW9ucy5ibHVlID0ge1xuICAgICAgICAgICAgLi4uYmVhdC5waWN0b2dyYXBoRGF0YS5tb3Rpb25zLmJsdWUsXG4gICAgICAgICAgICB0dXJuczogMCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChiZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMuYmx1ZSkge1xuICAgICAgICBiZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMuYmx1ZSA9IHtcbiAgICAgICAgICAuLi5iZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMuYmx1ZSxcbiAgICAgICAgICB0dXJuczogdHVybkJsdWUsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHJlZCB0dXJucyAtIGV4YWN0IGxlZ2FjeSBsb2dpY1xuICAgIGlmICh0dXJuUmVkID09PSBcImZsXCIpIHtcbiAgICAgIGlmIChcbiAgICAgICAgYmVhdC5waWN0b2dyYXBoRGF0YS5tb3Rpb25zLnJlZD8ubW90aW9uVHlwZSA9PT0gTW90aW9uVHlwZS5QUk8gfHxcbiAgICAgICAgYmVhdC5waWN0b2dyYXBoRGF0YS5tb3Rpb25zLnJlZD8ubW90aW9uVHlwZSA9PT0gTW90aW9uVHlwZS5BTlRJXG4gICAgICApIHtcbiAgICAgICAgaWYgKGJlYXQucGljdG9ncmFwaERhdGEubW90aW9ucy5yZWQpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgdXBkYXRlZCBtb3Rpb24gd2l0aCBmbG9hdCBwcm9wZXJ0aWVzXG4gICAgICAgICAgYmVhdC5waWN0b2dyYXBoRGF0YS5tb3Rpb25zLnJlZCA9IHtcbiAgICAgICAgICAgIC4uLmJlYXQucGljdG9ncmFwaERhdGEubW90aW9ucy5yZWQsXG4gICAgICAgICAgICB0dXJuczogXCJmbFwiLFxuICAgICAgICAgICAgcHJlZmxvYXRNb3Rpb25UeXBlOiBiZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMucmVkLm1vdGlvblR5cGUsXG4gICAgICAgICAgICBwcmVmbG9hdFJvdGF0aW9uRGlyZWN0aW9uOlxuICAgICAgICAgICAgICBiZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMucmVkLnJvdGF0aW9uRGlyZWN0aW9uLFxuICAgICAgICAgICAgbW90aW9uVHlwZTogTW90aW9uVHlwZS5GTE9BVCxcbiAgICAgICAgICAgIHJvdGF0aW9uRGlyZWN0aW9uOiBSb3RhdGlvbkRpcmVjdGlvbi5OT19ST1RBVElPTixcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYmVhdC5waWN0b2dyYXBoRGF0YS5tb3Rpb25zLnJlZCkge1xuICAgICAgICAgIGJlYXQucGljdG9ncmFwaERhdGEubW90aW9ucy5yZWQgPSB7XG4gICAgICAgICAgICAuLi5iZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMucmVkLFxuICAgICAgICAgICAgdHVybnM6IDAsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYmVhdC5waWN0b2dyYXBoRGF0YS5tb3Rpb25zLnJlZCkge1xuICAgICAgICBiZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMucmVkID0ge1xuICAgICAgICAgIC4uLmJlYXQucGljdG9ncmFwaERhdGEubW90aW9ucy5yZWQsXG4gICAgICAgICAgdHVybnM6IHR1cm5SZWQsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBkYXNoL3N0YXRpYyBwcm9wIHJvdGF0aW9uIGRpcmVjdGlvbnMgLSBleGFjdCBwb3J0IGZyb20gbGVnYWN5XG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZURhc2hTdGF0aWNSb3RhdGlvbkRpcmVjdGlvbnMoXG4gICAgYmVhdDogQmVhdERhdGEsXG4gICAgcHJvcENvbnRpbnVpdHk6IHN0cmluZyxcbiAgICBibHVlUm90YXRpb25EaXJlY3Rpb246IHN0cmluZyxcbiAgICByZWRSb3RhdGlvbkRpcmVjdGlvbjogc3RyaW5nXG4gICk6IHZvaWQge1xuICAgIGlmICghYmVhdC5waWN0b2dyYXBoRGF0YSkgcmV0dXJuO1xuXG4gICAgLy8gVXBkYXRlIGJsdWUgLSBleGFjdCBsZWdhY3kgbG9naWNcbiAgICBpZiAoXG4gICAgICBiZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMuYmx1ZT8ubW90aW9uVHlwZSA9PT0gTU9USU9OX1RZUEVTLkRBU0ggfHxcbiAgICAgIGJlYXQucGljdG9ncmFwaERhdGEubW90aW9ucy5ibHVlPy5tb3Rpb25UeXBlID09PSBNT1RJT05fVFlQRVMuU1RBVElDXG4gICAgKSB7XG4gICAgICBjb25zdCB0dXJucyA9IGJlYXQucGljdG9ncmFwaERhdGEubW90aW9ucy5ibHVlLnR1cm5zIHx8IDA7XG4gICAgICBpZiAocHJvcENvbnRpbnVpdHkgPT09IFByb3BDb250aW51aXR5LkNPTlRJTlVPVVMpIHtcbiAgICAgICAgY29uc3QgbmV3Um90YXRpb25EaXJlY3Rpb24gPVxuICAgICAgICAgIHR5cGVvZiB0dXJucyA9PT0gXCJudW1iZXJcIiAmJiB0dXJucyA+IDBcbiAgICAgICAgICAgID8gYmx1ZVJvdGF0aW9uRGlyZWN0aW9uXG4gICAgICAgICAgICA6IFJPVEFUSU9OX0RJUlMubm9Sb3RhdGlvbjtcbiAgICAgICAgYmVhdC5waWN0b2dyYXBoRGF0YS5tb3Rpb25zLmJsdWUgPSB7XG4gICAgICAgICAgLi4uYmVhdC5waWN0b2dyYXBoRGF0YS5tb3Rpb25zLmJsdWUsXG4gICAgICAgICAgcm90YXRpb25EaXJlY3Rpb246IG5ld1JvdGF0aW9uRGlyZWN0aW9uIGFzIFJvdGF0aW9uRGlyZWN0aW9uLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHVybnMgPT09IFwibnVtYmVyXCIgJiYgdHVybnMgPiAwKSB7XG4gICAgICAgIGNvbnN0IG5ld1JvdGF0aW9uRGlyZWN0aW9uID0gdGhpcy5yYW5kb21DaG9pY2UoW1xuICAgICAgICAgIFJPVEFUSU9OX0RJUlMuQ0xPQ0tXSVNFLFxuICAgICAgICAgIFJPVEFUSU9OX0RJUlMuQ09VTlRFUl9DTE9DS1dJU0UsXG4gICAgICAgIF0pO1xuICAgICAgICBiZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMuYmx1ZSA9IHtcbiAgICAgICAgICAuLi5iZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMuYmx1ZSxcbiAgICAgICAgICByb3RhdGlvbkRpcmVjdGlvbjogbmV3Um90YXRpb25EaXJlY3Rpb24sXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMuYmx1ZSA9IHtcbiAgICAgICAgICAuLi5iZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMuYmx1ZSxcbiAgICAgICAgICByb3RhdGlvbkRpcmVjdGlvbjogUk9UQVRJT05fRElSUy5ub1JvdGF0aW9uLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSByZWQgLSBleGFjdCBsZWdhY3kgbG9naWNcbiAgICBpZiAoXG4gICAgICBiZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMucmVkPy5tb3Rpb25UeXBlID09PSBNT1RJT05fVFlQRVMuREFTSCB8fFxuICAgICAgYmVhdC5waWN0b2dyYXBoRGF0YS5tb3Rpb25zLnJlZD8ubW90aW9uVHlwZSA9PT0gTU9USU9OX1RZUEVTLlNUQVRJQ1xuICAgICkge1xuICAgICAgY29uc3QgdHVybnMgPSBiZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMucmVkLnR1cm5zIHx8IDA7XG4gICAgICBpZiAocHJvcENvbnRpbnVpdHkgPT09IFByb3BDb250aW51aXR5LkNPTlRJTlVPVVMpIHtcbiAgICAgICAgY29uc3QgbmV3Um90YXRpb25EaXJlY3Rpb24gPVxuICAgICAgICAgIHR5cGVvZiB0dXJucyA9PT0gXCJudW1iZXJcIiAmJiB0dXJucyA+IDBcbiAgICAgICAgICAgID8gcmVkUm90YXRpb25EaXJlY3Rpb25cbiAgICAgICAgICAgIDogUk9UQVRJT05fRElSUy5ub1JvdGF0aW9uO1xuICAgICAgICBiZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMucmVkID0ge1xuICAgICAgICAgIC4uLmJlYXQucGljdG9ncmFwaERhdGEubW90aW9ucy5yZWQsXG4gICAgICAgICAgcm90YXRpb25EaXJlY3Rpb246IG5ld1JvdGF0aW9uRGlyZWN0aW9uIGFzIFJvdGF0aW9uRGlyZWN0aW9uLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHVybnMgPT09IFwibnVtYmVyXCIgJiYgdHVybnMgPiAwKSB7XG4gICAgICAgIGNvbnN0IG5ld1JvdGF0aW9uRGlyZWN0aW9uID0gdGhpcy5yYW5kb21DaG9pY2UoW1xuICAgICAgICAgIFJPVEFUSU9OX0RJUlMuQ0xPQ0tXSVNFLFxuICAgICAgICAgIFJPVEFUSU9OX0RJUlMuQ09VTlRFUl9DTE9DS1dJU0UsXG4gICAgICAgIF0pO1xuICAgICAgICBiZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMucmVkID0ge1xuICAgICAgICAgIC4uLmJlYXQucGljdG9ncmFwaERhdGEubW90aW9ucy5yZWQsXG4gICAgICAgICAgcm90YXRpb25EaXJlY3Rpb246IG5ld1JvdGF0aW9uRGlyZWN0aW9uLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmVhdC5waWN0b2dyYXBoRGF0YS5tb3Rpb25zLnJlZCA9IHtcbiAgICAgICAgICAuLi5iZWF0LnBpY3RvZ3JhcGhEYXRhLm1vdGlvbnMucmVkLFxuICAgICAgICAgIHJvdGF0aW9uRGlyZWN0aW9uOiBST1RBVElPTl9ESVJTLm5vUm90YXRpb24sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJhbmRvbSBjaG9pY2UgaGVscGVyIC0gZXhhY3QgYmVoYXZpb3IgZnJvbSBsZWdhY3kgcmFuZG9tLmNob2ljZSgpXG4gICAqL1xuICBwcml2YXRlIHJhbmRvbUNob2ljZTxUPihhcnJheTogVFtdKTogVCB7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNob29zZSBmcm9tIGVtcHR5IGFycmF5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyYXkubGVuZ3RoKV07XG4gIH1cblxuICAvKipcbiAgICogTWFwIGRpZmZpY3VsdHkgdG8gbGV2ZWwgLSBsZWdhY3kgbWFwcGluZ1xuICAgKi9cbiAgcHJpdmF0ZSBtYXBEaWZmaWN1bHR5VG9MZXZlbChkaWZmaWN1bHR5OiBEaWZmaWN1bHR5TGV2ZWwpOiBudW1iZXIge1xuICAgIHN3aXRjaCAoZGlmZmljdWx0eSkge1xuICAgICAgY2FzZSBEaWZmaWN1bHR5TGV2ZWwuQkVHSU5ORVI6XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBEaWZmaWN1bHR5TGV2ZWwuSU5URVJNRURJQVRFOlxuICAgICAgICByZXR1cm4gMjtcbiAgICAgIGNhc2UgRGlmZmljdWx0eUxldmVsLkFEVkFOQ0VEOlxuICAgICAgICByZXR1cm4gMztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBzZXF1ZW5jZSBuYW1lIGJhc2VkIG9uIG9wdGlvbnMgLSBtYXRjaGVzIGxlZ2FjeSBwYXR0ZXJuXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlU2VxdWVuY2VOYW1lKG9wdGlvbnM6IEdlbmVyYXRpb25PcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKFwiZW4tVVNcIiwge1xuICAgICAgbW9udGg6IFwic2hvcnRcIixcbiAgICAgIGRheTogXCJudW1lcmljXCIsXG4gICAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgfSk7XG5cbiAgICBjb25zdCBkaWZmaWN1bHR5ID1cbiAgICAgIG9wdGlvbnMuZGlmZmljdWx0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG9wdGlvbnMuZGlmZmljdWx0eS5zbGljZSgxKTtcbiAgICByZXR1cm4gYCR7ZGlmZmljdWx0eX0gJHtvcHRpb25zLmxlbmd0aH0tQmVhdCAoJHt0aW1lc3RhbXB9KWA7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgY2lyY3VsYXIgc2VxdWVuY2UgLSBub3QgaW1wbGVtZW50ZWQgaW4gUGhhc2UgMVxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVQYXR0ZXJuU2VxdWVuY2UoXG4gICAgcGF0dGVybjogR2VuZXJhdGlvbk1vZGUsXG4gICAgX29wdGlvbnM6IEdlbmVyYXRpb25PcHRpb25zXG4gICk6IFByb21pc2U8U2VxdWVuY2VEYXRhPiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3BhdHRlcm59IGdlbmVyYXRpb24gbm90IGltcGxlbWVudGVkIHlldGApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBnZW5lcmF0aW9uIHN0YXRpc3RpY3MgLSBub3QgaW1wbGVtZW50ZWQgaW4gUGhhc2UgMVxuICAgKi9cbiAgZ2V0R2VuZXJhdGlvblN0YXRzKCk6IHtcbiAgICB0b3RhbEdlbmVyYXRlZDogbnVtYmVyO1xuICAgIGF2ZXJhZ2VHZW5lcmF0aW9uVGltZTogbnVtYmVyO1xuICAgIGxhc3RHZW5lcmF0ZWQ6IHN0cmluZyB8IG51bGw7XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICB0b3RhbEdlbmVyYXRlZDogMCxcbiAgICAgIGF2ZXJhZ2VHZW5lcmF0aW9uVGltZTogMCxcbiAgICAgIGxhc3RHZW5lcmF0ZWQ6IG51bGwsXG4gICAgfTtcbiAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIkFBUUEsU0FBUywwQkFBMEI7QUFDbkMsU0FBUyxVQUFVLGdCQUFnQjtBQVNuQyxTQUFTLHdCQUF3QjtBQUNqQztBQUFBLEVBQ0U7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxPQUNLO0FBR1AsTUFBTSxnQkFBZ0I7QUFBQSxFQUNwQixXQUFXLGtCQUFrQjtBQUFBLEVBQzdCLG1CQUFtQixrQkFBa0I7QUFBQSxFQUNyQyxZQUFZLGtCQUFrQjtBQUNoQztBQUVBLE1BQU0sZUFBZTtBQUFBLEVBQ25CLEtBQUssV0FBVztBQUFBLEVBQ2hCLE1BQU0sV0FBVztBQUFBLEVBQ2pCLE9BQU8sV0FBVztBQUFBLEVBQ2xCLE1BQU0sV0FBVztBQUFBLEVBQ2pCLFFBQVEsV0FBVztBQUNyQjtBQUVPLGFBQU0sMEJBQWdFO0FBQUEsRUFDM0UsWUFDVSxvQkFDQSwrQkFDUjtBQUZRO0FBQ0E7QUFBQSxFQUNQO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLSCxNQUFNLGlCQUFpQixTQUFtRDtBQUN4RSxRQUFJO0FBQ0YsY0FBUSxJQUFJLGlEQUFpRCxPQUFPO0FBS3BFLFlBQU0sV0FBdUIsQ0FBQztBQUc5QixVQUFJO0FBQ0osVUFBSTtBQUVKLFVBQUksUUFBUSxtQkFBbUIsZUFBZSxZQUFZO0FBQ3hELGdDQUF3QixLQUFLLGFBQWE7QUFBQSxVQUN4QyxjQUFjO0FBQUEsVUFDZCxjQUFjO0FBQUEsUUFDaEIsQ0FBQztBQUNELCtCQUF1QixLQUFLLGFBQWE7QUFBQSxVQUN2QyxjQUFjO0FBQUEsVUFDZCxjQUFjO0FBQUEsUUFDaEIsQ0FBQztBQUFBLE1BQ0gsT0FBTztBQUVMLGdDQUF3QjtBQUN4QiwrQkFBdUI7QUFBQSxNQUN6QjtBQUVBLGNB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
