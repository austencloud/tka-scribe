var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
import { SortMethod as SortMethodEnum } from "/src/lib/domain/browse/SortMethod.ts";
import { injectable } from "/node_modules/.vite/deps/inversify.js?v=608ae08a";
import {
  safeSessionStorageGet,
  safeSessionStorageSet,
  safeSessionStorageRemove
} from "/src/lib/utils/safe-storage.ts";
export let FilterPersistenceService = class {
  CACHE_VERSION = "v2.1";
  // âœ… ROBUST: Cache versioning
  BROWSE_STATE_KEY = `tka-${this.CACHE_VERSION}-browse-state`;
  FILTER_HISTORY_KEY = `tka-${this.CACHE_VERSION}-filter-history`;
  MAX_HISTORY_SIZE = 50;
  async saveBrowseState(state) {
    try {
      const stateToSave = {
        ...state,
        lastUpdated: /* @__PURE__ */ new Date()
      };
      safeSessionStorageSet(this.BROWSE_STATE_KEY, stateToSave);
    } catch (error) {
      console.error("Failed to save browse state:", error);
    }
  }
  async loadBrowseState() {
    try {
      const parsed = safeSessionStorageGet(
        this.BROWSE_STATE_KEY,
        null
      );
      if (!parsed) return null;
      if (parsed.currentFilter && typeof parsed.currentFilter === "object" && parsed.currentFilter !== null && "appliedAt" in parsed.currentFilter) {
        parsed.currentFilter.appliedAt = new Date(
          parsed.currentFilter.appliedAt
        );
      }
      if (parsed.lastUpdated && typeof parsed.lastUpdated === "string") {
        parsed.lastUpdated = new Date(parsed.lastUpdated);
      }
      const oneDay = 24 * 60 * 60 * 1e3;
      if (parsed.lastUpdated instanceof Date && Date.now() - parsed.lastUpdated.getTime() > oneDay) {
        return null;
      }
      return parsed;
    } catch (error) {
      console.warn("Failed to load browse state:", error);
      return null;
    }
  }
  async saveFilterToHistory(filter) {
    try {
      const history = await this.getFilterHistory();
      const filteredHistory = history.filter(
        (f) => !(f.type === filter.type && JSON.stringify(f.value) === JSON.stringify(filter.value))
      );
      const newHistory = [filter, ...filteredHistory];
      const trimmedHistory = newHistory.slice(0, this.MAX_HISTORY_SIZE);
      safeSessionStorageSet(this.FILTER_HISTORY_KEY, trimmedHistory);
    } catch (error) {
      console.error("Failed to save filter to history:", error);
    }
  }
  async getFilterHistory() {
    try {
      const parsed = safeSessionStorageGet(
        this.FILTER_HISTORY_KEY,
        []
      );
      if (!parsed) return [];
      return parsed.map((filter) => {
        const f = filter;
        return {
          ...f,
          appliedAt: new Date(f.appliedAt)
        };
      });
    } catch (error) {
      console.warn("Failed to load filter history:", error);
      return [];
    }
  }
  async clearFilterHistory() {
    safeSessionStorageRemove(this.FILTER_HISTORY_KEY);
  }
  async getRecentFilters(limit = 10) {
    const history = await this.getFilterHistory();
    return history.slice(0, limit);
  }
  async clearAllState() {
    safeSessionStorageRemove(this.BROWSE_STATE_KEY);
    safeSessionStorageRemove(this.FILTER_HISTORY_KEY);
  }
  // Utility methods for filter management
  async getFilterFrequency() {
    const history = await this.getFilterHistory();
    const frequency = /* @__PURE__ */ new Map();
    history.forEach((filter) => {
      const key = `${filter.type}:${JSON.stringify(filter.value)}`;
      frequency.set(key, (frequency.get(key) || 0) + 1);
    });
    return frequency;
  }
  async getMostUsedFilters(limit = 5) {
    const history = await this.getFilterHistory();
    const frequency = await this.getFilterFrequency();
    const filterMap = /* @__PURE__ */ new Map();
    history.forEach((filter) => {
      const key = `${filter.type}:${JSON.stringify(filter.value)}`;
      if (!filterMap.has(key)) {
        filterMap.set(key, filter);
      }
    });
    return Array.from(filterMap.values()).sort((a, b) => {
      const keyA = `${a.type}:${JSON.stringify(a.value)}`;
      const keyB = `${b.type}:${JSON.stringify(b.value)}`;
      return (frequency.get(keyB) || 0) - (frequency.get(keyA) || 0);
    }).slice(0, limit);
  }
  async getDefaultBrowseState() {
    return {
      displayState: {
        currentView: "filter_selection",
        selectedSequence: null,
        isSequenceDetailOpen: false
      },
      loadingState: {
        isLoading: false,
        hasError: false,
        errorMessage: null
      },
      filterState: {
        activeFilters: {
          starting_letter: "",
          contains_letters: "",
          length: "",
          difficulty: "",
          startPosition: "",
          author: "",
          gridMode: "",
          all_sequences: "",
          favorites: "",
          recent: ""
        },
        sortMethod: "alphabetical",
        searchQuery: ""
      }
    };
  }
  // Additional methods required by browse-interfaces.ts
  async saveFilterState(state) {
    const browseState = {
      displayState: {
        currentView: "filter_selection",
        selectedSequence: null,
        isSequenceDetailOpen: false
      },
      loadingState: {
        isLoading: false,
        hasError: false,
        errorMessage: null
      },
      filterState: state
    };
    await this.saveBrowseState(browseState);
  }
  async loadFilterState() {
    const browseState = await this.loadBrowseState();
    return browseState?.filterState || {
      activeFilters: {
        starting_letter: null,
        contains_letters: null,
        length: null,
        difficulty: null,
        startPosition: null,
        author: null,
        gridMode: null,
        all_sequences: null,
        favorites: null,
        recent: null
      },
      sortMethod: SortMethodEnum.ALPHABETICAL,
      searchQuery: ""
    };
  }
};
FilterPersistenceService = __decorateClass([
  injectable()
], FilterPersistenceService);
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3NlcnZpY2VzL2ltcGxlbWVudGF0aW9ucy9wZXJzaXN0ZW5jZS9GaWx0ZXJQZXJzaXN0ZW5jZVNlcnZpY2UudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogRmlsdGVyIFBlcnNpc3RlbmNlIFNlcnZpY2UgLSBNYW5hZ2VzIGZpbHRlciBzdGF0ZSBwZXJzaXN0ZW5jZVxuICpcbiAqIEhhbmRsZXMgc2F2aW5nIGFuZCByZXN0b3JpbmcgZmlsdGVyIHN0YXRlcyBhY3Jvc3Mgc2Vzc2lvbnMsXG4gKiBmb2xsb3dpbmcgdGhlIG1pY3Jvc2VydmljZXMgYXJjaGl0ZWN0dXJlIHBhdHRlcm4uXG4gKi9cblxuaW1wb3J0IHR5cGUge1xuICBGaWx0ZXJUeXBlLFxuICBGaWx0ZXJWYWx1ZSxcbiAgU29ydE1ldGhvZCxcbn0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXMvZG9tYWluLXR5cGVzXCI7XG5pbXBvcnQgdHlwZSB7XG4gIEJyb3dzZVN0YXRlLFxuICBGaWx0ZXJTdGF0ZSBhcyBCcm93c2VGaWx0ZXJTdGF0ZSxcbn0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXMvYnJvd3NlLWludGVyZmFjZXNcIjtcbmltcG9ydCB7IFNvcnRNZXRob2QgYXMgU29ydE1ldGhvZEVudW0gfSBmcm9tIFwiLi4vLi4vLi4vZG9tYWluL2Jyb3dzZS9Tb3J0TWV0aG9kXCI7XG5pbXBvcnQgeyBpbmplY3RhYmxlIH0gZnJvbSBcImludmVyc2lmeVwiO1xuaW1wb3J0IHtcbiAgc2FmZVNlc3Npb25TdG9yYWdlR2V0LFxuICBzYWZlU2Vzc2lvblN0b3JhZ2VTZXQsXG4gIHNhZmVTZXNzaW9uU3RvcmFnZVJlbW92ZSxcbn0gZnJvbSBcIiRsaWIvdXRpbHMvc2FmZS1zdG9yYWdlXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsdGVyU3RhdGUge1xuICB0eXBlOiBGaWx0ZXJUeXBlO1xuICB2YWx1ZTogRmlsdGVyVmFsdWU7XG4gIGFwcGxpZWRBdDogRGF0ZTtcbn1cblxuLy8gVXNlIHRoZSBCcm93c2VTdGF0ZSBmcm9tIHRoZSBpbnRlcmZhY2UgaW5zdGVhZCBvZiBkZWZpbmluZyBvdXIgb3duXG4vLyBleHBvcnQgaW50ZXJmYWNlIEJyb3dzZVN0YXRlIHtcbi8vICAgY3VycmVudEZpbHRlcjogRmlsdGVyU3RhdGUgfCBudWxsO1xuLy8gICBzb3J0TWV0aG9kOiBTb3J0TWV0aG9kO1xuLy8gICBuYXZpZ2F0aW9uTW9kZTogXCJmaWx0ZXJfc2VsZWN0aW9uXCIgfCBcInNlcXVlbmNlX2Jyb3dzZXJcIjtcbi8vICAgc2VhcmNoUXVlcnk6IHN0cmluZztcbi8vICAgbGFzdFVwZGF0ZWQ6IERhdGU7XG4vLyB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZpbHRlclBlcnNpc3RlbmNlU2VydmljZSB7XG4gIC8qKiBTYXZlIGN1cnJlbnQgYnJvd3NlIHN0YXRlICovXG4gIHNhdmVCcm93c2VTdGF0ZShzdGF0ZTogQnJvd3NlU3RhdGUpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKiBMb2FkIHNhdmVkIGJyb3dzZSBzdGF0ZSAqL1xuICBsb2FkQnJvd3NlU3RhdGUoKTogUHJvbWlzZTxCcm93c2VTdGF0ZSB8IG51bGw+O1xuXG4gIC8qKiBTYXZlIGZpbHRlciBoaXN0b3J5ICovXG4gIHNhdmVGaWx0ZXJUb0hpc3RvcnkoZmlsdGVyOiBGaWx0ZXJTdGF0ZSk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqIEdldCBmaWx0ZXIgaGlzdG9yeSAqL1xuICBnZXRGaWx0ZXJIaXN0b3J5KCk6IFByb21pc2U8RmlsdGVyU3RhdGVbXT47XG5cbiAgLyoqIENsZWFyIGZpbHRlciBoaXN0b3J5ICovXG4gIGNsZWFyRmlsdGVySGlzdG9yeSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKiBHZXQgcmVjZW50bHkgdXNlZCBmaWx0ZXJzICovXG4gIGdldFJlY2VudEZpbHRlcnMobGltaXQ/OiBudW1iZXIpOiBQcm9taXNlPEZpbHRlclN0YXRlW10+O1xuXG4gIC8qKiBDbGVhciBhbGwgc2F2ZWQgc3RhdGUgKi9cbiAgY2xlYXJBbGxTdGF0ZSgpOiBQcm9taXNlPHZvaWQ+O1xufVxuXG5AaW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRmlsdGVyUGVyc2lzdGVuY2VTZXJ2aWNlIGltcGxlbWVudHMgSUZpbHRlclBlcnNpc3RlbmNlU2VydmljZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgQ0FDSEVfVkVSU0lPTiA9IFwidjIuMVwiOyAvLyDinIUgUk9CVVNUOiBDYWNoZSB2ZXJzaW9uaW5nXG4gIHByaXZhdGUgcmVhZG9ubHkgQlJPV1NFX1NUQVRFX0tFWSA9IGB0a2EtJHt0aGlzLkNBQ0hFX1ZFUlNJT059LWJyb3dzZS1zdGF0ZWA7XG4gIHByaXZhdGUgcmVhZG9ubHkgRklMVEVSX0hJU1RPUllfS0VZID0gYHRrYS0ke3RoaXMuQ0FDSEVfVkVSU0lPTn0tZmlsdGVyLWhpc3RvcnlgO1xuICBwcml2YXRlIHJlYWRvbmx5IE1BWF9ISVNUT1JZX1NJWkUgPSA1MDtcblxuICBhc3luYyBzYXZlQnJvd3NlU3RhdGUoc3RhdGU6IEJyb3dzZVN0YXRlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlVG9TYXZlID0ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCksXG4gICAgICB9O1xuICAgICAgc2FmZVNlc3Npb25TdG9yYWdlU2V0KHRoaXMuQlJPV1NFX1NUQVRFX0tFWSwgc3RhdGVUb1NhdmUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNhdmUgYnJvd3NlIHN0YXRlOlwiLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgbG9hZEJyb3dzZVN0YXRlKCk6IFByb21pc2U8QnJvd3NlU3RhdGUgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHNhZmVTZXNzaW9uU3RvcmFnZUdldDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gICAgICAgIHRoaXMuQlJPV1NFX1NUQVRFX0tFWSxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICAgIGlmICghcGFyc2VkKSByZXR1cm4gbnVsbDtcblxuICAgICAgLy8gQ29udmVydCBkYXRlIHN0cmluZ3MgYmFjayB0byBEYXRlIG9iamVjdHNcbiAgICAgIGlmIChcbiAgICAgICAgcGFyc2VkLmN1cnJlbnRGaWx0ZXIgJiZcbiAgICAgICAgdHlwZW9mIHBhcnNlZC5jdXJyZW50RmlsdGVyID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHBhcnNlZC5jdXJyZW50RmlsdGVyICE9PSBudWxsICYmXG4gICAgICAgIFwiYXBwbGllZEF0XCIgaW4gcGFyc2VkLmN1cnJlbnRGaWx0ZXJcbiAgICAgICkge1xuICAgICAgICAocGFyc2VkLmN1cnJlbnRGaWx0ZXIgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pLmFwcGxpZWRBdCA9IG5ldyBEYXRlKFxuICAgICAgICAgIChwYXJzZWQuY3VycmVudEZpbHRlciBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikuYXBwbGllZEF0IGFzIHN0cmluZ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnNlZC5sYXN0VXBkYXRlZCAmJiB0eXBlb2YgcGFyc2VkLmxhc3RVcGRhdGVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHBhcnNlZC5sYXN0VXBkYXRlZCA9IG5ldyBEYXRlKHBhcnNlZC5sYXN0VXBkYXRlZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZhbGlkYXRlIHN0YXRlIGlzIG5vdCB0b28gb2xkIChvbGRlciB0aGFuIDEgZGF5KVxuICAgICAgY29uc3Qgb25lRGF5ID0gMjQgKiA2MCAqIDYwICogMTAwMDtcbiAgICAgIGlmIChcbiAgICAgICAgcGFyc2VkLmxhc3RVcGRhdGVkIGluc3RhbmNlb2YgRGF0ZSAmJlxuICAgICAgICBEYXRlLm5vdygpIC0gcGFyc2VkLmxhc3RVcGRhdGVkLmdldFRpbWUoKSA+IG9uZURheVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VkIGFzIHVua25vd24gYXMgQnJvd3NlU3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBsb2FkIGJyb3dzZSBzdGF0ZTpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc2F2ZUZpbHRlclRvSGlzdG9yeShmaWx0ZXI6IEZpbHRlclN0YXRlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhpc3RvcnkgPSBhd2FpdCB0aGlzLmdldEZpbHRlckhpc3RvcnkoKTtcblxuICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBmaWx0ZXJzIChzYW1lIHR5cGUgYW5kIHZhbHVlKVxuICAgICAgY29uc3QgZmlsdGVyZWRIaXN0b3J5ID0gaGlzdG9yeS5maWx0ZXIoXG4gICAgICAgIChmKSA9PlxuICAgICAgICAgICEoXG4gICAgICAgICAgICBmLnR5cGUgPT09IGZpbHRlci50eXBlICYmXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShmLnZhbHVlKSA9PT0gSlNPTi5zdHJpbmdpZnkoZmlsdGVyLnZhbHVlKVxuICAgICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIC8vIEFkZCBuZXcgZmlsdGVyIHRvIHRoZSBiZWdpbm5pbmdcbiAgICAgIGNvbnN0IG5ld0hpc3RvcnkgPSBbZmlsdGVyLCAuLi5maWx0ZXJlZEhpc3RvcnldO1xuXG4gICAgICAvLyBMaW1pdCBoaXN0b3J5IHNpemVcbiAgICAgIGNvbnN0IHRyaW1tZWRIaXN0b3J5ID0gbmV3SGlzdG9yeS5zbGljZSgwLCB0aGlzLk1BWF9ISVNUT1JZX1NJWkUpO1xuXG4gICAgICBzYWZlU2Vzc2lvblN0b3JhZ2VTZXQodGhpcy5GSUxURVJfSElTVE9SWV9LRVksIHRyaW1tZWRIaXN0b3J5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzYXZlIGZpbHRlciB0byBoaXN0b3J5OlwiLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0RmlsdGVySGlzdG9yeSgpOiBQcm9taXNlPEZpbHRlclN0YXRlW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyc2VkID0gc2FmZVNlc3Npb25TdG9yYWdlR2V0PHVua25vd25bXT4oXG4gICAgICAgIHRoaXMuRklMVEVSX0hJU1RPUllfS0VZLFxuICAgICAgICBbXVxuICAgICAgKTtcbiAgICAgIGlmICghcGFyc2VkKSByZXR1cm4gW107XG5cbiAgICAgIC8vIENvbnZlcnQgZGF0ZSBzdHJpbmdzIGJhY2sgdG8gRGF0ZSBvYmplY3RzXG4gICAgICByZXR1cm4gcGFyc2VkLm1hcCgoZmlsdGVyOiB1bmtub3duKSA9PiB7XG4gICAgICAgIGNvbnN0IGYgPSBmaWx0ZXIgYXMge1xuICAgICAgICAgIHR5cGU6IEZpbHRlclR5cGU7XG4gICAgICAgICAgdmFsdWU6IEZpbHRlclZhbHVlO1xuICAgICAgICAgIGFwcGxpZWRBdDogc3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmYsXG4gICAgICAgICAgYXBwbGllZEF0OiBuZXcgRGF0ZShmLmFwcGxpZWRBdCksXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGxvYWQgZmlsdGVyIGhpc3Rvcnk6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjbGVhckZpbHRlckhpc3RvcnkoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgc2FmZVNlc3Npb25TdG9yYWdlUmVtb3ZlKHRoaXMuRklMVEVSX0hJU1RPUllfS0VZKTtcbiAgfVxuXG4gIGFzeW5jIGdldFJlY2VudEZpbHRlcnMobGltaXQ6IG51bWJlciA9IDEwKTogUHJvbWlzZTxGaWx0ZXJTdGF0ZVtdPiB7XG4gICAgY29uc3QgaGlzdG9yeSA9IGF3YWl0IHRoaXMuZ2V0RmlsdGVySGlzdG9yeSgpO1xuICAgIHJldHVybiBoaXN0b3J5LnNsaWNlKDAsIGxpbWl0KTtcbiAgfVxuXG4gIGFzeW5jIGNsZWFyQWxsU3RhdGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgc2FmZVNlc3Npb25TdG9yYWdlUmVtb3ZlKHRoaXMuQlJPV1NFX1NUQVRFX0tFWSk7XG4gICAgc2FmZVNlc3Npb25TdG9yYWdlUmVtb3ZlKHRoaXMuRklMVEVSX0hJU1RPUllfS0VZKTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kcyBmb3IgZmlsdGVyIG1hbmFnZW1lbnRcbiAgYXN5bmMgZ2V0RmlsdGVyRnJlcXVlbmN5KCk6IFByb21pc2U8TWFwPHN0cmluZywgbnVtYmVyPj4ge1xuICAgIGNvbnN0IGhpc3RvcnkgPSBhd2FpdCB0aGlzLmdldEZpbHRlckhpc3RvcnkoKTtcbiAgICBjb25zdCBmcmVxdWVuY3kgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG4gICAgaGlzdG9yeS5mb3JFYWNoKChmaWx0ZXIpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2ZpbHRlci50eXBlfToke0pTT04uc3RyaW5naWZ5KGZpbHRlci52YWx1ZSl9YDtcbiAgICAgIGZyZXF1ZW5jeS5zZXQoa2V5LCAoZnJlcXVlbmN5LmdldChrZXkpIHx8IDApICsgMSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnJlcXVlbmN5O1xuICB9XG5cbiAgYXN5bmMgZ2V0TW9zdFVzZWRGaWx0ZXJzKGxpbWl0OiBudW1iZXIgPSA1KTogUHJvbWlzZTxGaWx0ZXJTdGF0ZVtdPiB7XG4gICAgY29uc3QgaGlzdG9yeSA9IGF3YWl0IHRoaXMuZ2V0RmlsdGVySGlzdG9yeSgpO1xuICAgIGNvbnN0IGZyZXF1ZW5jeSA9IGF3YWl0IHRoaXMuZ2V0RmlsdGVyRnJlcXVlbmN5KCk7XG5cbiAgICAvLyBHcm91cCBmaWx0ZXJzIGJ5IHR5cGU6dmFsdWUgYW5kIGZpbmQgbW9zdCBmcmVxdWVudFxuICAgIGNvbnN0IGZpbHRlck1hcCA9IG5ldyBNYXA8c3RyaW5nLCBGaWx0ZXJTdGF0ZT4oKTtcbiAgICBoaXN0b3J5LmZvckVhY2goKGZpbHRlcikgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZmlsdGVyLnR5cGV9OiR7SlNPTi5zdHJpbmdpZnkoZmlsdGVyLnZhbHVlKX1gO1xuICAgICAgaWYgKCFmaWx0ZXJNYXAuaGFzKGtleSkpIHtcbiAgICAgICAgZmlsdGVyTWFwLnNldChrZXksIGZpbHRlcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbShmaWx0ZXJNYXAudmFsdWVzKCkpXG4gICAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBrZXlBID0gYCR7YS50eXBlfToke0pTT04uc3RyaW5naWZ5KGEudmFsdWUpfWA7XG4gICAgICAgIGNvbnN0IGtleUIgPSBgJHtiLnR5cGV9OiR7SlNPTi5zdHJpbmdpZnkoYi52YWx1ZSl9YDtcbiAgICAgICAgcmV0dXJuIChmcmVxdWVuY3kuZ2V0KGtleUIpIHx8IDApIC0gKGZyZXF1ZW5jeS5nZXQoa2V5QSkgfHwgMCk7XG4gICAgICB9KVxuICAgICAgLnNsaWNlKDAsIGxpbWl0KTtcbiAgfVxuXG4gIGFzeW5jIGdldERlZmF1bHRCcm93c2VTdGF0ZSgpOiBQcm9taXNlPEJyb3dzZVN0YXRlPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc3BsYXlTdGF0ZToge1xuICAgICAgICBjdXJyZW50VmlldzogXCJmaWx0ZXJfc2VsZWN0aW9uXCIsXG4gICAgICAgIHNlbGVjdGVkU2VxdWVuY2U6IG51bGwsXG4gICAgICAgIGlzU2VxdWVuY2VEZXRhaWxPcGVuOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICBsb2FkaW5nU3RhdGU6IHtcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgaGFzRXJyb3I6IGZhbHNlLFxuICAgICAgICBlcnJvck1lc3NhZ2U6IG51bGwsXG4gICAgICB9LFxuICAgICAgZmlsdGVyU3RhdGU6IHtcbiAgICAgICAgYWN0aXZlRmlsdGVyczoge1xuICAgICAgICAgIHN0YXJ0aW5nX2xldHRlcjogXCJcIixcbiAgICAgICAgICBjb250YWluc19sZXR0ZXJzOiBcIlwiLFxuICAgICAgICAgIGxlbmd0aDogXCJcIixcbiAgICAgICAgICBkaWZmaWN1bHR5OiBcIlwiLFxuICAgICAgICAgIHN0YXJ0UG9zaXRpb246IFwiXCIsXG4gICAgICAgICAgYXV0aG9yOiBcIlwiLFxuICAgICAgICAgIGdyaWRNb2RlOiBcIlwiLFxuICAgICAgICAgIGFsbF9zZXF1ZW5jZXM6IFwiXCIsXG4gICAgICAgICAgZmF2b3JpdGVzOiBcIlwiLFxuICAgICAgICAgIHJlY2VudDogXCJcIixcbiAgICAgICAgfSxcbiAgICAgICAgc29ydE1ldGhvZDogXCJhbHBoYWJldGljYWxcIiBhcyBTb3J0TWV0aG9kLFxuICAgICAgICBzZWFyY2hRdWVyeTogXCJcIixcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8vIEFkZGl0aW9uYWwgbWV0aG9kcyByZXF1aXJlZCBieSBicm93c2UtaW50ZXJmYWNlcy50c1xuICBhc3luYyBzYXZlRmlsdGVyU3RhdGUoc3RhdGU6IEJyb3dzZUZpbHRlclN0YXRlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gQ3JlYXRlIGEgQnJvd3NlU3RhdGUgd2l0aCB0aGUgZmlsdGVyIHN0YXRlXG4gICAgY29uc3QgYnJvd3NlU3RhdGU6IEJyb3dzZVN0YXRlID0ge1xuICAgICAgZGlzcGxheVN0YXRlOiB7XG4gICAgICAgIGN1cnJlbnRWaWV3OiBcImZpbHRlcl9zZWxlY3Rpb25cIixcbiAgICAgICAgc2VsZWN0ZWRTZXF1ZW5jZTogbnVsbCxcbiAgICAgICAgaXNTZXF1ZW5jZURldGFpbE9wZW46IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIGxvYWRpbmdTdGF0ZToge1xuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBoYXNFcnJvcjogZmFsc2UsXG4gICAgICAgIGVycm9yTWVzc2FnZTogbnVsbCxcbiAgICAgIH0sXG4gICAgICBmaWx0ZXJTdGF0ZTogc3RhdGUsXG4gICAgfTtcbiAgICBhd2FpdCB0aGlzLnNhdmVCcm93c2VTdGF0ZShicm93c2VTdGF0ZSk7XG4gIH1cblxuICBhc3luYyBsb2FkRmlsdGVyU3RhdGUoKTogUHJvbWlzZTxCcm93c2VGaWx0ZXJTdGF0ZT4ge1xuICAgIC8vIFVzZSB0aGUgZXhpc3RpbmcgbG9hZEJyb3dzZVN0YXRlIG1ldGhvZFxuICAgIGNvbnN0IGJyb3dzZVN0YXRlID0gYXdhaXQgdGhpcy5sb2FkQnJvd3NlU3RhdGUoKTtcblxuICAgIC8vIFJldHVybiB0aGUgZmlsdGVyIHN0YXRlIG9yIGEgZGVmYXVsdCBvbmUgd2l0aCBwcm9wZXIgRmlsdGVyVHlwZSBrZXlzXG4gICAgcmV0dXJuIChcbiAgICAgIGJyb3dzZVN0YXRlPy5maWx0ZXJTdGF0ZSB8fCB7XG4gICAgICAgIGFjdGl2ZUZpbHRlcnM6IHtcbiAgICAgICAgICBzdGFydGluZ19sZXR0ZXI6IG51bGwsXG4gICAgICAgICAgY29udGFpbnNfbGV0dGVyczogbnVsbCxcbiAgICAgICAgICBsZW5ndGg6IG51bGwsXG4gICAgICAgICAgZGlmZmljdWx0eTogbnVsbCxcbiAgICAgICAgICBzdGFydFBvc2l0aW9uOiBudWxsLFxuICAgICAgICAgIGF1dGhvcjogbnVsbCxcbiAgICAgICAgICBncmlkTW9kZTogbnVsbCxcbiAgICAgICAgICBhbGxfc2VxdWVuY2VzOiBudWxsLFxuICAgICAgICAgIGZhdm9yaXRlczogbnVsbCxcbiAgICAgICAgICByZWNlbnQ6IG51bGwsXG4gICAgICAgIH0sXG4gICAgICAgIHNvcnRNZXRob2Q6IFNvcnRNZXRob2RFbnVtLkFMUEhBQkVUSUNBTCxcbiAgICAgICAgc2VhcmNoUXVlcnk6IFwiXCIsXG4gICAgICB9XG4gICAgKTtcbiAgfVxu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
