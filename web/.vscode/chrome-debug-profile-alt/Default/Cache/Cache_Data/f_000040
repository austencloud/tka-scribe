import {
  MotionColor,
  createBeatData,
  GridMode,
  Location,
  MotionType,
  Orientation,
  PropType,
  RotationDirection
} from "/src/lib/domain/index.ts";
import { PictographDataFactory } from "/src/lib/services/factories/PictographDataFactory.ts";
import { Letter } from "/src/lib/domain/Letter.ts";
export class StartPositionService {
  DEFAULT_START_POSITIONS = {
    diamond: ["alpha1_alpha1", "beta5_beta5", "gamma11_gamma11"],
    box: ["alpha2_alpha2", "beta4_beta4", "gamma12_gamma12"]
  };
  async getAvailableStartPositions(propType, gridMode) {
    console.log(
      `ðŸ“ Getting available start positions for ${propType} in ${gridMode} mode`
    );
    try {
      const startPositionKeys = this.DEFAULT_START_POSITIONS[gridMode];
      if (!startPositionKeys) {
        console.error(
          `âŒ Unsupported grid mode: ${gridMode}. Supported modes: ${Object.keys(this.DEFAULT_START_POSITIONS).join(", ")}`
        );
        const fallbackKeys = this.DEFAULT_START_POSITIONS.diamond;
        console.log(`ðŸ”„ Falling back to diamond mode`);
        const beatData2 = fallbackKeys.map((key, index) => {
          return createBeatData({
            beatNumber: 0,
            isBlank: false,
            pictographData: this.createStartPositionPictograph(
              key,
              index,
              GridMode.DIAMOND
            )
          });
        });
        console.log(
          `âœ… Generated ${beatData2.length} available start positions (fallback)`
        );
        return beatData2;
      }
      const beatData = startPositionKeys.map((key, index) => {
        return createBeatData({
          beatNumber: 0,
          isBlank: false,
          pictographData: this.createStartPositionPictograph(
            key,
            index,
            gridMode
          )
        });
      });
      console.log(`âœ… Generated ${beatData.length} available start positions`);
      return beatData;
    } catch (error) {
      console.error("âŒ Error getting available start positions:", error);
      return [];
    }
  }
  async setStartPosition(startPosition) {
    try {
      if (typeof window !== "undefined") {
        const existingData = localStorage.getItem("startPosition");
        if (existingData) {
          try {
            const parsed = JSON.parse(existingData);
            if (parsed.endPosition) {
              return;
            }
          } catch {
          }
        }
        const optionPickerFormat = {
          endPosition: startPosition.metadata?.endPosition || "alpha1",
          // Extract from metadata
          pictographData: startPosition.pictographData,
          letter: startPosition.pictographData?.letter,
          gridMode: GridMode.DIAMOND,
          // Default
          isStartPosition: true,
          // Include the full beat data for compatibility
          ...startPosition
        };
        localStorage.setItem(
          "startPosition",
          JSON.stringify(optionPickerFormat)
        );
      }
    } catch (error) {
      console.error("Error setting start position:", error);
      throw new Error(
        `Failed to set start position: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  validateStartPosition(position) {
    const errors = [];
    if (!position.pictographData) {
      errors.push({
        code: "MISSING_pictographData",
        message: "Start position must have pictograph data",
        severity: "error"
      });
    }
    if (!position.pictographData?.motions?.blue && !position.pictographData?.motions?.red) {
      errors.push({
        code: "MISSING_MOTIONS",
        message: "Start position must have at least one motion",
        severity: "error"
      });
    }
    if (position.pictographData?.motions?.blue?.motionType !== MotionType.STATIC) {
      errors.push({
        code: "INVALID_BLUE_MOTION",
        message: "Blue motion must be static for start positions",
        severity: "error"
      });
    }
    if (position.pictographData?.motions?.red?.motionType !== MotionType.STATIC) {
      errors.push({
        code: "INVALID_RED_MOTION",
        message: "Red motion must be static for start positions",
        severity: "error"
      });
    }
    return {
      isValid: errors.length === 0,
      errors,
      warnings: []
    };
  }
  async getDefaultStartPositions(gridMode) {
    try {
      const startPositionKeys = this.DEFAULT_START_POSITIONS[gridMode];
      if (!startPositionKeys) {
        console.error(
          `Unsupported grid mode: ${gridMode}. Supported modes: ${Object.keys(this.DEFAULT_START_POSITIONS).join(", ")}`
        );
        const fallbackKeys = this.DEFAULT_START_POSITIONS.diamond;
        const pictographData2 = fallbackKeys.map(
          (key, index) => this.createStartPositionPictograph(key, index, GridMode.DIAMOND)
        );
        return pictographData2;
      }
      const pictographData = startPositionKeys.map(
        (key, index) => this.createStartPositionPictograph(key, index, gridMode)
      );
      return pictographData;
    } catch (error) {
      console.error("Error getting default start positions:", error);
      return [];
    }
  }
  createStartPositionPictograph(key, index, gridMode) {
    let letter;
    if (key.includes("alpha")) letter = Letter.ALPHA;
    else if (key.includes("beta")) letter = Letter.BETA;
    else if (key.includes("gamma")) letter = Letter.GAMMA;
    else letter = Letter.ALPHA;
    const positionMappings = {
      alpha1_alpha1: { blue: Location.SOUTH, red: Location.NORTH },
      // Alpha1: Blue=South, Red=North
      beta5_beta5: { blue: Location.SOUTH, red: Location.SOUTH },
      // Beta5: Blue=South, Red=South
      gamma11_gamma11: { blue: Location.SOUTH, red: Location.EAST },
      // Gamma11: Blue=South, Red=East
      // Box mode positions
      alpha2_alpha2: { blue: Location.SOUTHWEST, red: Location.NORTHEAST },
      // Alpha2: Blue=Southwest, Red=Northeast
      beta4_beta4: { blue: Location.SOUTHEAST, red: Location.SOUTHEAST },
      // Beta4: Blue=Southeast, Red=Southeast
      gamma12_gamma12: { blue: Location.NORTHWEST, red: Location.NORTHEAST }
      // Gamma12: Blue=Northwest, Red=Northeast
    };
    const mapping = positionMappings[key];
    if (!mapping) {
      console.warn(`No position mapping found for ${key}, using fallback`);
    }
    const blueLocation = mapping?.blue || Location.SOUTH;
    const redLocation = mapping?.red || Location.NORTH;
    return PictographDataFactory.create({
      id: `start-pos-${key}-${index}`,
      letter,
      gridMode,
      motions: {
        blue: {
          motionType: MotionType.STATIC,
          rotationDirection: RotationDirection.NO_ROTATION,
          startLocation: blueLocation,
          endLocation: blueLocation,
          turns: 0,
          startOrientation: Orientation.IN,
          endOrientation: Orientation.IN,
          color: MotionColor.BLUE
        },
        red: {
          motionType: MotionType.STATIC,
          rotationDirection: RotationDirection.NO_ROTATION,
          startLocation: redLocation,
          endLocation: redLocation,
          turns: 0,
          startOrientation: Orientation.IN,
          endOrientation: Orientation.IN,
          color: MotionColor.RED
        }
      },
      props: {
        blue: {
          propType: PropType.STAFF
        },
        red: {
          propType: PropType.STAFF
        }
      },
      arrows: {
        blue: {
          // âœ… SIMPLIFIED: Only arrow-specific properties, motion data comes from MotionData
          arrowLocation: null
          // Will be calculated by positioning system from motion data
        },
        red: {
          // âœ… SIMPLIFIED: Only arrow-specific properties, motion data comes from MotionData
          arrowLocation: null
          // Will be calculated by positioning system from motion data
        }
      },
      // âœ… GUARANTEED: Factory will derive endPosition from motion data
      isBlank: false,
      isMirrored: false
    });
  }
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3NlcnZpY2VzL2ltcGxlbWVudGF0aW9ucy9kb21haW4vU3RhcnRQb3NpdGlvblNlcnZpY2UudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogU3RhcnQgUG9zaXRpb24gU2VydmljZSAtIEltcGxlbWVudGF0aW9uXG4gKlxuICogUHJvdmlkZXMgc3RhcnQgcG9zaXRpb24gbWFuYWdlbWVudCBmdW5jdGlvbmFsaXR5IGZvciB0aGUgY29uc3RydWN0IHdvcmtmbG93LlxuICogQmFzZWQgb24gdGhlIGRlc2t0b3AgU3RhcnRQb3NpdGlvbk9yY2hlc3RyYXRvciBidXQgc2ltcGxpZmllZCBmb3Igd2ViLlxuICovXG5cbmltcG9ydCB0eXBlIHsgQmVhdERhdGEsIFBpY3RvZ3JhcGhEYXRhIH0gZnJvbSBcIi4uLy4uLy4uL2RvbWFpblwiO1xuaW1wb3J0IHtcbiAgTW90aW9uQ29sb3IsXG4gIGNyZWF0ZUJlYXREYXRhLFxuICBHcmlkTW9kZSxcbiAgTG9jYXRpb24sXG4gIE1vdGlvblR5cGUsXG4gIE9yaWVudGF0aW9uLFxuICBQcm9wVHlwZSxcbiAgUm90YXRpb25EaXJlY3Rpb24sXG59IGZyb20gXCIuLi8uLi8uLi9kb21haW5cIjtcbmltcG9ydCB0eXBlIHsgVmFsaWRhdGlvblJlc3VsdCB9IGZyb20gXCIuLi8uLi9pbnRlcmZhY2VzL2RvbWFpbi10eXBlc1wiO1xuaW1wb3J0IHR5cGUgeyBJU3RhcnRQb3NpdGlvblNlcnZpY2UgfSBmcm9tIFwiLi4vLi4vaW50ZXJmYWNlcy9hcHBsaWNhdGlvbi1pbnRlcmZhY2VzXCI7XG5pbXBvcnQgdHlwZSB7IFZhbGlkYXRpb25FcnJvciB9IGZyb20gXCIkbGliL2RvbWFpbi9zZXF1ZW5jZUNhcmRcIjtcbmltcG9ydCB7IFBpY3RvZ3JhcGhEYXRhRmFjdG9yeSB9IGZyb20gXCIuLi8uLi9mYWN0b3JpZXMvUGljdG9ncmFwaERhdGFGYWN0b3J5XCI7XG5pbXBvcnQgeyBMZXR0ZXIgfSBmcm9tIFwiJGxpYi9kb21haW4vTGV0dGVyXCI7XG5cbmV4cG9ydCBjbGFzcyBTdGFydFBvc2l0aW9uU2VydmljZSBpbXBsZW1lbnRzIElTdGFydFBvc2l0aW9uU2VydmljZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgREVGQVVMVF9TVEFSVF9QT1NJVElPTlMgPSB7XG4gICAgZGlhbW9uZDogW1wiYWxwaGExX2FscGhhMVwiLCBcImJldGE1X2JldGE1XCIsIFwiZ2FtbWExMV9nYW1tYTExXCJdLFxuICAgIGJveDogW1wiYWxwaGEyX2FscGhhMlwiLCBcImJldGE0X2JldGE0XCIsIFwiZ2FtbWExMl9nYW1tYTEyXCJdLFxuICB9O1xuXG4gIGFzeW5jIGdldEF2YWlsYWJsZVN0YXJ0UG9zaXRpb25zKFxuICAgIHByb3BUeXBlOiBzdHJpbmcsXG4gICAgZ3JpZE1vZGU6IEdyaWRNb2RlXG4gICk6IFByb21pc2U8QmVhdERhdGFbXT4ge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYPCfk40gR2V0dGluZyBhdmFpbGFibGUgc3RhcnQgcG9zaXRpb25zIGZvciAke3Byb3BUeXBlfSBpbiAke2dyaWRNb2RlfSBtb2RlYFxuICAgICk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhcnRQb3NpdGlvbktleXMgPSB0aGlzLkRFRkFVTFRfU1RBUlRfUE9TSVRJT05TW2dyaWRNb2RlXTtcblxuICAgICAgaWYgKCFzdGFydFBvc2l0aW9uS2V5cykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGDinYwgVW5zdXBwb3J0ZWQgZ3JpZCBtb2RlOiAke2dyaWRNb2RlfS4gU3VwcG9ydGVkIG1vZGVzOiAke09iamVjdC5rZXlzKHRoaXMuREVGQVVMVF9TVEFSVF9QT1NJVElPTlMpLmpvaW4oXCIsIFwiKX1gXG4gICAgICAgICk7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGRpYW1vbmQgbW9kZVxuICAgICAgICBjb25zdCBmYWxsYmFja0tleXMgPSB0aGlzLkRFRkFVTFRfU1RBUlRfUE9TSVRJT05TLmRpYW1vbmQ7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SEIEZhbGxpbmcgYmFjayB0byBkaWFtb25kIG1vZGVgKTtcblxuICAgICAgICBjb25zdCBiZWF0RGF0YTogQmVhdERhdGFbXSA9IGZhbGxiYWNrS2V5cy5tYXAoKGtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQmVhdERhdGEoe1xuICAgICAgICAgICAgYmVhdE51bWJlcjogMCxcbiAgICAgICAgICAgIGlzQmxhbms6IGZhbHNlLFxuICAgICAgICAgICAgcGljdG9ncmFwaERhdGE6IHRoaXMuY3JlYXRlU3RhcnRQb3NpdGlvblBpY3RvZ3JhcGgoXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgIEdyaWRNb2RlLkRJQU1PTkRcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGDinIUgR2VuZXJhdGVkICR7YmVhdERhdGEubGVuZ3RofSBhdmFpbGFibGUgc3RhcnQgcG9zaXRpb25zIChmYWxsYmFjaylgXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBiZWF0RGF0YTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmVhdERhdGE6IEJlYXREYXRhW10gPSBzdGFydFBvc2l0aW9uS2V5cy5tYXAoKGtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJlYXREYXRhKHtcbiAgICAgICAgICBiZWF0TnVtYmVyOiAwLFxuICAgICAgICAgIGlzQmxhbms6IGZhbHNlLFxuICAgICAgICAgIHBpY3RvZ3JhcGhEYXRhOiB0aGlzLmNyZWF0ZVN0YXJ0UG9zaXRpb25QaWN0b2dyYXBoKFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBncmlkTW9kZVxuICAgICAgICAgICksXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKGDinIUgR2VuZXJhdGVkICR7YmVhdERhdGEubGVuZ3RofSBhdmFpbGFibGUgc3RhcnQgcG9zaXRpb25zYCk7XG4gICAgICByZXR1cm4gYmVhdERhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRXJyb3IgZ2V0dGluZyBhdmFpbGFibGUgc3RhcnQgcG9zaXRpb25zOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc2V0U3RhcnRQb3NpdGlvbihzdGFydFBvc2l0aW9uOiBCZWF0RGF0YSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBTdG9yZSBpbiBsb2NhbFN0b3JhZ2UgZm9yIHBlcnNpc3RlbmNlIGluIHRoZSBmb3JtYXQgT3B0aW9uUGlja2VyIGV4cGVjdHNcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGxvY2FsU3RvcmFnZSBhbHJlYWR5IGhhcyB0aGUgY29ycmVjdCBmb3JtYXQgKGZyb20gU3RhcnRQb3NpdGlvblBpY2tlcilcbiAgICAgICAgY29uc3QgZXhpc3RpbmdEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdGFydFBvc2l0aW9uXCIpO1xuICAgICAgICBpZiAoZXhpc3RpbmdEYXRhKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZXhpc3RpbmdEYXRhKTtcbiAgICAgICAgICAgIC8vIElmIGl0IGFscmVhZHkgaGFzIHRvcC1sZXZlbCBlbmRQb3NpdGlvbiwgZG9uJ3Qgb3ZlcndyaXRlIGl0XG4gICAgICAgICAgICBpZiAocGFyc2VkLmVuZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIC8vIElmIHBhcnNpbmcgZmFpbHMsIGNvbnRpbnVlIHdpdGggc2F2aW5nIG5ldyBmb3JtYXRcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgdGhlIGZvcm1hdCB0aGF0IE9wdGlvblBpY2tlciBleHBlY3RzXG4gICAgICAgIGNvbnN0IG9wdGlvblBpY2tlckZvcm1hdCA9IHtcbiAgICAgICAgICBlbmRQb3NpdGlvbjogc3RhcnRQb3NpdGlvbi5tZXRhZGF0YT8uZW5kUG9zaXRpb24gfHwgXCJhbHBoYTFcIiwgLy8gRXh0cmFjdCBmcm9tIG1ldGFkYXRhXG4gICAgICAgICAgcGljdG9ncmFwaERhdGE6IHN0YXJ0UG9zaXRpb24ucGljdG9ncmFwaERhdGEsXG4gICAgICAgICAgbGV0dGVyOiBzdGFydFBvc2l0aW9uLnBpY3RvZ3JhcGhEYXRhPy5sZXR0ZXIsXG4gICAgICAgICAgZ3JpZE1vZGU6IEdyaWRNb2RlLkRJQU1PTkQsIC8vIERlZmF1bHRcbiAgICAgICAgICBpc1N0YXJ0UG9zaXRpb246IHRydWUsXG4gICAgICAgICAgLy8gSW5jbHVkZSB0aGUgZnVsbCBiZWF0IGRhdGEgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAuLi5zdGFydFBvc2l0aW9uLFxuICAgICAgICB9O1xuXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgIFwic3RhcnRQb3NpdGlvblwiLFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG9wdGlvblBpY2tlckZvcm1hdClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNldHRpbmcgc3RhcnQgcG9zaXRpb246XCIsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBzZXQgc3RhcnQgcG9zaXRpb246ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlU3RhcnRQb3NpdGlvbihwb3NpdGlvbjogQmVhdERhdGEpOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgICBjb25zdCBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcltdID0gW107XG5cbiAgICBpZiAoIXBvc2l0aW9uLnBpY3RvZ3JhcGhEYXRhKSB7XG4gICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgIGNvZGU6IFwiTUlTU0lOR19waWN0b2dyYXBoRGF0YVwiLFxuICAgICAgICBtZXNzYWdlOiBcIlN0YXJ0IHBvc2l0aW9uIG11c3QgaGF2ZSBwaWN0b2dyYXBoIGRhdGFcIixcbiAgICAgICAgc2V2ZXJpdHk6IFwiZXJyb3JcIixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICFwb3NpdGlvbi5waWN0b2dyYXBoRGF0YT8ubW90aW9ucz8uYmx1ZSAmJlxuICAgICAgIXBvc2l0aW9uLnBpY3RvZ3JhcGhEYXRhPy5tb3Rpb25zPy5yZWRcbiAgICApIHtcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgY29kZTogXCJNSVNTSU5HX01PVElPTlNcIixcbiAgICAgICAgbWVzc2FnZTogXCJTdGFydCBwb3NpdGlvbiBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIG1vdGlvblwiLFxuICAgICAgICBzZXZlcml0eTogXCJlcnJvclwiLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgbW90aW9uIHR5cGVzIGFyZSBzdGF0aWMgZm9yIHN0YXJ0IHBvc2l0aW9uc1xuICAgIGlmIChcbiAgICAgIHBvc2l0aW9uLnBpY3RvZ3JhcGhEYXRhPy5tb3Rpb25zPy5ibHVlPy5tb3Rpb25UeXBlICE9PSBNb3Rpb25UeXBlLlNUQVRJQ1xuICAgICkge1xuICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICBjb2RlOiBcIklOVkFMSURfQkxVRV9NT1RJT05cIixcbiAgICAgICAgbWVzc2FnZTogXCJCbHVlIG1vdGlvbiBtdXN0IGJlIHN0YXRpYyBmb3Igc3RhcnQgcG9zaXRpb25zXCIsXG4gICAgICAgIHNldmVyaXR5OiBcImVycm9yXCIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBwb3NpdGlvbi5waWN0b2dyYXBoRGF0YT8ubW90aW9ucz8ucmVkPy5tb3Rpb25UeXBlICE9PSBNb3Rpb25UeXBlLlNUQVRJQ1xuICAgICkge1xuICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICBjb2RlOiBcIklOVkFMSURfUkVEX01PVElPTlwiLFxuICAgICAgICBtZXNzYWdlOiBcIlJlZCBtb3Rpb24gbXVzdCBiZSBzdGF0aWMgZm9yIHN0YXJ0IHBvc2l0aW9uc1wiLFxuICAgICAgICBzZXZlcml0eTogXCJlcnJvclwiLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgICBlcnJvcnMsXG4gICAgICB3YXJuaW5nczogW10sXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGdldERlZmF1bHRTdGFydFBvc2l0aW9ucyhcbiAgICBncmlkTW9kZTogR3JpZE1vZGVcbiAgKTogUHJvbWlzZTxQaWN0b2dyYXBoRGF0YVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb25LZXlzID0gdGhpcy5ERUZBVUxUX1NUQVJUX1BPU0lUSU9OU1tncmlkTW9kZV07XG5cbiAgICAgIGlmICghc3RhcnRQb3NpdGlvbktleXMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgVW5zdXBwb3J0ZWQgZ3JpZCBtb2RlOiAke2dyaWRNb2RlfS4gU3VwcG9ydGVkIG1vZGVzOiAke09iamVjdC5rZXlzKHRoaXMuREVGQVVMVF9TVEFSVF9QT1NJVElPTlMpLmpvaW4oXCIsIFwiKX1gXG4gICAgICAgICk7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGRpYW1vbmQgbW9kZVxuICAgICAgICBjb25zdCBmYWxsYmFja0tleXMgPSB0aGlzLkRFRkFVTFRfU1RBUlRfUE9TSVRJT05TLmRpYW1vbmQ7XG5cbiAgICAgICAgY29uc3QgcGljdG9ncmFwaERhdGE6IFBpY3RvZ3JhcGhEYXRhW10gPSBmYWxsYmFja0tleXMubWFwKFxuICAgICAgICAgIChrZXksIGluZGV4KSA9PlxuICAgICAgICAgICAgdGhpcy5jcmVhdGVTdGFydFBvc2l0aW9uUGljdG9ncmFwaChrZXksIGluZGV4LCBHcmlkTW9kZS5ESUFNT05EKVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBwaWN0b2dyYXBoRGF0YTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGljdG9ncmFwaERhdGE6IFBpY3RvZ3JhcGhEYXRhW10gPSBzdGFydFBvc2l0aW9uS2V5cy5tYXAoXG4gICAgICAgIChrZXksIGluZGV4KSA9PiB0aGlzLmNyZWF0ZVN0YXJ0UG9zaXRpb25QaWN0b2dyYXBoKGtleSwgaW5kZXgsIGdyaWRNb2RlKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHBpY3RvZ3JhcGhEYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBkZWZhdWx0IHN0YXJ0IHBvc2l0aW9uczpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlU3RhcnRQb3NpdGlvblBpY3RvZ3JhcGgoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgaW5kZXg6IG51bWJlcixcbiAgICBncmlkTW9kZTogR3JpZE1vZGVcbiAgKTogUGljdG9ncmFwaERhdGEge1xuICAgIC8vIOKchSBDRU5UUkFMSVpFRDogVXNlIFBpY3RvZ3JhcGhEYXRhRmFjdG9yeSBmb3IgY29uc2lzdGVudCBjcmVhdGlvblxuXG4gICAgLy8gRGV0ZXJtaW5lIGxldHRlciBiYXNlZCBvbiBwb3NpdGlvbiBrZXlcbiAgICBsZXQgbGV0dGVyOiBMZXR0ZXI7XG4gICAgaWYgKGtleS5pbmNsdWRlcyhcImFscGhhXCIpKSBsZXR0ZXIgPSBMZXR0ZXIuQUxQSEE7XG4gICAgZWxzZSBpZiAoa2V5LmluY2x1ZGVzKFwiYmV0YVwiKSkgbGV0dGVyID0gTGV0dGVyLkJFVEE7XG4gICAgZWxzZSBpZiAoa2V5LmluY2x1ZGVzKFwiZ2FtbWFcIikpIGxldHRlciA9IExldHRlci5HQU1NQTtcbiAgICBlbHNlIGxldHRlciA9IExldHRlci5BTFBIQTsgLy8gRGVmYXVsdCBmYWxsYmFja1xuXG4gICAgLy8gVXNlIGNvcnJlY3QgbG9jYXRpb25zIGJhc2VkIG9uIGxlZ2FjeSBwb3NpdGlvbiBtYXBwaW5nc1xuICAgIC8vIEZyb20gUGF0dGVybkdlbmVyYXRvci50cyBhbmQgcG9zaXRpb25zX21hcC5weVxuICAgIGNvbnN0IHBvc2l0aW9uTWFwcGluZ3M6IFJlY29yZDxzdHJpbmcsIHsgYmx1ZTogTG9jYXRpb247IHJlZDogTG9jYXRpb24gfT4gPVxuICAgICAge1xuICAgICAgICBhbHBoYTFfYWxwaGExOiB7IGJsdWU6IExvY2F0aW9uLlNPVVRILCByZWQ6IExvY2F0aW9uLk5PUlRIIH0sIC8vIEFscGhhMTogQmx1ZT1Tb3V0aCwgUmVkPU5vcnRoXG4gICAgICAgIGJldGE1X2JldGE1OiB7IGJsdWU6IExvY2F0aW9uLlNPVVRILCByZWQ6IExvY2F0aW9uLlNPVVRIIH0sIC8vIEJldGE1OiBCbHVlPVNvdXRoLCBSZWQ9U291dGhcbiAgICAgICAgZ2FtbWExMV9nYW1tYTExOiB7IGJsdWU6IExvY2F0aW9uLlNPVVRILCByZWQ6IExvY2F0aW9uLkVBU1QgfSwgLy8gR2FtbWExMTogQmx1ZT1Tb3V0aCwgUmVkPUVhc3RcbiAgICAgICAgLy8gQm94IG1vZGUgcG9zaXRpb25zXG4gICAgICAgIGFscGhhMl9hbHBoYTI6IHsgYmx1ZTogTG9jYXRpb24uU09VVEhXRVNULCByZWQ6IExvY2F0aW9uLk5PUlRIRUFTVCB9LCAvLyBBbHBoYTI6IEJsdWU9U291dGh3ZXN0LCBSZWQ9Tm9ydGhlYXN0XG4gICAgICAgIGJldGE0X2JldGE0OiB7IGJsdWU6IExvY2F0aW9uLlNPVVRIRUFTVCwgcmVkOiBMb2NhdGlvbi5TT1VUSEVBU1QgfSwgLy8gQmV0YTQ6IEJsdWU9U291dGhlYXN0LCBSZWQ9U291dGhlYXN0XG4gICAgICAgIGdhbW1hMTJfZ2FtbWExMjogeyBibHVlOiBMb2NhdGlvbi5OT1JUSFdFU1QsIHJlZDogTG9jYXRpb24uTk9SVEhFQVNUIH0sIC8vIEdhbW1hMTI6IEJsdWU9Tm9ydGh3ZXN0LCBSZWQ9Tm9ydGhlYXN0XG4gICAgICB9O1xuXG4gICAgY29uc3QgbWFwcGluZyA9IHBvc2l0aW9uTWFwcGluZ3Nba2V5XTtcbiAgICBpZiAoIW1hcHBpbmcpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTm8gcG9zaXRpb24gbWFwcGluZyBmb3VuZCBmb3IgJHtrZXl9LCB1c2luZyBmYWxsYmFja2ApO1xuICAgIH1cblxuICAgIGNvbnN0IGJsdWVMb2NhdGlvbiA9IG1hcHBpbmc/LmJsdWUgfHwgTG9jYXRpb24uU09VVEg7XG4gICAgY29uc3QgcmVkTG9jYXRpb24gPSBtYXBwaW5nPy5yZWQgfHwgTG9jYXRpb24uTk9SVEg7XG5cbiAgICAvLyDinIUgQ0VOVFJBTElaRUQ6IFVzZSBQaWN0b2dyYXBoRGF0YUZhY3RvcnkgZm9yIGNvbnNpc3RlbnQsIGNvbXBsZXRlIGNyZWF0aW9uXG4gICAgcmV0dXJuIFBpY3RvZ3JhcGhEYXRhRmFjdG9yeS5jcmVhdGUoe1xuICAgICAgaWQ6IGBzdGFydC1wb3MtJHtrZXl9LSR7aW5kZXh9YCxcbiAgICAgIGxldHRlcixcbiAgICAgIGdyaWRNb2RlLFxuICAgICAgbW90aW9uczoge1xuICAgICAgICBibHVlOiB7XG4gICAgICAgICAgbW90aW9uVHlwZTogTW90aW9uVHlwZS5TVEFUSUMsXG4gICAgICAgICAgcm90YXRpb25EaXJlY3Rpb246IFJvdGF0aW9uRGlyZWN0aW9uLk5PX1JPVEFUSU9OLFxuICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGJsdWVMb2NhdGlvbixcbiAgICAgICAgICBlbmRMb2NhdGlvbjogYmx1ZUxvY2F0aW9uLFxuICAgICAgICAgIHR1cm5zOiAwLFxuICAgICAgICAgIHN0YXJ0T3JpZW50YXRpb246IE9yaWVudGF0aW9uLklOLFxuICAgICAgICAgIGVuZE9yaWVudGF0aW9uOiBPcmllbnRhdGlvbi5JTixcbiAgICAgICAgICBjb2xvcjogTW90aW9uQ29sb3IuQkxVRSxcbiAgICAgICAgfSxcbiAgICAgICAgcmVkOiB7XG4gICAgICAgICAgbW90aW9uVHlwZTogTW90aW9uVHlwZS5TVEFUSUMsXG4gICAgICAgICAgcm90YXRpb25EaXJlY3Rpb246IFJvdGF0aW9uRGlyZWN0aW9uLk5PX1JPVEFUSU9OLFxuICAgICAgICAgIHN0YXJ0TG9jYXRpb246IHJlZExvY2F0aW9uLFxuICAgICAgICAgIGVuZExvY2F0aW9uOiByZWRMb2NhdGlvbixcbiAgICAgICAgICB0dXJuczogMCxcbiAgICAgICAgICBzdGFydE9yaWVudGF0aW9uOiBPcmllbnRhdGlvbi5JTixcbiAgICAgICAgICBlbmRPcmllbnRhdGlvbjogT3JpZW50YXRpb24uSU4sXG4gICAgICAgICAgY29sb3I6IE1vdGlvbkNvbG9yLlJFRCxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBwcm9wczoge1xuICAgICAgICBibHVlOiB7XG4gICAgICAgICAgcHJvcFR5cGU6IFByb3BUeXBlLlNUQUZGLFxuICAgICAgICB9LFxuICAgICAgICByZWQ6IHtcbiAgICAgICAgICBwcm9wVHlwZTogUHJvcFR5cGUuU1RBRkYsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgYXJyb3dzOiB7XG4gICAgICAgIGJsdWU6IHtcbiAgICAgICAgICAvLyDinIUgU0lNUExJRklFRDogT25seSBhcnJvdy1zcGVjaWZpYyBwcm9wZXJ0aWVzLCBtb3Rpb24gZGF0YSBjb21lcyBmcm9tIE1vdGlvbkRhdGFcbiAgICAgICAgICBhcnJvd0xvY2F0aW9uOiBudWxsLCAvLyBXaWxsIGJlIGNhbGN1bGF0ZWQgYnkgcG9zaXRpb25pbmcgc3lzdGVtIGZyb20gbW90aW9uIGRhdGFcbiAgICAgICAgfSxcbiAgICAgICAgcmVkOiB7XG4gICAgICAgICAgLy8g4pyFIFNJTVBMSUZJRUQ6IE9ubHkgYXJyb3ctc3BlY2lmaWMgcHJvcGVydGllcywgbW90aW9uIGRhdGEgY29tZXMgZnJvbSBNb3Rpb25EYXRhXG4gICAgICAgICAgYXJyb3dMb2NhdGlvbjogbnVsbCwgLy8gV2lsbCBiZSBjYWxjdWxhdGVkIGJ5IHBvc2l0aW9uaW5nIHN5c3RlbSBmcm9tIG1vdGlvbiBkYXRhXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgLy8g4pyFIEdVQVJBTlRFRUQ6IEZhY3Rvcnkgd2lsbCBkZXJpdmUgZW5kUG9zaXRpb24gZnJvbSBtb3Rpb24gZGF0YVxuICAgICAgaXNCbGFuazogZmFsc2UsXG4gICAgICBpc01pcnJvcmVkOiBmYWxzZSxcbiAgICB9KTtcbiAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIkFBUUE7QUFBQSxFQUNFO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLE9BQ0s7QUFJUCxTQUFTLDZCQUE2QjtBQUN0QyxTQUFTLGNBQWM7QUFFaEIsYUFBTSxxQkFBc0Q7QUFBQSxFQUNoRCwwQkFBMEI7QUFBQSxJQUN6QyxTQUFTLENBQUMsaUJBQWlCLGVBQWUsaUJBQWlCO0FBQUEsSUFDM0QsS0FBSyxDQUFDLGlCQUFpQixlQUFlLGlCQUFpQjtBQUFBLEVBQ3pEO0FBQUEsRUFFQSxNQUFNLDJCQUNKLFVBQ0EsVUFDcUI7QUFDckIsWUFBUTtBQUFBLE1BQ04sNENBQTRDLFFBQVEsT0FBTyxRQUFRO0FBQUEsSUFDckU7QUFFQSxRQUFJO0FBQ0YsWUFBTSxvQkFBb0IsS0FBSyx3QkFBd0IsUUFBUTtBQUUvRCxVQUFJLENBQUMsbUJBQW1CO0FBQ3RCLGdCQUFRO0FBQUEsVUFDTiw0QkFBNEIsUUFBUSxzQkFBc0IsT0FBTyxLQUFLLEtBQUssdUJB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O0FBQUEsTUFDM0QsYUFBYSxFQUFFLE1BQU0sU0FBUyxPQUFPLEtBQUssU0FBUyxNQUFNO0FBQUE7QUFBQSxNQUN6RCxpQkFBaUIsRUFBRSxNQUFNLFNBQVMsT0FBTyxLQUFLLFNBQVMsS0FBSztBQUFBO0FBQUE7QUFBQSxNQUU1RCxlQUFlLEVBQUUsTUFBTSxTQUFTLFdBQVcsS0FBSyxTQUFTLFVBQVU7QUFBQTtBQUFBLE1BQ25FLGFBQWEsRUFBRSxNQUFNLFNBQVMsV0FBVyxLQUFLLFNBQVMsVUFBVTtBQUFBO0FBQUEsTUFDakUsaUJBQWlCLEVBQUUsTUFBTSxTQUFTLFdBQVcsS0FBSyxTQUFTLFVBQVU7QUFBQTtBQUFBLElBQ3ZFO0FBRUYsVUFBTSxVQUFVLGlCQUFpQixHQUFHO0FBQ3BDLFFBQUksQ0FBQyxTQUFTO0FBQ1osY0FBUSxLQUFLLGlDQUFpQyxHQUFHLGtCQUFrQjtBQUFBLElBQ3JFO0FBRUEsVUFBTSxlQUFlLFNBQVMsUUFBUSxTQUFTO0FBQy9DLFVBQU0sY0FBYyxTQUFTLE9BQU8sU0FBUztBQUc3QyxXQUFPLHNCQUFzQixPQUFPO0FBQUEsTUFDbEMsSUFBSSxhQUFhLEdBQUcsSUFBSSxLQUFLO0FBQUEsTUFDN0I7QUFBQSxNQUNBO0FBQUEsTUFDQSxTQUFTO0FBQUEsUUFDUCxNQUFNO0FBQUEsVUFDSixZQUFZLFdBQVc7QUFBQSxVQUN2QixtQkFBbUIsa0JBQWtCO0FBQUEsVUFDckMsZUFBZTtBQUFBLFVBQ2YsYUFBYTtBQUFBLFVBQ2IsT0FBTztBQUFBLFVBQ1Asa0JBQWtCLFlBQVk7QUFBQSxVQUM5QixnQkFBZ0IsWUFBWTtBQUFBLFVBQzVCLE9BQU8sWUFBWTtBQUFBLFFBQ3JCO0FBQUEsUUFDQSxLQUFLO0FBQUEsVUFDSCxZQUFZLFdBQVc7QUFBQSxVQUN2QixtQkFBbUIsa0JBQWtCO0FBQUEsVUFDckMsZUFBZTtBQUFBLFVBQ2YsYUFBYTtBQUFBLFVBQ2IsT0FBTztBQUFBLFVBQ1Asa0JBQWtCLFlBQVk7QUFBQSxVQUM5QixnQkFBZ0IsWUFBWTtBQUFBLFVBQzVCLE9BQU8sWUFBWTtBQUFBLFFBQ3JCO0FBQUEsTUFDRjtBQUFBLE1BQ0EsT0FBTztBQUFBLFFBQ0wsTUFBTTtBQUFBLFVBQ0osVUFBVSxTQUFTO0FBQUEsUUFDckI7QUFBQSxRQUNBLEtBQUs7QUFBQSxVQUNILFVBQVUsU0FBUztBQUFBLFFBQ3JCO0FBQUEsTUFDRjtBQUFBLE1BQ0EsUUFBUTtBQUFBLFFBQ04sTUFBTTtBQUFBO0FBQUEsVUFFSixlQUFlO0FBQUE7QUFBQSxRQUNqQjtBQUFBLFFBQ0EsS0FBSztBQUFBO0FBQUEsVUFFSCxlQUFlO0FBQUE7QUFBQSxRQUNqQjtBQUFBLE1BQ0Y7QUFBQTtBQUFBLE1BRUEsU0FBUztBQUFBLE1BQ1QsWUFBWTtBQUFBLElBQ2QsQ0FBQztBQUFBLEVBQ0g7QUFDRjsiLAogICJuYW1lcyI6IFsiYmVhdERhdGEiLCAicGljdG9ncmFwaERhdGEiXQp9Cg==
