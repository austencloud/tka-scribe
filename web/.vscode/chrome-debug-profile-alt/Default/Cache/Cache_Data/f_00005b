/* browse-state.svelte.ts generated by Svelte v5.38.1 */
import * as $ from "/node_modules/.vite/deps/svelte_internal_client.js?v=474c1bba";

import {
	NavigationMode,
	SortMethod as SortMethodEnum,
	createDefaultDisplayState,
	createDefaultLoadingState
} from "/src/lib/domain/browse/index.ts";

import { getBrowseStatePersistence } from "/src/lib/state/appState.svelte.ts";
import { getBrowseTabStateManager } from "/src/lib/state/browse-tab-state-manager.svelte.ts";

export function createBrowseState(
	browseService,
	thumbnailService,
	sequenceIndexService,
	favoritesService,
	navigationService,
	_filterPersistenceService,
	sectionService,
	deleteService
) {
	const stateManager = getBrowseTabStateManager();
	let allSequences = $.tag($.state($.proxy([])), 'allSequences');
	let filteredSequences = $.tag($.state($.proxy([])), 'filteredSequences');
	let displayedSequences = $.tag($.state($.proxy([])), 'displayedSequences');
	let selectedSequence = $.tag($.state(null), 'selectedSequence');
	let favorites = $.tag($.state($.proxy(/* @__PURE__ */ new Set())), 'favorites');
	let navigationSections = $.tag($.state($.proxy([])), 'navigationSections');
	let sequenceSections = $.tag($.state($.proxy([])), 'sequenceSections');

	let sectionConfiguration = $.tag(
		$.state($.proxy({
			groupBy: "letter",
			sortMethod: SortMethodEnum.ALPHABETICAL,
			showEmptySections: false,
			expandedSections: /* @__PURE__ */ new Set(["A", "B", "C"])
		})),
		'sectionConfiguration'
	);

	let deleteConfirmation = $.tag($.state(null), 'deleteConfirmation');
	let showDeleteDialog = $.tag($.state(false), 'showDeleteDialog');
	let currentFilter = $.tag($.state(null), 'currentFilter');
	let currentSort = $.tag($.state($.proxy(SortMethodEnum.ALPHABETICAL)), 'currentSort');
	let navigationMode = $.tag($.state($.proxy(NavigationMode.FILTER_SELECTION)), 'navigationMode');
	const loadingState = $.tag_proxy($.proxy(createDefaultLoadingState()), 'loadingState');
	let displayState = $.tag($.state($.proxy(createDefaultDisplayState())), 'displayState');
	let searchQuery = $.tag($.state(""), 'searchQuery');
	const isLoading = $.tag($.derived(() => loadingState.isLoading), 'isLoading');
	const hasSequences = $.tag($.derived(() => $.get(displayedSequences).length > 0), 'hasSequences');
	const hasError = $.tag($.derived(() => $.strict_equals(loadingState.error, null, false)), 'hasError');
	const sequenceCount = $.tag($.derived(() => $.get(displayedSequences).length), 'sequenceCount');

	const sortedSections = $.tag(
		$.derived(() => () => {
			if ($.strict_equals($.get(displayedSequences).length, 0)) return {};

			return groupSequencesBySection($.get(displayedSequences), $.get(currentSort));
		}),
		'sortedSections'
	);

	const favoritesCount = $.tag($.derived(() => $.get(favorites).size), 'favoritesCount');
	const hasNavigationSections = $.tag($.derived(() => $.get(navigationSections).length > 0), 'hasNavigationSections');
	const hasSequenceSections = $.tag($.derived(() => $.get(sequenceSections).length > 0), 'hasSequenceSections');

	const sectionStatistics = $.tag(
		$.derived(() => () => {
			if ($.strict_equals($.get(sequenceSections).length, 0)) return null;

			return {
				totalSections: $.get(sequenceSections).length,
				totalSequences: $.get(sequenceSections).reduce((sum, section) => sum + section.count, 0),
				expandedSections: $.get(sequenceSections).filter((section) => section.isExpanded).length
			};
		}),
		'sectionStatistics'
	);

	async function loadAllSequences() {
		try {
			loadingState.isLoading = true;
			loadingState.currentOperation = "Loading sequences...";
			loadingState.error = null;

			const sequences = (await $.track_reactivity_loss(browseService.loadSequenceMetadata()))();

			$.set(allSequences, sequences, true);
			$.set(filteredSequences, sequences, true);
			$.set(displayedSequences, sequences, true);
			(await $.track_reactivity_loss(loadFavorites()))();
			(await $.track_reactivity_loss(generateNavigationSections()))();
			(await $.track_reactivity_loss(generateSequenceSections()))();
			(await $.track_reactivity_loss(restoreFilterState()))();
			loadingState.isLoading = false;
			loadingState.loadedCount = sequences.length;
			loadingState.totalCount = sequences.length;
		} catch(error) {
			loadingState.isLoading = false;
			loadingState.error = error instanceof Error ? error.message : "Failed to load sequences";
		}
	}

	async function restoreFilterState() {
		try {
			const savedFilterState = (await $.track_reactivity_loss(getBrowseStatePersistence().loadFilterState()))();

			if (savedFilterState && savedFilterState.type && $.strict_equals(savedFilterState.value, null, false)) {
				console.log(...$.log_if_contains_state('log', "ðŸ“– Restoring filter state:", savedFilterState));

				const filterType = savedFilterState.type;
				const filterValue = savedFilterState.value;

				if (filterType.startsWith("navigation_")) {
					const sectionType = filterType.replace("navigation_", "");

					const matchingItem = {
						id: `${sectionType}_${filterValue}`,
						label: String(filterValue),
						value: filterValue,
						count: 0,

						// Will be updated when navigation sections are generated
						isActive: true,

						sequences: []

						// Will be populated by getSequencesForNavigationItem
					};

					const filtered = navigationService.getSequencesForNavigationItem(matchingItem, sectionType, $.get(allSequences));
					const sorted = (await $.track_reactivity_loss(browseService.sortSequences(filtered, $.get(currentSort))))();

					$.set(currentFilter, { type: filterType, value: filterValue }, true);
					$.set(filteredSequences, filtered, true);
					$.set(displayedSequences, sorted, true);
					$.set(navigationMode, NavigationMode.SEQUENCE_BROWSER, true);
					console.log("âœ… Navigation filter state restored successfully");
				} else {
					const filterTypeEnum = filterType;
					const filterValueEnum = filterValue;

					$.set(currentFilter, { type: filterTypeEnum, value: filterValueEnum }, true);

					const filtered = (await $.track_reactivity_loss(browseService.applyFilter($.get(allSequences), filterTypeEnum, filterValueEnum)))();
					const sorted = (await $.track_reactivity_loss(browseService.sortSequences(filtered, $.get(currentSort))))();

					$.set(filteredSequences, filtered, true);
					$.set(displayedSequences, sorted, true);
					$.set(navigationMode, NavigationMode.SEQUENCE_BROWSER, true);
					console.log("âœ… Regular filter state restored successfully");
				}
			} else {
				console.log("ðŸ“– No saved filter state to restore");
			}
		} catch(error) {
			console.warn(...$.log_if_contains_state('warn', "âš ï¸ Failed to restore filter state:", error));
		}
	}

	async function applyFilter(filterType, filterValue) {
		try {
			console.log(...$.log_if_contains_state('log', "ðŸŽ¯ browse-state.applyFilter() called with:", filterType, filterValue));
			loadingState.isLoading = true;
			loadingState.currentOperation = "Applying filter...";
			$.set(currentFilter, { type: filterType, value: filterValue }, true);
			console.log(...$.log_if_contains_state('log', "ðŸ“ Updated currentFilter:", $.get(currentFilter)));
			(await $.track_reactivity_loss(stateManager.saveFilterState(filterType, filterValue)))();
			console.log(...$.log_if_contains_state('log', "ðŸ’¾ Filter state saved:", { type: filterType, value: filterValue }));
			console.log(...$.log_if_contains_state('log', "ðŸ“Š allSequences available:", $.get(allSequences).length, "items"));

			const filtered = (await $.track_reactivity_loss(browseService.applyFilter($.get(allSequences), filterType, filterValue)))();

			console.log(...$.log_if_contains_state('log', "ðŸ” Filtered sequences received:", filtered.length, "items"));

			const sorted = (await $.track_reactivity_loss(browseService.sortSequences(filtered, $.get(currentSort))))();

			console.log(...$.log_if_contains_state('log', "ðŸ“ˆ Sorted sequences:", sorted.length, "items"));
			$.set(filteredSequences, filtered, true);
			$.set(displayedSequences, sorted, true);
			$.set(navigationMode, NavigationMode.SEQUENCE_BROWSER, true);
			loadingState.isLoading = false;
		} catch(error) {
			loadingState.isLoading = false;
			loadingState.error = error instanceof Error ? error.message : "Failed to apply filter";
		}
	}

	async function updateSort(sortMethod) {
		try {
			$.set(currentSort, sortMethod, true);

			const sorted = (await $.track_reactivity_loss(browseService.sortSequences($.get(filteredSequences), sortMethod)))();

			$.set(displayedSequences, sorted, true);
		} catch(error) {
			loadingState.error = error instanceof Error ? error.message : "Failed to sort sequences";
		}
	}

	async function searchSequences(query) {
		try {
			$.set(searchQuery, query, true);

			if (!query.trim()) {
				$.set(displayedSequences, $.get(filteredSequences), true);

				return;
			}

			loadingState.isLoading = true;
			loadingState.currentOperation = "Searching...";

			const searchResults = (await $.track_reactivity_loss(sequenceIndexService.searchSequences(query)))();
			let results = searchResults;

			if ($.get(currentFilter)) {
				results = (await $.track_reactivity_loss(browseService.applyFilter(searchResults, $.get(currentFilter).type, $.get(currentFilter).value)))();
			}

			const sorted = (await $.track_reactivity_loss(browseService.sortSequences(results, $.get(currentSort))))();

			$.set(displayedSequences, sorted, true);
			loadingState.isLoading = false;
		} catch(error) {
			loadingState.isLoading = false;
			loadingState.error = error instanceof Error ? error.message : "Search failed";
		}
	}

	async function selectSequence(sequence) {
		$.set(selectedSequence, sequence, true);
		(await $.track_reactivity_loss(stateManager.saveSelectionState(sequence.id, null)))();
		console.log(...$.log_if_contains_state('log', "ðŸ’¾ Selection state saved:", sequence.id));
	}

	async function clearSelection() {
		$.set(selectedSequence, null);
		(await $.track_reactivity_loss(stateManager.saveSelectionState(null, null)))();
		console.log("ðŸ—‘ï¸ Selection state cleared");
	}

	async function backToFilters() {
		$.set(navigationMode, NavigationMode.FILTER_SELECTION, true);
		$.set(currentFilter, null);
		$.set(searchQuery, "");
		$.set(displayedSequences, $.get(allSequences), true);
		(await $.track_reactivity_loss(stateManager.saveFilterState(null, null)))();
		console.log("ðŸ—‘ï¸ Filter state cleared");
	}

	async function preloadThumbnails(sequences) {
		try {
			const thumbnailsToPreload = sequences.slice(0, 20).flatMap((seq) => seq.thumbnails.map((thumb) => ({ sequenceId: seq.id, thumbnailPath: thumb })));

			for (const thumbnail of thumbnailsToPreload) {
				(await $.track_reactivity_loss(thumbnailService.preloadThumbnail(thumbnail.sequenceId, thumbnail.thumbnailPath)))();
			}
		} catch(error) {
			console.warn(...$.log_if_contains_state('warn', "Failed to preload thumbnails:", error));
		}
	}

	function getThumbnailUrl(sequenceId, thumbnailPath) {
		return thumbnailService.getThumbnailUrl(sequenceId, thumbnailPath);
	}

	function updateDisplaySettings(settings) {
		$.set(displayState, { ...$.get(displayState), ...settings }, true);
	}

	function clearError() {
		loadingState.error = null;
	}

	$.user_effect(() => {
		if ($.get(displayedSequences).length > 0) {
			preloadThumbnails($.get(displayedSequences));
		}
	});

	function groupSequencesBySection(sequences, sortMethod) {
		const sections = {};

		for (const sequence of sequences) {
			const sectionKey = getSectionKey(sequence, sortMethod);

			if (!sections[sectionKey]) {
				sections[sectionKey] = [];
			}

			sections[sectionKey].push(sequence);
		}

		return sections;
	}

	function getSectionKey(sequence, sortMethod) {
		switch (sortMethod) {
			case SortMethodEnum.ALPHABETICAL:
				return sequence.word[0]?.toUpperCase() || "#";

			case SortMethodEnum.DIFFICULTY_LEVEL:
				return sequence.difficultyLevel || "Unknown";

			case SortMethodEnum.AUTHOR:
				return sequence.author || "Unknown";

			case SortMethodEnum.SEQUENCE_LENGTH:
				{
					const length = sequence.sequenceLength || 0;

					if (length <= 4) return "3-4 beats";
					if (length <= 6) return "5-6 beats";
					if (length <= 8) return "7-8 beats";

					return "9+ beats";
				}

			default:
				return "All";
		}
	}

	async function loadFavorites() {
		try {
			const favoriteIds = (await $.track_reactivity_loss(favoritesService.getFavorites()))();

			$.set(favorites, new Set(favoriteIds), true);
		} catch(error) {
			console.warn(...$.log_if_contains_state('warn', "Failed to load favorites:", error));
		}
	}

	async function toggleFavorite(sequenceId) {
		try {
			(await $.track_reactivity_loss(favoritesService.toggleFavorite(sequenceId)))();

			if ($.get(favorites).has(sequenceId)) {
				$.get(favorites).delete(sequenceId);
			} else {
				$.get(favorites).add(sequenceId);
			}

			(await $.track_reactivity_loss(generateNavigationSections()))();
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "Failed to toggle favorite:", error));
		}
	}

	async function generateNavigationSections() {
		try {
			const sections = (await $.track_reactivity_loss(navigationService.generateNavigationSections($.get(allSequences), Array.from($.get(favorites)))))();

			$.set(navigationSections, sections, true);
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "Failed to generate navigation sections:", error));
		}
	}

	async function generateSequenceSections() {
		try {
			const sections = (await $.track_reactivity_loss(sectionService.organizeSections($.get(displayedSequences), $.get(sectionConfiguration))))();

			$.set(sequenceSections, sections, true);
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "Failed to generate sequence sections:", error));
		}
	}

	function toggleNavigationSection(sectionId) {
		$.set(navigationSections, navigationService.toggleSectionExpansion(sectionId, $.get(navigationSections)), true);
	}

	function setActiveNavigationItem(sectionId, itemId) {
		$.set(navigationSections, navigationService.setActiveItem(sectionId, itemId, $.get(navigationSections)), true);
	}

	async function filterSequencesByNavigation(sectionType, item) {
		try {
			const filtered = navigationService.getSequencesForNavigationItem(item, sectionType, $.get(allSequences));

			$.set(displayedSequences, filtered, true);
			$.set(filteredSequences, filtered, true);

			const filterType = `navigation_${sectionType}`;
			const filterValue = item.value;

			$.set(currentFilter, { type: filterType, value: filterValue }, true);
			(await $.track_reactivity_loss(stateManager.saveFilterState(filterType, filterValue)))();
			console.log(...$.log_if_contains_state('log', "ðŸ’¾ Navigation filter state saved:", { type: filterType, value: filterValue }));

			return filtered;
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "Failed to filter sequences by navigation:", error));

			return [];
		}
	}

	function toggleSequenceSection(sectionId) {
		$.set(sequenceSections, sectionService.toggleSectionExpansion(sectionId, $.get(sequenceSections)), true);
	}

	async function updateSectionConfiguration(updates) {
		$.set(sectionConfiguration, sectionService.updateSectionConfiguration($.get(sectionConfiguration), updates), true);
		(await $.track_reactivity_loss(generateSequenceSections()))();
	}

	async function prepareDeleteSequence(sequence) {
		try {
			const confirmationData = (await $.track_reactivity_loss(deleteService.prepareDeleteConfirmation(sequence, $.get(allSequences))))();

			$.set(deleteConfirmation, confirmationData, true);
			$.set(showDeleteDialog, true);
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "Failed to prepare delete confirmation:", error));
		}
	}

	async function confirmDeleteSequence() {
		if (!$.get(deleteConfirmation)) return;

		try {
			const result = (await $.track_reactivity_loss(deleteService.deleteSequence($.get(deleteConfirmation).sequence, $.get(allSequences))))();

			if (result.success && $.get(deleteConfirmation)) {
				const deletedSequenceId = $.get(deleteConfirmation).sequence.id;

				$.set(allSequences, $.get(allSequences).filter((seq) => $.strict_equals(seq.id, deletedSequenceId, false)), true);
				$.set(filteredSequences, $.get(filteredSequences).filter((seq) => $.strict_equals(seq.id, deletedSequenceId, false)), true);
				$.set(displayedSequences, $.get(displayedSequences).filter((seq) => $.strict_equals(seq.id, deletedSequenceId, false)), true);

				if ($.strict_equals($.get(selectedSequence)?.id, deletedSequenceId)) {
					$.set(selectedSequence, null);
				}

				(await $.track_reactivity_loss(generateNavigationSections()))();
				(await $.track_reactivity_loss(generateSequenceSections()))();
			}

			$.set(deleteConfirmation, null);
			$.set(showDeleteDialog, false);
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "Failed to delete sequence:", error));
		}
	}

	function cancelDeleteSequence() {
		$.set(deleteConfirmation, null);
		$.set(showDeleteDialog, false);
	}

	return {
		// âœ… REACTIVE STATE GETTERS
		get allSequences() {
			return $.get(allSequences);
		},

		get displayedSequences() {
			return $.get(displayedSequences);
		},

		get selectedSequence() {
			return $.get(selectedSequence);
		},

		get currentFilter() {
			return $.get(currentFilter);
		},

		get currentSort() {
			return $.get(currentSort);
		},

		get navigationMode() {
			return $.get(navigationMode);
		},

		get searchQuery() {
			return $.get(searchQuery);
		},

		// Advanced state getters
		get favorites() {
			return $.get(favorites);
		},

		get navigationSections() {
			return $.get(navigationSections);
		},

		get sequenceSections() {
			return $.get(sequenceSections);
		},

		get sectionConfiguration() {
			return $.get(sectionConfiguration);
		},

		get deleteConfirmation() {
			return $.get(deleteConfirmation);
		},

		get showDeleteDialog() {
			return $.get(showDeleteDialog);
		},

		// âœ… DERIVED STATE GETTERS
		get isLoading() {
			return $.get(isLoading);
		},

		get hasSequences() {
			return $.get(hasSequences);
		},

		get hasError() {
			return $.get(hasError);
		},

		get sequenceCount() {
			return $.get(sequenceCount);
		},

		get sortedSections() {
			return $.get(sortedSections);
		},

		get loadingState() {
			return loadingState;
		},

		get displayState() {
			return $.get(displayState);
		},

		// Advanced derived getters
		get favoritesCount() {
			return $.get(favoritesCount);
		},

		get hasNavigationSections() {
			return $.get(hasNavigationSections);
		},

		get hasSequenceSections() {
			return $.get(hasSequenceSections);
		},

		get sectionStatistics() {
			return $.get(sectionStatistics);
		},

		// âœ… ACTION METHODS
		loadAllSequences,

		applyFilter,
		updateSort,
		searchSequences,
		selectSequence,
		clearSelection,
		backToFilters,
		getThumbnailUrl,
		updateDisplaySettings,
		clearError,

		// Advanced action methods
		loadFavorites,

		toggleFavorite,
		generateNavigationSections,
		generateSequenceSections,
		toggleNavigationSection,
		setActiveNavigationItem,
		filterSequencesByNavigation,
		toggleSequenceSection,
		updateSectionConfiguration,
		prepareDeleteSequence,
		confirmDeleteSequence,
		cancelDeleteSequence
	};
}