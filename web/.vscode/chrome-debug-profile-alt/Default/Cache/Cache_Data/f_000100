import { GridMode } from "/src/lib/domain/enums.ts";
export class GridOverlayService {
  // Grid constants
  static GRID_OPACITY = 1;
  // Desktop uses 100% opacity
  static GRID_COLOR = "#e5e7eb";
  // Light gray
  static GRID_LINE_WIDTH = 1;
  /**
   * Apply combined grids to beat canvas
   * Matches desktop CombinedGridHandler.process_beat_for_combined_grids
   */
  applyCombinedGrids(canvas, currentGridMode) {
    if (!this.validateGridMode(currentGridMode)) {
      throw new Error(`Invalid grid mode: ${currentGridMode}`);
    }
    const combinedCanvas = document.createElement("canvas");
    combinedCanvas.width = canvas.width;
    combinedCanvas.height = canvas.height;
    const ctx = combinedCanvas.getContext("2d");
    if (!ctx) {
      throw new Error("Failed to get 2D context from combined canvas");
    }
    ctx.drawImage(canvas, 0, 0);
    const oppositeGridMode = this.getOppositeGridMode(currentGridMode);
    this.drawGridOverlay(
      ctx,
      oppositeGridMode,
      canvas.width,
      GridOverlayService.GRID_OPACITY
    );
    return combinedCanvas;
  }
  /**
   * Draw grid overlay on canvas
   * Implements both diamond and box grid patterns
   */
  drawGridOverlay(ctx, gridMode, size, opacity = 1) {
    if (!this.validateGridMode(gridMode)) {
      throw new Error(`Invalid grid mode: ${gridMode}`);
    }
    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.strokeStyle = GridOverlayService.GRID_COLOR;
    ctx.lineWidth = GridOverlayService.GRID_LINE_WIDTH;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    if (gridMode === GridMode.DIAMOND) {
      this.drawDiamondGrid(ctx, size);
    } else if (gridMode === GridMode.BOX) {
      this.drawBoxGrid(ctx, size);
    }
    ctx.restore();
  }
  /**
   * Get opposite grid mode
   * Matches desktop logic exactly
   */
  getOppositeGridMode(currentMode) {
    switch (currentMode.toLowerCase()) {
      case GridMode.DIAMOND:
        return GridMode.BOX;
      case GridMode.BOX:
        return GridMode.DIAMOND;
      default:
        throw new Error(`Unknown grid mode: ${currentMode}`);
    }
  }
  /**
   * Validate grid modes - only accepts proper GridMode enum
   */
  validateGridMode(gridMode) {
    const validModes = [GridMode.DIAMOND, GridMode.BOX];
    return validModes.includes(gridMode);
  }
  /**
   * Draw diamond grid pattern
   * Matches desktop diamond grid implementation
   */
  drawDiamondGrid(ctx, size) {
    const centerX = size / 2;
    const centerY = size / 2;
    const radius = size * 0.4;
    ctx.beginPath();
    ctx.moveTo(centerX, centerY - radius);
    ctx.lineTo(centerX + radius, centerY);
    ctx.lineTo(centerX, centerY + radius);
    ctx.lineTo(centerX - radius, centerY);
    ctx.closePath();
    ctx.stroke();
    this.drawDiamondGridLines(ctx, centerX, centerY, radius);
  }
  /**
   * Draw box grid pattern
   * Matches desktop box grid implementation
   */
  drawBoxGrid(ctx, size) {
    const margin = size * 0.1;
    const boxSize = size - 2 * margin;
    ctx.strokeRect(margin, margin, boxSize, boxSize);
    this.drawBoxGridLines(ctx, margin, margin, boxSize);
  }
  /**
   * Draw internal grid lines for diamond
   */
  drawDiamondGridLines(ctx, centerX, centerY, radius) {
    const originalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = originalAlpha * 0.5;
    ctx.beginPath();
    ctx.moveTo(centerX - radius * 0.7, centerY);
    ctx.lineTo(centerX + radius * 0.7, centerY);
    ctx.moveTo(centerX, centerY - radius * 0.7);
    ctx.lineTo(centerX, centerY + radius * 0.7);
    ctx.stroke();
    ctx.globalAlpha = originalAlpha;
  }
  /**
   * Draw internal grid lines for box
   */
  drawBoxGridLines(ctx, x, y, size) {
    const originalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = originalAlpha * 0.5;
    ctx.beginPath();
    const centerX = x + size / 2;
    const centerY = y + size / 2;
    ctx.moveTo(x, centerY);
    ctx.lineTo(x + size, centerY);
    ctx.moveTo(centerX, y);
    ctx.lineTo(centerX, y + size);
    ctx.stroke();
    ctx.globalAlpha = originalAlpha;
  }
  /**
   * Create grid overlay as separate canvas
   * Useful for caching grid patterns
   */
  createGridCanvas(gridMode, size) {
    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      throw new Error("Failed to get 2D context from grid canvas");
    }
    ctx.clearRect(0, 0, size, size);
    this.drawGridOverlay(ctx, gridMode, size);
    return canvas;
  }
  /**
   * Apply grid overlay with custom blend mode
   */
  applyGridWithBlendMode(canvas, gridMode, blendMode = "source-over") {
    const result = document.createElement("canvas");
    result.width = canvas.width;
    result.height = canvas.height;
    const ctx = result.getContext("2d");
    if (!ctx) {
      throw new Error("Failed to get 2D context from result canvas");
    }
    ctx.drawImage(canvas, 0, 0);
    ctx.globalCompositeOperation = blendMode;
    this.drawGridOverlay(ctx, gridMode, canvas.width);
    ctx.globalCompositeOperation = "source-over";
    return result;
  }
  /**
   * Create combined grid overlay (both grids at once)
   */
  createCombinedGridOverlay(size) {
    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      throw new Error("Failed to get 2D context from canvas");
    }
    ctx.clearRect(0, 0, size, size);
    ctx.globalAlpha = 0.7;
    this.drawGridOverlay(ctx, GridMode.DIAMOND, size);
    this.drawGridOverlay(ctx, GridMode.BOX, size);
    ctx.globalAlpha = 1;
    return canvas;
  }
  /**
   * Get recommended grid overlay settings
   */
  getRecommendedSettings(baseGridMode, purpose) {
    const overlayMode = this.getOppositeGridMode(baseGridMode);
    switch (purpose) {
      case "export":
        return {
          overlayMode,
          opacity: 1,
          // Full opacity for export (match desktop)
          lineWidth: 1,
          color: "#e5e7eb"
        };
      case "preview":
        return {
          overlayMode,
          opacity: 0.8,
          // Slightly transparent for preview
          lineWidth: 1,
          color: "#d1d5db"
        };
      case "print":
        return {
          overlayMode,
          opacity: 1,
          // Full opacity for print
          lineWidth: 2,
          // Thicker lines for print
          color: "#9ca3af"
        };
      default:
        throw new Error(`Unknown purpose: ${purpose}`);
    }
  }
  /**
   * Analyze grid contrast against background
   */
  analyzeGridContrast(_canvas, _gridMode) {
    const mockContrast = 0.7;
    return {
      averageContrast: mockContrast,
      minContrast: mockContrast - 0.1,
      maxContrast: mockContrast + 0.1,
      recommendation: mockContrast > 0.6 ? "optimal" : "increase"
    };
  }
  /**
   * Debug method to test grid rendering
   */
  debugGridRendering(size = 200) {
    return {
      diamondGrid: this.createGridCanvas(GridMode.DIAMOND, size),
      boxGrid: this.createGridCanvas(GridMode.BOX, size),
      combinedGrid: this.createCombinedGridOverlay(size)
    };
  }
  /**
   * Batch apply grid overlays to multiple canvases
   */
  batchApplyGrids(canvases, gridModes) {
    if (canvases.length !== gridModes.length) {
      throw new Error("Canvas count must match grid mode count");
    }
    return canvases.map((canvas, index) => {
      const gridMode = gridModes[index];
      return this.applyCombinedGrids(canvas, gridMode);
    });
  }
  /**
   * Get supported grid modes
   */
  getSupportedGridModes() {
    return [GridMode.DIAMOND, GridMode.BOX];
  }
  /**
   * Validate and normalize grid mode
   */
  normalizeGridMode(gridMode) {
    const normalized = gridMode.toLowerCase().trim();
    if (!this.validateGridMode(normalized)) {
      throw new Error(
        `Unsupported grid mode: ${gridMode}. Supported modes: ${this.getSupportedGridModes().join(", ")}`
      );
    }
    return normalized;
  }
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3NlcnZpY2VzL2ltcGxlbWVudGF0aW9ucy9pbWFnZS1leHBvcnQvR3JpZE92ZXJsYXlTZXJ2aWNlLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIEdyaWQgT3ZlcmxheSBTZXJ2aWNlXG4gKlxuICogSGFuZGxlcyBjb21iaW5lZCBncmlkIG92ZXJsYXlzIGZvciBUS0EgaW1hZ2UgZXhwb3J0LiBUaGlzIHNlcnZpY2UgaW1wbGVtZW50c1xuICogdGhlIGZ1bmN0aW9uYWxpdHkgZXF1aXZhbGVudCB0byBkZXNrdG9wIENvbWJpbmVkR3JpZEhhbmRsZXIsIGFsbG93aW5nIGJvdGhcbiAqIGRpYW1vbmQgYW5kIGJveCBncmlkcyB0byBiZSBkaXNwbGF5ZWQgc2ltdWx0YW5lb3VzbHkuXG4gKlxuICogQ3JpdGljYWw6IE11c3QgbWF0Y2ggZGVza3RvcCBvdmVybGF5IG9wYWNpdHkgYW5kIHBvc2l0aW9uaW5nIGV4YWN0bHkuXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBJR3JpZE92ZXJsYXlTZXJ2aWNlIH0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXMvaW1hZ2UtZXhwb3J0LWludGVyZmFjZXNcIjtcbmltcG9ydCB7IEdyaWRNb2RlIH0gZnJvbSBcIiRsaWIvZG9tYWluL2VudW1zXCI7XG5cbmV4cG9ydCBjbGFzcyBHcmlkT3ZlcmxheVNlcnZpY2UgaW1wbGVtZW50cyBJR3JpZE92ZXJsYXlTZXJ2aWNlIHtcbiAgLy8gR3JpZCBjb25zdGFudHNcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgR1JJRF9PUEFDSVRZID0gMS4wOyAvLyBEZXNrdG9wIHVzZXMgMTAwJSBvcGFjaXR5XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEdSSURfQ09MT1IgPSBcIiNlNWU3ZWJcIjsgLy8gTGlnaHQgZ3JheVxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBHUklEX0xJTkVfV0lEVEggPSAxO1xuXG4gIC8qKlxuICAgKiBBcHBseSBjb21iaW5lZCBncmlkcyB0byBiZWF0IGNhbnZhc1xuICAgKiBNYXRjaGVzIGRlc2t0b3AgQ29tYmluZWRHcmlkSGFuZGxlci5wcm9jZXNzX2JlYXRfZm9yX2NvbWJpbmVkX2dyaWRzXG4gICAqL1xuICBhcHBseUNvbWJpbmVkR3JpZHMoXG4gICAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCxcbiAgICBjdXJyZW50R3JpZE1vZGU6IHN0cmluZ1xuICApOiBIVE1MQ2FudmFzRWxlbWVudCB7XG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlR3JpZE1vZGUoY3VycmVudEdyaWRNb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGdyaWQgbW9kZTogJHtjdXJyZW50R3JpZE1vZGV9YCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG5ldyBjYW52YXMgZm9yIGNvbWJpbmVkIHJlc3VsdFxuICAgIGNvbnN0IGNvbWJpbmVkQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjb21iaW5lZENhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICBjb21iaW5lZENhbnZhcy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuXG4gICAgY29uc3QgY3R4ID0gY29tYmluZWRDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGlmICghY3R4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IDJEIGNvbnRleHQgZnJvbSBjb21iaW5lZCBjYW52YXNcIik7XG4gICAgfVxuXG4gICAgLy8gU3RlcCAxOiBEcmF3IG9yaWdpbmFsIGNhbnZhc1xuICAgIGN0eC5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcblxuICAgIC8vIFN0ZXAgMjogQWRkIG9wcG9zaXRlIGdyaWQgd2l0aCBmdWxsIG9wYWNpdHkgKG1hdGNoIGRlc2t0b3ApXG4gICAgY29uc3Qgb3Bwb3NpdGVHcmlkTW9kZSA9IHRoaXMuZ2V0T3Bwb3NpdGVHcmlkTW9kZShjdXJyZW50R3JpZE1vZGUpO1xuICAgIHRoaXMuZHJhd0dyaWRPdmVybGF5KFxuICAgICAgY3R4LFxuICAgICAgb3Bwb3NpdGVHcmlkTW9kZSxcbiAgICAgIGNhbnZhcy53aWR0aCxcbiAgICAgIEdyaWRPdmVybGF5U2VydmljZS5HUklEX09QQUNJVFlcbiAgICApO1xuXG4gICAgcmV0dXJuIGNvbWJpbmVkQ2FudmFzO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYXcgZ3JpZCBvdmVybGF5IG9uIGNhbnZhc1xuICAgKiBJbXBsZW1lbnRzIGJvdGggZGlhbW9uZCBhbmQgYm94IGdyaWQgcGF0dGVybnNcbiAgICovXG4gIGRyYXdHcmlkT3ZlcmxheShcbiAgICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgICBncmlkTW9kZTogc3RyaW5nLFxuICAgIHNpemU6IG51bWJlcixcbiAgICBvcGFjaXR5OiBudW1iZXIgPSAxLjBcbiAgKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlR3JpZE1vZGUoZ3JpZE1vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZ3JpZCBtb2RlOiAke2dyaWRNb2RlfWApO1xuICAgIH1cblxuICAgIC8vIFNhdmUgY3VycmVudCBjb250ZXh0IHN0YXRlXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIC8vIFNldCBncmlkIGRyYXdpbmcgcHJvcGVydGllc1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gR3JpZE92ZXJsYXlTZXJ2aWNlLkdSSURfQ09MT1I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IEdyaWRPdmVybGF5U2VydmljZS5HUklEX0xJTkVfV0lEVEg7XG4gICAgY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7XG4gICAgY3R4LmxpbmVKb2luID0gXCJyb3VuZFwiO1xuXG4gICAgaWYgKGdyaWRNb2RlID09PSBHcmlkTW9kZS5ESUFNT05EKSB7XG4gICAgICB0aGlzLmRyYXdEaWFtb25kR3JpZChjdHgsIHNpemUpO1xuICAgIH0gZWxzZSBpZiAoZ3JpZE1vZGUgPT09IEdyaWRNb2RlLkJPWCkge1xuICAgICAgdGhpcy5kcmF3Qm94R3JpZChjdHgsIHNpemUpO1xuICAgIH1cblxuICAgIC8vIFJlc3RvcmUgY29udGV4dCBzdGF0ZVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG9wcG9zaXRlIGdyaWQgbW9kZVxuICAgKiBNYXRjaGVzIGRlc2t0b3AgbG9naWMgZXhhY3RseVxuICAgKi9cbiAgZ2V0T3Bwb3NpdGVHcmlkTW9kZShjdXJyZW50TW9kZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKGN1cnJlbnRNb2RlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgR3JpZE1vZGUuRElBTU9ORDpcbiAgICAgICAgcmV0dXJuIEdyaWRNb2RlLkJPWDtcbiAgICAgIGNhc2UgR3JpZE1vZGUuQk9YOlxuICAgICAgICByZXR1cm4gR3JpZE1vZGUuRElBTU9ORDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBncmlkIG1vZGU6ICR7Y3VycmVudE1vZGV9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGdyaWQgbW9kZXMgLSBvbmx5IGFjY2VwdHMgcHJvcGVyIEdyaWRNb2RlIGVudW1cbiAgICovXG4gIHZhbGlkYXRlR3JpZE1vZGUoZ3JpZE1vZGU6IEdyaWRNb2RlKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdmFsaWRNb2RlcyA9IFtHcmlkTW9kZS5ESUFNT05ELCBHcmlkTW9kZS5CT1hdO1xuICAgIHJldHVybiB2YWxpZE1vZGVzLmluY2x1ZGVzKGdyaWRNb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3IGRpYW1vbmQgZ3JpZCBwYXR0ZXJuXG4gICAqIE1hdGNoZXMgZGVza3RvcCBkaWFtb25kIGdyaWQgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHByaXZhdGUgZHJhd0RpYW1vbmRHcmlkKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBzaXplOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBjZW50ZXJYID0gc2l6ZSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IHNpemUgLyAyO1xuICAgIGNvbnN0IHJhZGl1cyA9IHNpemUgKiAwLjQ7IC8vIFN0YW5kYXJkIGRpYW1vbmQgc2l6ZVxuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgLy8gRHJhdyBkaWFtb25kIHNoYXBlXG4gICAgY3R4Lm1vdmVUbyhjZW50ZXJYLCBjZW50ZXJZIC0gcmFkaXVzKTsgLy8gVG9wIHBvaW50XG4gICAgY3R4LmxpbmVUbyhjZW50ZXJYICsgcmFkaXVzLCBjZW50ZXJZKTsgLy8gUmlnaHQgcG9pbnRcbiAgICBjdHgubGluZVRvKGNlbnRlclgsIGNlbnRlclkgKyByYWRpdXMpOyAvLyBCb3R0b20gcG9pbnRcbiAgICBjdHgubGluZVRvKGNlbnRlclggLSByYWRpdXMsIGNlbnRlclkpOyAvLyBMZWZ0IHBvaW50XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgLy8gQWRkIGdyaWQgbGluZXMgaW5zaWRlIGRpYW1vbmQgKG9wdGlvbmFsIGVuaGFuY2VtZW50KVxuICAgIHRoaXMuZHJhd0RpYW1vbmRHcmlkTGluZXMoY3R4LCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYXcgYm94IGdyaWQgcGF0dGVyblxuICAgKiBNYXRjaGVzIGRlc2t0b3AgYm94IGdyaWQgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHByaXZhdGUgZHJhd0JveEdyaWQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHNpemU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IG1hcmdpbiA9IHNpemUgKiAwLjE7IC8vIFN0YW5kYXJkIGJveCBtYXJnaW5cbiAgICBjb25zdCBib3hTaXplID0gc2l6ZSAtIDIgKiBtYXJnaW47XG5cbiAgICAvLyBEcmF3IG1haW4gYm94XG4gICAgY3R4LnN0cm9rZVJlY3QobWFyZ2luLCBtYXJnaW4sIGJveFNpemUsIGJveFNpemUpO1xuXG4gICAgLy8gQWRkIGdyaWQgbGluZXMgaW5zaWRlIGJveCAob3B0aW9uYWwgZW5oYW5jZW1lbnQpXG4gICAgdGhpcy5kcmF3Qm94R3JpZExpbmVzKGN0eCwgbWFyZ2luLCBtYXJnaW4sIGJveFNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYXcgaW50ZXJuYWwgZ3JpZCBsaW5lcyBmb3IgZGlhbW9uZFxuICAgKi9cbiAgcHJpdmF0ZSBkcmF3RGlhbW9uZEdyaWRMaW5lcyhcbiAgICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgICBjZW50ZXJYOiBudW1iZXIsXG4gICAgY2VudGVyWTogbnVtYmVyLFxuICAgIHJhZGl1czogbnVtYmVyXG4gICk6IHZvaWQge1xuICAgIC8vIExpZ2h0ZXIgb3BhY2l0eSBmb3IgaW50ZXJuYWwgbGluZXNcbiAgICBjb25zdCBvcmlnaW5hbEFscGhhID0gY3R4Lmdsb2JhbEFscGhhO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9yaWdpbmFsQWxwaGEgKiAwLjU7XG5cbiAgICAvLyBEcmF3IGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGNlbnRlciBsaW5lc1xuICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgIC8vIEhvcml6b250YWwgbGluZVxuICAgIGN0eC5tb3ZlVG8oY2VudGVyWCAtIHJhZGl1cyAqIDAuNywgY2VudGVyWSk7XG4gICAgY3R4LmxpbmVUbyhjZW50ZXJYICsgcmFkaXVzICogMC43LCBjZW50ZXJZKTtcblxuICAgIC8vIFZlcnRpY2FsIGxpbmVcbiAgICBjdHgubW92ZVRvKGNlbnRlclgsIGNlbnRlclkgLSByYWRpdXMgKiAwLjcpO1xuICAgIGN0eC5saW5lVG8oY2VudGVyWCwgY2VudGVyWSArIHJhZGl1cyAqIDAuNyk7XG5cbiAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGFscGhhXG4gICAgY3R4Lmdsb2JhbEFscGhhID0gb3JpZ2luYWxBbHBoYTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3IGludGVybmFsIGdyaWQgbGluZXMgZm9yIGJveFxuICAgKi9cbiAgcHJpdmF0ZSBkcmF3Qm94R3JpZExpbmVzKFxuICAgIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICAgIHg6IG51bWJlcixcbiAgICB5OiBudW1iZXIsXG4gICAgc2l6ZTogbnVtYmVyXG4gICk6IHZvaWQge1xuICAgIC8vIExpZ2h0ZXIgb3BhY2l0eSBmb3IgaW50ZXJuYWwgbGluZXNcbiAgICBjb25zdCBvcmlnaW5hbEFscGhhID0gY3R4Lmdsb2JhbEFscGhhO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9yaWdpbmFsQWxwaGEgKiAwLjU7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAvLyBEcmF3IGNlbnRlciBjcm9zc1xuICAgIGNvbnN0IGNlbnRlclggPSB4ICsgc2l6ZSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IHkgKyBzaXplIC8gMjtcblxuICAgIC8vIEhvcml6b250YWwgbGluZVxuICAgIGN0eC5tb3ZlVG8oeCwgY2VudGVyWSk7XG4gICAgY3R4LmxpbmVUbyh4ICsgc2l6ZSwgY2VudGVyWSk7XG5cbiAgICAvLyBWZXJ0aWNhbCBsaW5lXG4gICAgY3R4Lm1vdmVUbyhjZW50ZXJYLCB5KTtcbiAgICBjdHgubGluZVRvKGNlbnRlclgsIHkgKyBzaXplKTtcblxuICAgIGN0eC5zdHJva2UoKTtcblxuICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgYWxwaGFcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcmlnaW5hbEFscGhhO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBncmlkIG92ZXJsYXkgYXMgc2VwYXJhdGUgY2FudmFzXG4gICAqIFVzZWZ1bCBmb3IgY2FjaGluZyBncmlkIHBhdHRlcm5zXG4gICAqL1xuICBjcmVhdGVHcmlkQ2FudmFzKGdyaWRNb2RlOiBzdHJpbmcsIHNpemU6IG51bWJlcik6IEhUTUxDYW52YXNFbGVtZW50IHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHNpemU7XG4gICAgY2FudmFzLmhlaWdodCA9IHNpemU7XG5cbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGlmICghY3R4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IDJEIGNvbnRleHQgZnJvbSBncmlkIGNhbnZhc1wiKTtcbiAgICB9XG5cbiAgICAvLyBGaWxsIHdpdGggdHJhbnNwYXJlbnQgYmFja2dyb3VuZFxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgc2l6ZSwgc2l6ZSk7XG5cbiAgICAvLyBEcmF3IGdyaWRcbiAgICB0aGlzLmRyYXdHcmlkT3ZlcmxheShjdHgsIGdyaWRNb2RlLCBzaXplKTtcblxuICAgIHJldHVybiBjYW52YXM7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgZ3JpZCBvdmVybGF5IHdpdGggY3VzdG9tIGJsZW5kIG1vZGVcbiAgICovXG4gIGFwcGx5R3JpZFdpdGhCbGVuZE1vZGUoXG4gICAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCxcbiAgICBncmlkTW9kZTogc3RyaW5nLFxuICAgIGJsZW5kTW9kZTogR2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiXG4gICk6IEhUTUxDYW52YXNFbGVtZW50IHtcbiAgICBjb25zdCByZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIHJlc3VsdC53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICByZXN1bHQuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcblxuICAgIGNvbnN0IGN0eCA9IHJlc3VsdC5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgMkQgY29udGV4dCBmcm9tIHJlc3VsdCBjYW52YXNcIik7XG4gICAgfVxuXG4gICAgLy8gRHJhdyBvcmlnaW5hbCBjYW52YXNcbiAgICBjdHguZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG5cbiAgICAvLyBTZXQgYmxlbmQgbW9kZSBhbmQgZHJhdyBncmlkXG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGJsZW5kTW9kZTtcbiAgICB0aGlzLmRyYXdHcmlkT3ZlcmxheShjdHgsIGdyaWRNb2RlLCBjYW52YXMud2lkdGgpO1xuXG4gICAgLy8gUmVzZXQgYmxlbmQgbW9kZVxuICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBjb21iaW5lZCBncmlkIG92ZXJsYXkgKGJvdGggZ3JpZHMgYXQgb25jZSlcbiAgICovXG4gIGNyZWF0ZUNvbWJpbmVkR3JpZE92ZXJsYXkoc2l6ZTogbnVtYmVyKTogSFRNTENhbnZhc0VsZW1lbnQge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gc2l6ZTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gc2l6ZTtcblxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgMkQgY29udGV4dCBmcm9tIGNhbnZhc1wiKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBiYWNrZ3JvdW5kXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBzaXplLCBzaXplKTtcblxuICAgIC8vIERyYXcgYm90aCBncmlkcyB3aXRoIHJlZHVjZWQgb3BhY2l0eVxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNztcbiAgICB0aGlzLmRyYXdHcmlkT3ZlcmxheShjdHgsIEdyaWRNb2RlLkRJQU1PTkQsIHNpemUpO1xuICAgIHRoaXMuZHJhd0dyaWRPdmVybGF5KGN0eCwgR3JpZE1vZGUuQk9YLCBzaXplKTtcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjA7XG5cbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCByZWNvbW1lbmRlZCBncmlkIG92ZXJsYXkgc2V0dGluZ3NcbiAgICovXG4gIGdldFJlY29tbWVuZGVkU2V0dGluZ3MoXG4gICAgYmFzZUdyaWRNb2RlOiBzdHJpbmcsXG4gICAgcHVycG9zZTogXCJleHBvcnRcIiB8IFwicHJldmlld1wiIHwgXCJwcmludFwiXG4gICk6IHtcbiAgICBvdmVybGF5TW9kZTogc3RyaW5nO1xuICAgIG9wYWNpdHk6IG51bWJlcjtcbiAgICBsaW5lV2lkdGg6IG51bWJlcjtcbiAgICBjb2xvcjogc3RyaW5nO1xuICB9IHtcbiAgICBjb25zdCBvdmVybGF5TW9kZSA9IHRoaXMuZ2V0T3Bwb3NpdGVHcmlkTW9kZShiYXNlR3JpZE1vZGUpO1xuXG4gICAgc3dpdGNoIChwdXJwb3NlKSB7XG4gICAgICBjYXNlIFwiZXhwb3J0XCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3ZlcmxheU1vZGUsXG4gICAgICAgICAgb3BhY2l0eTogMS4wLCAvLyBGdWxsIG9wYWNpdHkgZm9yIGV4cG9ydCAobWF0Y2ggZGVza3RvcClcbiAgICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgICAgY29sb3I6IFwiI2U1ZTdlYlwiLFxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIFwicHJldmlld1wiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG92ZXJsYXlNb2RlLFxuICAgICAgICAgIG9wYWNpdHk6IDAuOCwgLy8gU2xpZ2h0bHkgdHJhbnNwYXJlbnQgZm9yIHByZXZpZXdcbiAgICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgICAgY29sb3I6IFwiI2QxZDVkYlwiLFxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIFwicHJpbnRcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvdmVybGF5TW9kZSxcbiAgICAgICAgICBvcGFjaXR5OiAxLjAsIC8vIEZ1bGwgb3BhY2l0eSBmb3IgcHJpbnRcbiAgICAgICAgICBsaW5lV2lkdGg6IDIsIC8vIFRoaWNrZXIgbGluZXMgZm9yIHByaW50XG4gICAgICAgICAgY29sb3I6IFwiIzljYTNhZlwiLFxuICAgICAgICB9O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcHVycG9zZTogJHtwdXJwb3NlfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbmFseXplIGdyaWQgY29udHJhc3QgYWdhaW5zdCBiYWNrZ3JvdW5kXG4gICAqL1xuICBhbmFseXplR3JpZENvbnRyYXN0KFxuICAgIF9jYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICAgIF9ncmlkTW9kZTogc3RyaW5nXG4gICk6IHtcbiAgICBhdmVyYWdlQ29udHJhc3Q6IG51bWJlcjtcbiAgICBtaW5Db250cmFzdDogbnVtYmVyO1xuICAgIG1heENvbnRyYXN0OiBudW1iZXI7XG4gICAgcmVjb21tZW5kYXRpb246IFwiaW5jcmVhc2VcIiB8IFwiZGVjcmVhc2VcIiB8IFwib3B0aW1hbFwiO1xuICB9IHtcbiAgICAvLyBDcmVhdGUgYSB0ZXN0IGdyaWQgb3ZlcmxheVxuICAgIC8vIGNvbnN0IHRlc3RDYW52YXMgPSB0aGlzLmNyZWF0ZUdyaWRDYW52YXMoZ3JpZE1vZGUsIDEwMCk7IC8vIEZvciBmdXR1cmUgY29udHJhc3QgYW5hbHlzaXNcbiAgICAvLyBjb25zdCBjdHggPSB0ZXN0Q2FudmFzLmdldENvbnRleHQoXCIyZFwiKSE7IC8vIEZvciBmdXR1cmUgY29udHJhc3QgYW5hbHlzaXNcbiAgICAvLyBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEwMCwgMTAwKTsgLy8gRm9yIGZ1dHVyZSBjb250cmFzdCBhbmFseXNpc1xuXG4gICAgLy8gU2ltcGxpZmllZCBjb250cmFzdCBhbmFseXNpc1xuICAgIC8vIEluIGEgZnVsbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCBhbmFseXplIGFjdHVhbCBwaXhlbCB2YWx1ZXNcbiAgICBjb25zdCBtb2NrQ29udHJhc3QgPSAwLjc7IC8vIFBsYWNlaG9sZGVyIHZhbHVlXG5cbiAgICByZXR1cm4ge1xuICAgICAgYXZlcmFnZUNvbnRyYXN0OiBtb2NrQ29udHJhc3QsXG4gICAgICBtaW5Db250cmFzdDogbW9ja0NvbnRyYXN0IC0gMC4xLFxuICAgICAgbWF4Q29udHJhc3Q6IG1vY2tDb250cmFzdCArIDAuMSxcbiAgICAgIHJlY29tbWVuZGF0aW9uOiBtb2NrQ29udHJhc3QgPiAwLjYgPyBcIm9wdGltYWxcIiA6IFwiaW5jcmVhc2VcIixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlYnVnIG1ldGhvZCB0byB0ZXN0IGdyaWQgcmVuZGVyaW5nXG4gICAqL1xuICBkZWJ1Z0dyaWRSZW5kZXJpbmcoc2l6ZTogbnVtYmVyID0gMjAwKToge1xuICAgIGRpYW1vbmRHcmlkOiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICBib3hHcmlkOiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICBjb21iaW5lZEdyaWQ6IEhUTUxDYW52YXNFbGVtZW50O1xuICB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgZGlhbW9uZEdyaWQ6IHRoaXMuY3JlYXRlR3JpZENhbnZhcyhHcmlkTW9kZS5ESUFNT05ELCBzaXplKSxcbiAgICAgIGJveEdyaWQ6IHRoaXMuY3JlYXRlR3JpZENhbnZhcyhHcmlkTW9kZS5CT1gsIHNpemUpLFxuICAgICAgY29tYmluZWRHcmlkOiB0aGlzLmNyZWF0ZUNvbWJpbmVkR3JpZE92ZXJsYXkoc2l6ZSksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXRjaCBhcHBseSBncmlkIG92ZXJsYXlzIHRvIG11bHRpcGxlIGNhbnZhc2VzXG4gICAqL1xuICBiYXRjaEFwcGx5R3JpZHMoXG4gICAgY2FudmFzZXM6IEhUTUxDYW52YXNFbGVtZW50W10sXG4gICAgZ3JpZE1vZGVzOiBzdHJpbmdbXVxuICApOiBIVE1MQ2FudmFzRWxlbWVudFtdIHtcbiAgICBpZiAoY2FudmFzZXMubGVuZ3RoICE9PSBncmlkTW9kZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgY291bnQgbXVzdCBtYXRjaCBncmlkIG1vZGUgY291bnRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbnZhc2VzLm1hcCgoY2FudmFzLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZ3JpZE1vZGUgPSBncmlkTW9kZXNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHRoaXMuYXBwbHlDb21iaW5lZEdyaWRzKGNhbnZhcywgZ3JpZE1vZGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzdXBwb3J0ZWQgZ3JpZCBtb2Rlc1xuICAgKi9cbiAgZ2V0U3VwcG9ydGVkR3JpZE1vZGVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gW0dyaWRNb2RlLkRJQU1PTkQsIEdyaWRNb2RlLkJPWF07XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgYW5kIG5vcm1hbGl6ZSBncmlkIG1vZGVcbiAgICovXG4gIG5vcm1hbGl6ZUdyaWRNb2RlKGdyaWRNb2RlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBncmlkTW9kZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcblxuICAgIGlmICghdGhpcy52YWxpZGF0ZUdyaWRNb2RlKG5vcm1hbGl6ZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBVbnN1cHBvcnRlZCBncmlkIG1vZGU6ICR7Z3JpZE1vZGV9LiBTdXBwb3J0ZWQgbW9kZXM6ICR7dGhpcy5nZXRTdXBwb3J0ZWRHcmlkTW9kZXMoKS5qb2luKFwiLCBcIil9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIkFBV0EsU0FBUyxnQkFBZ0I7QUFFbEIsYUFBTSxtQkFBa0Q7QUFBQTtBQUFBLEVBRTdELE9BQXdCLGVBQWU7QUFBQTtBQUFBLEVBQ3ZDLE9BQXdCLGFBQWE7QUFBQTtBQUFBLEVBQ3JDLE9BQXdCLGtCQUFrQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNMUMsbUJBQ0UsUUFDQSxpQkFDbUI7QUFDbkIsUUFBSSxDQUFDLEtBQUssaUJBQWlCLGVBQWUsR0FBRztBQUMzQyxZQUFNLElBQUksTUFBTSxzQkFBc0IsZUFBZSxFQUFFO0FBQUEsSUFDekQ7QUFHQSxVQUFNLGlCQUFpQixTQUFTLGNBQWMsUUFBUTtBQUN0RCxtQkFBZSxRQUFRLE9BQU87QUFDOUIsbUJBQWUsU0FBUyxPQUFPO0FBRS9CLFVBQU0sTUFBTSxlQUFlLFdBQVcsSUFBSTtBQUMxQyxRQUFJLENBQUMsS0FBSztBQUNSLFlBQU0sSUFBSSxNQUFNLCtDQUErQztBQUFBLElBQ2pFO0FBR0EsUUFBSSxVQUFVLFFBQVEsR0FBRyxDQUFDO0FBRzFCLFVBQU0sbUJBQW1CLEtBQUssb0JBQW9CLGVBQWU7QUFDakUsU0FBSztBQUFBLE1BQ0g7QUFBQSxNQUNBO0FBQUEsTUFDQSxPQUFPO0FBQUEsTUFDUCxtQkFBbUI7QUFBQSxJQUNyQjtBQUVBLFdBQU87QUFBQSxFQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU1BLGdCQUNFLEtBQ0EsVUFDQSxNQUNBLFVBQWtCLEdBQ1o7QUFDTixRQUFJLENBQUMsS0FBSyxpQkFBaUIsUUFBUSxHQUFHO0FBQ3BDLFlBQU0sSUFBSSxNQUFNLHNCQUFzQixRQUFRLEVBQUU7QUFBQSxJQUNsRDtBQUdBLFFBQUksS0FBSztBQUdULFFBQUksY0FBYztBQUNsQixRQUFJLGNBQWMsbUJBQW1CO0FBQ3JDLFFBQUksWUFBWSxtQkFBbUI7QUFDbkMsUUFBSSxVQUFVO0FBQ2Qs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
