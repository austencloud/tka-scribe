import { GridMode } from "/src/lib/domain/index.ts";
export class LetterQueryService {
  constructor(letterMappingRepository, csvLoaderService, csvParserService, pictographTransformationService) {
    this.letterMappingRepository = letterMappingRepository;
    this.csvLoaderService = csvLoaderService;
    this.csvParserService = csvParserService;
    this.pictographTransformationService = pictographTransformationService;
  }
  parsedData = null;
  isInitialized = false;
  /**
   * Initialize CSV data and letter mapping repository if not already loaded
   */
  async ensureInitialized() {
    if (this.isInitialized) {
      return;
    }
    try {
      if (this.letterMappingRepository && typeof this.letterMappingRepository.initialize === "function") {
        await this.letterMappingRepository.initialize();
        console.log(
          "‚úÖ LetterQueryService: Letter mapping repository initialized"
        );
      }
      const csvData = await this.csvLoaderService.loadCsvData();
      const diamondParseResult = this.csvParserService.parseCSV(
        csvData.diamondData
      );
      const boxParseResult = this.csvParserService.parseCSV(csvData.boxData);
      console.log(
        `üìä Diamond CSV parsing result: ${diamondParseResult.successfulRows} successful rows out of ${diamondParseResult.totalRows} total`
      );
      console.log(
        `üìä Box CSV parsing result: ${boxParseResult.successfulRows} successful rows out of ${boxParseResult.totalRows} total`
      );
      if (diamondParseResult.errors.length > 0) {
        console.warn(`‚ö†Ô∏è Diamond CSV parsing errors (first 3):`);
        diamondParseResult.errors.slice(0, 3).forEach((error, index) => {
          console.warn(
            `  Error ${index + 1}: Row ${error.rowIndex} - ${error.error}`
          );
          console.warn(`  Raw row: ${error.rawRow.substring(0, 100)}...`);
        });
      }
      if (boxParseResult.errors.length > 0) {
        console.warn(`‚ö†Ô∏è Box CSV parsing errors (first 3):`);
        boxParseResult.errors.slice(0, 3).forEach((error, index) => {
          console.warn(
            `  Error ${index + 1}: Row ${error.rowIndex} - ${error.error}`
          );
          console.warn(`  Raw row: ${error.rawRow.substring(0, 100)}...`);
        });
      }
      this.parsedData = {
        [GridMode.DIAMOND]: diamondParseResult.rows,
        [GridMode.BOX]: boxParseResult.rows
      };
      console.log(
        `üìä Final parsed data: Diamond=${this.parsedData[GridMode.DIAMOND]?.length || 0} rows, Box=${this.parsedData[GridMode.BOX]?.length || 0} rows`
      );
      this.isInitialized = true;
      console.log("‚úÖ LetterQueryService: CSV data loaded and parsed");
    } catch (error) {
      console.error("‚ùå LetterQueryService: Error loading CSV data:", error);
      throw new Error(
        `Failed to load CSV data: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Get a specific pictograph by letter using LetterMappingRepository
   */
  async getPictographByLetter(letter, gridMode) {
    if (!this.letterMappingRepository) {
      console.error(
        "‚ùå LetterMappingRepository not available for getPictographByLetter"
      );
      return null;
    }
    await this.ensureInitialized();
    try {
      const mapping = this.letterMappingRepository.getLetterMapping(letter);
      if (!mapping) {
        console.warn(`‚ö†Ô∏è No letter mapping found for letter: ${letter}`);
        return null;
      }
      console.log(
        `üîç Finding CSV data for letter ${letter} with mapping:`,
        mapping
      );
      const csvRow = this.findMatchingCsvRowByMapping(
        letter,
        mapping,
        gridMode
      );
      if (!csvRow) {
        console.warn(`‚ö†Ô∏è No CSV data found for letter ${letter}`);
        return null;
      }
      console.log(`‚úÖ Found CSV data for letter ${letter}:`, csvRow);
      return this.pictographTransformationService.convertCsvRowToPictographData(
        csvRow,
        gridMode.toString()
      );
    } catch (error) {
      console.error(`‚ùå Error getting pictograph for letter ${letter}:`, error);
      return null;
    }
  }
  /**
   * Get all pictographs from the codex using LetterMappingRepository
   */
  async getAllCodexPictographs(gridMode) {
    if (!this.letterMappingRepository) {
      console.error(
        "‚ùå LetterMappingRepository not available for getAllCodexPictographs"
      );
      return [];
    }
    await this.ensureInitialized();
    try {
      const allLetters = this.letterMappingRepository.getAllLetters();
      console.log(`üìö Getting all ${allLetters.length} pictographs from codex`);
      const pictographs = [];
      for (const letter of allLetters) {
        const pictograph = await this.getPictographByLetter(letter, gridMode);
        if (pictograph) {
          pictographs.push(pictograph);
        }
      }
      console.log(`‚úÖ Retrieved ${pictographs.length} pictographs from codex`);
      return pictographs;
    } catch (error) {
      console.error("‚ùå Error getting all codex pictographs:", error);
      return [];
    }
  }
  /**
   * Get ALL pictograph variations from CSV data (not limited by letter mappings)
   * This returns every row in the CSV as a separate pictograph, including multiple variations per letter
   */
  async getAllPictographVariations(gridMode) {
    await this.ensureInitialized();
    try {
      if (!this.parsedData) {
        console.error("‚ùå No parsed CSV data available");
        return [];
      }
      const csvRows = this.parsedData[gridMode];
      if (!csvRows || csvRows.length === 0) {
        console.error(`‚ùå No CSV data available for grid mode: ${gridMode}`);
        return [];
      }
      console.log(
        `üìö Converting all ${csvRows.length} CSV rows to pictographs`
      );
      const pictographs = [];
      for (let i = 0; i < csvRows.length; i++) {
        const row = csvRows[i];
        try {
          const pictograph = this.pictographTransformationService.convertCsvRowToPictographData(
            row,
            gridMode.toString(),
            i
          );
          if (pictograph) {
            pictographs.push(pictograph);
          }
        } catch (error) {
          console.warn(
            `‚ö†Ô∏è Failed to convert CSV row ${i} (letter: ${row.letter}):`,
            error
          );
        }
      }
      console.log(
        `‚úÖ Retrieved ${pictographs.length} pictograph variations from CSV`
      );
      return pictographs;
    } catch (error) {
      console.error("‚ùå Error getting all pictograph variations:", error);
      return [];
    }
  }
  /**
   * Search pictographs by letter patterns
   */
  async searchPictographs(searchTerm, gridMode) {
    if (!this.letterMappingRepository) {
      console.error(
        "‚ùå LetterMappingRepository not available for searchPictographs"
      );
      return [];
    }
    await this.ensureInitialized();
    try {
      const allLetters = this.letterMappingRepository.getAllLetters();
      const matchingLetters = allLetters.filter(
        (letter) => letter.toLowerCase().includes(searchTerm.toLowerCase())
      );
      console.log(
        `üîç Found ${matchingLetters.length} letters matching "${searchTerm}"`
      );
      const pictographs = [];
      for (const letter of matchingLetters) {
        const pictograph = await this.getPictographByLetter(letter, gridMode);
        if (pictograph) {
          pictographs.push(pictograph);
        }
      }
      return pictographs;
    } catch (error) {
      console.error(
        `‚ùå Error searching pictographs for "${searchTerm}":`,
        error
      );
      return [];
    }
  }
  /**
   * Get pictographs for multiple letters
   */
  async getPictographsByLetters(letters, gridMode) {
    await this.ensureInitialized();
    const pictographs = [];
    for (const letter of letters) {
      const pictograph = await this.getPictographByLetter(letter, gridMode);
      if (pictograph) {
        pictographs.push(pictograph);
      }
    }
    return pictographs;
  }
  /**
   * Find matching CSV row by letter mapping
   */
  findMatchingCsvRowByMapping(letter, mapping, gridMode) {
    if (!this.parsedData) {
      return null;
    }
    const csvRows = this.parsedData[gridMode];
    if (!csvRows) {
      return null;
    }
    const mappingData = mapping;
    const matchingRow = csvRows.find(
      (row) => row.letter === letter && row.startPosition === mapping.startPosition && row.endPosition === mapping.endPosition && row.blueMotionType === (mappingData.blueMotion || mappingData.blueMotionType) && row.redMotionType === (mappingData.redMotion || mappingData.redMotionType)
    );
    return matchingRow || null;
  }
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3NlcnZpY2VzL2ltcGxlbWVudGF0aW9ucy9kYXRhL0xldHRlclF1ZXJ5U2VydmljZS50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyoqXG4gKiBMZXR0ZXIgUXVlcnkgU2VydmljZSAtIExldHRlci1iYXNlZCBwaWN0b2dyYXBoIGxvb2t1cHNcbiAqXG4gKiBTaW5nbGUgcmVzcG9uc2liaWxpdHk6IFF1ZXJ5IHBpY3RvZ3JhcGhzIGJ5IGxldHRlciB1c2luZyBMZXR0ZXJNYXBwaW5nUmVwb3NpdG9yeVxuICogVXNlcyBzaGFyZWQgc2VydmljZXMgZm9yIENTViBsb2FkaW5nLCBwYXJzaW5nLCBhbmQgdHJhbnNmb3JtYXRpb24uXG4gKi9cblxuaW1wb3J0IHsgR3JpZE1vZGUgfSBmcm9tIFwiJGxpYi9kb21haW5cIjtcbmltcG9ydCB0eXBlIHsgUGljdG9ncmFwaERhdGEgfSBmcm9tIFwiJGxpYi9kb21haW5cIjtcbmltcG9ydCB0eXBlIHsgTGV0dGVyTWFwcGluZywgTW90aW9uVHlwZSB9IGZyb20gXCIkbGliL2RvbWFpbi9jb2RleC90eXBlc1wiO1xuaW1wb3J0IHR5cGUgeyBJTGV0dGVyTWFwcGluZ1JlcG9zaXRvcnkgfSBmcm9tIFwiJGxpYi9yZXBvc2l0b3JpZXMvTGV0dGVyTWFwcGluZ1JlcG9zaXRvcnlcIjtcbmltcG9ydCB0eXBlIHsgSUNzdkxvYWRlclNlcnZpY2UgfSBmcm9tIFwiLi9Dc3ZMb2FkZXJTZXJ2aWNlXCI7XG5pbXBvcnQgdHlwZSB7IElDU1ZQYXJzZXJTZXJ2aWNlLCBQYXJzZWRDc3ZSb3cgfSBmcm9tIFwiLi9DU1ZQYXJzZXJTZXJ2aWNlXCI7XG5pbXBvcnQgdHlwZSB7IElQaWN0b2dyYXBoVHJhbnNmb3JtYXRpb25TZXJ2aWNlIH0gZnJvbSBcIi4vUGljdG9ncmFwaFRyYW5zZm9ybWF0aW9uU2VydmljZVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIElMZXR0ZXJRdWVyeVNlcnZpY2Uge1xuICBnZXRQaWN0b2dyYXBoQnlMZXR0ZXIoXG4gICAgbGV0dGVyOiBzdHJpbmcsXG4gICAgZ3JpZE1vZGU6IEdyaWRNb2RlXG4gICk6IFByb21pc2U8UGljdG9ncmFwaERhdGEgfCBudWxsPjtcbiAgZ2V0QWxsQ29kZXhQaWN0b2dyYXBocyhncmlkTW9kZTogR3JpZE1vZGUpOiBQcm9taXNlPFBpY3RvZ3JhcGhEYXRhW10+O1xuICBnZXRBbGxQaWN0b2dyYXBoVmFyaWF0aW9ucyhncmlkTW9kZTogR3JpZE1vZGUpOiBQcm9taXNlPFBpY3RvZ3JhcGhEYXRhW10+O1xuICBzZWFyY2hQaWN0b2dyYXBocyhcbiAgICBzZWFyY2hUZXJtOiBzdHJpbmcsXG4gICAgZ3JpZE1vZGU6IEdyaWRNb2RlXG4gICk6IFByb21pc2U8UGljdG9ncmFwaERhdGFbXT47XG4gIGdldFBpY3RvZ3JhcGhzQnlMZXR0ZXJzKFxuICAgIGxldHRlcnM6IHN0cmluZ1tdLFxuICAgIGdyaWRNb2RlOiBHcmlkTW9kZVxuICApOiBQcm9taXNlPFBpY3RvZ3JhcGhEYXRhW10+O1xufVxuXG5leHBvcnQgY2xhc3MgTGV0dGVyUXVlcnlTZXJ2aWNlIGltcGxlbWVudHMgSUxldHRlclF1ZXJ5U2VydmljZSB7XG4gIHByaXZhdGUgcGFyc2VkRGF0YTogUmVjb3JkPEdyaWRNb2RlLCBQYXJzZWRDc3ZSb3dbXT4gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpc0luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBsZXR0ZXJNYXBwaW5nUmVwb3NpdG9yeTogSUxldHRlck1hcHBpbmdSZXBvc2l0b3J5LFxuICAgIHByaXZhdGUgY3N2TG9hZGVyU2VydmljZTogSUNzdkxvYWRlclNlcnZpY2UsXG4gICAgcHJpdmF0ZSBjc3ZQYXJzZXJTZXJ2aWNlOiBJQ1NWUGFyc2VyU2VydmljZSxcbiAgICBwcml2YXRlIHBpY3RvZ3JhcGhUcmFuc2Zvcm1hdGlvblNlcnZpY2U6IElQaWN0b2dyYXBoVHJhbnNmb3JtYXRpb25TZXJ2aWNlXG4gICkge31cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBDU1YgZGF0YSBhbmQgbGV0dGVyIG1hcHBpbmcgcmVwb3NpdG9yeSBpZiBub3QgYWxyZWFkeSBsb2FkZWRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZW5zdXJlSW5pdGlhbGl6ZWQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBJbml0aWFsaXplIGxldHRlciBtYXBwaW5nIHJlcG9zaXRvcnkgZmlyc3RcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5sZXR0ZXJNYXBwaW5nUmVwb3NpdG9yeSAmJlxuICAgICAgICB0eXBlb2YgdGhpcy5sZXR0ZXJNYXBwaW5nUmVwb3NpdG9yeS5pbml0aWFsaXplID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICkge1xuICAgICAgICBhd2FpdCB0aGlzLmxldHRlck1hcHBpbmdSZXBvc2l0b3J5LmluaXRpYWxpemUoKTtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgXCLinIUgTGV0dGVyUXVlcnlTZXJ2aWNlOiBMZXR0ZXIgbWFwcGluZyByZXBvc2l0b3J5IGluaXRpYWxpemVkXCJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gTG9hZCByYXcgQ1NWIGRhdGFcbiAgICAgIGNvbnN0IGNzdkRhdGEgPSBhd2FpdCB0aGlzLmNzdkxvYWRlclNlcnZpY2UubG9hZENzdkRhdGEoKTtcblxuICAgICAgLy8gUGFyc2UgQ1NWIGRhdGEgdXNpbmcgc2hhcmVkIHNlcnZpY2VcbiAgICAgIGNvbnN0IGRpYW1vbmRQYXJzZVJlc3VsdCA9IHRoaXMuY3N2UGFyc2VyU2VydmljZS5wYXJzZUNTVihcbiAgICAgICAgY3N2RGF0YS5kaWFtb25kRGF0YVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGJveFBhcnNlUmVzdWx0ID0gdGhpcy5jc3ZQYXJzZXJTZXJ2aWNlLnBhcnNlQ1NWKGNzdkRhdGEuYm94RGF0YSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBg8J+TiiBEaWFtb25kIENTViBwYXJzaW5nIHJlc3VsdDogJHtkaWFtb25kUGFyc2VSZXN1bHQuc3VjY2Vzc2Z1bFJvd3N9IHN1Y2Nlc3NmdWwgcm93cyBvdXQgb2YgJHtkaWFtb25kUGFyc2VSZXN1bHQudG90YWxSb3dzfSB0b3RhbGBcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYPCfk4ogQm94IENTViBwYXJzaW5nIHJlc3VsdDogJHtib3hQYXJzZVJlc3VsdC5zdWNjZXNzZnVsUm93c30gc3VjY2Vzc2Z1bCByb3dzIG91dCBvZiAke2JveFBhcnNlUmVzdWx0LnRvdGFsUm93c30gdG90YWxgXG4gICAgICApO1xuXG4gICAgICBpZiAoZGlhbW9uZFBhcnNlUmVzdWx0LmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIERpYW1vbmQgQ1NWIHBhcnNpbmcgZXJyb3JzIChmaXJzdCAzKTpgKTtcbiAgICAgICAgZGlhbW9uZFBhcnNlUmVzdWx0LmVycm9ycy5zbGljZSgwLCAzKS5mb3JFYWNoKChlcnJvciwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgICBFcnJvciAke2luZGV4ICsgMX06IFJvdyAke2Vycm9yLnJvd0luZGV4fSAtICR7ZXJyb3IuZXJyb3J9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc29sZS53YXJuKGAgIFJhdyByb3c6ICR7ZXJyb3IucmF3Um93LnN1YnN0cmluZygwLCAxMDApfS4uLmApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChib3hQYXJzZVJlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBCb3ggQ1NWIHBhcnNpbmcgZXJyb3JzIChmaXJzdCAzKTpgKTtcbiAgICAgICAgYm94UGFyc2VSZXN1bHQuZXJyb3JzLnNsaWNlKDAsIDMpLmZvckVhY2goKGVycm9yLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGAgIEVycm9yICR7aW5kZXggKyAxfTogUm93ICR7ZXJyb3Iucm93SW5kZXh9IC0gJHtlcnJvci5lcnJvcn1gXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYCAgUmF3IHJvdzogJHtlcnJvci5yYXdSb3cuc3Vic3RyaW5nKDAsIDEwMCl9Li4uYCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhcnNlZERhdGEgPSB7XG4gICAgICAgIFtHcmlkTW9kZS5ESUFNT05EXTogZGlhbW9uZFBhcnNlUmVzdWx0LnJvd3MsXG4gICAgICAgIFtHcmlkTW9kZS5CT1hdOiBib3hQYXJzZVJlc3VsdC5yb3dzLFxuICAgICAgfTtcblxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGDwn5OKIEZpbmFsIHBhcnNlZCBkYXRhOiBEaWFtb25kPSR7dGhpcy5wYXJzZWREYXRhW0dyaWRNb2RlLkRJQU1PTkRdPy5sZW5ndGggfHwgMH0gcm93cywgQm94PSR7dGhpcy5wYXJzZWREYXRhW0dyaWRNb2RlLkJPWF0/Lmxlbmd0aCB8fCAwfSByb3dzYFxuICAgICAgKTtcblxuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUubG9nKFwi4pyFIExldHRlclF1ZXJ5U2VydmljZTogQ1NWIGRhdGEgbG9hZGVkIGFuZCBwYXJzZWRcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgTGV0dGVyUXVlcnlTZXJ2aWNlOiBFcnJvciBsb2FkaW5nIENTViBkYXRhOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gbG9hZCBDU1YgZGF0YTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHNwZWNpZmljIHBpY3RvZ3JhcGggYnkgbGV0dGVyIHVzaW5nIExldHRlck1hcHBpbmdSZXBvc2l0b3J5XG4gICAqL1xuICBhc3luYyBnZXRQaWN0b2dyYXBoQnlMZXR0ZXIoXG4gICAgbGV0dGVyOiBzdHJpbmcsXG4gICAgZ3JpZE1vZGU6IEdyaWRNb2RlXG4gICk6IFByb21pc2U8UGljdG9ncmFwaERhdGEgfCBudWxsPiB7XG4gICAgaWYgKCF0aGlzLmxldHRlck1hcHBpbmdSZXBvc2l0b3J5KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIuKdjCBMZXR0ZXJNYXBwaW5nUmVwb3NpdG9yeSBub3QgYXZhaWxhYmxlIGZvciBnZXRQaWN0b2dyYXBoQnlMZXR0ZXJcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgbGV0dGVyIG1hcHBpbmcgZnJvbSByZXBvc2l0b3J5XG4gICAgICBjb25zdCBtYXBwaW5nID0gdGhpcy5sZXR0ZXJNYXBwaW5nUmVwb3NpdG9yeS5nZXRMZXR0ZXJNYXBwaW5nKGxldHRlcik7XG4gICAgICBpZiAoIW1hcHBpbmcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gTm8gbGV0dGVyIG1hcHBpbmcgZm91bmQgZm9yIGxldHRlcjogJHtsZXR0ZXJ9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYPCflI0gRmluZGluZyBDU1YgZGF0YSBmb3IgbGV0dGVyICR7bGV0dGVyfSB3aXRoIG1hcHBpbmc6YCxcbiAgICAgICAgbWFwcGluZ1xuICAgICAgKTtcblxuICAgICAgLy8gRmluZCBtYXRjaGluZyBDU1Ygcm93XG4gICAgICBjb25zdCBjc3ZSb3cgPSB0aGlzLmZpbmRNYXRjaGluZ0NzdlJvd0J5TWFwcGluZyhcbiAgICAgICAgbGV0dGVyLFxuICAgICAgICBtYXBwaW5nLFxuICAgICAgICBncmlkTW9kZVxuICAgICAgKTtcbiAgICAgIGlmICghY3N2Um93KSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIE5vIENTViBkYXRhIGZvdW5kIGZvciBsZXR0ZXIgJHtsZXR0ZXJ9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIENTViBkYXRhIGZvciBsZXR0ZXIgJHtsZXR0ZXJ9OmAsIGNzdlJvdyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSBDU1Ygcm93IHRvIFBpY3RvZ3JhcGhEYXRhIHVzaW5nIHNoYXJlZCBzZXJ2aWNlXG4gICAgICByZXR1cm4gdGhpcy5waWN0b2dyYXBoVHJhbnNmb3JtYXRpb25TZXJ2aWNlLmNvbnZlcnRDc3ZSb3dUb1BpY3RvZ3JhcGhEYXRhKFxuICAgICAgICBjc3ZSb3csXG4gICAgICAgIGdyaWRNb2RlLnRvU3RyaW5nKClcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciBnZXR0aW5nIHBpY3RvZ3JhcGggZm9yIGxldHRlciAke2xldHRlcn06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgcGljdG9ncmFwaHMgZnJvbSB0aGUgY29kZXggdXNpbmcgTGV0dGVyTWFwcGluZ1JlcG9zaXRvcnlcbiAgICovXG4gIGFzeW5jIGdldEFsbENvZGV4UGljdG9ncmFwaHMoZ3JpZE1vZGU6IEdyaWRNb2RlKTogUHJvbWlzZTxQaWN0b2dyYXBoRGF0YVtdPiB7XG4gICAgaWYgKCF0aGlzLmxldHRlck1hcHBpbmdSZXBvc2l0b3J5KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIuKdjCBMZXR0ZXJNYXBwaW5nUmVwb3NpdG9yeSBub3QgYXZhaWxhYmxlIGZvciBnZXRBbGxDb2RleFBpY3RvZ3JhcGhzXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFsbExldHRlcnMgPSB0aGlzLmxldHRlck1hcHBpbmdSZXBvc2l0b3J5LmdldEFsbExldHRlcnMoKTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OaIEdldHRpbmcgYWxsICR7YWxsTGV0dGVycy5sZW5ndGh9IHBpY3RvZ3JhcGhzIGZyb20gY29kZXhgKTtcblxuICAgICAgY29uc3QgcGljdG9ncmFwaHM6IFBpY3RvZ3JhcGhEYXRhW10gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgbGV0dGVyIG9mIGFsbExldHRlcnMpIHtcbiAgICAgICAgY29uc3QgcGljdG9ncmFwaCA9IGF3YWl0IHRoaXMuZ2V0UGljdG9ncmFwaEJ5TGV0dGVyKGxldHRlciwgZ3JpZE1vZGUpO1xuICAgICAgICBpZiAocGljdG9ncmFwaCkge1xuICAgICAgICAgIHBpY3RvZ3JhcGhzLnB1c2gocGljdG9ncmFwaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYOKchSBSZXRyaWV2ZWQgJHtwaWN0b2dyYXBocy5sZW5ndGh9IHBpY3RvZ3JhcGhzIGZyb20gY29kZXhgKTtcbiAgICAgIHJldHVybiBwaWN0b2dyYXBocztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBFcnJvciBnZXR0aW5nIGFsbCBjb2RleCBwaWN0b2dyYXBoczpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgQUxMIHBpY3RvZ3JhcGggdmFyaWF0aW9ucyBmcm9tIENTViBkYXRhIChub3QgbGltaXRlZCBieSBsZXR0ZXIgbWFwcGluZ3MpXG4gICAqIFRoaXMgcmV0dXJucyBldmVyeSByb3cgaW4gdGhlIENTViBhcyBhIHNlcGFyYXRlIHBpY3RvZ3JhcGgsIGluY2x1ZGluZyBtdWx0aXBsZSB2YXJpYXRpb25zIHBlciBsZXR0ZXJcbiAgICovXG4gIGFzeW5jIGdldEFsbFBpY3RvZ3JhcGhWYXJpYXRpb25zKFxuICAgIGdyaWRNb2RlOiBHcmlkTW9kZVxuICApOiBQcm9taXNlPFBpY3RvZ3JhcGhEYXRhW10+IHtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLnBhcnNlZERhdGEpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBObyBwYXJzZWQgQ1NWIGRhdGEgYXZhaWxhYmxlXCIpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNzdlJvd3MgPSB0aGlzLnBhcnNlZERhdGFbZ3JpZE1vZGVdO1xuICAgICAgaWYgKCFjc3ZSb3dzIHx8IGNzdlJvd3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBObyBDU1YgZGF0YSBhdmFpbGFibGUgZm9yIGdyaWQgbW9kZTogJHtncmlkTW9kZX1gKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYPCfk5ogQ29udmVydGluZyBhbGwgJHtjc3ZSb3dzLmxlbmd0aH0gQ1NWIHJvd3MgdG8gcGljdG9ncmFwaHNgXG4gICAgICApO1xuXG4gICAgICBjb25zdCBwaWN0b2dyYXBoczogUGljdG9ncmFwaERhdGFbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjc3ZSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IGNzdlJvd3NbaV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGljdG9ncmFwaCA9XG4gICAgICAgICAgICB0aGlzLnBpY3RvZ3JhcGhUcmFuc2Zvcm1hdGlvblNlcnZpY2UuY29udmVydENzdlJvd1RvUGljdG9ncmFwaERhdGEoXG4gICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgZ3JpZE1vZGUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAocGljdG9ncmFwaCkge1xuICAgICAgICAgICAgcGljdG9ncmFwaHMucHVzaChwaWN0b2dyYXBoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYOKaoO+4jyBGYWlsZWQgdG8gY29udmVydCBDU1Ygcm93ICR7aX0gKGxldHRlcjogJHtyb3cubGV0dGVyfSk6YCxcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYOKchSBSZXRyaWV2ZWQgJHtwaWN0b2dyYXBocy5sZW5ndGh9IHBpY3RvZ3JhcGggdmFyaWF0aW9ucyBmcm9tIENTVmBcbiAgICAgICk7XG4gICAgICByZXR1cm4gcGljdG9ncmFwaHM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRXJyb3IgZ2V0dGluZyBhbGwgcGljdG9ncmFwaCB2YXJpYXRpb25zOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCBwaWN0b2dyYXBocyBieSBsZXR0ZXIgcGF0dGVybnNcbiAgICovXG4gIGFzeW5jIHNlYXJjaFBpY3RvZ3JhcGhzKFxuICAgIHNlYXJjaFRlcm06IHN0cmluZyxcbiAgICBncmlkTW9kZTogR3JpZE1vZGVcbiAgKTogUHJvbWlzZTxQaWN0b2dyYXBoRGF0YVtdPiB7XG4gICAgaWYgKCF0aGlzLmxldHRlck1hcHBpbmdSZXBvc2l0b3J5KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIuKdjCBMZXR0ZXJNYXBwaW5nUmVwb3NpdG9yeSBub3QgYXZhaWxhYmxlIGZvciBzZWFyY2hQaWN0b2dyYXBoc1wiXG4gICAgICApO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBhbGxMZXR0ZXJzID0gdGhpcy5sZXR0ZXJNYXBwaW5nUmVwb3NpdG9yeS5nZXRBbGxMZXR0ZXJzKCk7XG4gICAgICBjb25zdCBtYXRjaGluZ0xldHRlcnMgPSBhbGxMZXR0ZXJzLmZpbHRlcigobGV0dGVyKSA9PlxuICAgICAgICBsZXR0ZXIudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hUZXJtLnRvTG93ZXJDYXNlKCkpXG4gICAgICApO1xuXG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYPCflI0gRm91bmQgJHttYXRjaGluZ0xldHRlcnMubGVuZ3RofSBsZXR0ZXJzIG1hdGNoaW5nIFwiJHtzZWFyY2hUZXJtfVwiYFxuICAgICAgKTtcblxuICAgICAgY29uc3QgcGljdG9ncmFwaHM6IFBpY3RvZ3JhcGhEYXRhW10gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgbGV0dGVyIG9mIG1hdGNoaW5nTGV0dGVycykge1xuICAgICAgICBjb25zdCBwaWN0b2dyYXBoID0gYXdhaXQgdGhpcy5nZXRQaWN0b2dyYXBoQnlMZXR0ZXIobGV0dGVyLCBncmlkTW9kZSk7XG4gICAgICAgIGlmIChwaWN0b2dyYXBoKSB7XG4gICAgICAgICAgcGljdG9ncmFwaHMucHVzaChwaWN0b2dyYXBoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGljdG9ncmFwaHM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGDinYwgRXJyb3Igc2VhcmNoaW5nIHBpY3RvZ3JhcGhzIGZvciBcIiR7c2VhcmNoVGVybX1cIjpgLFxuICAgICAgICBlcnJvclxuICAgICAgKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHBpY3RvZ3JhcGhzIGZvciBtdWx0aXBsZSBsZXR0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRQaWN0b2dyYXBoc0J5TGV0dGVycyhcbiAgICBsZXR0ZXJzOiBzdHJpbmdbXSxcbiAgICBncmlkTW9kZTogR3JpZE1vZGVcbiAgKTogUHJvbWlzZTxQaWN0b2dyYXBoRGF0YVtdPiB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuXG4gICAgY29uc3QgcGljdG9ncmFwaHM6IFBpY3RvZ3JhcGhEYXRhW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGxldHRlciBvZiBsZXR0ZXJzKSB7XG4gICAgICBjb25zdCBwaWN0b2dyYXBoID0gYXdhaXQgdGhpcy5nZXRQaWN0b2dyYXBoQnlMZXR0ZXIobGV0dGVyLCBncmlkTW9kZSk7XG4gICAgICBpZiAocGljdG9ncmFwaCkge1xuICAgICAgICBwaWN0b2dyYXBocy5wdXNoKHBpY3RvZ3JhcGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwaWN0b2dyYXBocztcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIG1hdGNoaW5nIENTViByb3cgYnkgbGV0dGVyIG1hcHBpbmdcbiAgICovXG4gIHByaXZhdGUgZmluZE1hdGNoaW5nQ3N2Um93QnlNYXBwaW5nKFxuICAgIGxldHRlcjogc3RyaW5nLFxuICAgIG1hcHBpbmc6IExldHRlck1hcHBpbmcsXG4gICAgZ3JpZE1vZGU6IEdyaWRNb2RlXG4gICk6IFBhcnNlZENzdlJvdyB8IG51bGwge1xuICAgIGlmICghdGhpcy5wYXJzZWREYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBjc3ZSb3dzID0gdGhpcy5wYXJzZWREYXRhW2dyaWRNb2RlXTtcbiAgICBpZiAoIWNzdlJvd3MpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgbWlzbWF0Y2ggYmV0d2VlbiBKU09OIGNvbmZpZyBhbmQgTGV0dGVyTWFwcGluZyBpbnRlcmZhY2VcbiAgICBjb25zdCBtYXBwaW5nRGF0YSA9IG1hcHBpbmcgYXMgTGV0dGVyTWFwcGluZyAmIHtcbiAgICAgIGJsdWVNb3Rpb24/OiBNb3Rpb25UeXBlO1xuICAgICAgcmVkTW90aW9uPzogTW90aW9uVHlwZTtcbiAgICB9O1xuICAgIGNvbnN0IG1hdGNoaW5nUm93ID0gY3N2Um93cy5maW5kKFxuICAgICAgKHJvdykgPT5cbiAgICAgICAgcm93LmxldHRlciA9PT0gbGV0dGVyICYmXG4gICAgICAgIHJvdy5zdGFydFBvc2l0aW9uID09PSBtYXBwaW5nLnN0YXJ0UG9zaXRpb24gJiZcbiAgICAgICAgcm93LmVuZFBvc2l0aW9uID09PSBtYXBwaW5nLmVuZFBvc2l0aW9uICYmXG4gICAgICAgIHJvdy5ibHVlTW90aW9uVHlwZSA9PT1cbiAgICAgICAgICAobWFwcGluZ0RhdGEuYmx1ZU1vdGlvbiB8fCBtYXBwaW5nRGF0YS5ibHVlTW90aW9uVHlwZSkgJiZcbiAgICAgICAgcm93LnJlZE1vdGlvblR5cGUgPT09XG4gICAgICAgICAgKG1hcHBpbmdEYXRhLnJlZE1vdGlvbiB8fCBtYXBwaW5nRGF0YS5yZWRNb3Rpb25UeXBlKVxuICAgICk7XG5cbiAgICByZXR1cm4gbWF0Y2hpbmdSb3cgfHwgbnVsbDtcbiAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIkFBT0EsU0FBUyxnQkFBZ0I7QUF5QmxCLGFBQU0sbUJBQWtEO0FBQUEsRUFJN0QsWUFDVSx5QkFDQSxrQkFDQSxrQkFDQSxpQ0FDUjtBQUpRO0FBQ0E7QUFDQTtBQUNBO0FBQUEsRUFDUDtBQUFBLEVBUkssYUFBc0Q7QUFBQSxFQUN0RCxnQkFBZ0I7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVl4QixNQUFjLG9CQUFtQztBQUMvQyxRQUFJLEtBQUssZUFBZTtB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
