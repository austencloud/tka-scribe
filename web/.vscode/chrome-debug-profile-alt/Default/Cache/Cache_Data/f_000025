import { createPictographData } from "/src/lib/domain/PictographData.ts";
import { createPropData } from "/src/lib/domain/PropData.ts";
import { createPropPlacementData } from "/src/lib/domain/PropPlacementData.ts";
import { pictographDataDebugger } from "/src/lib/services/debug/PictographDataDebugger.ts";
import { MotionColor } from "/src/lib/domain/enums.ts";
import { createMotionData } from "/src/lib/domain/MotionData.ts";
export class PictographTransformationService {
  constructor(enumMappingService) {
    this.enumMappingService = enumMappingService;
  }
  /**
   * Convert CSV row to PictographData - main public interface
   */
  convertCsvRowToPictographData(row, gridMode, index) {
    try {
      const identifier = `${row.letter || "unknown"}_${index || Date.now()}`;
      pictographDataDebugger.startTrace(identifier);
      pictographDataDebugger.addTraceStep(identifier, "CSV_INPUT", row);
      const result = this.createPictographFromCSVRow(row, gridMode);
      if (result) {
        pictographDataDebugger.addTraceStep(
          identifier,
          "PICTOGRAPH_CREATED",
          result
        );
        pictographDataDebugger.getPictographDebugInfo(result, row);
      } else {
        pictographDataDebugger.addTraceStep(
          identifier,
          "CONVERSION_FAILED",
          null,
          ["Failed to create pictograph"]
        );
      }
      return result;
    } catch (error) {
      console.warn(
        `âš ï¸ Failed to convert CSV row ${index || "unknown"} to pictograph:`,
        error
      );
      return null;
    }
  }
  /**
   * Create PictographData from CSV row with comprehensive error handling
   */
  createPictographFromCSVRow(row, gridMode) {
    try {
      const validation = this.validateCSVRow(row);
      if (!validation.isValid) {
        console.warn("âš ï¸ CSV row validation failed:", validation.errors);
        return null;
      }
      const letter = row.letter;
      if (!letter) {
        console.warn("âš ï¸ Missing letter in CSV row");
        return null;
      }
      if (letter === "G" || letter === "g") {
        console.log(`ðŸ”§ [G DEBUG] CSV row data:`, {
          letter: row.letter,
          blueStartLocation: row.blueStartLocation || row.blueStartLoc,
          blueEndLocation: row.blueEndLocation || row.blueendLocation,
          redStartLocation: row.redStartLocation || row.redStartLoc,
          redEndLocation: row.redEndLocation || row.redendLocation,
          fullRow: row
        });
      }
      const blueMotion = createMotionData({
        motionType: this.enumMappingService.mapMotionType(row.blueMotionType),
        rotationDirection: this.enumMappingService.mapRotationDirection(
          row.blueRotationDirection
        ),
        startLocation: this.enumMappingService.mapLocation(
          row.blueStartLocation || row.blueStartLoc
        ),
        endLocation: this.enumMappingService.mapLocation(
          row.blueEndLocation || row.blueendLocation
        ),
        turns: 0,
        isVisible: true,
        color: MotionColor.BLUE
        // âœ… Explicitly set blue color
      });
      const redMotion = createMotionData({
        motionType: this.enumMappingService.mapMotionType(row.redMotionType),
        rotationDirection: this.enumMappingService.mapRotationDirection(
          row.redRotationDirection
        ),
        startLocation: this.enumMappingService.mapLocation(
          row.redStartLocation || row.redStartLoc
        ),
        endLocation: this.enumMappingService.mapLocation(
          row.redEndLocation || row.redendLocation
        ),
        turns: 0,
        isVisible: true,
        color: MotionColor.RED
        // âœ… Explicitly set red color
      });
      const blueProps = this.createPropFromMotion(blueMotion, MotionColor.BLUE);
      const redProps = this.createPropFromMotion(redMotion, MotionColor.RED);
      return createPictographData({
        letter,
        motions: {
          blue: blueMotion,
          red: redMotion
        },
        props: {
          blue: blueProps,
          red: redProps
        },
        startPosition: this.enumMappingService.convertToGridPosition(
          row.startPosition
        ),
        endPosition: this.enumMappingService.convertToGridPosition(
          row.endPosition
        ),
        gridMode,
        isBlank: false,
        metadata: {
          source: "csv_transformation_service",
          gridMode,
          originalRow: row,
          letterType: this.enumMappingService.getLetterType(letter)
        }
      });
    } catch (error) {
      console.warn("âš ï¸ Failed to create pictograph from CSV row:", error);
      return null;
    }
  }
  /**
   * Create PropData from MotionData
   * This ensures props have the correct location and orientation from motion data
   */
  createPropFromMotion(motion, color) {
    console.log(`ðŸ”§ [DEBUG] Creating prop from motion for ${color}:`, {
      motionData: {
        startLocation: motion.startLocation,
        endLocation: motion.endLocation,
        endOrientation: motion.endOrientation,
        rotationDirection: motion.rotationDirection
      },
      willCreatePropWith: {
        location: motion.endLocation,
        orientation: motion.endOrientation,
        rotationDirection: motion.rotationDirection
      }
    });
    const propData = createPropData({
      orientation: motion.endOrientation,
      rotationDirection: motion.rotationDirection,
      placementData: createPropPlacementData(),
      isVisible: motion.isVisible
    });
    console.log(`ðŸ”§ [DEBUG] Created prop result:`, {
      color,
      // âœ… Color from parameter (MotionColor.BLUE or MotionColor.RED)
      location: motion.endLocation,
      // Get location from motion.endLocation
      orientation: propData.orientation,
      rotationDirection: propData.rotationDirection
    });
    return propData;
  }
  /**
   * Validate CSV row has required fields
   */
  validateCSVRow(row) {
    const errors = [];
    const requiredFields = [
      "letter",
      "startPosition",
      "endPosition",
      "blueMotionType",
      "redMotionType"
    ];
    for (const field of requiredFields) {
      if (!row[field] || row[field].trim() === "") {
        errors.push(`Missing required field: ${field}`);
      }
    }
    const blueStartLoc = row.blueStartLocation || row.blueStartLoc;
    const blueEndLoc = row.blueEndLocation || row.blueendLocation;
    const redStartLoc = row.redStartLocation || row.redStartLoc;
    const redEndLoc = row.redEndLocation || row.redendLocation;
    if (!blueStartLoc) errors.push("Missing blue start location");
    if (!blueEndLoc) errors.push("Missing blue end location");
    if (!redStartLoc) errors.push("Missing red start location");
    if (!redEndLoc) errors.push("Missing red end location");
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  /**
   * Batch convert multiple CSV rows to PictographData
   */
  convertMultipleRows(rows, gridMode) {
    const successful = [];
    const failed = [];
    rows.forEach((row, index) => {
      try {
        const pictograph = this.convertCsvRowToPictographData(
          row,
          gridMode,
          index
        );
        if (pictograph) {
          successful.push(pictograph);
        } else {
          failed.push({
            index,
            row,
            error: "Conversion returned null"
          });
        }
      } catch (error) {
        failed.push({
          index,
          row,
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
    return { successful, failed };
  }
  /**
   * Get transformation statistics for debugging
   */
  getTransformationStats(rows, _gridMode) {
    const stats = {
      totalRows: rows.length,
      validRows: 0,
      invalidRows: 0,
      validationErrors: []
    };
    rows.forEach((row, index) => {
      const validation = this.validateCSVRow(row);
      if (validation.isValid) {
        stats.validRows++;
      } else {
        stats.invalidRows++;
        stats.validationErrors.push({
          index,
          errors: validation.errors
        });
      }
    });
    return stats;
  }
  /**
   * Create pictograph with custom metadata
   */
  createPictographWithMetadata(row, gridMode, additionalMetadata = {}) {
    const pictograph = this.createPictographFromCSVRow(row, gridMode);
    if (!pictograph) return null;
    return {
      ...pictograph,
      metadata: {
        ...pictograph.metadata,
        ...additionalMetadata
      }
    };
  }
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3NlcnZpY2VzL2ltcGxlbWVudGF0aW9ucy9kYXRhL1BpY3RvZ3JhcGhUcmFuc2Zvcm1hdGlvblNlcnZpY2UudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogUGljdG9ncmFwaFRyYW5zZm9ybWF0aW9uU2VydmljZSAtIENlbnRyYWxpemVkIHBpY3RvZ3JhcGggZGF0YSB0cmFuc2Zvcm1hdGlvblxuICpcbiAqIEhhbmRsZXMgY29udmVyc2lvbiBmcm9tIENTViByb3dzIHRvIFBpY3RvZ3JhcGhEYXRhIG9iamVjdHMgdXNpbmcgc2hhcmVkIHV0aWxpdGllcy5cbiAqIEVsaW1pbmF0ZXMgZHVwbGljYXRpb24gb2YgdHJhbnNmb3JtYXRpb24gbG9naWMgYWNyb3NzIHNlcnZpY2VzLlxuICovXG5cbmltcG9ydCB0eXBlIHsgUGljdG9ncmFwaERhdGEgfSBmcm9tIFwiJGxpYi9kb21haW4vUGljdG9ncmFwaERhdGFcIjtcbmltcG9ydCB7IGNyZWF0ZVBpY3RvZ3JhcGhEYXRhIH0gZnJvbSBcIiRsaWIvZG9tYWluL1BpY3RvZ3JhcGhEYXRhXCI7XG5cbmltcG9ydCB7IGNyZWF0ZVByb3BEYXRhIH0gZnJvbSBcIiRsaWIvZG9tYWluL1Byb3BEYXRhXCI7XG5pbXBvcnQgeyBjcmVhdGVQcm9wUGxhY2VtZW50RGF0YSB9IGZyb20gXCIkbGliL2RvbWFpbi9Qcm9wUGxhY2VtZW50RGF0YVwiO1xuaW1wb3J0IHR5cGUgeyBJRW51bU1hcHBpbmdTZXJ2aWNlIH0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXMvYXBwbGljYXRpb24taW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgcGljdG9ncmFwaERhdGFEZWJ1Z2dlciB9IGZyb20gXCIuLi8uLi9kZWJ1Zy9QaWN0b2dyYXBoRGF0YURlYnVnZ2VyXCI7XG5pbXBvcnQgeyBNb3Rpb25Db2xvciB9IGZyb20gXCIkbGliL2RvbWFpbi9lbnVtc1wiO1xuaW1wb3J0IHsgY3JlYXRlTW90aW9uRGF0YSB9IGZyb20gXCIkbGliL2RvbWFpbi9Nb3Rpb25EYXRhXCI7XG5pbXBvcnQgdHlwZSB7IE1vdGlvbkRhdGEsIFByb3BEYXRhIH0gZnJvbSBcIiRsaWIvZG9tYWluXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVBpY3RvZ3JhcGhUcmFuc2Zvcm1hdGlvblNlcnZpY2Uge1xuICBjb252ZXJ0Q3N2Um93VG9QaWN0b2dyYXBoRGF0YShcbiAgICByb3c6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gICAgZ3JpZE1vZGU6IHN0cmluZyxcbiAgICBpbmRleD86IG51bWJlclxuICApOiBQaWN0b2dyYXBoRGF0YSB8IG51bGw7XG5cbiAgY3JlYXRlUGljdG9ncmFwaEZyb21DU1ZSb3coXG4gICAgcm93OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGdyaWRNb2RlOiBzdHJpbmdcbiAgKTogUGljdG9ncmFwaERhdGEgfCBudWxsO1xuXG4gIHZhbGlkYXRlQ1NWUm93KHJvdzogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IHtcbiAgICBpc1ZhbGlkOiBib29sZWFuO1xuICAgIGVycm9yczogc3RyaW5nW107XG4gIH07XG59XG5cbmV4cG9ydCBjbGFzcyBQaWN0b2dyYXBoVHJhbnNmb3JtYXRpb25TZXJ2aWNlXG4gIGltcGxlbWVudHMgSVBpY3RvZ3JhcGhUcmFuc2Zvcm1hdGlvblNlcnZpY2VcbntcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbnVtTWFwcGluZ1NlcnZpY2U6IElFbnVtTWFwcGluZ1NlcnZpY2UpIHt9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgQ1NWIHJvdyB0byBQaWN0b2dyYXBoRGF0YSAtIG1haW4gcHVibGljIGludGVyZmFjZVxuICAgKi9cbiAgY29udmVydENzdlJvd1RvUGljdG9ncmFwaERhdGEoXG4gICAgcm93OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGdyaWRNb2RlOiBzdHJpbmcsXG4gICAgaW5kZXg/OiBudW1iZXJcbiAgKTogUGljdG9ncmFwaERhdGEgfCBudWxsIHtcbiAgICB0cnkge1xuICAgICAgLy8gU3RhcnQgZGVidWdnaW5nIHRyYWNlXG4gICAgICBjb25zdCBpZGVudGlmaWVyID0gYCR7cm93LmxldHRlciB8fCBcInVua25vd25cIn1fJHtpbmRleCB8fCBEYXRlLm5vdygpfWA7XG4gICAgICBwaWN0b2dyYXBoRGF0YURlYnVnZ2VyLnN0YXJ0VHJhY2UoaWRlbnRpZmllcik7XG4gICAgICBwaWN0b2dyYXBoRGF0YURlYnVnZ2VyLmFkZFRyYWNlU3RlcChpZGVudGlmaWVyLCBcIkNTVl9JTlBVVFwiLCByb3cpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZVBpY3RvZ3JhcGhGcm9tQ1NWUm93KHJvdywgZ3JpZE1vZGUpO1xuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhRGVidWdnZXIuYWRkVHJhY2VTdGVwKFxuICAgICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgICAgXCJQSUNUT0dSQVBIX0NSRUFURURcIixcbiAgICAgICAgICByZXN1bHRcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBHZXQgY29tcHJlaGVuc2l2ZSBkZWJ1ZyBpbmZvIC0gYnV0IGRvbid0IG1vZGlmeSB0aGUgcmVzdWx0XG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhRGVidWdnZXIuZ2V0UGljdG9ncmFwaERlYnVnSW5mbyhyZXN1bHQsIHJvdyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaWN0b2dyYXBoRGF0YURlYnVnZ2VyLmFkZFRyYWNlU3RlcChcbiAgICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICAgIFwiQ09OVkVSU0lPTl9GQUlMRURcIixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIFtcIkZhaWxlZCB0byBjcmVhdGUgcGljdG9ncmFwaFwiXVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGDimqDvuI8gRmFpbGVkIHRvIGNvbnZlcnQgQ1NWIHJvdyAke2luZGV4IHx8IFwidW5rbm93blwifSB0byBwaWN0b2dyYXBoOmAsXG4gICAgICAgIGVycm9yXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBQaWN0b2dyYXBoRGF0YSBmcm9tIENTViByb3cgd2l0aCBjb21wcmVoZW5zaXZlIGVycm9yIGhhbmRsaW5nXG4gICAqL1xuICBjcmVhdGVQaWN0b2dyYXBoRnJvbUNTVlJvdyhcbiAgICByb3c6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gICAgZ3JpZE1vZGU6IHN0cmluZ1xuICApOiBQaWN0b2dyYXBoRGF0YSB8IG51bGwge1xuICAgIHRyeSB7XG4gICAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBmaWVsZHNcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlQ1NWUm93KHJvdyk7XG4gICAgICBpZiAoIXZhbGlkYXRpb24uaXNWYWxpZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gQ1NWIHJvdyB2YWxpZGF0aW9uIGZhaWxlZDpcIiwgdmFsaWRhdGlvbi5lcnJvcnMpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGV0dGVyID0gcm93LmxldHRlcjtcbiAgICAgIGlmICghbGV0dGVyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBNaXNzaW5nIGxldHRlciBpbiBDU1Ygcm93XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gREVCVUc6IExvZyBDU1Ygcm93IGRhdGEgZm9yIEcgcGljdG9ncmFwaHNcbiAgICAgIGlmIChsZXR0ZXIgPT09IFwiR1wiIHx8IGxldHRlciA9PT0gXCJnXCIpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflKcgW0cgREVCVUddIENTViByb3cgZGF0YTpgLCB7XG4gICAgICAgICAgbGV0dGVyOiByb3cubGV0dGVyLFxuICAgICAgICAgIGJsdWVTdGFydExvY2F0aW9uOiByb3cuYmx1ZVN0YXJ0TG9jYXRpb24gfHwgcm93LmJsdWVTdGFydExvYyxcbiAgICAgICAgICBibHVlRW5kTG9jYXRpb246IHJvdy5ibHVlRW5kTG9jYXRpb24gfHwgcm93LmJsdWVlbmRMb2NhdGlvbixcbiAgICAgICAgICByZWRTdGFydExvY2F0aW9uOiByb3cucmVkU3RhcnRMb2NhdGlvbiB8fCByb3cucmVkU3RhcnRMb2MsXG4gICAgICAgICAgcmVkRW5kTG9jYXRpb246IHJvdy5yZWRFbmRMb2NhdGlvbiB8fCByb3cucmVkZW5kTG9jYXRpb24sXG4gICAgICAgICAgZnVsbFJvdzogcm93LFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGJsdWUgbW90aW9uIGRhdGFcbiAgICAgIGNvbnN0IGJsdWVNb3Rpb24gPSBjcmVhdGVNb3Rpb25EYXRhKHtcbiAgICAgICAgbW90aW9uVHlwZTogdGhpcy5lbnVtTWFwcGluZ1NlcnZpY2UubWFwTW90aW9uVHlwZShyb3cuYmx1ZU1vdGlvblR5cGUpLFxuICAgICAgICByb3RhdGlvbkRpcmVjdGlvbjogdGhpcy5lbnVtTWFwcGluZ1NlcnZpY2UubWFwUm90YXRpb25EaXJlY3Rpb24oXG4gICAgICAgICAgcm93LmJsdWVSb3RhdGlvbkRpcmVjdGlvblxuICAgICAgICApLFxuICAgICAgICBzdGFydExvY2F0aW9uOiB0aGlzLmVudW1NYXBwaW5nU2VydmljZS5tYXBMb2NhdGlvbihcbiAgICAgICAgICByb3cuYmx1ZVN0YXJ0TG9jYXRpb24gfHwgcm93LmJsdWVTdGFydExvY1xuICAgICAgICApLFxuICAgICAgICBlbmRMb2NhdGlvbjogdGhpcy5lbnVtTWFwcGluZ1NlcnZpY2UubWFwTG9jYXRpb24oXG4gICAgICAgICAgcm93LmJsdWVFbmRMb2NhdGlvbiB8fCByb3cuYmx1ZWVuZExvY2F0aW9uXG4gICAgICAgICksXG4gICAgICAgIHR1cm5zOiAwLFxuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIGNvbG9yOiBNb3Rpb25Db2xvci5CTFVFLCAvLyDinIUgRXhwbGljaXRseSBzZXQgYmx1ZSBjb2xvclxuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSByZWQgbW90aW9uIGRhdGFcbiAgICAgIGNvbnN0IHJlZE1vdGlvbiA9IGNyZWF0ZU1vdGlvbkRhdGEoe1xuICAgICAgICBtb3Rpb25UeXBlOiB0aGlzLmVudW1NYXBwaW5nU2VydmljZS5tYXBNb3Rpb25UeXBlKHJvdy5yZWRNb3Rpb25UeXBlKSxcbiAgICAgICAgcm90YXRpb25EaXJlY3Rpb246IHRoaXMuZW51bU1hcHBpbmdTZXJ2aWNlLm1hcFJvdGF0aW9uRGlyZWN0aW9uKFxuICAgICAgICAgIHJvdy5yZWRSb3RhdGlvbkRpcmVjdGlvblxuICAgICAgICApLFxuICAgICAgICBzdGFydExvY2F0aW9uOiB0aGlzLmVudW1NYXBwaW5nU2VydmljZS5tYXBMb2NhdGlvbihcbiAgICAgICAgICByb3cucmVkU3RhcnRMb2NhdGlvbiB8fCByb3cucmVkU3RhcnRMb2NcbiAgICAgICAgKSxcbiAgICAgICAgZW5kTG9jYXRpb246IHRoaXMuZW51bU1hcHBpbmdTZXJ2aWNlLm1hcExvY2F0aW9uKFxuICAgICAgICAgIHJvdy5yZWRFbmRMb2NhdGlvbiB8fCByb3cucmVkZW5kTG9jYXRpb25cbiAgICAgICAgKSxcbiAgICAgICAgdHVybnM6IDAsXG4gICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgY29sb3I6IE1vdGlvbkNvbG9yLlJFRCwgLy8g4pyFIEV4cGxpY2l0bHkgc2V0IHJlZCBjb2xvclxuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBwcm9wcyBiYXNlZCBvbiBtb3Rpb24gZGF0YVxuICAgICAgY29uc3QgYmx1ZVByb3BzID0gdGhpcy5jcmVhdGVQcm9wRnJvbU1vdGlvbihibHVlTW90aW9uLCBNb3Rpb25Db2xvci5CTFVFKTtcbiAgICAgIGNvbnN0IHJlZFByb3BzID0gdGhpcy5jcmVhdGVQcm9wRnJvbU1vdGlvbihyZWRNb3Rpb24sIE1vdGlvbkNvbG9yLlJFRCk7XG5cbiAgICAgIC8vIENyZWF0ZSBwaWN0b2dyYXBoIGRhdGFcbiAgICAgIHJldHVybiBjcmVhdGVQaWN0b2dyYXBoRGF0YSh7XG4gICAgICAgIGxldHRlcixcbiAgICAgICAgbW90aW9uczoge1xuICAgICAgICAgIGJsdWU6IGJsdWVNb3Rpb24sXG4gICAgICAgICAgcmVkOiByZWRNb3Rpb24sXG4gICAgICAgIH0sXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgYmx1ZTogYmx1ZVByb3BzLFxuICAgICAgICAgIHJlZDogcmVkUHJvcHMsXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0UG9zaXRpb246IHRoaXMuZW51bU1hcHBpbmdTZXJ2aWNlLmNvbnZlcnRUb0dyaWRQb3NpdGlvbihcbiAgICAgICAgICByb3cuc3RhcnRQb3NpdGlvblxuICAgICAgICApLFxuICAgICAgICBlbmRQb3NpdGlvbjogdGhpcy5lbnVtTWFwcGluZ1NlcnZpY2UuY29udmVydFRvR3JpZFBvc2l0aW9uKFxuICAgICAgICAgIHJvdy5lbmRQb3NpdGlvblxuICAgICAgICApLFxuICAgICAgICBncmlkTW9kZTogZ3JpZE1vZGUsXG4gICAgICAgIGlzQmxhbms6IGZhbHNlLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHNvdXJjZTogXCJjc3ZfdHJhbnNmb3JtYXRpb25fc2VydmljZVwiLFxuICAgICAgICAgIGdyaWRNb2RlLFxuICAgICAgICAgIG9yaWdpbmFsUm93OiByb3csXG4gICAgICAgICAgbGV0dGVyVHlwZTogdGhpcy5lbnVtTWFwcGluZ1NlcnZpY2UuZ2V0TGV0dGVyVHlwZShsZXR0ZXIpLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBGYWlsZWQgdG8gY3JlYXRlIHBpY3RvZ3JhcGggZnJvbSBDU1Ygcm93OlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIFByb3BEYXRhIGZyb20gTW90aW9uRGF0YVxuICAgKiBUaGlzIGVuc3VyZXMgcHJvcHMgaGF2ZSB0aGUgY29ycmVjdCBsb2NhdGlvbiBhbmQgb3JpZW50YXRpb24gZnJvbSBtb3Rpb24gZGF0YVxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVQcm9wRnJvbU1vdGlvbihcbiAgICBtb3Rpb246IE1vdGlvbkRhdGEsXG4gICAgY29sb3I6IE1vdGlvbkNvbG9yXG4gICk6IFByb3BEYXRhIHtcbiAgICBjb25zb2xlLmxvZyhg8J+UpyBbREVCVUddIENyZWF0aW5nIHByb3AgZnJvbSBtb3Rpb24gZm9yICR7Y29sb3J9OmAsIHtcbiAgICAgIG1vdGlvbkRhdGE6IHtcbiAgICAgICAgc3RhcnRMb2NhdGlvbjogbW90aW9uLnN0YXJ0TG9jYXRpb24sXG4gICAgICAgIGVuZExvY2F0aW9uOiBtb3Rpb24uZW5kTG9jYXRpb24sXG4gICAgICAgIGVuZE9yaWVudGF0aW9uOiBtb3Rpb24uZW5kT3JpZW50YXRpb24sXG4gICAgICAgIHJvdGF0aW9uRGlyZWN0aW9uOiBtb3Rpb24ucm90YXRpb25EaXJlY3Rpb24sXG4gICAgICB9LFxuICAgICAgd2lsbENyZWF0ZVByb3BXaXRoOiB7XG4gICAgICAgIGxvY2F0aW9uOiBtb3Rpb24uZW5kTG9jYXRpb24sXG4gICAgICAgIG9yaWVudGF0aW9uOiBtb3Rpb24uZW5kT3JpZW50YXRpb24sXG4gICAgICAgIHJvdGF0aW9uRGlyZWN0aW9uOiBtb3Rpb24ucm90YXRpb25EaXJlY3Rpb24sXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgcHJvcERhdGEgPSBjcmVhdGVQcm9wRGF0YSh7XG4gICAgICBvcmllbnRhdGlvbjogbW90aW9uLmVuZE9yaWVudGF0aW9uLFxuICAgICAgcm90YXRpb25EaXJlY3Rpb246IG1vdGlvbi5yb3RhdGlvbkRpcmVjdGlvbixcbiAgICAgIHBsYWNlbWVudERhdGE6IGNyZWF0ZVByb3BQbGFjZW1lbnREYXRhKCksXG4gICAgICBpc1Zpc2libGU6IG1vdGlvbi5pc1Zpc2libGUsXG4gICAgfSk7XG5cbiAgICBjb25zb2xlLmxvZyhg8J+UpyBbREVCVUddIENyZWF0ZWQgcHJvcCByZXN1bHQ6YCwge1xuICAgICAgY29sb3I6IGNvbG9yLCAvLyDinIUgQ29sb3IgZnJvbSBwYXJhbWV0ZXIgKE1vdGlvbkNvbG9yLkJMVUUgb3IgTW90aW9uQ29sb3IuUkVEKVxuICAgICAgbG9jYXRpb246IG1vdGlvbi5lbmRMb2NhdGlvbiwgLy8gR2V0IGxvY2F0aW9uIGZyb20gbW90aW9uLmVuZExvY2F0aW9uXG4gICAgICBvcmllbnRhdGlvbjogcHJvcERhdGEub3JpZW50YXRpb24sXG4gICAgICByb3RhdGlvbkRpcmVjdGlvbjogcHJvcERhdGEucm90YXRpb25EaXJlY3Rpb24sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvcERhdGE7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgQ1NWIHJvdyBoYXMgcmVxdWlyZWQgZmllbGRzXG4gICAqL1xuICB2YWxpZGF0ZUNTVlJvdyhyb3c6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiB7XG4gICAgaXNWYWxpZDogYm9vbGVhbjtcbiAgICBlcnJvcnM6IHN0cmluZ1tdO1xuICB9IHtcbiAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgcmVxdWlyZWRGaWVsZHMgPSBbXG4gICAgICBcImxldHRlclwiLFxuICAgICAgXCJzdGFydFBvc2l0aW9uXCIsXG4gICAgICBcImVuZFBvc2l0aW9uXCIsXG4gICAgICBcImJsdWVNb3Rpb25UeXBlXCIsXG4gICAgICBcInJlZE1vdGlvblR5cGVcIixcbiAgICBdO1xuXG4gICAgLy8gQ2hlY2sgcmVxdWlyZWQgZmllbGRzXG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiByZXF1aXJlZEZpZWxkcykge1xuICAgICAgaWYgKCFyb3dbZmllbGRdIHx8IHJvd1tmaWVsZF0udHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGBNaXNzaW5nIHJlcXVpcmVkIGZpZWxkOiAke2ZpZWxkfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGxvY2F0aW9uIGZpZWxkcyAod2l0aCBmYWxsYmFja3MpXG4gICAgY29uc3QgYmx1ZVN0YXJ0TG9jID0gcm93LmJsdWVTdGFydExvY2F0aW9uIHx8IHJvdy5ibHVlU3RhcnRMb2M7XG4gICAgY29uc3QgYmx1ZUVuZExvYyA9IHJvdy5ibHVlRW5kTG9jYXRpb24gfHwgcm93LmJsdWVlbmRMb2NhdGlvbjtcbiAgICBjb25zdCByZWRTdGFydExvYyA9IHJvdy5yZWRTdGFydExvY2F0aW9uIHx8IHJvdy5yZWRTdGFydExvYztcbiAgICBjb25zdCByZWRFbmRMb2MgPSByb3cucmVkRW5kTG9jYXRpb24gfHwgcm93LnJlZGVuZExvY2F0aW9uO1xuXG4gICAgaWYgKCFibHVlU3RhcnRMb2MpIGVycm9ycy5wdXNoKFwiTWlzc2luZyBibHVlIHN0YXJ0IGxvY2F0aW9uXCIpO1xuICAgIGlmICghYmx1ZUVuZExvYykgZXJyb3JzLnB1c2goXCJNaXNzaW5nIGJsdWUgZW5kIGxvY2F0aW9uXCIpO1xuICAgIGlmICghcmVkU3RhcnRMb2MpIGVycm9ycy5wdXNoKFwiTWlzc2luZyByZWQgc3RhcnQgbG9jYXRpb25cIik7XG4gICAgaWYgKCFyZWRFbmRMb2MpIGVycm9ycy5wdXNoKFwiTWlzc2luZyByZWQgZW5kIGxvY2F0aW9uXCIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgICBlcnJvcnMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXRjaCBjb252ZXJ0IG11bHRpcGxlIENTViByb3dzIHRvIFBpY3RvZ3JhcGhEYXRhXG4gICAqL1xuICBjb252ZXJ0TXVsdGlwbGVSb3dzKFxuICAgIHJvd3M6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5bXSxcbiAgICBncmlkTW9kZTogc3RyaW5nXG4gICk6IHtcbiAgICBzdWNjZXNzZnVsOiBQaWN0b2dyYXBoRGF0YVtdO1xuICAgIGZhaWxlZDogQXJyYXk8e1xuICAgICAgaW5kZXg6IG51bWJlcjtcbiAgICAgIHJvdzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICAgIGVycm9yOiBzdHJpbmc7XG4gICAgfT47XG4gIH0ge1xuICAgIGNvbnN0IHN1Y2Nlc3NmdWw6IFBpY3RvZ3JhcGhEYXRhW10gPSBbXTtcbiAgICBjb25zdCBmYWlsZWQ6IEFycmF5PHtcbiAgICAgIGluZGV4OiBudW1iZXI7XG4gICAgICByb3c6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgICBlcnJvcjogc3RyaW5nO1xuICAgIH0+ID0gW107XG5cbiAgICByb3dzLmZvckVhY2goKHJvdywgaW5kZXgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBpY3RvZ3JhcGggPSB0aGlzLmNvbnZlcnRDc3ZSb3dUb1BpY3RvZ3JhcGhEYXRhKFxuICAgICAgICAgIHJvdyxcbiAgICAgICAgICBncmlkTW9kZSxcbiAgICAgICAgICBpbmRleFxuICAgICAgICApO1xuICAgICAgICBpZiAocGljdG9ncmFwaCkge1xuICAgICAgICAgIHN1Y2Nlc3NmdWwucHVzaChwaWN0b2dyYXBoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmYWlsZWQucHVzaCh7XG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgIGVycm9yOiBcIkNvbnZlcnNpb24gcmV0dXJuZWQgbnVsbFwiLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBmYWlsZWQucHVzaCh7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcm93LFxuICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7IHN1Y2Nlc3NmdWwsIGZhaWxlZCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0cmFuc2Zvcm1hdGlvbiBzdGF0aXN0aWNzIGZvciBkZWJ1Z2dpbmdcbiAgICovXG4gIGdldFRyYW5zZm9ybWF0aW9uU3RhdHMoXG4gICAgcm93czogUmVjb3JkPHN0cmluZywgc3RyaW5nPltdLFxuICAgIF9ncmlkTW9kZTogc3RyaW5nXG4gICk6IHtcbiAgICB0b3RhbFJvd3M6IG51bWJlcjtcbiAgICB2YWxpZFJvd3M6IG51bWJlcjtcbiAgICBpbnZhbGlkUm93czogbnVtYmVyO1xuICAgIHZhbGlkYXRpb25FcnJvcnM6IEFycmF5PHsgaW5kZXg6IG51bWJlcjsgZXJyb3JzOiBzdHJpbmdbXSB9PjtcbiAgfSB7XG4gICAgY29uc3Qgc3RhdHMgPSB7XG4gICAgICB0b3RhbFJvd3M6IHJvd3MubGVuZ3RoLFxuICAgICAgdmFsaWRSb3dzOiAwLFxuICAgICAgaW52YWxpZFJvd3M6IDAsXG4gICAgICB2YWxpZGF0aW9uRXJyb3JzOiBbXSBhcyBBcnJheTx7IGluZGV4OiBudW1iZXI7IGVycm9yczogc3RyaW5nW10gfT4sXG4gICAgfTtcblxuICAgIHJvd3MuZm9yRWFjaCgocm93LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVDU1ZSb3cocm93KTtcbiAgICAgIGlmICh2YWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgc3RhdHMudmFsaWRSb3dzKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0cy5pbnZhbGlkUm93cysrO1xuICAgICAgICBzdGF0cy52YWxpZGF0aW9uRXJyb3JzLnB1c2goe1xuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIGVycm9yczogdmFsaWRhdGlvbi5lcnJvcnMsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0YXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBwaWN0b2dyYXBoIHdpdGggY3VzdG9tIG1ldGFkYXRhXG4gICAqL1xuICBjcmVhdGVQaWN0b2dyYXBoV2l0aE1ldGFkYXRhKFxuICAgIHJvdzogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgICBncmlkTW9kZTogc3RyaW5nLFxuICAgIGFkZGl0aW9uYWxNZXRhZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fVxuICApOiBQaWN0b2dyYXBoRGF0YSB8IG51bGwge1xuICAgIGNvbnN0IHBpY3RvZ3JhcGggPSB0aGlzLmNyZWF0ZVBpY3RvZ3JhcGhGcm9tQ1NWUm93KHJvdywgZ3JpZE1vZGUpO1xuXG4gICAgaWYgKCFwaWN0b2dyYXBoKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5waWN0b2dyYXBoLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgLi4ucGljdG9ncmFwaC5tZXRhZGF0YSxcbiAgICAgICAgLi4uYWRkaXRpb25hbE1ldGFkYXRhLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiQUFRQSxTQUFTLDRCQUE0QjtBQUVyQyxTQUFTLHNCQUFzQjtBQUMvQixTQUFTLCtCQUErQjtBQUV4QyxTQUFTLDhCQUE4QjtBQUN2QyxTQUFTLG1CQUFtQjtBQUM1QixTQUFTLHdCQUF3QjtBQXFCMUIsYUFBTSxnQ0FFYjtBQUFBLEVBQ0UsWUFBb0Isb0JBQXlDO0FBQXpDO0FBQUEsRUFBMEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUs5RCw4QkFDRSxLQUNBLFVBQ0EsT0FDdUI7QUFDdkIsUUFBSTtBQUVGLFlBQU0sYUFBYSxHQUFHLElBQUksVUFBVSxTQUFTLElBQUksU0FBUyxLQUFLLElBQUksQ0FBQztBQUNwRSw2QkFBdUIsV0FBVyxVQUFVO0FBQzVDLDZCQUF1Qixh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
