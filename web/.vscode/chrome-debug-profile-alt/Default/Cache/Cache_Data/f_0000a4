import { createHotContext as __vite__createHotContext } from "/@vite/client";import.meta.hot = __vite__createHotContext("/src/lib/components/pictograph/TKAGlyph.svelte");import "/node_modules/.vite/deps/svelte_internal_disclose-version.js?v=474c1bba";

TKAGlyph[$.FILENAME] = 'src/lib/components/pictograph/TKAGlyph.svelte';

import * as $ from "/node_modules/.vite/deps/svelte_internal_client.js?v=474c1bba";
import { getLetterImagePath } from "/src/lib/utils/letter-type-classification.ts";
import { MotionColor } from "/src/lib/domain/enums.ts";

var root_3 = $.add_locations($.from_svg(`<circle r="12" stroke="white" stroke-width="2" opacity="0.9" class="s-X_6UOtCCgcv0"></circle><text text-anchor="middle" dominant-baseline="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="white" class="s-X_6UOtCCgcv0"> </text>`, 1), TKAGlyph[$.FILENAME], [[161, 10], [172, 10]]);
var root_2 = $.add_locations($.from_svg(`<g class="turn-indicators s-X_6UOtCCgcv0"></g>`), TKAGlyph[$.FILENAME], [[158, 6]]);
var root_4 = $.add_locations($.from_svg(`<text x="0" text-anchor="middle" font-family="Arial, sans-serif" font-weight="normal" fill="#6b7280" opacity="0.8" class="s-X_6UOtCCgcv0"> </text>`), TKAGlyph[$.FILENAME], [[190, 6]]);
var root_1 = $.add_locations($.from_svg(`<g class="tka-glyph s-X_6UOtCCgcv0"><image x="0" y="0" preserveAspectRatio="xMinYMin meet" class="letter-image s-X_6UOtCCgcv0"></image><!><!></g>`), TKAGlyph[$.FILENAME], [[139, 2, [[146, 4]]]]);

function TKAGlyph($$anchor, $$props) {
	$.check_target(new.target);
	$.push($$props, true, TKAGlyph);

	let x = $.prop($$props, 'x', 3, 50),
		// Match legacy positioning exactly
		y = $.prop($$props, 'y', 3, 800),
		// Match legacy positioning exactly
		turnsTuple = $.prop($$props, 'turnsTuple', 3, "(s, 0, 0)"),
		// color = '#4b5563',
		scale = $.prop($$props, 'scale', 3, 1);

	// Match legacy default scale
	const fontSize = 16;

	let letterDimensions = $.tag($.state($.proxy({ width: 0, height: 0 })), 'letterDimensions');
	let isLetterLoaded = $.tag($.state(false), 'isLetterLoaded');
	const dimensionsCache = /* @__PURE__ */ new Map();

	async function loadLetterDimensions(currentLetter) {
		if (!currentLetter) return;

		const cacheKey = currentLetter;

		if (dimensionsCache.has(cacheKey)) {
			$.set(letterDimensions, dimensionsCache.get(cacheKey), true);
			$.set(isLetterLoaded, true);

			return;
		}

		try {
			const svgPath = getLetterImagePath(currentLetter);
			const response = (await $.track_reactivity_loss(fetch(svgPath)))();

			if (!response.ok) throw new Error(`Failed to fetch ${svgPath}: ${response.status}`);

			const svgText = (await $.track_reactivity_loss(response.text()))();
			const viewBoxMatch = svgText.match(/viewBox\s*=\s*"[\d.-]+\s+[\d.-]+\s+([\d.-]+)\s+([\d.-]+)"/i);

			if (!viewBoxMatch) {
				console.warn(`SVG at ${svgPath} has no valid viewBox, using defaults`);
				$.set(letterDimensions, { width: 100, height: 100 }, true);
			} else {
				$.set(
					letterDimensions,
					{
						width: parseFloat(viewBoxMatch[1] || "100"),
						height: parseFloat(viewBoxMatch[2] || "100")
					},
					true
				);
			}

			dimensionsCache.set(cacheKey, $.get(letterDimensions));
			$.set(isLetterLoaded, true);
		} catch(error) {
			console.error(...$.log_if_contains_state('error', `Failed to load letter dimensions for ${currentLetter}:`, error));
			$.set(letterDimensions, { width: 50, height: 50 }, true);
			$.set(isLetterLoaded, true);
		}
	}

	$.user_effect(() => {
		if ($$props.letter) {
			$.set(isLetterLoaded, false);
			loadLetterDimensions($$props.letter);
		}
	});

	const hasLetter = $.tag(
		$.derived(() => () => {
			return $.equals($$props.letter, null, false) && $.strict_equals($$props.letter.trim(), "", false);
		}),
		'hasLetter'
	);

	const parsedTurns = $.tag(
		$.derived(() => () => {
			if (!turnsTuple()) return { timing: "s", blue: 0, red: 0 };

			try {
				const cleaned = turnsTuple().replace(/[()]/g, "").trim();
				const parts = cleaned.split(",").map((s) => s.trim());

				if ($.strict_equals(parts.length, 3, false)) {
					return { timing: "s", blue: 0, red: 0 };
				}

				return {
					timing: parts[0] || "",
					blue: parseFloat(parts[1] || "0") || 0,
					red: parseFloat(parts[2] || "0") || 0
				};
			} catch(error) {
				return { timing: "s", blue: 0, red: 0 };
			}
		}),
		'parsedTurns'
	);

	const showTurns = $.tag(
		$.derived(() => () => {
			return false;
		}),
		'showTurns'
	);

	const turnDisplays = $.tag(
		$.derived(() => () => {
			const turns = $.get(parsedTurns)();
			const displays = [];

			if ($.strict_equals(turns.blue, 0, false)) {
				displays.push({
					color: MotionColor.BLUE,
					value: turns.blue,
					displayText: formatTurnValue(turns.blue)
				});
			}

			if ($.strict_equals(turns.red, 0, false)) {
				displays.push({
					color: MotionColor.RED,
					value: turns.red,
					displayText: formatTurnValue(turns.red)
				});
			}

			return displays;
		}),
		'turnDisplays'
	);

	function formatTurnValue(value) {
		if ($.strict_equals(value, 0)) return "";
		if ($.strict_equals(value % 1, 0)) return value.toString();

		return value.toFixed(1);
	}

	function getTurnColor(color) {
		switch (color) {
			case "blue":
				return "#3b82f6";

			case "red":
				return "#ef4444";

			default:
				return "#6b7280";
		}
	}

	const turnPositions = $.tag(
		$.derived(() => () => {
			const displays = $.get(turnDisplays)();
			const spacing = 40;
			const startX = x() - (displays.length - 1) * spacing / 2;

			return displays.map((display, index) => ({ ...display, x: startX + index * spacing, y: y() + 30

			// Below the letter
			 }));
		}),
		'turnPositions'
	);

	var fragment = $.comment();
	var node = $.first_child(fragment);

	{
		var consequent_2 = ($$anchor) => {
			var g = root_1();
			var image = $.child(g);
			var node_1 = $.sibling(image);

			{
				var consequent = ($$anchor) => {
					var g_1 = root_2();

					$.validate_each_keys(() => $.get(turnPositions)(), (turn) => turn.color);

					$.add_svelte_meta(
						() => $.each(g_1, 21, () => $.get(turnPositions)(), (turn) => turn.color, ($$anchor, turn) => {
							var fragment_1 = root_3();
							var circle = $.first_child(fragment_1);
							var text = $.sibling(circle);
							var text_1 = $.child(text, true);

							$.reset(text);

							$.template_effect(
								($0) => {
									$.set_attribute(circle, 'cx', $.get(turn).x);
									$.set_attribute(circle, 'cy', $.get(turn).y);
									$.set_attribute(circle, 'fill', $0);
									$.set_attribute(text, 'x', $.get(turn).x);
									$.set_attribute(text, 'y', $.get(turn).y);
									$.set_text(text_1, $.get(turn).displayText);
								},
								[() => getTurnColor($.get(turn).color)]
							);

							$.append($$anchor, fragment_1);
						}),
						'each',
						TKAGlyph,
						159,
						8
					);

					$.reset(g_1);
					$.append($$anchor, g_1);
				};

				$.add_svelte_meta(
					() => $.if(node_1, ($$render) => {
						if ($.get(showTurns)()) $$render(consequent);
					}),
					'if',
					TKAGlyph,
					157,
					4
				);
			}

			var node_2 = $.sibling(node_1);

			{
				var consequent_1 = ($$anchor) => {
					var text_2 = root_4();

					$.set_attribute(text_2, 'y', -fontSize - 10);
					$.set_attribute(text_2, 'font-size', fontSize * 0.6);

					var text_3 = $.child(text_2, true);

					$.reset(text_2);
					$.template_effect(($0) => $.set_text(text_3, $0), [() => $.get(parsedTurns)()?.timing?.toUpperCase() || ""]);
					$.append($$anchor, text_2);
				};

				$.add_svelte_meta(
					() => $.if(node_2, ($$render) => {
						if ($.strict_equals($.get(parsedTurns)().timing, "s", false)) $$render(consequent_1);
					}),
					'if',
					TKAGlyph,
					189,
					4
				);
			}

			$.reset(g);

			$.template_effect(
				($0) => {
					$.set_attribute(g, 'data-letter', $$props.letter);
					$.set_attribute(g, 'data-turns', turnsTuple());
					$.set_attribute(g, 'transform', `translate(${x() ?? ''}, ${y() ?? ''}) scale(${scale() ?? ''})`);
					$.set_attribute(image, 'href', $0);
					$.set_attribute(image, 'width', $.get(letterDimensions).width);
					$.set_attribute(image, 'height', $.get(letterDimensions).height);
				},
				[
					() => $$props.letter ? getLetterImagePath($$props.letter) : ""
				]
			);

			$.append($$anchor, g);
		};

		$.add_svelte_meta(
			() => $.if(node, ($$render) => {
				if ($.get(hasLetter)() && $.get(isLetterLoaded)) $$render(consequent_2);
			}),
			'if',
			TKAGlyph,
			138,
			0
		);
	}

	$.append($$anchor, fragment);

	return $.pop({ ...$.legacy_api() });
}

if (import.meta.hot) {
	TKAGlyph = $.hmr(TKAGlyph, () => TKAGlyph[$.HMR].source);

	import.meta.hot.acceptExports(["default"],(module) => {
		$.cleanup_styles('s-X_6UOtCCgcv0');
		module.default[$.HMR].source = TKAGlyph[$.HMR].source;
		$.set(TKAGlyph[$.HMR].source, module.default[$.HMR].original);
	});
}

export default TKAGlyph;
import "/src/lib/components/pictograph/TKAGlyph.svelte?svelte&type=style&lang.css";

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6Ijs7Ozs7U0FRVywwQkFBbUI7U0FpQnhCOzs7Ozs7O3FDQXpCTixDQUFDOzs7O0tBbURLOztFQUNBOztFQUNBOztFQUdGLG9DQUFJOzs7T0FLQSxXQUFVOztLQUlWO0tBQ0Y7T0FJRSxzQ0FBcUI7O2dCQUdaLHFCQUFXLGVBQXdCO09BQzFDOztRQUlKLFdBQWdCOztNQUNoQixnQkFBaUI7U0FDbkIsa0JBQWdCO1NBQ2QsZ0JBQVE7OztFQUMrQzs7TUFJdkQ7U0FFRjtTQUNGOztRQUdRLFNBQU0sY0FDQTs7U0FFVix5Q0FBcUIsU0FBTTtTQUM3Qiw2QkFDRDs7UUFLQTtJQUdLLHVCQUF1QixPQUFNO1VBQzVCLG9CQUFxQixPQUFRLEtBQUssUUFBTTtHQUV6Qzs7S0FFRjs7TUFDTSxrQkFBZ0IsYUFBZSxDQUFDLFVBQVE7TUFFMUMsUUFBTSxXQUFjOzs7O0dBRXhCOztHQUdFLGdCQUFlLElBQUs7U0FDcEIsZ0JBQWlCO0VBQW9CLFFBQ2hDO0dBQ1AsMEZBQ2Msa0JBQ2Q7U0FNRSxvQkFBcUIsT0FBTTtTQUcvQixnQkFBTztFQUNSO0NBR0Q7O0NBSUUsb0JBQVU7c0JBQ0M7U0FDUCxnQkFBTztHQUNQO0VBQWE7Q0FDMEI7O09BS3pDO3dCQUFjO21DQUNMLCtDQUFZO0VBQUE7Ozs7T0FJdkI7d0JBQUE7UUFFTzs7T0FJVDtVQUVNLFVBQWlCLGFBQU8sUUFBTSxTQUFTO1VBQ3BDLFFBQU0sUUFBUzs7d0JBSWYsY0FBYSxXQUF1QjtjQUM1QjtJQUNiOzs7S0FHRSxRQUFPO0tBQ1Q7S0FDRSxLQUFPOztHQUViO2FBR00sUUFBZ0IsV0FBUyxHQUFNO0dBQ25DO0VBQ0E7Ozs7T0FLSzt3QkFBaUI7VUFFcEI7RUFDSDs7OztPQUdLO3dCQUFlO1NBQ2xCLGNBQWE7U0FDZjs7dUJBRUssTUFBQyxNQUFjO0lBQ25CLFNBQVc7S0FDWCxPQUFXLFlBQVk7S0FDekI7S0FDTSxhQUFhLGdCQUFXLE1BQU87O0dBRXZDOzt1QkFFTSxNQUFNLEtBQVM7SUFDZixTQUFPO0tBQ1AsT0FBUTtLQUNSO0tBQ0EsYUFBYyxnQkFBSzs7OztVQUloQjtFQUNUOzs7O1VBR1c7c0JBQ1gsT0FBZ0IsV0FBTTtzQkFDdEIsUUFBZ0IsR0FBTTs7U0FDdEIsTUFBaUI7Q0FDakI7O1VBR0EsYUFBd0I7VUFDYjs7V0FFSTs7UUFDSjtXQUNJOzs7V0FFSDs7Q0FFWjs7T0FHQTt3QkFBdUI7U0FDYjtTQUNWLFVBQWtCO1NBQ1IsU0FBTTs7VUFFUCx1Q0FDRCxzQ0FFRixHQUFHOzs7O0VBRVQ7Ozs7Ozs7Ozs7Ozs7Ozs7O3NDQXlCRTs7O3dDQUFBOzs7Ozs7Ozs7OzZDQUdjLElBQUksRUFBQyxDQUFDOzZDQUNwQjs7Ozs7O2VBRWdCLFlBQVEsT0FBSyxJQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztnQkFSekIsU0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0NBZkUsVUFBSTtrREFDZDs7MkNBT0E7NENBQ087Ozs7Ozs7Ozs7OztjQWJiLFNBQWEsYUFBTyxjQUFhOzs7Ozs7Ozs7Ozs7Q0FIakMiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIlRLQUdseXBoLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8IS0tXG5US0FHbHlwaC5zdmVsdGUgLSBNb2Rlcm4gUnVuZS1CYXNlZCBUS0EgR2x5cGggQ29tcG9uZW50XG5cblJlbmRlcnMgbGV0dGVycywgdHVybiBpbmRpY2F0b3JzLCBhbmQgb3RoZXIgVEtBIG5vdGF0aW9uIGVsZW1lbnRzLlxuVXNlcyBwdXJlIHJ1bmVzIGluc3RlYWQgb2Ygc3RvcmVzIGZvciByZWFjdGl2aXR5LlxuLS0+XG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICBpbXBvcnQgeyBnZXRMZXR0ZXJJbWFnZVBhdGggfSBmcm9tIFwiJGxpYi91dGlscy9sZXR0ZXItdHlwZS1jbGFzc2lmaWNhdGlvblwiO1xuICBpbXBvcnQgeyBNb3Rpb25Db2xvciB9IGZyb20gXCIkbGliL2RvbWFpbi9lbnVtc1wiO1xuXG4gIGludGVyZmFjZSBQcm9wcyB7XG4gICAgLyoqIFRoZSBsZXR0ZXIgdG8gZGlzcGxheSAqL1xuICAgIGxldHRlcjogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgICAvKiogUG9zaXRpb24gWCBjb29yZGluYXRlICovXG4gICAgeD86IG51bWJlcjtcbiAgICAvKiogUG9zaXRpb24gWSBjb29yZGluYXRlICovXG4gICAgeT86IG51bWJlcjtcbiAgICAvKiogVHVybnMgdHVwbGUgaW4gZm9ybWF0IFwiKHMsIDAsIDApXCIgKi9cbiAgICB0dXJuc1R1cGxlPzogc3RyaW5nO1xuICAgIC8qKiBUZXh0IGNvbG9yICovXG4gICAgY29sb3I/OiBzdHJpbmc7XG4gICAgLyoqIFNjYWxlIGZhY3RvciAtIG1hdGNoIGxlZ2FjeSBiZWhhdmlvciAqL1xuICAgIHNjYWxlPzogbnVtYmVyO1xuICB9XG5cbiAgbGV0IHtcbiAgICBsZXR0ZXIsXG4gICAgeCA9IDUwLCAvLyBNYXRjaCBsZWdhY3kgcG9zaXRpb25pbmcgZXhhY3RseVxuICAgIHkgPSA4MDAsIC8vIE1hdGNoIGxlZ2FjeSBwb3NpdGlvbmluZyBleGFjdGx5XG4gICAgdHVybnNUdXBsZSA9IFwiKHMsIDAsIDApXCIsXG4gICAgLy8gY29sb3IgPSAnIzRiNTU2MycsXG4gICAgc2NhbGUgPSAxLCAvLyBNYXRjaCBsZWdhY3kgZGVmYXVsdCBzY2FsZVxuICB9OiBQcm9wcyA9ICRwcm9wcygpO1xuXG4gIC8vIEZvbnQgc2l6ZSBmb3IgdGltaW5nIGluZGljYXRvcnNcbiAgY29uc3QgZm9udFNpemUgPSAxNjtcblxuICAvLyBMZXR0ZXIgZGltZW5zaW9ucyBzdGF0ZSAtIG1hdGNoIGxlZ2FjeSBiZWhhdmlvclxuICBsZXQgbGV0dGVyRGltZW5zaW9ucyA9ICRzdGF0ZSh7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG4gIGxldCBpc0xldHRlckxvYWRlZCA9ICRzdGF0ZShmYWxzZSk7XG5cbiAgLy8gQ2FjaGUgZm9yIFNWRyBkaW1lbnNpb25zIChzaW1wbGUgaW4tbWVtb3J5IGNhY2hlKVxuICBjb25zdCBkaW1lbnNpb25zQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9PigpO1xuXG4gIC8vIExvYWQgbGV0dGVyIGRpbWVuc2lvbnMgdXNpbmcgU1ZHIHZpZXdCb3ggbGlrZSBsZWdhY3kgdmVyc2lvblxuICBhc3luYyBmdW5jdGlvbiBsb2FkTGV0dGVyRGltZW5zaW9ucyhjdXJyZW50TGV0dGVyOiBzdHJpbmcpIHtcbiAgICBpZiAoIWN1cnJlbnRMZXR0ZXIpIHJldHVybjtcblxuICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0XG4gICAgY29uc3QgY2FjaGVLZXkgPSBjdXJyZW50TGV0dGVyO1xuICAgIGlmIChkaW1lbnNpb25zQ2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgbGV0dGVyRGltZW5zaW9ucyA9IGRpbWVuc2lvbnNDYWNoZS5nZXQoY2FjaGVLZXkpITtcbiAgICAgIGlzTGV0dGVyTG9hZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gVXNlIGNvcnJlY3QgcGF0aCBiYXNlZCBvbiBsZXR0ZXIgdHlwZSBhbmQgc2FmZSBmaWxlbmFtZVxuICAgICAgY29uc3Qgc3ZnUGF0aCA9IGdldExldHRlckltYWdlUGF0aChjdXJyZW50TGV0dGVyKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goc3ZnUGF0aCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke3N2Z1BhdGh9OiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcblxuICAgICAgY29uc3Qgc3ZnVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGNvbnN0IHZpZXdCb3hNYXRjaCA9IHN2Z1RleHQubWF0Y2goXG4gICAgICAgIC92aWV3Qm94XFxzKj1cXHMqXCJbXFxkLi1dK1xccytbXFxkLi1dK1xccysoW1xcZC4tXSspXFxzKyhbXFxkLi1dKylcIi9pXG4gICAgICApO1xuXG4gICAgICBpZiAoIXZpZXdCb3hNYXRjaCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFNWRyBhdCAke3N2Z1BhdGh9IGhhcyBubyB2YWxpZCB2aWV3Qm94LCB1c2luZyBkZWZhdWx0c2ApO1xuICAgICAgICBsZXR0ZXJEaW1lbnNpb25zID0geyB3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMCB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0dGVyRGltZW5zaW9ucyA9IHtcbiAgICAgICAgICB3aWR0aDogcGFyc2VGbG9hdCh2aWV3Qm94TWF0Y2hbMV0gfHwgXCIxMDBcIiksXG4gICAgICAgICAgaGVpZ2h0OiBwYXJzZUZsb2F0KHZpZXdCb3hNYXRjaFsyXSB8fCBcIjEwMFwiKSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZGltZW5zaW9uc0NhY2hlLnNldChjYWNoZUtleSwgbGV0dGVyRGltZW5zaW9ucyk7XG4gICAgICBpc0xldHRlckxvYWRlZCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gbG9hZCBsZXR0ZXIgZGltZW5zaW9ucyBmb3IgJHtjdXJyZW50TGV0dGVyfTpgLFxuICAgICAgICBlcnJvclxuICAgICAgKTtcbiAgICAgIC8vIEZhbGxiYWNrIGRpbWVuc2lvbnNcbiAgICAgIGxldHRlckRpbWVuc2lvbnMgPSB7IHdpZHRoOiA1MCwgaGVpZ2h0OiA1MCB9O1xuICAgICAgaXNMZXR0ZXJMb2FkZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIExvYWQgZGltZW5zaW9ucyB3aGVuIGxldHRlciBjaGFuZ2VzXG4gICRlZmZlY3QoKCkgPT4ge1xuICAgIGlmIChsZXR0ZXIpIHtcbiAgICAgIGlzTGV0dGVyTG9hZGVkID0gZmFsc2U7XG4gICAgICBsb2FkTGV0dGVyRGltZW5zaW9ucyhsZXR0ZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gRGVyaXZlZCBzdGF0ZSAtIGNoZWNrIGlmIHdlIGhhdmUgYSB2YWxpZCBsZXR0ZXJcbiAgY29uc3QgaGFzTGV0dGVyID0gJGRlcml2ZWQoKCkgPT4ge1xuICAgIHJldHVybiBsZXR0ZXIgIT0gbnVsbCAmJiBsZXR0ZXIudHJpbSgpICE9PSBcIlwiO1xuICB9KTtcblxuICAvLyBEZXJpdmVkIHN0YXRlIC0gcGFyc2UgdHVybnMgdHVwbGVcbiAgY29uc3QgcGFyc2VkVHVybnMgPSAkZGVyaXZlZCgoKSA9PiB7XG4gICAgaWYgKCF0dXJuc1R1cGxlKSByZXR1cm4geyB0aW1pbmc6IFwic1wiLCBibHVlOiAwLCByZWQ6IDAgfTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBSZW1vdmUgcGFyZW50aGVzZXMgYW5kIHNwbGl0IGJ5IGNvbW1hXG4gICAgICBjb25zdCBjbGVhbmVkID0gdHVybnNUdXBsZS5yZXBsYWNlKC9bKCldL2csIFwiXCIpLnRyaW0oKTtcbiAgICAgIGNvbnN0IHBhcnRzID0gY2xlYW5lZC5zcGxpdChcIixcIikubWFwKChzKSA9PiBzLnRyaW0oKSk7XG5cbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgcmV0dXJuIHsgdGltaW5nOiBcInNcIiwgYmx1ZTogMCwgcmVkOiAwIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRpbWluZzogcGFydHNbMF0gfHwgXCJcIixcbiAgICAgICAgYmx1ZTogcGFyc2VGbG9hdChwYXJ0c1sxXSB8fCBcIjBcIikgfHwgMCxcbiAgICAgICAgcmVkOiBwYXJzZUZsb2F0KHBhcnRzWzJdIHx8IFwiMFwiKSB8fCAwLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHsgdGltaW5nOiBcInNcIiwgYmx1ZTogMCwgcmVkOiAwIH07XG4gICAgfVxuICB9KTtcblxuICAvLyBEZXJpdmVkIHN0YXRlIC0gY2hlY2sgaWYgd2Ugc2hvdWxkIHNob3cgdHVybiBpbmRpY2F0b3JzXG4gIC8vIFRFTVBPUkFSSUxZIERJU0FCTEVEOiBUdXJuIGluZGljYXRvcnMgd2VyZSBjcmVhdGluZyBDSVJDTEVfUFJPUCBkdXBsaWNhdGVzIGluIGNvbXBhcmlzb24gdGVzdHNcbiAgY29uc3Qgc2hvd1R1cm5zID0gJGRlcml2ZWQoKCkgPT4ge1xuICAgIC8vIGNvbnN0IHR1cm5zID0gcGFyc2VkVHVybnMoKTtcbiAgICAvLyByZXR1cm4gdHVybnMuYmx1ZSAhPT0gMCB8fCB0dXJucy5yZWQgIT09IDA7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBEaXNhYmxlIHR1cm4gaW5kaWNhdG9ycyB0byBwcmV2ZW50IENJUkNMRV9QUk9QIGR1cGxpY2F0ZXNcbiAgfSk7XG5cbiAgLy8gRGVyaXZlZCBzdGF0ZSAtIGZvcm1hdCB0dXJuIGRpc3BsYXlzXG4gIGNvbnN0IHR1cm5EaXNwbGF5cyA9ICRkZXJpdmVkKCgpID0+IHtcbiAgICBjb25zdCB0dXJucyA9IHBhcnNlZFR1cm5zKCk7XG4gICAgY29uc3QgZGlzcGxheXMgPSBbXTtcblxuICAgIGlmICh0dXJucy5ibHVlICE9PSAwKSB7XG4gICAgICBkaXNwbGF5cy5wdXNoKHtcbiAgICAgICAgY29sb3I6IE1vdGlvbkNvbG9yLkJMVUUsXG4gICAgICAgIHZhbHVlOiB0dXJucy5ibHVlLFxuICAgICAgICBkaXNwbGF5VGV4dDogZm9ybWF0VHVyblZhbHVlKHR1cm5zLmJsdWUpLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR1cm5zLnJlZCAhPT0gMCkge1xuICAgICAgZGlzcGxheXMucHVzaCh7XG4gICAgICAgIGNvbG9yOiBNb3Rpb25Db2xvci5SRUQsXG4gICAgICAgIHZhbHVlOiB0dXJucy5yZWQsXG4gICAgICAgIGRpc3BsYXlUZXh0OiBmb3JtYXRUdXJuVmFsdWUodHVybnMucmVkKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBkaXNwbGF5cztcbiAgfSk7XG5cbiAgLy8gRm9ybWF0IHR1cm4gdmFsdWUgZm9yIGRpc3BsYXlcbiAgZnVuY3Rpb24gZm9ybWF0VHVyblZhbHVlKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGlmICh2YWx1ZSA9PT0gMCkgcmV0dXJuIFwiXCI7XG4gICAgaWYgKHZhbHVlICUgMSA9PT0gMCkgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7IC8vIFdob2xlIG51bWJlclxuICAgIHJldHVybiB2YWx1ZS50b0ZpeGVkKDEpOyAvLyBEZWNpbWFsXG4gIH1cblxuICAvLyBHZXQgY29sb3IgZm9yIHR1cm4gaW5kaWNhdG9yc1xuICBmdW5jdGlvbiBnZXRUdXJuQ29sb3IoY29sb3I6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgc3dpdGNoIChjb2xvcikge1xuICAgICAgY2FzZSBcImJsdWVcIjpcbiAgICAgICAgcmV0dXJuIFwiIzNiODJmNlwiO1xuICAgICAgY2FzZSBcInJlZFwiOlxuICAgICAgICByZXR1cm4gXCIjZWY0NDQ0XCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCIjNmI3MjgwXCI7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9ucyBmb3IgdHVybiBpbmRpY2F0b3JzXG4gIGNvbnN0IHR1cm5Qb3NpdGlvbnMgPSAkZGVyaXZlZCgoKSA9PiB7XG4gICAgY29uc3QgZGlzcGxheXMgPSB0dXJuRGlzcGxheXMoKTtcbiAgICBjb25zdCBzcGFjaW5nID0gNDA7XG4gICAgY29uc3Qgc3RhcnRYID0geCAtICgoZGlzcGxheXMubGVuZ3RoIC0gMSkgKiBzcGFjaW5nKSAvIDI7XG5cbiAgICByZXR1cm4gZGlzcGxheXMubWFwKChkaXNwbGF5LCBpbmRleCkgPT4gKHtcbiAgICAgIC4uLmRpc3BsYXksXG4gICAgICB4OiBzdGFydFggKyBpbmRleCAqIHNwYWNpbmcsXG4gICAgICB5OiB5ICsgMzAsIC8vIEJlbG93IHRoZSBsZXR0ZXJcbiAgICB9KSk7XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjwhLS0gVEtBIEdseXBoIEdyb3VwIC0tPlxueyNpZiBoYXNMZXR0ZXIoKSAmJiBpc0xldHRlckxvYWRlZH1cbiAgPGdcbiAgICBjbGFzcz1cInRrYS1nbHlwaFwiXG4gICAgZGF0YS1sZXR0ZXI9e2xldHRlcn1cbiAgICBkYXRhLXR1cm5zPXt0dXJuc1R1cGxlfVxuICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSh7eH0sIHt5fSkgc2NhbGUoe3NjYWxlfSlcIlxuICA+XG4gICAgPCEtLSBNYWluIGxldHRlciB3aXRoIGV4YWN0IGxlZ2FjeSBkaW1lbnNpb25zIC0tPlxuICAgIDxpbWFnZVxuICAgICAgeD1cIjBcIlxuICAgICAgeT1cIjBcIlxuICAgICAgaHJlZj17bGV0dGVyID8gZ2V0TGV0dGVySW1hZ2VQYXRoKGxldHRlcikgOiBcIlwifVxuICAgICAgd2lkdGg9e2xldHRlckRpbWVuc2lvbnMud2lkdGh9XG4gICAgICBoZWlnaHQ9e2xldHRlckRpbWVuc2lvbnMuaGVpZ2h0fVxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaW5ZTWluIG1lZXRcIlxuICAgICAgY2xhc3M9XCJsZXR0ZXItaW1hZ2VcIlxuICAgIC8+XG5cbiAgICA8IS0tIFR1cm4gaW5kaWNhdG9ycyAtLT5cbiAgICB7I2lmIHNob3dUdXJucygpfVxuICAgICAgPGcgY2xhc3M9XCJ0dXJuLWluZGljYXRvcnNcIj5cbiAgICAgICAgeyNlYWNoIHR1cm5Qb3NpdGlvbnMoKSBhcyB0dXJuICh0dXJuLmNvbG9yKX1cbiAgICAgICAgICA8IS0tIFR1cm4gY2lyY2xlIGJhY2tncm91bmQgLS0+XG4gICAgICAgICAgPGNpcmNsZVxuICAgICAgICAgICAgY3g9e3R1cm4ueH1cbiAgICAgICAgICAgIGN5PXt0dXJuLnl9XG4gICAgICAgICAgICByPVwiMTJcIlxuICAgICAgICAgICAgZmlsbD17Z2V0VHVybkNvbG9yKHR1cm4uY29sb3IpfVxuICAgICAgICAgICAgc3Ryb2tlPVwid2hpdGVcIlxuICAgICAgICAgICAgc3Ryb2tlLXdpZHRoPVwiMlwiXG4gICAgICAgICAgICBvcGFjaXR5PVwiMC45XCJcbiAgICAgICAgICAvPlxuXG4gICAgICAgICAgPCEtLSBUdXJuIHZhbHVlIHRleHQgLS0+XG4gICAgICAgICAgPHRleHRcbiAgICAgICAgICAgIHg9e3R1cm4ueH1cbiAgICAgICAgICAgIHk9e3R1cm4ueX1cbiAgICAgICAgICAgIHRleHQtYW5jaG9yPVwibWlkZGxlXCJcbiAgICAgICAgICAgIGRvbWluYW50LWJhc2VsaW5lPVwibWlkZGxlXCJcbiAgICAgICAgICAgIGZvbnQtZmFtaWx5PVwiQXJpYWwsIHNhbnMtc2VyaWZcIlxuICAgICAgICAgICAgZm9udC1zaXplPVwiMTFcIlxuICAgICAgICAgICAgZm9udC13ZWlnaHQ9XCJib2xkXCJcbiAgICAgICAgICAgIGZpbGw9XCJ3aGl0ZVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAge3R1cm4uZGlzcGxheVRleHR9XG4gICAgICAgICAgPC90ZXh0PlxuICAgICAgICB7L2VhY2h9XG4gICAgICA8L2c+XG4gICAgey9pZn1cblxuICAgIDwhLS0gVGltaW5nIGluZGljYXRvciAoaWYgbm90ICdzJyAtIHNpbXVsdGFuZW91cykgLS0+XG4gICAgeyNpZiBwYXJzZWRUdXJucygpLnRpbWluZyAhPT0gXCJzXCJ9XG4gICAgICA8dGV4dFxuICAgICAgICB4PVwiMFwiXG4gICAgICAgIHk9ey1mb250U2l6ZSAtIDEwfVxuICAgICAgICB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiXG4gICAgICAgIGZvbnQtZmFtaWx5PVwiQXJpYWwsIHNhbnMtc2VyaWZcIlxuICAgICAgICBmb250LXNpemU9e2ZvbnRTaXplICogMC42fVxuICAgICAgICBmb250LXdlaWdodD1cIm5vcm1hbFwiXG4gICAgICAgIGZpbGw9XCIjNmI3MjgwXCJcbiAgICAgICAgb3BhY2l0eT1cIjAuOFwiXG4gICAgICA+XG4gICAgICAgIHtwYXJzZWRUdXJucygpPy50aW1pbmc/LnRvVXBwZXJDYXNlKCkgfHwgXCJcIn1cbiAgICAgIDwvdGV4dD5cbiAgICB7L2lmfVxuICA8L2c+XG57L2lmfVxuXG48c3R5bGU+XG4gIC50a2EtZ2x5cGgge1xuICAgIC8qIEdseXBocyBhcmUgcmVuZGVyZWQgb24gdG9wIGxheWVyIGFib3ZlIGFycm93cyAqL1xuICAgIHotaW5kZXg6IDQ7XG4gIH1cblxuICAubGV0dGVyLWltYWdlIHtcbiAgICAvKiBTbW9vdGggaW1hZ2UgcmVuZGVyaW5nICovXG4gICAgaW1hZ2UtcmVuZGVyaW5nOiBvcHRpbWl6ZVF1YWxpdHk7XG4gIH1cblxuICAudHVybi1pbmRpY2F0b3JzIGNpcmNsZSB7XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuMnMgZWFzZTtcbiAgfVxuXG4gIC50dXJuLWluZGljYXRvcnMgY2lyY2xlOmhvdmVyIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMSk7XG4gICAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xuICB9XG48L3N0eWxlPlxuIl0sImZpbGUiOiJDOi9US0Evd2ViL3NyYy9saWIvY29tcG9uZW50cy9waWN0b2dyYXBoL1RLQUdseXBoLnN2ZWx0ZSJ9