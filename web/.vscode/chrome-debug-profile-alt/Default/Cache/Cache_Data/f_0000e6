import { ArrowAdjustmentProcessor } from "/src/lib/services/positioning/arrows/orchestration/ArrowAdjustmentProcessor.ts";
import { ArrowCoordinateTransformer } from "/src/lib/services/positioning/arrows/orchestration/ArrowCoordinateTransformer.ts";
import { ArrowDataProcessor } from "/src/lib/services/positioning/arrows/orchestration/ArrowDataProcessor.ts";
export class ArrowPositionCalculator {
  locationCalculator;
  rotationCalculator;
  adjustmentCalculator;
  coordinateSystem;
  adjustmentProcessor;
  coordinateTransformer;
  dataProcessor;
  constructor(locationCalculator, rotationCalculator, adjustmentCalculator, coordinateSystem) {
    this.locationCalculator = locationCalculator;
    this.rotationCalculator = rotationCalculator;
    this.adjustmentCalculator = adjustmentCalculator;
    this.coordinateSystem = coordinateSystem;
    this.adjustmentProcessor = new ArrowAdjustmentProcessor();
    this.coordinateTransformer = new ArrowCoordinateTransformer();
    this.dataProcessor = new ArrowDataProcessor(coordinateSystem);
  }
  async calculateArrowPosition(arrowData, pictographData, motionData) {
    try {
      const motion = motionData;
      if (!motion) {
        const center = this.coordinateSystem.getSceneCenter();
        return [center.x, center.y, 0];
      }
      const location = this.locationCalculator.calculateLocation(
        motion,
        pictographData
      );
      const initialPosition = this.coordinateSystem.getInitialPosition(
        motion,
        location
      );
      const validPosition = this.dataProcessor.ensureValidPosition(initialPosition);
      const rotation = this.rotationCalculator.calculateRotation(
        motion,
        location
      );
      const adjustment = await this.adjustmentCalculator.calculateAdjustment(
        pictographData,
        motion,
        motion.color,
        // ✅ FIXED: Use color from MotionData
        location
      );
      const [adjustmentX, adjustmentY] = this.dataProcessor.extractAdjustmentValues(adjustment);
      const [transformedAdjustmentX, transformedAdjustmentY] = this.coordinateTransformer.transformAdjustmentByRotation(
        adjustmentX,
        adjustmentY,
        rotation
      );
      const finalX = validPosition.x + transformedAdjustmentX;
      const finalY = validPosition.y + transformedAdjustmentY;
      return [finalX, finalY, rotation];
    } catch (error) {
      console.error("Arrow positioning calculation failed:", error);
      const center = this.coordinateSystem.getSceneCenter();
      return [center.x, center.y, 0];
    }
  }
  async updateArrowPosition(pictographData, color, motionData) {
    try {
      const arrowData = pictographData.arrows?.[color];
      if (!arrowData) {
        console.warn(`No arrow data found for color: ${color}`);
        return pictographData;
      }
      const [x, y, rotation] = await this.calculateArrowPosition(
        arrowData,
        pictographData,
        motionData
      );
      const shouldMirror = this.shouldMirrorArrow(arrowData, pictographData);
      const updates = {
        positionX: x,
        positionY: y,
        rotationAngle: rotation,
        svgMirrored: shouldMirror
        // ✅ FIXED: Use correct property name
      };
      return this.dataProcessor.updateArrowInPictograph(
        pictographData,
        color,
        updates
      );
    } catch (error) {
      console.error("Arrow position update failed:", error);
      return pictographData;
    }
  }
  async calculateAllArrowPositions(pictographData) {
    try {
      if (!pictographData.arrows) {
        return pictographData;
      }
      let updatedPictograph = { ...pictographData };
      for (const color of Object.keys(pictographData.arrows)) {
        const arrowData = pictographData.arrows[color];
        if (arrowData) {
          const [x, y, rotation] = await this.calculateArrowPosition(
            arrowData,
            updatedPictograph
          );
          const currentMotionData = updatedPictograph.motions[color];
          const shouldMirror = this.shouldMirrorArrow(
            arrowData,
            updatedPictograph,
            currentMotionData
          );
          const updates = {
            positionX: x,
            positionY: y,
            rotationAngle: rotation,
            svgMirrored: shouldMirror
            // ✅ FIXED: Use correct property name
          };
          updatedPictograph = this.dataProcessor.updateArrowInPictograph(
            updatedPictograph,
            color,
            updates
          );
        }
      }
      return updatedPictograph;
    } catch (error) {
      console.error("Failed to calculate all arrow positions:", error);
      return pictographData;
    }
  }
  shouldMirrorArrow(_arrowData, pictographData, motionData) {
    if (!pictographData?.motions || !motionData) {
      return false;
    }
    const motionType = motionData.motionType?.toLowerCase();
    const propRotDir = motionData.rotationDirection?.toLowerCase();
    if (!motionType || !propRotDir) {
      return false;
    }
    const mirrorConditions = {
      anti: { cw: true, ccw: false },
      other: { cw: false, ccw: true }
    };
    const conditionKey = motionType === "anti" ? "anti" : "other";
    const shouldMirror = mirrorConditions[conditionKey][propRotDir] ?? false;
    return shouldMirror;
  }
  applyMirrorTransform(arrowItem, shouldMirror) {
    if (shouldMirror) {
      arrowItem.style.transform = `${arrowItem.style.transform || ""} scaleX(-1)`;
    } else {
      const transform = arrowItem.style.transform || "";
      arrowItem.style.transform = transform.replace(/scaleX\(-1\)\s*/g, "").trim();
    }
  }
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3NlcnZpY2VzL3Bvc2l0aW9uaW5nL2Fycm93cy9vcmNoZXN0cmF0aW9uL0Fycm93UG9zaXRpb25DYWxjdWxhdG9yLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIEFycm93IFBvc2l0aW9uIENhbGN1bGF0b3JcbiAqXG4gKiBIYW5kbGVzIHRoZSBtYWluIGFycm93IHBvc2l0aW9uaW5nIGNhbGN1bGF0aW9uIGxvZ2ljLlxuICogQ29vcmRpbmF0ZXMgd2l0aCBvdGhlciBzZXJ2aWNlcyB0byBjb21wdXRlIGZpbmFsIGFycm93IHBvc2l0aW9ucy5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7IEFycm93RGF0YSwgTW90aW9uRGF0YSwgUGljdG9ncmFwaERhdGEgfSBmcm9tIFwiJGxpYi9kb21haW5cIjtcbmltcG9ydCB0eXBlIHtcbiAgSUFycm93QWRqdXN0bWVudENhbGN1bGF0b3IsXG4gIElBcnJvd0Nvb3JkaW5hdGVTeXN0ZW1TZXJ2aWNlLFxuICBJQXJyb3dMb2NhdGlvbkNhbGN1bGF0b3IsXG4gIElBcnJvd1Bvc2l0aW9uaW5nT3JjaGVzdHJhdG9yLFxuICBJQXJyb3dSb3RhdGlvbkNhbGN1bGF0b3IsXG59IGZyb20gXCIuLi8uLi9jb3JlLXNlcnZpY2VzXCI7XG5pbXBvcnQgeyBBcnJvd0FkanVzdG1lbnRQcm9jZXNzb3IgfSBmcm9tIFwiLi9BcnJvd0FkanVzdG1lbnRQcm9jZXNzb3JcIjtcbmltcG9ydCB7IEFycm93Q29vcmRpbmF0ZVRyYW5zZm9ybWVyIH0gZnJvbSBcIi4vQXJyb3dDb29yZGluYXRlVHJhbnNmb3JtZXJcIjtcbmltcG9ydCB7IEFycm93RGF0YVByb2Nlc3NvciB9IGZyb20gXCIuL0Fycm93RGF0YVByb2Nlc3NvclwiO1xuXG5leHBvcnQgY2xhc3MgQXJyb3dQb3NpdGlvbkNhbGN1bGF0b3IgaW1wbGVtZW50cyBJQXJyb3dQb3NpdGlvbmluZ09yY2hlc3RyYXRvciB7XG4gIHByaXZhdGUgbG9jYXRpb25DYWxjdWxhdG9yOiBJQXJyb3dMb2NhdGlvbkNhbGN1bGF0b3I7XG4gIHByaXZhdGUgcm90YXRpb25DYWxjdWxhdG9yOiBJQXJyb3dSb3RhdGlvbkNhbGN1bGF0b3I7XG4gIHByaXZhdGUgYWRqdXN0bWVudENhbGN1bGF0b3I6IElBcnJvd0FkanVzdG1lbnRDYWxjdWxhdG9yO1xuICBwcml2YXRlIGNvb3JkaW5hdGVTeXN0ZW06IElBcnJvd0Nvb3JkaW5hdGVTeXN0ZW1TZXJ2aWNlO1xuXG4gIHByaXZhdGUgYWRqdXN0bWVudFByb2Nlc3NvcjogQXJyb3dBZGp1c3RtZW50UHJvY2Vzc29yO1xuICBwcml2YXRlIGNvb3JkaW5hdGVUcmFuc2Zvcm1lcjogQXJyb3dDb29yZGluYXRlVHJhbnNmb3JtZXI7XG4gIHByaXZhdGUgZGF0YVByb2Nlc3NvcjogQXJyb3dEYXRhUHJvY2Vzc29yO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGxvY2F0aW9uQ2FsY3VsYXRvcjogSUFycm93TG9jYXRpb25DYWxjdWxhdG9yLFxuICAgIHJvdGF0aW9uQ2FsY3VsYXRvcjogSUFycm93Um90YXRpb25DYWxjdWxhdG9yLFxuICAgIGFkanVzdG1lbnRDYWxjdWxhdG9yOiBJQXJyb3dBZGp1c3RtZW50Q2FsY3VsYXRvcixcbiAgICBjb29yZGluYXRlU3lzdGVtOiBJQXJyb3dDb29yZGluYXRlU3lzdGVtU2VydmljZVxuICApIHtcbiAgICB0aGlzLmxvY2F0aW9uQ2FsY3VsYXRvciA9IGxvY2F0aW9uQ2FsY3VsYXRvcjtcbiAgICB0aGlzLnJvdGF0aW9uQ2FsY3VsYXRvciA9IHJvdGF0aW9uQ2FsY3VsYXRvcjtcbiAgICB0aGlzLmFkanVzdG1lbnRDYWxjdWxhdG9yID0gYWRqdXN0bWVudENhbGN1bGF0b3I7XG4gICAgdGhpcy5jb29yZGluYXRlU3lzdGVtID0gY29vcmRpbmF0ZVN5c3RlbTtcblxuICAgIHRoaXMuYWRqdXN0bWVudFByb2Nlc3NvciA9IG5ldyBBcnJvd0FkanVzdG1lbnRQcm9jZXNzb3IoKTtcbiAgICB0aGlzLmNvb3JkaW5hdGVUcmFuc2Zvcm1lciA9IG5ldyBBcnJvd0Nvb3JkaW5hdGVUcmFuc2Zvcm1lcigpO1xuICAgIHRoaXMuZGF0YVByb2Nlc3NvciA9IG5ldyBBcnJvd0RhdGFQcm9jZXNzb3IoY29vcmRpbmF0ZVN5c3RlbSk7XG4gIH1cblxuICBhc3luYyBjYWxjdWxhdGVBcnJvd1Bvc2l0aW9uKFxuICAgIGFycm93RGF0YTogQXJyb3dEYXRhLFxuICAgIHBpY3RvZ3JhcGhEYXRhOiBQaWN0b2dyYXBoRGF0YSxcbiAgICBtb3Rpb25EYXRhPzogTW90aW9uRGF0YVxuICApOiBQcm9taXNlPFtudW1iZXIsIG51bWJlciwgbnVtYmVyXT4ge1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBhcnJvdyBwb3NpdGlvbiBhc3luY2hyb25vdXNseSB3aXRoIGZ1bGwgc2VydmljZSBjb29yZGluYXRpb24uXG4gICAgICovXG4gICAgdHJ5IHtcbiAgICAgIC8vIFNURVAgMTogRXh0cmFjdCBvciB1c2UgcHJvdmlkZWQgbW90aW9uIGRhdGFcbiAgICAgIC8vIOKchSBGSVhFRDogUGFzcyBjb2xvciBkaXJlY3RseSBzaW5jZSBBcnJvd0RhdGEgbm8gbG9uZ2VyIGhhcyBjb2xvclxuICAgICAgY29uc3QgbW90aW9uID0gbW90aW9uRGF0YTtcbiAgICAgIGlmICghbW90aW9uKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbS5nZXRTY2VuZUNlbnRlcigpO1xuICAgICAgICByZXR1cm4gW2NlbnRlci54LCBjZW50ZXIueSwgMF07XG4gICAgICB9XG5cbiAgICAgIC8vIFNURVAgMjogQ2FsY3VsYXRlIGxvY2F0aW9uIGFuZCBpbml0aWFsIHBvc2l0aW9uXG4gICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMubG9jYXRpb25DYWxjdWxhdG9yLmNhbGN1bGF0ZUxvY2F0aW9uKFxuICAgICAgICBtb3Rpb24sXG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhXG4gICAgICApO1xuICAgICAgY29uc3QgaW5pdGlhbFBvc2l0aW9uID0gdGhpcy5jb29yZGluYXRlU3lzdGVtLmdldEluaXRpYWxQb3NpdGlvbihcbiAgICAgICAgbW90aW9uLFxuICAgICAgICBsb2NhdGlvblxuICAgICAgKTtcbiAgICAgIGNvbnN0IHZhbGlkUG9zaXRpb24gPVxuICAgICAgICB0aGlzLmRhdGFQcm9jZXNzb3IuZW5zdXJlVmFsaWRQb3NpdGlvbihpbml0aWFsUG9zaXRpb24pO1xuXG4gICAgICAvLyBTVEVQIDM6IENhbGN1bGF0ZSByb3RhdGlvblxuICAgICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uQ2FsY3VsYXRvci5jYWxjdWxhdGVSb3RhdGlvbihcbiAgICAgICAgbW90aW9uLFxuICAgICAgICBsb2NhdGlvblxuICAgICAgKTtcblxuICAgICAgLy8gU1RFUCA0OiBDYWxjdWxhdGUgYWRqdXN0bWVudCB1c2luZyBzb3BoaXN0aWNhdGVkIHNlcnZpY2VcbiAgICAgIGNvbnN0IGFkanVzdG1lbnQgPSBhd2FpdCB0aGlzLmFkanVzdG1lbnRDYWxjdWxhdG9yLmNhbGN1bGF0ZUFkanVzdG1lbnQoXG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhLFxuICAgICAgICBtb3Rpb24sXG4gICAgICAgIG1vdGlvbi5jb2xvciwgLy8g4pyFIEZJWEVEOiBVc2UgY29sb3IgZnJvbSBNb3Rpb25EYXRhXG4gICAgICAgIGxvY2F0aW9uXG4gICAgICApO1xuICAgICAgY29uc3QgW2FkanVzdG1lbnRYLCBhZGp1c3RtZW50WV0gPVxuICAgICAgICB0aGlzLmRhdGFQcm9jZXNzb3IuZXh0cmFjdEFkanVzdG1lbnRWYWx1ZXMoYWRqdXN0bWVudCk7XG5cbiAgICAgIC8vIFNURVAgNTogQXBwbHkgcm90YXRpb24gdHJhbnNmb3JtYXRpb24gdG8gYWRqdXN0bWVudCBjb29yZGluYXRlc1xuICAgICAgY29uc3QgW3RyYW5zZm9ybWVkQWRqdXN0bWVudFgsIHRyYW5zZm9ybWVkQWRqdXN0bWVudFldID1cbiAgICAgICAgdGhpcy5jb29yZGluYXRlVHJhbnNmb3JtZXIudHJhbnNmb3JtQWRqdXN0bWVudEJ5Um90YXRpb24oXG4gICAgICAgICAgYWRqdXN0bWVudFgsXG4gICAgICAgICAgYWRqdXN0bWVudFksXG4gICAgICAgICAgcm90YXRpb25cbiAgICAgICAgKTtcblxuICAgICAgLy8gU1RFUCA2OiBDb21iaW5lIGFsbCBwb3NpdGlvbmluZyBjYWxjdWxhdGlvbnNcbiAgICAgIGNvbnN0IGZpbmFsWCA9IHZhbGlkUG9zaXRpb24ueCArIHRyYW5zZm9ybWVkQWRqdXN0bWVudFg7XG4gICAgICBjb25zdCBmaW5hbFkgPSB2YWxpZFBvc2l0aW9uLnkgKyB0cmFuc2Zvcm1lZEFkanVzdG1lbnRZO1xuXG4gICAgICByZXR1cm4gW2ZpbmFsWCwgZmluYWxZLCByb3RhdGlvbl07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBcnJvdyBwb3NpdGlvbmluZyBjYWxjdWxhdGlvbiBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbS5nZXRTY2VuZUNlbnRlcigpO1xuICAgICAgcmV0dXJuIFtjZW50ZXIueCwgY2VudGVyLnksIDBdO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZUFycm93UG9zaXRpb24oXG4gICAgcGljdG9ncmFwaERhdGE6IFBpY3RvZ3JhcGhEYXRhLFxuICAgIGNvbG9yOiBzdHJpbmcsXG4gICAgbW90aW9uRGF0YT86IE1vdGlvbkRhdGFcbiAgKTogUHJvbWlzZTxQaWN0b2dyYXBoRGF0YT4ge1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhcnJvdyBwb3NpdGlvbiBpbiBwaWN0b2dyYXBoIGRhdGEuXG4gICAgICovXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFycm93RGF0YSA9IHBpY3RvZ3JhcGhEYXRhLmFycm93cz8uW2NvbG9yXTtcbiAgICAgIGlmICghYXJyb3dEYXRhKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgTm8gYXJyb3cgZGF0YSBmb3VuZCBmb3IgY29sb3I6ICR7Y29sb3J9YCk7XG4gICAgICAgIHJldHVybiBwaWN0b2dyYXBoRGF0YTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgW3gsIHksIHJvdGF0aW9uXSA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlQXJyb3dQb3NpdGlvbihcbiAgICAgICAgYXJyb3dEYXRhLFxuICAgICAgICBwaWN0b2dyYXBoRGF0YSxcbiAgICAgICAgbW90aW9uRGF0YVxuICAgICAgKTtcblxuICAgICAgLy8gQ1JJVElDQUw6IEFsc28gY2FsY3VsYXRlIG1pcnJvcmluZyBmb3IgdGhpcyBhcnJvd1xuICAgICAgY29uc3Qgc2hvdWxkTWlycm9yID0gdGhpcy5zaG91bGRNaXJyb3JBcnJvdyhhcnJvd0RhdGEsIHBpY3RvZ3JhcGhEYXRhKTtcblxuICAgICAgY29uc3QgdXBkYXRlczogUGFydGlhbDxBcnJvd0RhdGE+ID0ge1xuICAgICAgICBwb3NpdGlvblg6IHgsXG4gICAgICAgIHBvc2l0aW9uWTogeSxcbiAgICAgICAgcm90YXRpb25BbmdsZTogcm90YXRpb24sXG4gICAgICAgIHN2Z01pcnJvcmVkOiBzaG91bGRNaXJyb3IsIC8vIOKchSBGSVhFRDogVXNlIGNvcnJlY3QgcHJvcGVydHkgbmFtZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFQcm9jZXNzb3IudXBkYXRlQXJyb3dJblBpY3RvZ3JhcGgoXG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgdXBkYXRlc1xuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkFycm93IHBvc2l0aW9uIHVwZGF0ZSBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBwaWN0b2dyYXBoRGF0YTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjYWxjdWxhdGVBbGxBcnJvd1Bvc2l0aW9ucyhcbiAgICBwaWN0b2dyYXBoRGF0YTogUGljdG9ncmFwaERhdGFcbiAgKTogUHJvbWlzZTxQaWN0b2dyYXBoRGF0YT4ge1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBwb3NpdGlvbnMgZm9yIGFsbCBhcnJvd3MgaW4gdGhlIHBpY3RvZ3JhcGguXG4gICAgICovXG4gICAgdHJ5IHtcbiAgICAgIGlmICghcGljdG9ncmFwaERhdGEuYXJyb3dzKSB7XG4gICAgICAgIHJldHVybiBwaWN0b2dyYXBoRGF0YTtcbiAgICAgIH1cblxuICAgICAgbGV0IHVwZGF0ZWRQaWN0b2dyYXBoID0geyAuLi5waWN0b2dyYXBoRGF0YSB9O1xuXG4gICAgICBmb3IgKGNvbnN0IGNvbG9yIG9mIE9iamVjdC5rZXlzKHBpY3RvZ3JhcGhEYXRhLmFycm93cykpIHtcbiAgICAgICAgY29uc3QgYXJyb3dEYXRhID0gcGljdG9ncmFwaERhdGEuYXJyb3dzW2NvbG9yXTtcbiAgICAgICAgaWYgKGFycm93RGF0YSkge1xuICAgICAgICAgIGNvbnN0IFt4LCB5LCByb3RhdGlvbl0gPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUFycm93UG9zaXRpb24oXG4gICAgICAgICAgICBhcnJvd0RhdGEsXG4gICAgICAgICAgICB1cGRhdGVkUGljdG9ncmFwaFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBDUklUSUNBTDogQWxzbyBjYWxjdWxhdGUgbWlycm9yaW5nIGZvciB0aGlzIGFycm93XG4gICAgICAgICAgY29uc3QgY3VycmVudE1vdGlvbkRhdGEgPSB1cGRhdGVkUGljdG9ncmFwaC5tb3Rpb25zW2NvbG9yXTtcbiAgICAgICAgICBjb25zdCBzaG91bGRNaXJyb3IgPSB0aGlzLnNob3VsZE1pcnJvckFycm93KFxuICAgICAgICAgICAgYXJyb3dEYXRhLFxuICAgICAgICAgICAgdXBkYXRlZFBpY3RvZ3JhcGgsXG4gICAgICAgICAgICBjdXJyZW50TW90aW9uRGF0YVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb25zdCB1cGRhdGVzOiBQYXJ0aWFsPEFycm93RGF0YT4gPSB7XG4gICAgICAgICAgICBwb3NpdGlvblg6IHgsXG4gICAgICAgICAgICBwb3NpdGlvblk6IHksXG4gICAgICAgICAgICByb3RhdGlvbkFuZ2xlOiByb3RhdGlvbixcbiAgICAgICAgICAgIHN2Z01pcnJvcmVkOiBzaG91bGRNaXJyb3IsIC8vIOKchSBGSVhFRDogVXNlIGNvcnJlY3QgcHJvcGVydHkgbmFtZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB1cGRhdGVkUGljdG9ncmFwaCA9IHRoaXMuZGF0YVByb2Nlc3Nvci51cGRhdGVBcnJvd0luUGljdG9ncmFwaChcbiAgICAgICAgICAgIHVwZGF0ZWRQaWN0b2dyYXBoLFxuICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICB1cGRhdGVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlZFBpY3RvZ3JhcGg7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY2FsY3VsYXRlIGFsbCBhcnJvdyBwb3NpdGlvbnM6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBwaWN0b2dyYXBoRGF0YTtcbiAgICB9XG4gIH1cblxuICBzaG91bGRNaXJyb3JBcnJvdyhcbiAgICBfYXJyb3dEYXRhOiBBcnJvd0RhdGEsXG4gICAgcGljdG9ncmFwaERhdGE/OiBQaWN0b2dyYXBoRGF0YSxcbiAgICBtb3Rpb25EYXRhPzogTW90aW9uRGF0YVxuICApOiBib29sZWFuIHtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgYXJyb3cgc2hvdWxkIGJlIG1pcnJvcmVkIGJhc2VkIG9uIG1vdGlvbiB0eXBlIGFuZCBwcm9wIHJvdGF0aW9uIGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIE1pcnJvciBjb25kaXRpb25zIChtYXRjaGluZyBkZXNrdG9wIGxvZ2ljKTpcbiAgICAgKiAtIEFudGkgbW90aW9uICsgY2xvY2t3aXNlIOKGkiBNaXJyb3IgPSBUcnVlXG4gICAgICogLSBBbnRpIG1vdGlvbiArIGNvdW50ZXJjbG9ja3dpc2Ug4oaSIE1pcnJvciA9IEZhbHNlXG4gICAgICogLSBQcm8gbW90aW9uICsgY2xvY2t3aXNlIOKGkiBNaXJyb3IgPSBGYWxzZVxuICAgICAqIC0gUHJvIG1vdGlvbiArIGNvdW50ZXJjbG9ja3dpc2Ug4oaSIE1pcnJvciA9IFRydWVcbiAgICAgKiAtIE90aGVyIG1vdGlvbnMgZm9sbG93IFwicHJvXCIgcnVsZXNcbiAgICAgKi9cblxuICAgIC8vIEdldCBtb3Rpb24gZGF0YSBmb3IgdGhpcyBhcnJvdydzIGNvbG9yXG4gICAgaWYgKCFwaWN0b2dyYXBoRGF0YT8ubW90aW9ucyB8fCAhbW90aW9uRGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG1vdGlvblR5cGUgPSBtb3Rpb25EYXRhLm1vdGlvblR5cGU/LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgcHJvcFJvdERpciA9IG1vdGlvbkRhdGEucm90YXRpb25EaXJlY3Rpb24/LnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoIW1vdGlvblR5cGUgfHwgIXByb3BSb3REaXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBNaXJyb3IgY29uZGl0aW9ucyBtYXRjaGluZyBkZXNrdG9wIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgbWlycm9yQ29uZGl0aW9ucyA9IHtcbiAgICAgIGFudGk6IHsgY3c6IHRydWUsIGNjdzogZmFsc2UgfSxcbiAgICAgIG90aGVyOiB7IGN3OiBmYWxzZSwgY2N3OiB0cnVlIH0sXG4gICAgfTtcblxuICAgIC8vIFVzZSBcImFudGlcIiBjb25kaXRpb25zIGZvciBhbnRpIG1vdGlvbiwgXCJvdGhlclwiIGZvciBldmVyeXRoaW5nIGVsc2UgKHBybywgc3RhdGljLCBkYXNoLCBmbG9hdClcbiAgICBjb25zdCBjb25kaXRpb25LZXkgPSBtb3Rpb25UeXBlID09PSBcImFudGlcIiA/IFwiYW50aVwiIDogXCJvdGhlclwiO1xuICAgIGNvbnN0IHNob3VsZE1pcnJvciA9XG4gICAgICBtaXJyb3JDb25kaXRpb25zW2NvbmRpdGlvbktleV1bXG4gICAgICAgIHByb3BSb3REaXIgYXMga2V5b2YgdHlwZW9mIG1pcnJvckNvbmRpdGlvbnMuYW50aVxuICAgICAgXSA/PyBmYWxzZTtcblxuICAgIHJldHVybiBzaG91bGRNaXJyb3I7XG4gIH1cblxuICBhcHBseU1pcnJvclRyYW5zZm9ybShcbiAgICBhcnJvd0l0ZW06IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCxcbiAgICBzaG91bGRNaXJyb3I6IGJvb2xlYW5cbiAgKTogdm9pZCB7XG4gICAgLyoqXG4gICAgICogQXBwbHkgbWlycm9yIHRyYW5zZm9ybWF0aW9uIHRvIGFycm93IGdyYXBoaWNzIGl0ZW0uXG4gICAgICovXG4gICAgaWYgKHNob3VsZE1pcnJvcikge1xuICAgICAgYXJyb3dJdGVtLnN0eWxlLnRyYW5zZm9ybSA9IGAke2Fycm93SXRlbS5zdHlsZS50cmFuc2Zvcm0gfHwgXCJcIn0gc2NhbGVYKC0xKWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSBtaXJyb3IgdHJhbnNmb3JtYXRpb25cbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGFycm93SXRlbS5zdHlsZS50cmFuc2Zvcm0gfHwgXCJcIjtcbiAgICAgIGFycm93SXRlbS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbiAgICAgICAgLnJlcGxhY2UoL3NjYWxlWFxcKC0xXFwpXFxzKi9nLCBcIlwiKVxuICAgICAgICAudHJpbSgpO1xuICAgIH1cbiAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIkFBZUEsU0FBUyxnQ0FBZ0M7QUFDekMsU0FBUyxrQ0FBa0M7QUFDM0MsU0FBUywwQkFBMEI7QUFFNUIsYUFBTSx3QkFBaUU7QUFBQSxFQUNwRTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBRUE7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBRVIsWUFDRSxvQkFDQSxvQkFDQSxzQkFDQSxrQkFDQTtBQUNBLFNBQUsscUJBQXFCO0FBQzFCLFNBQUsscUJBQXFCO0FBQzFCLFNBQUssdUJBQXVCO0FBQzVCLFNBQUssbUJBQW1CO0FBRXhCLFNBQUssc0JBQXNCLElBQUkseUJBQXlCO0FBQ3hELFNBQUssd0JBQXdCLElBQUksMkJBQTJCO0FBQzVELFNBQUssZ0JBQWdCLElBQUksbUJBQW1CLGdCQUFnQjtBQUFBLEVBQzlEO0FBQUEsRUFFQSxNQUFNLHVCQUNKLFdBQ0EsZ0JBQ0EsWUFDbUM7QUFJbkMsUUFBSTtBQUdGLFlBQU0sU0FBUztBQUNmLFVBQUksQ0FBQyxRQUFRO0FBQ1gsY0FBTSxTQUFTLEtBQUssaUJBQWlCLGVBQWU7QUFDcEQsZUFBTyxDQUFDLE9BQU8sR0FBRyxPQUFPLEdBQUcsQ0FBQztBQUFBLE1BQy9CO0FBR0EsWUFBTSxXQUFXLEtBQUssbUJBQW1CO0FBQUEsUUFDdkM7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUNBLFlBQU0sa0JBQWtCLEtBQUssaUJBQWlCO0FBQUEsUUFDNUM7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUNBLFlBQU0sZ0JBQ0osS0FBSyxjQUFjLG9CQUFvQixlQUFlO0FBR3hELFlBQU0sV0FBVyxLQUFLLG1CQUFtQjtBQUFBLFFBQ3ZDO0FBQUEsUUFDQTtBQUFBLE1BQ0Y7QUFHQSxZQUFNLGFBQWEsTUFBTSxLQUFLLHFCQUFxQjtBQUFBLFFBQ2pEO0FBQUEsUUFDQTtBQUFBLFFBQ0EsT0FBTztBQUFBO0FBQUEsUUFDUDtBQUFBLE1BQ0Y7QUFDQSxZQUFNLENBQUMsYUFBYSxXQUFXLElBQzdCLEtBQUssY0FBYyx3QkFBd0IsVUFBVTtBQUd2RCxZQUFNLENBQUMsd0JBQXdCLHNCQUFzQixJQUNuRCxLQUFLLHNCQUFzQjtBQUFBLFFBQ3pCO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBR0YsWUFBTSxTQUFTLGNBQWMsSUFBSTtBQUNqQyxZQUFNLFNBQVMsY0FBYyxJQUFJO0FBRWpDLGFBQU8sQ0FBQyxRQUFRLFFBQVEsUUFBUTtBQUFBLElBQ2xDLFNBQVMsT0FBTztBQUNkLGNBQVEsTUFBTSx5Q0FBeUMsS0FBSztBQUM1RCxZQUFNLFNBQVMsS0FBSyxpQkFBaUIsZUFBZTtBQUNwRCxhQUFPLENBQUMsT0FBTyxHQUFHLE9BQU8sR0FBRyxDQUFDO0FBQUEsSUFDL0I7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFNLG9CQUNKLGdCQUNBLE9BQ0EsWUFDeUI7QUFJekIsUUFBSTtBQUNGLFlBQU0sWUFBWSxlQUFlLFNBQVMsS0FBSztBQUMvQyxVQUFJLENBQUMsV0FBVztBQUNkLGdCQUFRLEtBQUssa0NBQWtDLEtBQUssRUFBRTtBQUN0RCxlQUFPO0FBQUEsTUFDVDtBQUVBLFlBQU0sQ0FBQyxHQUFHLEdBQUcsUUFBUSxJQUFJLE1BQU0sS0FBSztBQUFBLFFBQ2xDO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBR0EsWUFBTSxlQUFlLEtBQUssa0JBQWtCLFdBQVcsY0FBYztBQUVyRSxZQUFNLFVBQThCO0FBQUEsUUFDbEMsV0FBVztBQUFBLFFBQ1gsV0FBVztBQUFBLFFBQ1gsZUFBZTtBQUFBLFFBQ2YsYUFBYTtBQUFBO0FBQUEsTUFDZjtBQUNBLGFBQU8sS0FBSyxjQUFjO0FBQUEsUUFDeEI7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLE1BQ0Y7QUFBQSxJQUNGLFNBQVMsT0FBTztBQUNkLGNBQVEsTUFBTSxpQ0FBaUMsS0FBSztBQUNwRCxhQUFPO0FBQUEsSUFDVDtBQUFBLEVBQ0Y7QUFBQSxFQUVBLE1BQU0sMkJBQ0osZ0JBQ3lCO0FBSXpCLFFBQUk7QUFDRixVQUFJLENBQUMsZUFBZSxRQUFRO0FBQzFCLGVBQU87QUFBQSxNQUNUO0FBRUEsVUFBSSxvQkFBb0IsRUFBRSxHQUFHLGVBQWU7QUFFNUMsaUJBQVcsU0FBUyxPQUFPLEtBQUssZUFBZSxNQUFNLEdBQUc7QUFDdEQsY0FBTSxZQUFZLGVBQWUsT0FBTyxLQUFLO0FBQzdDLFlBQUksV0FBVztBQUNiLGdCQUFNLENBQUMsR0FBRyxHQUFHLFFBQVEsSUFBSSxNQUFNLEtBQUs7QUFBQSxZQUNsQztBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBR0EsZ0JBQU0sb0JBQW9CLGtCQUFrQixRQUFRLEtBQUs7QUFDekQsZ0JBQU0sZUFBZSxLQUFLO0FBQUEsWUFDeEI7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFFQSxnQkFBTSxVQUE4QjtBQUFBLFlBQ2xDLFdBQVc7QUFBQSxZQUNYLFdBQVc7QUFBQSxZQUNYLGVBQWU7QUFBQSxZQUNmLGFBQWE7QUFBQTtBQUFBLFVBQ2Y7QUFFQSw4QkFBb0IsS0FBSyxjQUFjO0FBQUEsWUFDckM7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVBLGFBQU87QUFBQSxJQUNULFNBQVMsT0FBTztBQUNkLGNBQVEsTUFBTSw0Q0FBNEMsS0FBSztBQUMvRCxhQUFPO0FBQUEsSUFDVDtBQUFBLEVBQ0Y7QUFBQSxFQUVBLGtCQUNFLFlBQ0EsZ0JBQ0EsWUFDUztBQWFULFFBQUksQ0FBQyxnQkFBZ0IsV0FBVyxDQUFDLFlBQVk7QUFDM0MsYUFBTztBQUFBLElBQ1Q7QUFFQSxVQUFNLGFBQWEsV0FBVyxZQUFZLFlBQVk7QUFDdEQsVUFBTSxhQUFhLFdBQVcsbUJBQW1CLFlBQVk7QUFFN0QsUUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZO0FBQzlCLGFBQU87QUFBQSxJQUNUO0FBR0EsVUFBTSxtQkFBbUI7QUFBQSxNQUN2QixNQUFNLEVBQUUsSUFBSSxNQUFNLEtBQUssTUFBTTtBQUFBLE1BQzdCLE9BQU8sRUFBRSxJQUFJLE9BQU8sS0FBSyxLQUFLO0FBQUEsSUFDaEM7QUFHQSxVQUFNLGVBQWUsZUFBZSxTQUFTLFNBQVM7QUFDdEQsVUFBTSxlQUNKLGlCQUFpQixZQUFZLEVBQzNCLFVBQ0YsS0FBSztBQUVQLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFFQSxxQkFDRSxXQUNBLGNBQ007QUFJTixRQUFJLGNBQWM7QUFDaEIsZ0JBQVUsTUFBTSxZQUFZLEdBQUcsVUFBVSxNQUFNLGFBQWEsRUFBRTtBQUFBLElBQ2hFLE9BQU87QUFFTCxZQUFNLFlBQVksVUFBVSxNQUFNLGFBQWE7QUFDL0MsZ0JBQVUsTUFBTSxZQUFZLFVBQ3pCLFFBQVEsb0JBQW9CLEVBQUUsRUFDOUIsS0FBSztBQUFBLElBQ1Y7QUFBQSxFQUNGO0FBQ0Y7IiwKICAibmFtZXMiOiBbXQp9Cg==
