export class PngMetadataExtractor {
  /**
   * Extract complete JSON metadata from a PNG file
   * @param filePath - Path to the PNG file (relative to static directory)
   * @returns Promise<Record<string, unknown>[]> - The complete sequence metadata as JSON array
   */
  static async extractMetadata(filePath) {
    try {
      const response = await fetch(filePath);
      if (!response.ok) {
        throw new Error(
          `Failed to fetch PNG file: ${response.status} ${response.statusText}`
        );
      }
      const arrayBuffer = await response.arrayBuffer();
      const uint8Array = new Uint8Array(arrayBuffer);
      const metadataJson = this.findTextChunk(uint8Array, "metadata");
      if (!metadataJson) {
        throw new Error("No unified JSON metadata found in PNG file");
      }
      const parsed = JSON.parse(metadataJson);
      return parsed.sequence || parsed;
    } catch (error) {
      console.error("Error extracting PNG metadata:", error);
      throw error;
    }
  }
  /**
   * Find the unified JSON metadata tEXt chunk in PNG data
   *
   * We only look for the "metadata" keyword which contains the complete
   * JSON structure with all sequence information. This is our single
   * source of truth for all metadata fields.
   *
   * @param data - PNG file data as Uint8Array
   * @param keyword - Should always be "metadata" for TKA sequences
   * @returns string | null - The JSON metadata string or null if not found
   */
  static findTextChunk(data, keyword) {
    let offset = 8;
    while (offset < data.length) {
      const length = data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
      offset += 4;
      const type = String.fromCharCode(
        data[offset],
        data[offset + 1],
        data[offset + 2],
        data[offset + 3]
      );
      offset += 4;
      if (type === "tEXt") {
        const chunkData = data.slice(offset, offset + length);
        const text = new TextDecoder("latin1").decode(chunkData);
        const nullIndex = text.indexOf("\0");
        if (nullIndex !== -1) {
          const chunkKeyword = text.substring(0, nullIndex);
          if (chunkKeyword === keyword) {
            return text.substring(nullIndex + 1);
          }
        }
      }
      offset += length + 4;
    }
    return null;
  }
  /**
   * Extract metadata for a specific sequence by name
   * @param sequenceName - Name of the sequence (e.g., "DKIIEJII")
   * @returns Promise<Record<string, unknown>[]> - The extracted metadata
   */
  static async extractSequenceMetadata(sequenceName) {
    const filePath = `/dictionary/${sequenceName}/${sequenceName}_ver1.png`;
    return this.extractMetadata(filePath);
  }
  /**
   * Debug method to display complete unified metadata for a sequence
   *
   * This shows the entire JSON metadata structure including:
   * - Author, level, start position (from first entry)
   * - All beat data with motion types and attributes
   * - Any other fields in the unified metadata
   *
   * @param sequenceName - Name of the sequence to analyze
   */
  static async debugSequenceMetadata(sequenceName) {
    try {
      console.log(
        `üîç [UNIFIED METADATA] Extracting complete metadata for ${sequenceName}...`
      );
      const metadata = await this.extractSequenceMetadata(sequenceName);
      console.log(
        `üìã [UNIFIED METADATA] Complete JSON structure for ${sequenceName}:`
      );
      console.log(JSON.stringify(metadata, null, 2));
      const firstEntry = metadata[0] || {};
      const startPositionEntries = metadata.filter(
        (step) => step.sequence_start_position
      );
      console.log(
        `üë§ [UNIFIED METADATA] Author: ${firstEntry.author || "MISSING"}`
      );
      console.log(
        `üìç [UNIFIED METADATA] Start Position: ${startPositionEntries[0]?.sequence_start_position || "MISSING"}`
      );
      console.log(
        `üìä [UNIFIED METADATA] Level: ${firstEntry.level || "MISSING"}`
      );
      console.log(`üéØ [UNIFIED METADATA] Motion types for ${sequenceName}:`);
      const realBeats = metadata.slice(1).filter(
        (step) => step.letter && !step.sequence_start_position
      );
      realBeats.forEach((step, index) => {
        const blueAttrs = step.blueAttributes;
        const redAttrs = step.redAttributes;
        const blueMotion = blueAttrs?.motionType || "unknown";
        const redMotion = redAttrs?.motionType || "unknown";
        console.log(
          `  Beat ${index + 1} (${step.letter}): blue=${blueMotion}, red=${redMotion}`
        );
      });
    } catch (error) {
      console.error(
        `‚ùå [UNIFIED METADATA] Failed to extract metadata for ${sequenceName}:`,
        error
      );
    }
  }
}
if (typeof window !== "undefined") {
  window.extractPngMetadata = PngMetadataExtractor.debugSequenceMetadata;
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3V0aWxzL3BuZy1tZXRhZGF0YS1leHRyYWN0b3IudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogVW5pZmllZCBQTkcgTWV0YWRhdGEgRXh0cmFjdG9yIGZvciBUS0EgU2VxdWVuY2VzXG4gKlxuICogVGhpcyBjbGFzcyBleHRyYWN0cyBBTEwgc2VxdWVuY2UgbWV0YWRhdGEgZnJvbSBhIHNpbmdsZSBKU09OIHN0cnVjdHVyZVxuICogc3RvcmVkIGluIHRoZSBcIm1ldGFkYXRhXCIgdEVYdCBjaHVuayBvZiBQTkcgZmlsZXMuIFRoaXMgaW5jbHVkZXM6XG4gKiAtIFNlcXVlbmNlIGluZm9ybWF0aW9uIChhdXRob3IsIGxldmVsLCBzdGFydCBwb3NpdGlvbiwgZXRjLilcbiAqIC0gQmVhdCBkYXRhIChsZXR0ZXJzLCBtb3Rpb24gdHlwZXMsIGF0dHJpYnV0ZXMpXG4gKiAtIEFsbCBvdGhlciBtZXRhZGF0YSBmaWVsZHNcbiAqXG4gKiBXZSB1c2UgT05FIGNvbnNpc3RlbnQgc3lzdGVtIC0gSlNPTiBtZXRhZGF0YSBvbmx5LlxuICogTm8gc2VwYXJhdGUgdEVYdCBjaHVua3MgZm9yIGluZGl2aWR1YWwgZmllbGRzLlxuICovXG5cbmV4cG9ydCBjbGFzcyBQbmdNZXRhZGF0YUV4dHJhY3RvciB7XG4gIC8qKlxuICAgKiBFeHRyYWN0IGNvbXBsZXRlIEpTT04gbWV0YWRhdGEgZnJvbSBhIFBORyBmaWxlXG4gICAqIEBwYXJhbSBmaWxlUGF0aCAtIFBhdGggdG8gdGhlIFBORyBmaWxlIChyZWxhdGl2ZSB0byBzdGF0aWMgZGlyZWN0b3J5KVxuICAgKiBAcmV0dXJucyBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHVua25vd24+W10+IC0gVGhlIGNvbXBsZXRlIHNlcXVlbmNlIG1ldGFkYXRhIGFzIEpTT04gYXJyYXlcbiAgICovXG4gIHN0YXRpYyBhc3luYyBleHRyYWN0TWV0YWRhdGEoXG4gICAgZmlsZVBhdGg6IHN0cmluZ1xuICApOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHVua25vd24+W10+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRmV0Y2ggdGhlIFBORyBmaWxlXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZpbGVQYXRoKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gZmV0Y2ggUE5HIGZpbGU6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuXG4gICAgICAvLyBFeHRyYWN0IHRoZSB1bmlmaWVkIEpTT04gbWV0YWRhdGEgZnJvbSB0aGUgXCJtZXRhZGF0YVwiIHRFWHQgY2h1bmtcbiAgICAgIGNvbnN0IG1ldGFkYXRhSnNvbiA9IHRoaXMuZmluZFRleHRDaHVuayh1aW50OEFycmF5LCBcIm1ldGFkYXRhXCIpO1xuXG4gICAgICBpZiAoIW1ldGFkYXRhSnNvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB1bmlmaWVkIEpTT04gbWV0YWRhdGEgZm91bmQgaW4gUE5HIGZpbGVcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhcnNlIGFuZCByZXR1cm4gdGhlIGNvbXBsZXRlIG1ldGFkYXRhIHN0cnVjdHVyZVxuICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShtZXRhZGF0YUpzb24pO1xuICAgICAgcmV0dXJuIHBhcnNlZC5zZXF1ZW5jZSB8fCBwYXJzZWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBleHRyYWN0aW5nIFBORyBtZXRhZGF0YTpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHVuaWZpZWQgSlNPTiBtZXRhZGF0YSB0RVh0IGNodW5rIGluIFBORyBkYXRhXG4gICAqXG4gICAqIFdlIG9ubHkgbG9vayBmb3IgdGhlIFwibWV0YWRhdGFcIiBrZXl3b3JkIHdoaWNoIGNvbnRhaW5zIHRoZSBjb21wbGV0ZVxuICAgKiBKU09OIHN0cnVjdHVyZSB3aXRoIGFsbCBzZXF1ZW5jZSBpbmZvcm1hdGlvbi4gVGhpcyBpcyBvdXIgc2luZ2xlXG4gICAqIHNvdXJjZSBvZiB0cnV0aCBmb3IgYWxsIG1ldGFkYXRhIGZpZWxkcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBQTkcgZmlsZSBkYXRhIGFzIFVpbnQ4QXJyYXlcbiAgICogQHBhcmFtIGtleXdvcmQgLSBTaG91bGQgYWx3YXlzIGJlIFwibWV0YWRhdGFcIiBmb3IgVEtBIHNlcXVlbmNlc1xuICAgKiBAcmV0dXJucyBzdHJpbmcgfCBudWxsIC0gVGhlIEpTT04gbWV0YWRhdGEgc3RyaW5nIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBmaW5kVGV4dENodW5rKFxuICAgIGRhdGE6IFVpbnQ4QXJyYXksXG4gICAga2V5d29yZDogc3RyaW5nXG4gICk6IHN0cmluZyB8IG51bGwge1xuICAgIGxldCBvZmZzZXQgPSA4OyAvLyBTa2lwIFBORyBzaWduYXR1cmVcblxuICAgIHdoaWxlIChvZmZzZXQgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgLy8gUmVhZCBjaHVuayBsZW5ndGggKDQgYnl0ZXMsIGJpZy1lbmRpYW4pXG4gICAgICBjb25zdCBsZW5ndGggPVxuICAgICAgICAoZGF0YVtvZmZzZXRdIDw8IDI0KSB8XG4gICAgICAgIChkYXRhW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAgIChkYXRhW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgICAgZGF0YVtvZmZzZXQgKyAzXTtcbiAgICAgIG9mZnNldCArPSA0O1xuXG4gICAgICAvLyBSZWFkIGNodW5rIHR5cGUgKDQgYnl0ZXMpXG4gICAgICBjb25zdCB0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgZGF0YVtvZmZzZXRdLFxuICAgICAgICBkYXRhW29mZnNldCArIDFdLFxuICAgICAgICBkYXRhW29mZnNldCArIDJdLFxuICAgICAgICBkYXRhW29mZnNldCArIDNdXG4gICAgICApO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSB0RVh0IGNodW5rLCBjaGVjayBpZiBpdCBjb250YWlucyBvdXIga2V5d29yZFxuICAgICAgaWYgKHR5cGUgPT09IFwidEVYdFwiKSB7XG4gICAgICAgIGNvbnN0IGNodW5rRGF0YSA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHREZWNvZGVyKFwibGF0aW4xXCIpLmRlY29kZShjaHVua0RhdGEpO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIG51bGwgc2VwYXJhdG9yIGJldHdlZW4ga2V5d29yZCBhbmQgdGV4dFxuICAgICAgICBjb25zdCBudWxsSW5kZXggPSB0ZXh0LmluZGV4T2YoXCJcXDBcIik7XG4gICAgICAgIGlmIChudWxsSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgY2h1bmtLZXl3b3JkID0gdGV4dC5zdWJzdHJpbmcoMCwgbnVsbEluZGV4KTtcbiAgICAgICAgICBpZiAoY2h1bmtLZXl3b3JkID09PSBrZXl3b3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcobnVsbEluZGV4ICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNraXAgY2h1bmsgZGF0YSBhbmQgQ1JDICg0IGJ5dGVzKVxuICAgICAgb2Zmc2V0ICs9IGxlbmd0aCArIDQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyBzZXF1ZW5jZSBieSBuYW1lXG4gICAqIEBwYXJhbSBzZXF1ZW5jZU5hbWUgLSBOYW1lIG9mIHRoZSBzZXF1ZW5jZSAoZS5nLiwgXCJES0lJRUpJSVwiKVxuICAgKiBAcmV0dXJucyBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHVua25vd24+W10+IC0gVGhlIGV4dHJhY3RlZCBtZXRhZGF0YVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGV4dHJhY3RTZXF1ZW5jZU1ldGFkYXRhKFxuICAgIHNlcXVlbmNlTmFtZTogc3RyaW5nXG4gICk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgdW5rbm93bj5bXT4ge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gYC9kaWN0aW9uYXJ5LyR7c2VxdWVuY2VOYW1lfS8ke3NlcXVlbmNlTmFtZX1fdmVyMS5wbmdgO1xuICAgIHJldHVybiB0aGlzLmV4dHJhY3RNZXRhZGF0YShmaWxlUGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogRGVidWcgbWV0aG9kIHRvIGRpc3BsYXkgY29tcGxldGUgdW5pZmllZCBtZXRhZGF0YSBmb3IgYSBzZXF1ZW5jZVxuICAgKlxuICAgKiBUaGlzIHNob3dzIHRoZSBlbnRpcmUgSlNPTiBtZXRhZGF0YSBzdHJ1Y3R1cmUgaW5jbHVkaW5nOlxuICAgKiAtIEF1dGhvciwgbGV2ZWwsIHN0YXJ0IHBvc2l0aW9uIChmcm9tIGZpcnN0IGVudHJ5KVxuICAgKiAtIEFsbCBiZWF0IGRhdGEgd2l0aCBtb3Rpb24gdHlwZXMgYW5kIGF0dHJpYnV0ZXNcbiAgICogLSBBbnkgb3RoZXIgZmllbGRzIGluIHRoZSB1bmlmaWVkIG1ldGFkYXRhXG4gICAqXG4gICAqIEBwYXJhbSBzZXF1ZW5jZU5hbWUgLSBOYW1lIG9mIHRoZSBzZXF1ZW5jZSB0byBhbmFseXplXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZGVidWdTZXF1ZW5jZU1ldGFkYXRhKHNlcXVlbmNlTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBg8J+UjSBbVU5JRklFRCBNRVRBREFUQV0gRXh0cmFjdGluZyBjb21wbGV0ZSBtZXRhZGF0YSBmb3IgJHtzZXF1ZW5jZU5hbWV9Li4uYFxuICAgICAgKTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5leHRyYWN0U2VxdWVuY2VNZXRhZGF0YShzZXF1ZW5jZU5hbWUpO1xuXG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYPCfk4sgW1VOSUZJRUQgTUVUQURBVEFdIENvbXBsZXRlIEpTT04gc3RydWN0dXJlIGZvciAke3NlcXVlbmNlTmFtZX06YFxuICAgICAgKTtcbiAgICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhLCBudWxsLCAyKSk7XG5cbiAgICAgIC8vIFNob3cgYXV0aG9yIGFuZCBzdGFydCBwb3NpdGlvbiBmcm9tIHRoZSB1bmlmaWVkIHN0cnVjdHVyZVxuICAgICAgY29uc3QgZmlyc3RFbnRyeSA9IG1ldGFkYXRhWzBdIHx8IHt9O1xuICAgICAgY29uc3Qgc3RhcnRQb3NpdGlvbkVudHJpZXMgPSBtZXRhZGF0YS5maWx0ZXIoXG4gICAgICAgIChzdGVwOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgPT4gc3RlcC5zZXF1ZW5jZV9zdGFydF9wb3NpdGlvblxuICAgICAgKTtcblxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGDwn5GkIFtVTklGSUVEIE1FVEFEQVRBXSBBdXRob3I6ICR7Zmlyc3RFbnRyeS5hdXRob3IgfHwgXCJNSVNTSU5HXCJ9YFxuICAgICAgKTtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBg8J+TjSBbVU5JRklFRCBNRVRBREFUQV0gU3RhcnQgUG9zaXRpb246ICR7c3RhcnRQb3NpdGlvbkVudHJpZXNbMF0/LnNlcXVlbmNlX3N0YXJ0X3Bvc2l0aW9uIHx8IFwiTUlTU0lOR1wifWBcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYPCfk4ogW1VOSUZJRUQgTUVUQURBVEFdIExldmVsOiAke2ZpcnN0RW50cnkubGV2ZWwgfHwgXCJNSVNTSU5HXCJ9YFxuICAgICAgKTtcblxuICAgICAgLy8gRXh0cmFjdCBtb3Rpb24gdHlwZXMgZm9yIGVhY2ggYmVhdFxuICAgICAgY29uc29sZS5sb2coYPCfjq8gW1VOSUZJRUQgTUVUQURBVEFdIE1vdGlvbiB0eXBlcyBmb3IgJHtzZXF1ZW5jZU5hbWV9OmApO1xuICAgICAgY29uc3QgcmVhbEJlYXRzID0gbWV0YWRhdGFcbiAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgKHN0ZXA6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSA9PlxuICAgICAgICAgICAgc3RlcC5sZXR0ZXIgJiYgIXN0ZXAuc2VxdWVuY2Vfc3RhcnRfcG9zaXRpb25cbiAgICAgICAgKTtcbiAgICAgIHJlYWxCZWF0cy5mb3JFYWNoKChzdGVwOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBibHVlQXR0cnMgPSBzdGVwLmJsdWVBdHRyaWJ1dGVzIGFzXG4gICAgICAgICAgfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICAgICAgICAgIHwgdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCByZWRBdHRycyA9IHN0ZXAucmVkQXR0cmlidXRlcyBhc1xuICAgICAgICAgIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICAgICAgICB8IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgYmx1ZU1vdGlvbiA9IGJsdWVBdHRycz8ubW90aW9uVHlwZSB8fCBcInVua25vd25cIjtcbiAgICAgICAgY29uc3QgcmVkTW90aW9uID0gcmVkQXR0cnM/Lm1vdGlvblR5cGUgfHwgXCJ1bmtub3duXCI7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGAgIEJlYXQgJHtpbmRleCArIDF9ICgke3N0ZXAubGV0dGVyfSk6IGJsdWU9JHtibHVlTW90aW9ufSwgcmVkPSR7cmVkTW90aW9ufWBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBg4p2MIFtVTklGSUVEIE1FVEFEQVRBXSBGYWlsZWQgdG8gZXh0cmFjdCBtZXRhZGF0YSBmb3IgJHtzZXF1ZW5jZU5hbWV9OmAsXG4gICAgICAgIGVycm9yXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBFeHRlbmQgV2luZG93IGludGVyZmFjZSBmb3IgZGVidWcgZnVuY3Rpb25cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgZXh0cmFjdFBuZ01ldGFkYXRhPzogdHlwZW9mIFBuZ01ldGFkYXRhRXh0cmFjdG9yLmRlYnVnU2VxdWVuY2VNZXRhZGF0YTtcbiAgfVxufVxuXG4vLyBHbG9iYWwgdXRpbGl0eSBmdW5jdGlvbiBmb3IgZWFzeSBkZWJ1Z2dpbmcgb2YgdW5pZmllZCBtZXRhZGF0YSAoYnJvd3NlciBvbmx5KVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgd2luZG93LmV4dHJhY3RQbmdNZXRhZGF0YSA9IFBuZ01ldGFkYXRhRXh0cmFjdG9yLmRlYnVnU2VxdWVuY2VNZXRhZGF0YTtcbn1cbiJdLAogICJtYXBwaW5ncyI6ICJBQWFPLGFBQU0scUJBQXFCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBTWhDLGFBQWEsZ0JBQ1gsVUFDb0M7QUFDcEMsUUFBSTtBQUVGLFlBQU0sV0FBVyxNQUFNLE1BQU0sUUFBUTtBQUNyQyxVQUFJLENBQUMsU0FBUyxJQUFJO0FBQ2hCLGNBQU0sSUFBSTtBQUFBLFVBQ1IsNkJBQTZCLFNBQVMsTUFBTSxJQUFJLFNBQVMsVUFBVTtBQUFBLFFBQ3JFO0FBQUEsTUFDRjtBQUVBLFlBQU0sY0FBYyxNQUFNLFNBQVMsWUFB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
