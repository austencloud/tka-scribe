const DEBUG_MODE = typeof window !== "undefined" && window.location.search.includes("debug=foldable");
const FOLDABLE_DEVICE_SPECS = {
  zfold3: {
    models: ["SM-F926"],
    foldedDimensions: {
      width: { min: 350, max: 400 },
      height: { min: 800, max: 900 }
    },
    unfoldedDimensions: {
      width: { min: 700, max: 800 },
      height: { min: 800, max: 900 }
    }
  },
  zfold4: {
    models: ["SM-F936"],
    foldedDimensions: {
      width: { min: 350, max: 400 },
      height: { min: 800, max: 900 }
    },
    unfoldedDimensions: {
      width: { min: 700, max: 800 },
      height: { min: 800, max: 900 }
    }
  },
  zfold5: {
    models: ["SM-F946"],
    foldedDimensions: {
      width: { min: 350, max: 400 },
      height: { min: 800, max: 900 }
    },
    unfoldedDimensions: {
      width: { min: 700, max: 820 },
      height: { min: 800, max: 920 }
    }
  },
  zfold6: {
    models: ["SM-F956"],
    // Example model, update if needed
    foldedDimensions: {
      width: { min: 350, max: 410 },
      height: { min: 800, max: 950 }
    },
    // Estimated
    unfoldedDimensions: {
      width: { min: 800, max: 850 },
      height: { min: 680, max: 750 }
    }
    // Based on previous user log
  }
  // Add other known foldable specs here (e.g., Pixel Fold)
};
export function detectFoldableDevice() {
  const manualOverride = checkManualOverride();
  if (manualOverride) {
    if (DEBUG_MODE)
      console.log("Foldable Detect: Using Manual Override", manualOverride);
    return manualOverride;
  }
  const finalResult = {
    isFoldable: false,
    isUnfolded: false,
    foldableType: "unknown",
    confidence: 0,
    detectionMethod: "none"
  };
  if (typeof window === "undefined" || typeof navigator === "undefined") {
    console.warn("Foldable Detect: Cannot run outside browser environment.");
    return finalResult;
  }
  const ua = navigator.userAgent;
  const windowW = window.innerWidth;
  const windowH = window.innerHeight;
  const pixelRatio = window.devicePixelRatio;
  const aspectRatio = windowW / windowH;
  if (DEBUG_MODE) {
    console.log("Foldable Detect: UA:", ua);
    console.log("Foldable Detect: Window WxH:", windowW, "x", windowH);
    console.log("Foldable Detect: DPR:", pixelRatio);
    console.log("Foldable Detect: Aspect Ratio:", aspectRatio.toFixed(3));
  }
  const specMatchFound = checkAgainstDeviceSpecs(
    ua,
    windowW,
    windowH,
    finalResult
  );
  if (specMatchFound) {
    if (DEBUG_MODE)
      console.log("Foldable Detect: Result from Spec Match", finalResult);
    saveDetectionResult(finalResult);
    return finalResult;
  }
  const isScreenSpanning = window.matchMedia("(screen-spanning: single-fold-vertical)").matches || window.matchMedia("(screen-spanning: single-fold-horizontal)").matches;
  let segmentCount = 0;
  try {
    if ("getWindowSegments" in navigator && typeof navigator.getWindowSegments === "function") {
      segmentCount = navigator.getWindowSegments().length;
    }
  } catch (e) {
    if (DEBUG_MODE) console.warn("Error accessing getWindowSegments", e);
  }
  let viewportSegments;
  try {
    if (window.visualViewport && "segments" in window.visualViewport) {
      viewportSegments = window.visualViewport.segments;
    }
  } catch (e) {
    if (DEBUG_MODE) console.warn("Error accessing visualViewport.segments", e);
  }
  const hasSegments = segmentCount > 1 || viewportSegments && viewportSegments.length > 1;
  if (isScreenSpanning || hasSegments) {
    if (DEBUG_MODE)
      console.log("Foldable Detect: Detected via Spanning/Segments API");
    finalResult.isFoldable = true;
    finalResult.confidence = 0.8;
    finalResult.detectionMethod = isScreenSpanning ? "mediaQuery" : segmentCount > 1 ? "getWindowSegments" : "visualViewport";
    finalResult.isUnfolded = aspectRatio > 0.8 && aspectRatio < 1.3;
    finalResult.foldableType = /galaxy z/i.test(ua) ? "zfold" : "other";
    if (DEBUG_MODE)
      console.log("Foldable Detect: Result from API Match", finalResult);
    saveDetectionResult(finalResult);
    return finalResult;
  }
  const isLikelyDesktopUA = /Windows NT|Macintosh|Linux x86_64/i.test(ua) && !/Android|iPhone|iPad|iPod|Mobile/i.test(ua);
  if (isLikelyDesktopUA) {
    if (DEBUG_MODE)
      console.log(
        "Foldable Detect: Detected standard desktop platform via UA. Not foldable."
      );
    return finalResult;
  }
  if (DEBUG_MODE)
    console.log(
      "Foldable Detect: No API/Desktop match, trying generic dimension heuristic..."
    );
  if (windowW > 600 && aspectRatio > 0.8 && aspectRatio < 1.3 && pixelRatio > 1.5) {
    if (DEBUG_MODE)
      console.log(
        "Foldable Detect: Generic dimension heuristic PASSED (with pixelRatio check)."
      );
    finalResult.isFoldable = true;
    finalResult.isUnfolded = true;
    finalResult.confidence = 0.5;
    finalResult.detectionMethod = "GenericDimensionsPixelRatio";
    finalResult.foldableType = /galaxy z/i.test(ua) ? "zfold" : "other";
  } else {
    if (DEBUG_MODE)
      console.log("Foldable Detect: Generic dimension heuristic FAILED.");
  }
  if (DEBUG_MODE && finalResult.isFoldable) {
    console.log(
      "Foldable Detect: Result from Dimension Heuristic",
      finalResult
    );
  } else if (DEBUG_MODE && !finalResult.isFoldable) {
    console.log("Foldable Detect: Final Result - Not Foldable");
  }
  saveDetectionResult(finalResult);
  return finalResult;
}
function checkManualOverride() {
  if (typeof window === "undefined" || typeof localStorage === "undefined")
    return null;
  try {
    const override = localStorage.getItem("foldableDeviceOverride");
    if (override) {
      const settings = JSON.parse(override);
      if (typeof settings.isFoldable === "boolean" && typeof settings.isUnfolded === "boolean") {
        return {
          isFoldable: settings.isFoldable,
          foldableType: settings.foldableType || "unknown",
          isUnfolded: settings.isUnfolded,
          confidence: 1,
          // Max confidence for manual override
          detectionMethod: "ManualOverride"
        };
      }
    }
  } catch (e) {
    if (DEBUG_MODE) console.error("Error checking for manual override:", e);
  }
  return null;
}
function saveDetectionResult(result) {
  if (typeof window === "undefined" || typeof localStorage === "undefined")
    return;
  if (!result.isFoldable || result.confidence < 0.6) return;
  try {
    const dataToSave = {
      ...result,
      timestamp: Date.now(),
      width: window.innerWidth,
      // Save dimensions at time of detection
      height: window.innerHeight
    };
    localStorage.setItem("foldableDeviceState", JSON.stringify(dataToSave));
    if (DEBUG_MODE)
      console.log("Foldable Detect: Saved state to localStorage", dataToSave);
  } catch (e) {
    if (DEBUG_MODE) console.error("Error saving detection state:", e);
  }
}
function checkAgainstDeviceSpecs(ua, width, height, result) {
  for (const [deviceKey, specs] of Object.entries(FOLDABLE_DEVICE_SPECS)) {
    const isMatchingModel = specs.models.some((model) => ua.includes(model));
    if (isMatchingModel) {
      if (DEBUG_MODE)
        console.log(
          `Foldable Detect: Spec Match - Found model match for ${deviceKey}`
        );
      result.isFoldable = true;
      result.foldableType = deviceKey.startsWith("zfold") ? "zfold" : "other";
      result.confidence = 0.9;
      result.detectionMethod = "DeviceSpecMatch";
      const { min: minWUnfolded, max: maxWUnfolded } = specs.unfoldedDimensions.width;
      const { min: minHUnfolded, max: maxHUnfolded } = specs.unfoldedDimensions.height;
      const isUnfoldedMatch = width >= minWUnfolded && width <= maxWUnfolded && height >= minHUnfolded && height <= maxHUnfolded || height >= minWUnfolded && height <= maxWUnfolded && width >= minHUnfolded && width <= maxHUnfolded;
      result.isUnfolded = isUnfoldedMatch;
      if (DEBUG_MODE)
        console.log(
          `Foldable Detect: Spec Match - Unfolded state: ${result.isUnfolded}`
        );
      return true;
    }
  }
  if (DEBUG_MODE)
    console.log("Foldable Detect: Spec Match - No matching model found.");
  return false;
}
export const FoldableDeviceUtils = {
  /**
   * Sets a manual override in localStorage for testing purposes.
   * Requires page reload to take effect.
   */
  setManualOverride(settings) {
    if (typeof localStorage !== "undefined") {
      localStorage.setItem("foldableDeviceOverride", JSON.stringify(settings));
      if (DEBUG_MODE) console.log("Foldable Utils: Set Override", settings);
    } else {
      console.warn(
        "Foldable Utils: Cannot set override, localStorage not available."
      );
    }
  },
  /**
   * Clears any manual override from localStorage.
   * Requires page reload to take effect.
   */
  clearManualOverride() {
    if (typeof localStorage !== "undefined") {
      localStorage.removeItem("foldableDeviceOverride");
      if (DEBUG_MODE) console.log("Foldable Utils: Cleared Override");
    } else {
      console.warn(
        "Foldable Utils: Cannot clear override, localStorage not available."
      );
    }
  },
  /**
   * Forces a re-run of the detection logic.
   * @returns {FoldableDetectionResult} The latest detection result.
   */
  refreshDetection() {
    if (DEBUG_MODE) console.log("Foldable Utils: Refreshing detection...");
    return detectFoldableDevice();
  },
  /**
   * Gathers various pieces of information useful for debugging detection issues.
   * @returns {object} An object containing debug information.
   */
  getDebugInfo: () => {
    if (typeof window === "undefined" || typeof navigator === "undefined") {
      return { error: "Cannot get debug info outside browser environment." };
    }
    const currentDetection = detectFoldableDevice();
    const hasManualOverride = localStorage.getItem("foldableDeviceOverride") !== null;
    let apiChecks = {};
    try {
      apiChecks = {
        isScreenSpanning: window.matchMedia("(screen-spanning: single-fold-vertical)").matches || window.matchMedia("(screen-spanning: single-fold-horizontal)").matches,
        getWindowSegmentsLength: "getWindowSegments" in navigator && typeof navigator.getWindowSegments === "function" ? navigator.getWindowSegments().length : "N/A",
        visualViewportSegmentsLength: window.visualViewport && "segments" in window.visualViewport ? window.visualViewport.segments?.length : "N/A"
      };
    } catch (e) {
      if (DEBUG_MODE) console.error("Error getting API check info:", e);
    }
    return {
      currentDetection,
      hasManualOverride,
      windowDimensions: {
        width: window.innerWidth,
        height: window.innerHeight,
        pixelRatio: window.devicePixelRatio,
        aspectRatio: (window.innerWidth / window.innerHeight).toFixed(3)
      },
      screenDimensions: {
        width: window.screen.width,
        height: window.screen.height,
        availWidth: window.screen.availWidth,
        availHeight: window.screen.availHeight
      },
      userAgent: navigator.userAgent,
      apiChecks
    };
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL2NvbXBvbmVudHMvY29uc3RydWN0L29wdGlvbi1waWNrZXIvdXRpbHMvZGV2aWNlRGV0ZWN0aW9uLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIEVuaGFuY2VkIGZvbGRhYmxlIGRldmljZSBkZXRlY3Rpb24gdXRpbGl0eVxuICogUHJvdmlkZXMgY29tcHJlaGVuc2l2ZSBkZXRlY3Rpb24gZm9yIGZvbGRhYmxlIGRldmljZXMgd2l0aCBhIGZvY3VzIG9uIFNhbXN1bmcgWiBGb2xkIHNlcmllc1xuICovXG5cbi8vIC0tLSBDb25zdGFudHMgLS0tXG4vLyBFbmFibGUgZGVidWcgbG9nZ2luZyB2aWEgVVJMIHBhcmFtZXRlciAoZS5nLiwgP2RlYnVnPWZvbGRhYmxlKVxuY29uc3QgREVCVUdfTU9ERSA9XG4gIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgd2luZG93LmxvY2F0aW9uLnNlYXJjaC5pbmNsdWRlcyhcImRlYnVnPWZvbGRhYmxlXCIpO1xuXG4vLyBEZXZpY2Ugc3BlY2lmaWNhdGlvbiBjb25maWd1cmF0aW9uXG4vLyBOT1RFOiBLZWVwIHRoZXNlIGRpbWVuc2lvbnMgdXBkYXRlZCBhcyBuZXcgZGV2aWNlcyBhcmUgcmVsZWFzZWQgb3IgdGVzdGVkXG5jb25zdCBGT0xEQUJMRV9ERVZJQ0VfU1BFQ1MgPSB7XG4gIHpmb2xkMzoge1xuICAgIG1vZGVsczogW1wiU00tRjkyNlwiXSxcbiAgICBmb2xkZWREaW1lbnNpb25zOiB7XG4gICAgICB3aWR0aDogeyBtaW46IDM1MCwgbWF4OiA0MDAgfSxcbiAgICAgIGhlaWdodDogeyBtaW46IDgwMCwgbWF4OiA5MDAgfSxcbiAgICB9LFxuICAgIHVuZm9sZGVkRGltZW5zaW9uczoge1xuICAgICAgd2lkdGg6IHsgbWluOiA3MDAsIG1heDogODAwIH0sXG4gICAgICBoZWlnaHQ6IHsgbWluOiA4MDAsIG1heDogOTAwIH0sXG4gICAgfSxcbiAgfSxcbiAgemZvbGQ0OiB7XG4gICAgbW9kZWxzOiBbXCJTTS1GOTM2XCJdLFxuICAgIGZvbGRlZERpbWVuc2lvbnM6IHtcbiAgICAgIHdpZHRoOiB7IG1pbjogMzUwLCBtYXg6IDQwMCB9LFxuICAgICAgaGVpZ2h0OiB7IG1pbjogODAwLCBtYXg6IDkwMCB9LFxuICAgIH0sXG4gICAgdW5mb2xkZWREaW1lbnNpb25zOiB7XG4gICAgICB3aWR0aDogeyBtaW46IDcwMCwgbWF4OiA4MDAgfSxcbiAgICAgIGhlaWdodDogeyBtaW46IDgwMCwgbWF4OiA5MDAgfSxcbiAgICB9LFxuICB9LFxuICB6Zm9sZDU6IHtcbiAgICBtb2RlbHM6IFtcIlNNLUY5NDZcIl0sXG4gICAgZm9sZGVkRGltZW5zaW9uczoge1xuICAgICAgd2lkdGg6IHsgbWluOiAzNTAsIG1heDogNDAwIH0sXG4gICAgICBoZWlnaHQ6IHsgbWluOiA4MDAsIG1heDogOTAwIH0sXG4gICAgfSxcbiAgICB1bmZvbGRlZERpbWVuc2lvbnM6IHtcbiAgICAgIHdpZHRoOiB7IG1pbjogNzAwLCBtYXg6IDgyMCB9LFxuICAgICAgaGVpZ2h0OiB7IG1pbjogODAwLCBtYXg6IDkyMCB9LFxuICAgIH0sXG4gIH0sXG4gIHpmb2xkNjoge1xuICAgIG1vZGVsczogW1wiU00tRjk1NlwiXSwgLy8gRXhhbXBsZSBtb2RlbCwgdXBkYXRlIGlmIG5lZWRlZFxuICAgIGZvbGRlZERpbWVuc2lvbnM6IHtcbiAgICAgIHdpZHRoOiB7IG1pbjogMzUwLCBtYXg6IDQxMCB9LFxuICAgICAgaGVpZ2h0OiB7IG1pbjogODAwLCBtYXg6IDk1MCB9LFxuICAgIH0sIC8vIEVzdGltYXRlZFxuICAgIHVuZm9sZGVkRGltZW5zaW9uczoge1xuICAgICAgd2lkdGg6IHsgbWluOiA4MDAsIG1heDogODUwIH0sXG4gICAgICBoZWlnaHQ6IHsgbWluOiA2ODAsIG1heDogNzUwIH0sXG4gICAgfSwgLy8gQmFzZWQgb24gcHJldmlvdXMgdXNlciBsb2dcbiAgfSxcbiAgLy8gQWRkIG90aGVyIGtub3duIGZvbGRhYmxlIHNwZWNzIGhlcmUgKGUuZy4sIFBpeGVsIEZvbGQpXG59O1xuXG4vLyAtLS0gSW50ZXJmYWNlcyAtLS1cbmV4cG9ydCBpbnRlcmZhY2UgRm9sZGFibGVEZXRlY3Rpb25SZXN1bHQge1xuICBpc0ZvbGRhYmxlOiBib29sZWFuO1xuICBpc1VuZm9sZGVkOiBib29sZWFuO1xuICBmb2xkYWJsZVR5cGU6IFwiemZvbGRcIiB8IFwib3RoZXJcIiB8IFwidW5rbm93blwiO1xuICBjb25maWRlbmNlOiBudW1iZXI7IC8vIENvbmZpZGVuY2Ugc2NvcmUgKDAgdG8gMSlcbiAgZGV0ZWN0aW9uTWV0aG9kPzogc3RyaW5nOyAvLyBIb3cgdGhlIGRldGVjdGlvbiB3YXMgbWFkZVxufVxuXG4vLyAtLS0gTWFpbiBEZXRlY3Rpb24gRnVuY3Rpb24gLS0tXG4vKipcbiAqIERldGVjdHMgaWYgdGhlIGN1cnJlbnQgZGV2aWNlIGlzIGxpa2VseSBmb2xkYWJsZSBhbmQgaXRzIHN0YXRlLlxuICogUHJpb3JpdGl6ZXMgbWFudWFsIG92ZXJyaWRlcywgdGhlbiBkZXZpY2Ugc3BlYyBtYXRjaGluZywgdGhlbiBBUElzLFxuICogdGhlbiBVc2VyIEFnZW50IGNoZWNrcywgYW5kIGZpbmFsbHkgYSBkaW1lbnNpb24gaGV1cmlzdGljIGFzIGEgZmFsbGJhY2suXG4gKiBAcmV0dXJucyB7Rm9sZGFibGVEZXRlY3Rpb25SZXN1bHR9IE9iamVjdCBjb250YWluaW5nIGRldGVjdGlvbiByZXN1bHRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0Rm9sZGFibGVEZXZpY2UoKTogRm9sZGFibGVEZXRlY3Rpb25SZXN1bHQge1xuICAvLyBDaGVjayBmb3IgbWFudWFsIG92ZXJyaWRlIGZpcnN0IChtb3N0IHJlbGlhYmxlIGlmIHNldClcbiAgY29uc3QgbWFudWFsT3ZlcnJpZGUgPSBjaGVja01hbnVhbE92ZXJyaWRlKCk7XG4gIGlmIChtYW51YWxPdmVycmlkZSkge1xuICAgIGlmIChERUJVR19NT0RFKVxuICAgICAgY29uc29sZS5sb2coXCJGb2xkYWJsZSBEZXRlY3Q6IFVzaW5nIE1hbnVhbCBPdmVycmlkZVwiLCBtYW51YWxPdmVycmlkZSk7XG4gICAgcmV0dXJuIG1hbnVhbE92ZXJyaWRlO1xuICB9XG5cbiAgLy8gRGVmYXVsdCByZXN1bHQgKG5vdCBmb2xkYWJsZSlcbiAgY29uc3QgZmluYWxSZXN1bHQ6IEZvbGRhYmxlRGV0ZWN0aW9uUmVzdWx0ID0ge1xuICAgIGlzRm9sZGFibGU6IGZhbHNlLFxuICAgIGlzVW5mb2xkZWQ6IGZhbHNlLFxuICAgIGZvbGRhYmxlVHlwZTogXCJ1bmtub3duXCIsXG4gICAgY29uZmlkZW5jZTogMCxcbiAgICBkZXRlY3Rpb25NZXRob2Q6IFwibm9uZVwiLFxuICB9O1xuXG4gIC8vIEVuc3VyZSBjb2RlIG9ubHkgcnVucyBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnNvbGUud2FybihcIkZvbGRhYmxlIERldGVjdDogQ2Fubm90IHJ1biBvdXRzaWRlIGJyb3dzZXIgZW52aXJvbm1lbnQuXCIpO1xuICAgIHJldHVybiBmaW5hbFJlc3VsdDtcbiAgfVxuXG4gIC8vIC0tLSBHYXRoZXIgRW52aXJvbm1lbnQgSW5mbyAtLS1cbiAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICBjb25zdCB3aW5kb3dXID0gd2luZG93LmlubmVyV2lkdGg7XG4gIGNvbnN0IHdpbmRvd0ggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIGNvbnN0IHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aW5kb3dXIC8gd2luZG93SDtcblxuICBpZiAoREVCVUdfTU9ERSkge1xuICAgIGNvbnNvbGUubG9nKFwiRm9sZGFibGUgRGV0ZWN0OiBVQTpcIiwgdWEpO1xuICAgIGNvbnNvbGUubG9nKFwiRm9sZGFibGUgRGV0ZWN0OiBXaW5kb3cgV3hIOlwiLCB3aW5kb3dXLCBcInhcIiwgd2luZG93SCk7XG4gICAgY29uc29sZS5sb2coXCJGb2xkYWJsZSBEZXRlY3Q6IERQUjpcIiwgcGl4ZWxSYXRpbyk7XG4gICAgY29uc29sZS5sb2coXCJGb2xkYWJsZSBEZXRlY3Q6IEFzcGVjdCBSYXRpbzpcIiwgYXNwZWN0UmF0aW8udG9GaXhlZCgzKSk7XG4gIH1cblxuICAvLyAtLS0gRGV0ZWN0aW9uIExvZ2ljIFBpcGVsaW5lIC0tLVxuXG4gIC8vIDEuIERldmljZSBTcGVjaWZpY2F0aW9uIE1hdGNoaW5nIChIaWdoIENvbmZpZGVuY2UpXG4gIGNvbnN0IHNwZWNNYXRjaEZvdW5kID0gY2hlY2tBZ2FpbnN0RGV2aWNlU3BlY3MoXG4gICAgdWEsXG4gICAgd2luZG93VyxcbiAgICB3aW5kb3dILFxuICAgIGZpbmFsUmVzdWx0XG4gICk7XG4gIGlmIChzcGVjTWF0Y2hGb3VuZCkge1xuICAgIGlmIChERUJVR19NT0RFKVxuICAgICAgY29uc29sZS5sb2coXCJGb2xkYWJsZSBEZXRlY3Q6IFJlc3VsdCBmcm9tIFNwZWMgTWF0Y2hcIiwgZmluYWxSZXN1bHQpO1xuICAgIHNhdmVEZXRlY3Rpb25SZXN1bHQoZmluYWxSZXN1bHQpOyAvLyBTYXZlIGNvbmZpZGVudCByZXN1bHRcbiAgICByZXR1cm4gZmluYWxSZXN1bHQ7XG4gIH1cblxuICAvLyAyLiBTY3JlZW4gU3Bhbm5pbmcgLyBXaW5kb3cgU2VnbWVudHMgQVBJcyAoSGlnaCBDb25maWRlbmNlKVxuICBjb25zdCBpc1NjcmVlblNwYW5uaW5nID1cbiAgICB3aW5kb3cubWF0Y2hNZWRpYShcIihzY3JlZW4tc3Bhbm5pbmc6IHNpbmdsZS1mb2xkLXZlcnRpY2FsKVwiKS5tYXRjaGVzIHx8XG4gICAgd2luZG93Lm1hdGNoTWVkaWEoXCIoc2NyZWVuLXNwYW5uaW5nOiBzaW5nbGUtZm9sZC1ob3Jpem9udGFsKVwiKS5tYXRjaGVzO1xuICBsZXQgc2VnbWVudENvdW50ID0gMDtcbiAgdHJ5IHtcbiAgICAvLyBFeHBlcmltZW50YWwgQVBJXG4gICAgaWYgKFxuICAgICAgXCJnZXRXaW5kb3dTZWdtZW50c1wiIGluIG5hdmlnYXRvciAmJlxuICAgICAgdHlwZW9mIG5hdmlnYXRvci5nZXRXaW5kb3dTZWdtZW50cyA9PT0gXCJmdW5jdGlvblwiXG4gICAgKSB7XG4gICAgICBzZWdtZW50Q291bnQgPSAoXG4gICAgICAgIG5hdmlnYXRvciBhcyB7IGdldFdpbmRvd1NlZ21lbnRzKCk6IHVua25vd25bXSB9XG4gICAgICApLmdldFdpbmRvd1NlZ21lbnRzKCkubGVuZ3RoO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChERUJVR19NT0RFKSBjb25zb2xlLndhcm4oXCJFcnJvciBhY2Nlc3NpbmcgZ2V0V2luZG93U2VnbWVudHNcIiwgZSk7XG4gIH1cblxuICBsZXQgdmlld3BvcnRTZWdtZW50czogdW5rbm93bltdIHwgdW5kZWZpbmVkO1xuICB0cnkge1xuICAgIC8vIEV4cGVyaW1lbnRhbCBBUElcbiAgICBpZiAod2luZG93LnZpc3VhbFZpZXdwb3J0ICYmIFwic2VnbWVudHNcIiBpbiB3aW5kb3cudmlzdWFsVmlld3BvcnQpIHtcbiAgICAgIHZpZXdwb3J0U2VnbWVudHMgPSAod2luZG93LnZpc3VhbFZpZXdwb3J0IGFzIHsgc2VnbWVudHM/OiB1bmtub3duW10gfSlcbiAgICAgICAgLnNlZ21lbnRzO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChERUJVR19NT0RFKSBjb25zb2xlLndhcm4oXCJFcnJvciBhY2Nlc3NpbmcgdmlzdWFsVmlld3BvcnQuc2VnbWVudHNcIiwgZSk7XG4gIH1cblxuICBjb25zdCBoYXNTZWdtZW50cyA9XG4gICAgc2VnbWVudENvdW50ID4gMSB8fCAodmlld3BvcnRTZWdtZW50cyAmJiB2aWV3cG9ydFNlZ21lbnRzLmxlbmd0aCA+IDEpO1xuXG4gIGlmIChpc1NjcmVlblNwYW5uaW5nIHx8IGhhc1NlZ21lbnRzKSB7XG4gICAgaWYgKERFQlVHX01PREUpXG4gICAgICBjb25zb2xlLmxvZyhcIkZvbGRhYmxlIERldGVjdDogRGV0ZWN0ZWQgdmlhIFNwYW5uaW5nL1NlZ21lbnRzIEFQSVwiKTtcbiAgICBmaW5hbFJlc3VsdC5pc0ZvbGRhYmxlID0gdHJ1ZTtcbiAgICBmaW5hbFJlc3VsdC5jb25maWRlbmNlID0gMC44OyAvLyBGYWlybHkgaGlnaCBjb25maWRlbmNlXG4gICAgZmluYWxSZXN1bHQuZGV0ZWN0aW9uTWV0aG9kID0gaXNTY3JlZW5TcGFubmluZ1xuICAgICAgPyBcIm1lZGlhUXVlcnlcIlxuICAgICAgOiBzZWdtZW50Q291bnQgPiAxXG4gICAgICAgID8gXCJnZXRXaW5kb3dTZWdtZW50c1wiXG4gICAgICAgIDogXCJ2aXN1YWxWaWV3cG9ydFwiO1xuICAgIC8vIEhldXJpc3RpYyBmb3IgdW5mb2xkZWQgc3RhdGUgd2hlbiBBUEkgZGV0ZWN0cyBmb2xkYWJpbGl0eVxuICAgIGZpbmFsUmVzdWx0LmlzVW5mb2xkZWQgPSBhc3BlY3RSYXRpbyA+IDAuOCAmJiBhc3BlY3RSYXRpbyA8IDEuMzsgLy8gQXNzdW1lIG5lYXJseSBzcXVhcmUgaXMgdW5mb2xkZWRcbiAgICBmaW5hbFJlc3VsdC5mb2xkYWJsZVR5cGUgPSAvZ2FsYXh5IHovaS50ZXN0KHVhKSA/IFwiemZvbGRcIiA6IFwib3RoZXJcIjsgLy8gVUEgaGludCBmb3IgdHlwZVxuXG4gICAgaWYgKERFQlVHX01PREUpXG4gICAgICBjb25zb2xlLmxvZyhcIkZvbGRhYmxlIERldGVjdDogUmVzdWx0IGZyb20gQVBJIE1hdGNoXCIsIGZpbmFsUmVzdWx0KTtcbiAgICBzYXZlRGV0ZWN0aW9uUmVzdWx0KGZpbmFsUmVzdWx0KTtcbiAgICByZXR1cm4gZmluYWxSZXN1bHQ7XG4gIH1cblxuICAvLyAzLiBVc2VyIEFnZW50IFBsYXRmb3JtIENoZWNrIChFeGNsdWRlIERlc2t0b3BzKVxuICBjb25zdCBpc0xpa2VseURlc2t0b3BVQSA9XG4gICAgL1dpbmRvd3MgTlR8TWFjaW50b3NofExpbnV4IHg4Nl82NC9pLnRlc3QodWEpICYmXG4gICAgIS9BbmRyb2lkfGlQaG9uZXxpUGFkfGlQb2R8TW9iaWxlL2kudGVzdCh1YSk7XG4gIGlmIChpc0xpa2VseURlc2t0b3BVQSkge1xuICAgIC8vIElmIFVBIGNsZWFybHkgaW5kaWNhdGVzIGEgc3RhbmRhcmQgZGVza3RvcCBPUywgaXQncyBub3QgYSBmb2xkYWJsZSBwaG9uZS5cbiAgICBpZiAoREVCVUdfTU9ERSlcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBcIkZvbGRhYmxlIERldGVjdDogRGV0ZWN0ZWQgc3RhbmRhcmQgZGVza3RvcCBwbGF0Zm9ybSB2aWEgVUEuIE5vdCBmb2xkYWJsZS5cIlxuICAgICAgKTtcbiAgICByZXR1cm4gZmluYWxSZXN1bHQ7IC8vIFJldHVybiBkZWZhdWx0IChpc0ZvbGRhYmxlOiBmYWxzZSlcbiAgfVxuXG4gIC8vIDQuIEdlbmVyaWMgRGltZW5zaW9uICsgUGl4ZWwgUmF0aW8gSGV1cmlzdGljIChMb3dlciBDb25maWRlbmNlIEZhbGxiYWNrKVxuICAvLyBPbmx5IGF0dGVtcHQgaWYgbm90IGlkZW50aWZpZWQgYXMgZGVza3RvcCBhbmQgQVBJcyBkaWRuJ3QgY29uZmlybS5cbiAgaWYgKERFQlVHX01PREUpXG4gICAgY29uc29sZS5sb2coXG4gICAgICBcIkZvbGRhYmxlIERldGVjdDogTm8gQVBJL0Rlc2t0b3AgbWF0Y2gsIHRyeWluZyBnZW5lcmljIGRpbWVuc2lvbiBoZXVyaXN0aWMuLi5cIlxuICAgICk7XG4gIC8vIENoZWNrIGZvciBzb21ld2hhdCBzcXVhcmUgYXNwZWN0IHJhdGlvIEFORCBoaWdoIHBpeGVsIGRlbnNpdHlcbiAgaWYgKFxuICAgIHdpbmRvd1cgPiA2MDAgJiZcbiAgICBhc3BlY3RSYXRpbyA+IDAuOCAmJlxuICAgIGFzcGVjdFJhdGlvIDwgMS4zICYmXG4gICAgcGl4ZWxSYXRpbyA+IDEuNVxuICApIHtcbiAgICBpZiAoREVCVUdfTU9ERSlcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBcIkZvbGRhYmxlIERldGVjdDogR2VuZXJpYyBkaW1lbnNpb24gaGV1cmlzdGljIFBBU1NFRCAod2l0aCBwaXhlbFJhdGlvIGNoZWNrKS5cIlxuICAgICAgKTtcbiAgICBmaW5hbFJlc3VsdC5pc0ZvbGRhYmxlID0gdHJ1ZTtcbiAgICBmaW5hbFJlc3VsdC5pc1VuZm9sZGVkID0gdHJ1ZTsgLy8gQXNzdW1lIHVuZm9sZGVkIGlmIGRpbWVuc2lvbnMgbWF0Y2ggdGhpcyBoZXVyaXN0aWNcbiAgICBmaW5hbFJlc3VsdC5jb25maWRlbmNlID0gMC41OyAvLyBMb3dlciBjb25maWRlbmNlIGZvciBoZXVyaXN0aWNcbiAgICBmaW5hbFJlc3VsdC5kZXRlY3Rpb25NZXRob2QgPSBcIkdlbmVyaWNEaW1lbnNpb25zUGl4ZWxSYXRpb1wiO1xuICAgIGZpbmFsUmVzdWx0LmZvbGRhYmxlVHlwZSA9IC9nYWxheHkgei9pLnRlc3QodWEpID8gXCJ6Zm9sZFwiIDogXCJvdGhlclwiOyAvLyBTdGlsbCBjaGVjayBVQSBmb3IgdHlwZSBoaW50XG4gIH0gZWxzZSB7XG4gICAgaWYgKERFQlVHX01PREUpXG4gICAgICBjb25zb2xlLmxvZyhcIkZvbGRhYmxlIERldGVjdDogR2VuZXJpYyBkaW1lbnNpb24gaGV1cmlzdGljIEZBSUxFRC5cIik7XG4gICAgLy8gS2VlcCBkZWZhdWx0IGZpbmFsUmVzdWx0IChpc0ZvbGRhYmxlOiBmYWxzZSlcbiAgfVxuXG4gIC8vIC0tLSBMb2cgRmluYWwgUmVzdWx0IGFuZCBSZXR1cm4gLS0tXG4gIGlmIChERUJVR19NT0RFICYmIGZpbmFsUmVzdWx0LmlzRm9sZGFibGUpIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIFwiRm9sZGFibGUgRGV0ZWN0OiBSZXN1bHQgZnJvbSBEaW1lbnNpb24gSGV1cmlzdGljXCIsXG4gICAgICBmaW5hbFJlc3VsdFxuICAgICk7XG4gIH0gZWxzZSBpZiAoREVCVUdfTU9ERSAmJiAhZmluYWxSZXN1bHQuaXNGb2xkYWJsZSkge1xuICAgIGNvbnNvbGUubG9nKFwiRm9sZGFibGUgRGV0ZWN0OiBGaW5hbCBSZXN1bHQgLSBOb3QgRm9sZGFibGVcIik7XG4gIH1cblxuICBzYXZlRGV0ZWN0aW9uUmVzdWx0KGZpbmFsUmVzdWx0KTsgLy8gU2F2ZSBpZiBjb25maWRlbmNlIGlzIGhpZ2ggZW5vdWdoXG4gIHJldHVybiBmaW5hbFJlc3VsdDtcbn1cblxuLy8gLS0tIEhlbHBlciBGdW5jdGlvbnMgLS0tXG5cbi8qKlxuICogQ2hlY2tzIGxvY2FsU3RvcmFnZSBmb3IgYSBtYW51YWwgb3ZlcnJpZGUgc2V0dGluZy5cbiAqIEByZXR1cm5zIHtGb2xkYWJsZURldGVjdGlvblJlc3VsdCB8IG51bGx9IFRoZSBvdmVycmlkZSByZXN1bHQgb3IgbnVsbCBpZiBub3QgZm91bmQvaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tNYW51YWxPdmVycmlkZSgpOiBGb2xkYWJsZURldGVjdGlvblJlc3VsdCB8IG51bGwge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgbG9jYWxTdG9yYWdlID09PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybiBudWxsO1xuICB0cnkge1xuICAgIGNvbnN0IG92ZXJyaWRlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJmb2xkYWJsZURldmljZU92ZXJyaWRlXCIpO1xuICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgY29uc3Qgc2V0dGluZ3MgPSBKU09OLnBhcnNlKG92ZXJyaWRlKTtcbiAgICAgIC8vIEJhc2ljIHZhbGlkYXRpb24gb2Ygc3RvcmVkIHNldHRpbmdzXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBzZXR0aW5ncy5pc0ZvbGRhYmxlID09PSBcImJvb2xlYW5cIiAmJlxuICAgICAgICB0eXBlb2Ygc2V0dGluZ3MuaXNVbmZvbGRlZCA9PT0gXCJib29sZWFuXCJcbiAgICAgICkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzRm9sZGFibGU6IHNldHRpbmdzLmlzRm9sZGFibGUsXG4gICAgICAgICAgZm9sZGFibGVUeXBlOiBzZXR0aW5ncy5mb2xkYWJsZVR5cGUgfHwgXCJ1bmtub3duXCIsXG4gICAgICAgICAgaXNVbmZvbGRlZDogc2V0dGluZ3MuaXNVbmZvbGRlZCxcbiAgICAgICAgICBjb25maWRlbmNlOiAxLjAsIC8vIE1heCBjb25maWRlbmNlIGZvciBtYW51YWwgb3ZlcnJpZGVcbiAgICAgICAgICBkZXRlY3Rpb25NZXRob2Q6IFwiTWFudWFsT3ZlcnJpZGVcIixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoREVCVUdfTU9ERSkgY29uc29sZS5lcnJvcihcIkVycm9yIGNoZWNraW5nIGZvciBtYW51YWwgb3ZlcnJpZGU6XCIsIGUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFNhdmVzIGNvbmZpZGVudCBkZXRlY3Rpb24gcmVzdWx0cyB0byBsb2NhbFN0b3JhZ2UgKGlmIGZvbGRhYmxlIGFuZCBjb25maWRlbmNlID49IDAuNikuXG4gKiBAcGFyYW0ge0ZvbGRhYmxlRGV0ZWN0aW9uUmVzdWx0fSByZXN1bHQgLSBUaGUgZGV0ZWN0aW9uIHJlc3VsdCB0byBwb3RlbnRpYWxseSBzYXZlLlxuICovXG5mdW5jdGlvbiBzYXZlRGV0ZWN0aW9uUmVzdWx0KHJlc3VsdDogRm9sZGFibGVEZXRlY3Rpb25SZXN1bHQpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGxvY2FsU3RvcmFnZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICByZXR1cm47XG4gIC8vIE9ubHkgc2F2ZSByZWFzb25hYmx5IGNvbmZpZGVudCBmb2xkYWJsZSBkZXRlY3Rpb25zXG4gIGlmICghcmVzdWx0LmlzRm9sZGFibGUgfHwgcmVzdWx0LmNvbmZpZGVuY2UgPCAwLjYpIHJldHVybjtcblxuICB0cnkge1xuICAgIGNvbnN0IGRhdGFUb1NhdmUgPSB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsIC8vIFNhdmUgZGltZW5zaW9ucyBhdCB0aW1lIG9mIGRldGVjdGlvblxuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgfTtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImZvbGRhYmxlRGV2aWNlU3RhdGVcIiwgSlNPTi5zdHJpbmdpZnkoZGF0YVRvU2F2ZSkpO1xuICAgIGlmIChERUJVR19NT0RFKVxuICAgICAgY29uc29sZS5sb2coXCJGb2xkYWJsZSBEZXRlY3Q6IFNhdmVkIHN0YXRlIHRvIGxvY2FsU3RvcmFnZVwiLCBkYXRhVG9TYXZlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChERUJVR19NT0RFKSBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nIGRldGVjdGlvbiBzdGF0ZTpcIiwgZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgdGhlIFVzZXIgQWdlbnQgYW5kIGN1cnJlbnQgd2luZG93IGRpbWVuc2lvbnMgYWdhaW5zdCBrbm93biBmb2xkYWJsZSBkZXZpY2Ugc3BlY2lmaWNhdGlvbnMuXG4gKiBNb2RpZmllcyB0aGUgcGFzc2VkICdyZXN1bHQnIG9iamVjdCBkaXJlY3RseSBpZiBhIG1hdGNoIGlzIGZvdW5kLlxuICogQHBhcmFtIHtzdHJpbmd9IHVhIC0gVGhlIG5hdmlnYXRvci51c2VyQWdlbnQgc3RyaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gQ3VycmVudCB3aW5kb3cgaW5uZXJXaWR0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBDdXJyZW50IHdpbmRvdyBpbm5lckhlaWdodC5cbiAqIEBwYXJhbSB7Rm9sZGFibGVEZXRlY3Rpb25SZXN1bHR9IHJlc3VsdCAtIFRoZSByZXN1bHQgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGEgc3BlYyBtYXRjaCB3YXMgZm91bmQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gY2hlY2tBZ2FpbnN0RGV2aWNlU3BlY3MoXG4gIHVhOiBzdHJpbmcsXG4gIHdpZHRoOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyLFxuICByZXN1bHQ6IEZvbGRhYmxlRGV0ZWN0aW9uUmVzdWx0XG4pOiBib29sZWFuIHtcbiAgZm9yIChjb25zdCBbZGV2aWNlS2V5LCBzcGVjc10gb2YgT2JqZWN0LmVudHJpZXMoRk9MREFCTEVfREVWSUNFX1NQRUNTKSkge1xuICAgIC8vIENoZWNrIGlmIFVBIGNvbnRhaW5zIGFueSBvZiB0aGUga25vd24gbW9kZWwgc3RyaW5ncyBmb3IgdGhpcyBkZXZpY2VcbiAgICBjb25zdCBpc01hdGNoaW5nTW9kZWwgPSBzcGVjcy5tb2RlbHMuc29tZSgobW9kZWwpID0+IHVhLmluY2x1ZGVzKG1vZGVsKSk7XG5cbiAgICBpZiAoaXNNYXRjaGluZ01vZGVsKSB7XG4gICAgICBpZiAoREVCVUdfTU9ERSlcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYEZvbGRhYmxlIERldGVjdDogU3BlYyBNYXRjaCAtIEZvdW5kIG1vZGVsIG1hdGNoIGZvciAke2RldmljZUtleX1gXG4gICAgICAgICk7XG4gICAgICByZXN1bHQuaXNGb2xkYWJsZSA9IHRydWU7XG4gICAgICByZXN1bHQuZm9sZGFibGVUeXBlID0gZGV2aWNlS2V5LnN0YXJ0c1dpdGgoXCJ6Zm9sZFwiKSA/IFwiemZvbGRcIiA6IFwib3RoZXJcIjtcbiAgICAgIHJlc3VsdC5jb25maWRlbmNlID0gMC45OyAvLyBIaWdoIGNvbmZpZGVuY2UgZm9yIHNwZWNpZmljIG1vZGVsIG1hdGNoXG4gICAgICByZXN1bHQuZGV0ZWN0aW9uTWV0aG9kID0gXCJEZXZpY2VTcGVjTWF0Y2hcIjtcblxuICAgICAgLy8gQ2hlY2sgY3VycmVudCBkaW1lbnNpb25zIGFnYWluc3QgVU5GT0xERUQgc3BlY3MgKGFsbG93aW5nIGZvciBvcmllbnRhdGlvbiBzd2FwKVxuICAgICAgY29uc3QgeyBtaW46IG1pbldVbmZvbGRlZCwgbWF4OiBtYXhXVW5mb2xkZWQgfSA9XG4gICAgICAgIHNwZWNzLnVuZm9sZGVkRGltZW5zaW9ucy53aWR0aDtcbiAgICAgIGNvbnN0IHsgbWluOiBtaW5IVW5mb2xkZWQsIG1heDogbWF4SFVuZm9sZGVkIH0gPVxuICAgICAgICBzcGVjcy51bmZvbGRlZERpbWVuc2lvbnMuaGVpZ2h0O1xuXG4gICAgICBjb25zdCBpc1VuZm9sZGVkTWF0Y2ggPVxuICAgICAgICAod2lkdGggPj0gbWluV1VuZm9sZGVkICYmXG4gICAgICAgICAgd2lkdGggPD0gbWF4V1VuZm9sZGVkICYmXG4gICAgICAgICAgaGVpZ2h0ID49IG1pbkhVbmZvbGRlZCAmJlxuICAgICAgICAgIGhlaWdodCA8PSBtYXhIVW5mb2xkZWQpIHx8XG4gICAgICAgIChoZWlnaHQgPj0gbWluV1VuZm9sZGVkICYmXG4gICAgICAgICAgaGVpZ2h0IDw9IG1heFdVbmZvbGRlZCAmJlxuICAgICAgICAgIHdpZHRoID49IG1pbkhVbmZvbGRlZCAmJlxuICAgICAgICAgIHdpZHRoIDw9IG1heEhVbmZvbGRlZCk7XG5cbiAgICAgIHJlc3VsdC5pc1VuZm9sZGVkID0gaXNVbmZvbGRlZE1hdGNoO1xuICAgICAgaWYgKERFQlVHX01PREUpXG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGBGb2xkYWJsZSBEZXRlY3Q6IFNwZWMgTWF0Y2ggLSBVbmZvbGRlZCBzdGF0ZTogJHtyZXN1bHQuaXNVbmZvbGRlZH1gXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gU3RvcCBjaGVja2luZyBvbmNlIGEgbW9kZWwgbWF0Y2hlc1xuICAgIH1cbiAgfVxuICBpZiAoREVCVUdfTU9ERSlcbiAgICBjb25zb2xlLmxvZyhcIkZvbGRhYmxlIERldGVjdDogU3BlYyBNYXRjaCAtIE5vIG1hdGNoaW5nIG1vZGVsIGZvdW5kLlwiKTtcbiAgcmV0dXJuIGZhbHNlOyAvLyBObyBzcGVjIG1hdGNoIGZvdW5kXG59XG5cbi8vIC0tLSBVdGlsaXRpZXMgRXhwb3J0IC0tLVxuLyoqXG4gKiBQcm92aWRlcyBtZXRob2RzIGZvciBtYW51YWxseSBjb250cm9sbGluZyBvciBkZWJ1Z2dpbmcgZm9sZGFibGUgZGV0ZWN0aW9uLlxuICovXG5leHBvcnQgY29uc3QgRm9sZGFibGVEZXZpY2VVdGlscyA9IHtcbiAgLyoqXG4gICAqIFNldHMgYSBtYW51YWwgb3ZlcnJpZGUgaW4gbG9jYWxTdG9yYWdlIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICAgKiBSZXF1aXJlcyBwYWdlIHJlbG9hZCB0byB0YWtlIGVmZmVjdC5cbiAgICovXG4gIHNldE1hbnVhbE92ZXJyaWRlKHNldHRpbmdzOiB7XG4gICAgaXNGb2xkYWJsZTogYm9vbGVhbjtcbiAgICBmb2xkYWJsZVR5cGU6IFwiemZvbGRcIiB8IFwib3RoZXJcIiB8IFwidW5rbm93blwiO1xuICAgIGlzVW5mb2xkZWQ6IGJvb2xlYW47XG4gIH0pIHtcbiAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJmb2xkYWJsZURldmljZU92ZXJyaWRlXCIsIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSk7XG4gICAgICBpZiAoREVCVUdfTU9ERSkgY29uc29sZS5sb2coXCJGb2xkYWJsZSBVdGlsczogU2V0IE92ZXJyaWRlXCIsIHNldHRpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIkZvbGRhYmxlIFV0aWxzOiBDYW5ub3Qgc2V0IG92ZXJyaWRlLCBsb2NhbFN0b3JhZ2Ugbm90IGF2YWlsYWJsZS5cIlxuICAgICAgKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFycyBhbnkgbWFudWFsIG92ZXJyaWRlIGZyb20gbG9jYWxTdG9yYWdlLlxuICAgKiBSZXF1aXJlcyBwYWdlIHJlbG9hZCB0byB0YWtlIGVmZmVjdC5cbiAgICovXG4gIGNsZWFyTWFudWFsT3ZlcnJpZGUoKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwiZm9sZGFibGVEZXZpY2VPdmVycmlkZVwiKTtcbiAgICAgIGlmIChERUJVR19NT0RFKSBjb25zb2xlLmxvZyhcIkZvbGRhYmxlIFV0aWxzOiBDbGVhcmVkIE92ZXJyaWRlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiRm9sZGFibGUgVXRpbHM6IENhbm5vdCBjbGVhciBvdmVycmlkZSwgbG9jYWxTdG9yYWdlIG5vdCBhdmFpbGFibGUuXCJcbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYSByZS1ydW4gb2YgdGhlIGRldGVjdGlvbiBsb2dpYy5cbiAgICogQHJldHVybnMge0ZvbGRhYmxlRGV0ZWN0aW9uUmVzdWx0fSBUaGUgbGF0ZXN0IGRldGVjdGlvbiByZXN1bHQuXG4gICAqL1xuICByZWZyZXNoRGV0ZWN0aW9uKCkge1xuICAgIGlmIChERUJVR19NT0RFKSBjb25zb2xlLmxvZyhcIkZvbGRhYmxlIFV0aWxzOiBSZWZyZXNoaW5nIGRldGVjdGlvbi4uLlwiKTtcbiAgICByZXR1cm4gZGV0ZWN0Rm9sZGFibGVEZXZpY2UoKTtcbiAgfSxcblxuICAvKipcbiAgICogR2F0aGVycyB2YXJpb3VzIHBpZWNlcyBvZiBpbmZvcm1hdGlvbiB1c2VmdWwgZm9yIGRlYnVnZ2luZyBkZXRlY3Rpb24gaXNzdWVzLlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBkZWJ1ZyBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGdldERlYnVnSW5mbzogKCk6IG9iamVjdCA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IFwiQ2Fubm90IGdldCBkZWJ1ZyBpbmZvIG91dHNpZGUgYnJvd3NlciBlbnZpcm9ubWVudC5cIiB9O1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50RGV0ZWN0aW9uID0gZGV0ZWN0Rm9sZGFibGVEZXZpY2UoKTsgLy8gUnVuIGRldGVjdGlvbiB0byBnZXQgY3VycmVudCBzdGF0ZVxuICAgIGNvbnN0IGhhc01hbnVhbE92ZXJyaWRlID1cbiAgICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiZm9sZGFibGVEZXZpY2VPdmVycmlkZVwiKSAhPT0gbnVsbDtcbiAgICBsZXQgYXBpQ2hlY2tzID0ge307XG4gICAgdHJ5IHtcbiAgICAgIGFwaUNoZWNrcyA9IHtcbiAgICAgICAgaXNTY3JlZW5TcGFubmluZzpcbiAgICAgICAgICB3aW5kb3cubWF0Y2hNZWRpYShcIihzY3JlZW4tc3Bhbm5pbmc6IHNpbmdsZS1mb2xkLXZlcnRpY2FsKVwiKVxuICAgICAgICAgICAgLm1hdGNoZXMgfHxcbiAgICAgICAgICB3aW5kb3cubWF0Y2hNZWRpYShcIihzY3JlZW4tc3Bhbm5pbmc6IHNpbmdsZS1mb2xkLWhvcml6b250YWwpXCIpXG4gICAgICAgICAgICAubWF0Y2hlcyxcbiAgICAgICAgZ2V0V2luZG93U2VnbWVudHNMZW5ndGg6XG4gICAgICAgICAgXCJnZXRXaW5kb3dTZWdtZW50c1wiIGluIG5hdmlnYXRvciAmJlxuICAgICAgICAgIHR5cGVvZiAobmF2aWdhdG9yIGFzIHsgZ2V0V2luZG93U2VnbWVudHM/OiAoKSA9PiB1bmtub3duW10gfSlcbiAgICAgICAgICAgIC5nZXRXaW5kb3dTZWdtZW50cyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IChcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3IgYXMgeyBnZXRXaW5kb3dTZWdtZW50cygpOiB1bmtub3duW10gfVxuICAgICAgICAgICAgICApLmdldFdpbmRvd1NlZ21lbnRzKCkubGVuZ3RoXG4gICAgICAgICAgICA6IFwiTi9BXCIsXG4gICAgICAgIHZpc3VhbFZpZXdwb3J0U2VnbWVudHNMZW5ndGg6XG4gICAgICAgICAgd2luZG93LnZpc3VhbFZpZXdwb3J0ICYmIFwic2VnbWVudHNcIiBpbiB3aW5kb3cudmlzdWFsVmlld3BvcnRcbiAgICAgICAgICAgID8gKHdpbmRvdy52aXN1YWxWaWV3cG9ydCBhcyB7IHNlZ21lbnRzPzogdW5rbm93bltdIH0pLnNlZ21lbnRzXG4gICAgICAgICAgICAgICAgPy5sZW5ndGhcbiAgICAgICAgICAgIDogXCJOL0FcIixcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKERFQlVHX01PREUpIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIEFQSSBjaGVjayBpbmZvOlwiLCBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudERldGVjdGlvbixcbiAgICAgIGhhc01hbnVhbE92ZXJyaWRlLFxuICAgICAgd2luZG93RGltZW5zaW9uczoge1xuICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvOiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgYXNwZWN0UmF0aW86ICh3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCkudG9GaXhlZCgzKSxcbiAgICAgIH0sXG4gICAgICBzY3JlZW5EaW1lbnNpb25zOiB7XG4gICAgICAgIHdpZHRoOiB3aW5kb3cuc2NyZWVuLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHdpbmRvdy5zY3JlZW4uaGVpZ2h0LFxuICAgICAgICBhdmFpbFdpZHRoOiB3aW5kb3cuc2NyZWVuLmF2YWlsV2lkdGgsXG4gICAgICAgIGF2YWlsSGVpZ2h0OiB3aW5kb3cuc2NyZWVuLmF2YWlsSGVpZ2h0LFxuICAgICAgfSxcbiAgICAgIHVzZXJBZ2VudDogbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIGFwaUNoZWNrcyxcbiAgICB9O1xuICB9LFxufTtcbiJdLAogICJtYXBwaW5ncyI6ICJBQU9BLE1BQU0sYUFDSixPQUFPLFdBQVcsZUFDbEIsT0FBTyxTQUFTLE9BQU8sU0FBUyxnQkFBZ0I7QUFJbEQsTUFBTSx3QkFBd0I7QUFBQSxFQUM1QixRQUFRO0FBQUEsSUFDTixRQUFRLENBQUMsU0FBUztBQUFBLElBQ2xCLGtCQUFrQjtBQUFBLE1BQ2hCLE9BQU8sRUFBRSxLQUFLLEtBQUssS0FBSyxJQUFJO0FBQUEsTUFDNUIsUUFBUSxFQUFFLEtBQUssS0FBSyxLQUFLLElBQUk7QUFBQSxJQUMvQjtBQUFBLElBQ0Esb0JBQW9CO0FBQUEsTUFDbEIsT0FBTyxFQUFFLEtBQUssS0FBSyxLQUFLLElBQUk7QUFBQSxNQUM1QixRQUFRLEVBQUUsS0FBSyxLQUFLLEtBQUssSUFBSTtBQUFBLElBQy9CO0FBQUEsRUFDRjtBQUFBLEVBQ0EsUUFBUTtBQUFBLElBQ04sUUFBUSxDQUFDLFNBQVM7QUFBQSxJQUNsQixrQkFBa0I7QUFBQSxNQUNoQixPQUFPLEVBQUUsS0FBSyxLQUFLLEtBQUssSUFBSTtBQUFBLE1BQzVCLFFBQVEsRUFBRSxLQUFLLEtBQUssS0FBSyxJQUFJO0FBQUEsSUFDL0I7QUFBQSxJQUNBLG9CQUFvQjtBQUFBLE1BQ2xCLE9BQU8sRUFBRSxLQUFLLEtBQUssS0FBSyxJQUFJO0FBQUEsTUFDNUIsUUFBUSxFQUFFLEtBQUssS0FBSyxLQUFLLElBQUk7QUFBQSxJQUMvQjtBQUFBLEVBQ0Y7QUFBQSxFQUNBLFFBQVE7QUFBQSxJQUNOLFFBQVEsQ0FBQyxTQUFTO0FBQUEsSUFDbEIsa0JBQWtCO0FBQUEsTUFDaEIsT0FBTyxFQUFFLEtBQUssS0FBSyxLQUFLLElBQUk7QUFBQSxNQUM1QixRQUFRLEVBQUUsS0FBSyxLQUFLLEtBQUssSUFBSTtBQUFBLElBQy9CO0FBQUEs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
