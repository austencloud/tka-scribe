import { GridMode } from "/src/lib/domain/enums.ts";
export class GridOverlayService {
  // Grid constants
  static GRID_OPACITY = 1;
  // Desktop uses 100% opacity
  static GRID_COLOR = "#e5e7eb";
  // Light gray
  static GRID_LINE_WIDTH = 1;
  /**
   * Apply combined grids to beat canvas
   * Matches desktop CombinedGridHandler.process_beat_for_combined_grids
   */
  applyCombinedGrids(canvas, currentGridMode) {
    if (!this.validateGridMode(currentGridMode)) {
      throw new Error(`Invalid grid mode: ${currentGridMode}`);
    }
    const combinedCanvas = document.createElement("canvas");
    combinedCanvas.width = canvas.width;
    combinedCanvas.height = canvas.height;
    const ctx = combinedCanvas.getContext("2d");
    if (!ctx) {
      throw new Error("Failed to get 2D context from combined canvas");
    }
    ctx.drawImage(canvas, 0, 0);
    const oppositeGridMode = this.getOppositeGridMode(currentGridMode);
    this.drawGridOverlay(
      ctx,
      oppositeGridMode,
      canvas.width,
      GridOverlayService.GRID_OPACITY
    );
    return combinedCanvas;
  }
  /**
   * Draw grid overlay on canvas
   * Implements both diamond and box grid patterns
   */
  drawGridOverlay(ctx, gridMode, size, opacity = 1) {
    if (!this.validateGridMode(gridMode)) {
      throw new Error(`Invalid grid mode: ${gridMode}`);
    }
    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.strokeStyle = GridOverlayService.GRID_COLOR;
    ctx.lineWidth = GridOverlayService.GRID_LINE_WIDTH;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    if (gridMode === GridMode.DIAMOND) {
      this.drawDiamondGrid(ctx, size);
    } else if (gridMode === GridMode.BOX) {
      this.drawBoxGrid(ctx, size);
    }
    ctx.restore();
  }
  /**
   * Get opposite grid mode
   * Matches desktop logic exactly
   */
  getOppositeGridMode(currentMode) {
    switch (currentMode.toLowerCase()) {
      case GridMode.DIAMOND:
        return GridMode.BOX;
      case GridMode.BOX:
        return GridMode.DIAMOND;
      default:
        throw new Error(`Unknown grid mode: ${currentMode}`);
    }
  }
  /**
   * Validate grid modes
   */
  validateGridMode(gridMode) {
    const validModes = [GridMode.DIAMOND, GridMode.BOX];
    const modeToCheck = typeof gridMode === "string" ? gridMode.toLowerCase() : gridMode;
    return validModes.includes(modeToCheck);
  }
  /**
   * Draw diamond grid pattern
   * Matches desktop diamond grid implementation
   */
  drawDiamondGrid(ctx, size) {
    const centerX = size / 2;
    const centerY = size / 2;
    const radius = size * 0.4;
    ctx.beginPath();
    ctx.moveTo(centerX, centerY - radius);
    ctx.lineTo(centerX + radius, centerY);
    ctx.lineTo(centerX, centerY + radius);
    ctx.lineTo(centerX - radius, centerY);
    ctx.closePath();
    ctx.stroke();
    this.drawDiamondGridLines(ctx, centerX, centerY, radius);
  }
  /**
   * Draw box grid pattern
   * Matches desktop box grid implementation
   */
  drawBoxGrid(ctx, size) {
    const margin = size * 0.1;
    const boxSize = size - 2 * margin;
    ctx.strokeRect(margin, margin, boxSize, boxSize);
    this.drawBoxGridLines(ctx, margin, margin, boxSize);
  }
  /**
   * Draw internal grid lines for diamond
   */
  drawDiamondGridLines(ctx, centerX, centerY, radius) {
    const originalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = originalAlpha * 0.5;
    ctx.beginPath();
    ctx.moveTo(centerX - radius * 0.7, centerY);
    ctx.lineTo(centerX + radius * 0.7, centerY);
    ctx.moveTo(centerX, centerY - radius * 0.7);
    ctx.lineTo(centerX, centerY + radius * 0.7);
    ctx.stroke();
    ctx.globalAlpha = originalAlpha;
  }
  /**
   * Draw internal grid lines for box
   */
  drawBoxGridLines(ctx, x, y, size) {
    const originalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = originalAlpha * 0.5;
    ctx.beginPath();
    const centerX = x + size / 2;
    const centerY = y + size / 2;
    ctx.moveTo(x, centerY);
    ctx.lineTo(x + size, centerY);
    ctx.moveTo(centerX, y);
    ctx.lineTo(centerX, y + size);
    ctx.stroke();
    ctx.globalAlpha = originalAlpha;
  }
  /**
   * Create grid overlay as separate canvas
   * Useful for caching grid patterns
   */
  createGridCanvas(gridMode, size) {
    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      throw new Error("Failed to get 2D context from grid canvas");
    }
    ctx.clearRect(0, 0, size, size);
    this.drawGridOverlay(ctx, gridMode, size);
    return canvas;
  }
  /**
   * Apply grid overlay with custom blend mode
   */
  applyGridWithBlendMode(canvas, gridMode, blendMode = "source-over") {
    const result = document.createElement("canvas");
    result.width = canvas.width;
    result.height = canvas.height;
    const ctx = result.getContext("2d");
    if (!ctx) {
      throw new Error("Failed to get 2D context from result canvas");
    }
    ctx.drawImage(canvas, 0, 0);
    ctx.globalCompositeOperation = blendMode;
    this.drawGridOverlay(ctx, gridMode, canvas.width);
    ctx.globalCompositeOperation = "source-over";
    return result;
  }
  /**
   * Create combined grid overlay (both grids at once)
   */
  createCombinedGridOverlay(size) {
    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      throw new Error("Failed to get 2D context from canvas");
    }
    ctx.clearRect(0, 0, size, size);
    ctx.globalAlpha = 0.7;
    this.drawGridOverlay(ctx, GridMode.DIAMOND, size);
    this.drawGridOverlay(ctx, GridMode.BOX, size);
    ctx.globalAlpha = 1;
    return canvas;
  }
  /**
   * Get recommended grid overlay settings
   */
  getRecommendedSettings(baseGridMode, purpose) {
    const overlayMode = this.getOppositeGridMode(baseGridMode);
    switch (purpose) {
      case "export":
        return {
          overlayMode,
          opacity: 1,
          // Full opacity for export (match desktop)
          lineWidth: 1,
          color: "#e5e7eb"
        };
      case "preview":
        return {
          overlayMode,
          opacity: 0.8,
          // Slightly transparent for preview
          lineWidth: 1,
          color: "#d1d5db"
        };
      case "print":
        return {
          overlayMode,
          opacity: 1,
          // Full opacity for print
          lineWidth: 2,
          // Thicker lines for print
          color: "#9ca3af"
        };
      default:
        throw new Error(`Unknown purpose: ${purpose}`);
    }
  }
  /**
   * Analyze grid contrast against background
   */
  analyzeGridContrast(_canvas, _gridMode) {
    const mockContrast = 0.7;
    return {
      averageContrast: mockContrast,
      minContrast: mockContrast - 0.1,
      maxContrast: mockContrast + 0.1,
      recommendation: mockContrast > 0.6 ? "optimal" : "increase"
    };
  }
  /**
   * Debug method to test grid rendering
   */
  debugGridRendering(size = 200) {
    return {
      diamondGrid: this.createGridCanvas(GridMode.DIAMOND, size),
      boxGrid: this.createGridCanvas(GridMode.BOX, size),
      combinedGrid: this.createCombinedGridOverlay(size)
    };
  }
  /**
   * Batch apply grid overlays to multiple canvases
   */
  batchApplyGrids(canvases, gridModes) {
    if (canvases.length !== gridModes.length) {
      throw new Error("Canvas count must match grid mode count");
    }
    return canvases.map((canvas, index) => {
      const gridMode = gridModes[index];
      return this.applyCombinedGrids(canvas, gridMode);
    });
  }
  /**
   * Get supported grid modes
   */
  getSupportedGridModes() {
    return [GridMode.DIAMOND, GridMode.BOX];
  }
  /**
   * Validate and normalize grid mode
   */
  normalizeGridMode(gridMode) {
    const normalized = gridMode.toLowerCase().trim();
    if (!this.validateGridMode(normalized)) {
      throw new Error(
        `Unsupported grid mode: ${gridMode}. Supported modes: ${this.getSupportedGridModes().join(", ")}`
      );
    }
    return normalized;
  }
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3NlcnZpY2VzL2ltcGxlbWVudGF0aW9ucy9pbWFnZS1leHBvcnQvR3JpZE92ZXJsYXlTZXJ2aWNlLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIEdyaWQgT3ZlcmxheSBTZXJ2aWNlXG4gKlxuICogSGFuZGxlcyBjb21iaW5lZCBncmlkIG92ZXJsYXlzIGZvciBUS0EgaW1hZ2UgZXhwb3J0LiBUaGlzIHNlcnZpY2UgaW1wbGVtZW50c1xuICogdGhlIGZ1bmN0aW9uYWxpdHkgZXF1aXZhbGVudCB0byBkZXNrdG9wIENvbWJpbmVkR3JpZEhhbmRsZXIsIGFsbG93aW5nIGJvdGhcbiAqIGRpYW1vbmQgYW5kIGJveCBncmlkcyB0byBiZSBkaXNwbGF5ZWQgc2ltdWx0YW5lb3VzbHkuXG4gKlxuICogQ3JpdGljYWw6IE11c3QgbWF0Y2ggZGVza3RvcCBvdmVybGF5IG9wYWNpdHkgYW5kIHBvc2l0aW9uaW5nIGV4YWN0bHkuXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBJR3JpZE92ZXJsYXlTZXJ2aWNlIH0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXMvaW1hZ2UtZXhwb3J0LWludGVyZmFjZXNcIjtcbmltcG9ydCB7IEdyaWRNb2RlIH0gZnJvbSBcIiRsaWIvZG9tYWluL2VudW1zXCI7XG5cbmV4cG9ydCBjbGFzcyBHcmlkT3ZlcmxheVNlcnZpY2UgaW1wbGVtZW50cyBJR3JpZE92ZXJsYXlTZXJ2aWNlIHtcbiAgLy8gR3JpZCBjb25zdGFudHNcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgR1JJRF9PUEFDSVRZID0gMS4wOyAvLyBEZXNrdG9wIHVzZXMgMTAwJSBvcGFjaXR5XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEdSSURfQ09MT1IgPSBcIiNlNWU3ZWJcIjsgLy8gTGlnaHQgZ3JheVxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBHUklEX0xJTkVfV0lEVEggPSAxO1xuXG4gIC8qKlxuICAgKiBBcHBseSBjb21iaW5lZCBncmlkcyB0byBiZWF0IGNhbnZhc1xuICAgKiBNYXRjaGVzIGRlc2t0b3AgQ29tYmluZWRHcmlkSGFuZGxlci5wcm9jZXNzX2JlYXRfZm9yX2NvbWJpbmVkX2dyaWRzXG4gICAqL1xuICBhcHBseUNvbWJpbmVkR3JpZHMoXG4gICAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCxcbiAgICBjdXJyZW50R3JpZE1vZGU6IHN0cmluZ1xuICApOiBIVE1MQ2FudmFzRWxlbWVudCB7XG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlR3JpZE1vZGUoY3VycmVudEdyaWRNb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGdyaWQgbW9kZTogJHtjdXJyZW50R3JpZE1vZGV9YCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG5ldyBjYW52YXMgZm9yIGNvbWJpbmVkIHJlc3VsdFxuICAgIGNvbnN0IGNvbWJpbmVkQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjb21iaW5lZENhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICBjb21iaW5lZENhbnZhcy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuXG4gICAgY29uc3QgY3R4ID0gY29tYmluZWRDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGlmICghY3R4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IDJEIGNvbnRleHQgZnJvbSBjb21iaW5lZCBjYW52YXNcIik7XG4gICAgfVxuXG4gICAgLy8gU3RlcCAxOiBEcmF3IG9yaWdpbmFsIGNhbnZhc1xuICAgIGN0eC5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcblxuICAgIC8vIFN0ZXAgMjogQWRkIG9wcG9zaXRlIGdyaWQgd2l0aCBmdWxsIG9wYWNpdHkgKG1hdGNoIGRlc2t0b3ApXG4gICAgY29uc3Qgb3Bwb3NpdGVHcmlkTW9kZSA9IHRoaXMuZ2V0T3Bwb3NpdGVHcmlkTW9kZShjdXJyZW50R3JpZE1vZGUpO1xuICAgIHRoaXMuZHJhd0dyaWRPdmVybGF5KFxuICAgICAgY3R4LFxuICAgICAgb3Bwb3NpdGVHcmlkTW9kZSxcbiAgICAgIGNhbnZhcy53aWR0aCxcbiAgICAgIEdyaWRPdmVybGF5U2VydmljZS5HUklEX09QQUNJVFlcbiAgICApO1xuXG4gICAgcmV0dXJuIGNvbWJpbmVkQ2FudmFzO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYXcgZ3JpZCBvdmVybGF5IG9uIGNhbnZhc1xuICAgKiBJbXBsZW1lbnRzIGJvdGggZGlhbW9uZCBhbmQgYm94IGdyaWQgcGF0dGVybnNcbiAgICovXG4gIGRyYXdHcmlkT3ZlcmxheShcbiAgICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgICBncmlkTW9kZTogc3RyaW5nLFxuICAgIHNpemU6IG51bWJlcixcbiAgICBvcGFjaXR5OiBudW1iZXIgPSAxLjBcbiAgKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlR3JpZE1vZGUoZ3JpZE1vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZ3JpZCBtb2RlOiAke2dyaWRNb2RlfWApO1xuICAgIH1cblxuICAgIC8vIFNhdmUgY3VycmVudCBjb250ZXh0IHN0YXRlXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIC8vIFNldCBncmlkIGRyYXdpbmcgcHJvcGVydGllc1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gR3JpZE92ZXJsYXlTZXJ2aWNlLkdSSURfQ09MT1I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IEdyaWRPdmVybGF5U2VydmljZS5HUklEX0xJTkVfV0lEVEg7XG4gICAgY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7XG4gICAgY3R4LmxpbmVKb2luID0gXCJyb3VuZFwiO1xuXG4gICAgaWYgKGdyaWRNb2RlID09PSBHcmlkTW9kZS5ESUFNT05EKSB7XG4gICAgICB0aGlzLmRyYXdEaWFtb25kR3JpZChjdHgsIHNpemUpO1xuICAgIH0gZWxzZSBpZiAoZ3JpZE1vZGUgPT09IEdyaWRNb2RlLkJPWCkge1xuICAgICAgdGhpcy5kcmF3Qm94R3JpZChjdHgsIHNpemUpO1xuICAgIH1cblxuICAgIC8vIFJlc3RvcmUgY29udGV4dCBzdGF0ZVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG9wcG9zaXRlIGdyaWQgbW9kZVxuICAgKiBNYXRjaGVzIGRlc2t0b3AgbG9naWMgZXhhY3RseVxuICAgKi9cbiAgZ2V0T3Bwb3NpdGVHcmlkTW9kZShjdXJyZW50TW9kZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKGN1cnJlbnRNb2RlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgR3JpZE1vZGUuRElBTU9ORDpcbiAgICAgICAgcmV0dXJuIEdyaWRNb2RlLkJPWDtcbiAgICAgIGNhc2UgR3JpZE1vZGUuQk9YOlxuICAgICAgICByZXR1cm4gR3JpZE1vZGUuRElBTU9ORDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBncmlkIG1vZGU6ICR7Y3VycmVudE1vZGV9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGdyaWQgbW9kZXNcbiAgICovXG4gIHZhbGlkYXRlR3JpZE1vZGUoZ3JpZE1vZGU6IEdyaWRNb2RlIHwgc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdmFsaWRNb2RlcyA9IFtHcmlkTW9kZS5ESUFNT05ELCBHcmlkTW9kZS5CT1hdO1xuICAgIC8vIEhhbmRsZSBib3RoIGVudW0gYW5kIHN0cmluZyBpbnB1dHNcbiAgICBjb25zdCBtb2RlVG9DaGVjayA9XG4gICAgICB0eXBlb2YgZ3JpZE1vZGUgPT09IFwic3RyaW5nXCIgPyBncmlkTW9kZS50b0xvd2VyQ2FzZSgpIDogZ3JpZE1vZGU7XG4gICAgcmV0dXJuIHZhbGlkTW9kZXMuaW5jbHVkZXMobW9kZVRvQ2hlY2sgYXMgR3JpZE1vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYXcgZGlhbW9uZCBncmlkIHBhdHRlcm5cbiAgICogTWF0Y2hlcyBkZXNrdG9wIGRpYW1vbmQgZ3JpZCBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBkcmF3RGlhbW9uZEdyaWQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHNpemU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGNlbnRlclggPSBzaXplIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gc2l6ZSAvIDI7XG4gICAgY29uc3QgcmFkaXVzID0gc2l6ZSAqIDAuNDsgLy8gU3RhbmRhcmQgZGlhbW9uZCBzaXplXG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAvLyBEcmF3IGRpYW1vbmQgc2hhcGVcbiAgICBjdHgubW92ZVRvKGNlbnRlclgsIGNlbnRlclkgLSByYWRpdXMpOyAvLyBUb3AgcG9pbnRcbiAgICBjdHgubGluZVRvKGNlbnRlclggKyByYWRpdXMsIGNlbnRlclkpOyAvLyBSaWdodCBwb2ludFxuICAgIGN0eC5saW5lVG8oY2VudGVyWCwgY2VudGVyWSArIHJhZGl1cyk7IC8vIEJvdHRvbSBwb2ludFxuICAgIGN0eC5saW5lVG8oY2VudGVyWCAtIHJhZGl1cywgY2VudGVyWSk7IC8vIExlZnQgcG9pbnRcbiAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAvLyBBZGQgZ3JpZCBsaW5lcyBpbnNpZGUgZGlhbW9uZCAob3B0aW9uYWwgZW5oYW5jZW1lbnQpXG4gICAgdGhpcy5kcmF3RGlhbW9uZEdyaWRMaW5lcyhjdHgsIGNlbnRlclgsIGNlbnRlclksIHJhZGl1cyk7XG4gIH1cblxuICAvKipcbiAgICogRHJhdyBib3ggZ3JpZCBwYXR0ZXJuXG4gICAqIE1hdGNoZXMgZGVza3RvcCBib3ggZ3JpZCBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBkcmF3Qm94R3JpZChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgc2l6ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgbWFyZ2luID0gc2l6ZSAqIDAuMTsgLy8gU3RhbmRhcmQgYm94IG1hcmdpblxuICAgIGNvbnN0IGJveFNpemUgPSBzaXplIC0gMiAqIG1hcmdpbjtcblxuICAgIC8vIERyYXcgbWFpbiBib3hcbiAgICBjdHguc3Ryb2tlUmVjdChtYXJnaW4sIG1hcmdpbiwgYm94U2l6ZSwgYm94U2l6ZSk7XG5cbiAgICAvLyBBZGQgZ3JpZCBsaW5lcyBpbnNpZGUgYm94IChvcHRpb25hbCBlbmhhbmNlbWVudClcbiAgICB0aGlzLmRyYXdCb3hHcmlkTGluZXMoY3R4LCBtYXJnaW4sIG1hcmdpbiwgYm94U2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogRHJhdyBpbnRlcm5hbCBncmlkIGxpbmVzIGZvciBkaWFtb25kXG4gICAqL1xuICBwcml2YXRlIGRyYXdEaWFtb25kR3JpZExpbmVzKFxuICAgIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICAgIGNlbnRlclg6IG51bWJlcixcbiAgICBjZW50ZXJZOiBudW1iZXIsXG4gICAgcmFkaXVzOiBudW1iZXJcbiAgKTogdm9pZCB7XG4gICAgLy8gTGlnaHRlciBvcGFjaXR5IGZvciBpbnRlcm5hbCBsaW5lc1xuICAgIGNvbnN0IG9yaWdpbmFsQWxwaGEgPSBjdHguZ2xvYmFsQWxwaGE7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gb3JpZ2luYWxBbHBoYSAqIDAuNTtcblxuICAgIC8vIERyYXcgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgY2VudGVyIGxpbmVzXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgLy8gSG9yaXpvbnRhbCBsaW5lXG4gICAgY3R4Lm1vdmVUbyhjZW50ZXJYIC0gcmFkaXVzICogMC43LCBjZW50ZXJZKTtcbiAgICBjdHgubGluZVRvKGNlbnRlclggKyByYWRpdXMgKiAwLjcsIGNlbnRlclkpO1xuXG4gICAgLy8gVmVydGljYWwgbGluZVxuICAgIGN0eC5tb3ZlVG8oY2VudGVyWCwgY2VudGVyWSAtIHJhZGl1cyAqIDAuNyk7XG4gICAgY3R4LmxpbmVUbyhjZW50ZXJYLCBjZW50ZXJZICsgcmFkaXVzICogMC43KTtcblxuICAgIGN0eC5zdHJva2UoKTtcblxuICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgYWxwaGFcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcmlnaW5hbEFscGhhO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYXcgaW50ZXJuYWwgZ3JpZCBsaW5lcyBmb3IgYm94XG4gICAqL1xuICBwcml2YXRlIGRyYXdCb3hHcmlkTGluZXMoXG4gICAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gICAgeDogbnVtYmVyLFxuICAgIHk6IG51bWJlcixcbiAgICBzaXplOiBudW1iZXJcbiAgKTogdm9pZCB7XG4gICAgLy8gTGlnaHRlciBvcGFjaXR5IGZvciBpbnRlcm5hbCBsaW5lc1xuICAgIGNvbnN0IG9yaWdpbmFsQWxwaGEgPSBjdHguZ2xvYmFsQWxwaGE7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gb3JpZ2luYWxBbHBoYSAqIDAuNTtcblxuICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgIC8vIERyYXcgY2VudGVyIGNyb3NzXG4gICAgY29uc3QgY2VudGVyWCA9IHggKyBzaXplIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0geSArIHNpemUgLyAyO1xuXG4gICAgLy8gSG9yaXpvbnRhbCBsaW5lXG4gICAgY3R4Lm1vdmVUbyh4LCBjZW50ZXJZKTtcbiAgICBjdHgubGluZVRvKHggKyBzaXplLCBjZW50ZXJZKTtcblxuICAgIC8vIFZlcnRpY2FsIGxpbmVcbiAgICBjdHgubW92ZVRvKGNlbnRlclgsIHkpO1xuICAgIGN0eC5saW5lVG8oY2VudGVyWCwgeSArIHNpemUpO1xuXG4gICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBhbHBoYVxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9yaWdpbmFsQWxwaGE7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGdyaWQgb3ZlcmxheSBhcyBzZXBhcmF0ZSBjYW52YXNcbiAgICogVXNlZnVsIGZvciBjYWNoaW5nIGdyaWQgcGF0dGVybnNcbiAgICovXG4gIGNyZWF0ZUdyaWRDYW52YXMoZ3JpZE1vZGU6IHN0cmluZywgc2l6ZTogbnVtYmVyKTogSFRNTENhbnZhc0VsZW1lbnQge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gc2l6ZTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gc2l6ZTtcblxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgMkQgY29udGV4dCBmcm9tIGdyaWQgY2FudmFzXCIpO1xuICAgIH1cblxuICAgIC8vIEZpbGwgd2l0aCB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBzaXplLCBzaXplKTtcblxuICAgIC8vIERyYXcgZ3JpZFxuICAgIHRoaXMuZHJhd0dyaWRPdmVybGF5KGN0eCwgZ3JpZE1vZGUsIHNpemUpO1xuXG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBncmlkIG92ZXJsYXkgd2l0aCBjdXN0b20gYmxlbmQgbW9kZVxuICAgKi9cbiAgYXBwbHlHcmlkV2l0aEJsZW5kTW9kZShcbiAgICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICAgIGdyaWRNb2RlOiBzdHJpbmcsXG4gICAgYmxlbmRNb2RlOiBHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCJcbiAgKTogSFRNTENhbnZhc0VsZW1lbnQge1xuICAgIGNvbnN0IHJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgcmVzdWx0LndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIHJlc3VsdC5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuXG4gICAgY29uc3QgY3R4ID0gcmVzdWx0LmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBpZiAoIWN0eCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCAyRCBjb250ZXh0IGZyb20gcmVzdWx0IGNhbnZhc1wiKTtcbiAgICB9XG5cbiAgICAvLyBEcmF3IG9yaWdpbmFsIGNhbnZhc1xuICAgIGN0eC5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcblxuICAgIC8vIFNldCBibGVuZCBtb2RlIGFuZCBkcmF3IGdyaWRcbiAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gYmxlbmRNb2RlO1xuICAgIHRoaXMuZHJhd0dyaWRPdmVybGF5KGN0eCwgZ3JpZE1vZGUsIGNhbnZhcy53aWR0aCk7XG5cbiAgICAvLyBSZXNldCBibGVuZCBtb2RlXG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGNvbWJpbmVkIGdyaWQgb3ZlcmxheSAoYm90aCBncmlkcyBhdCBvbmNlKVxuICAgKi9cbiAgY3JlYXRlQ29tYmluZWRHcmlkT3ZlcmxheShzaXplOiBudW1iZXIpOiBIVE1MQ2FudmFzRWxlbWVudCB7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSBzaXplO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzaXplO1xuXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBpZiAoIWN0eCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCAyRCBjb250ZXh0IGZyb20gY2FudmFzXCIpO1xuICAgIH1cblxuICAgIC8vIENsZWFyIGJhY2tncm91bmRcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHNpemUsIHNpemUpO1xuXG4gICAgLy8gRHJhdyBib3RoIGdyaWRzIHdpdGggcmVkdWNlZCBvcGFjaXR5XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gMC43O1xuICAgIHRoaXMuZHJhd0dyaWRPdmVybGF5KGN0eCwgR3JpZE1vZGUuRElBTU9ORCwgc2l6ZSk7XG4gICAgdGhpcy5kcmF3R3JpZE92ZXJsYXkoY3R4LCBHcmlkTW9kZS5CT1gsIHNpemUpO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IDEuMDtcblxuICAgIHJldHVybiBjYW52YXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHJlY29tbWVuZGVkIGdyaWQgb3ZlcmxheSBzZXR0aW5nc1xuICAgKi9cbiAgZ2V0UmVjb21tZW5kZWRTZXR0aW5ncyhcbiAgICBiYXNlR3JpZE1vZGU6IHN0cmluZyxcbiAgICBwdXJwb3NlOiBcImV4cG9ydFwiIHwgXCJwcmV2aWV3XCIgfCBcInByaW50XCJcbiAgKToge1xuICAgIG92ZXJsYXlNb2RlOiBzdHJpbmc7XG4gICAgb3BhY2l0eTogbnVtYmVyO1xuICAgIGxpbmVXaWR0aDogbnVtYmVyO1xuICAgIGNvbG9yOiBzdHJpbmc7XG4gIH0ge1xuICAgIGNvbnN0IG92ZXJsYXlNb2RlID0gdGhpcy5nZXRPcHBvc2l0ZUdyaWRNb2RlKGJhc2VHcmlkTW9kZSk7XG5cbiAgICBzd2l0Y2ggKHB1cnBvc2UpIHtcbiAgICAgIGNhc2UgXCJleHBvcnRcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvdmVybGF5TW9kZSxcbiAgICAgICAgICBvcGFjaXR5OiAxLjAsIC8vIEZ1bGwgb3BhY2l0eSBmb3IgZXhwb3J0IChtYXRjaCBkZXNrdG9wKVxuICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICBjb2xvcjogXCIjZTVlN2ViXCIsXG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgXCJwcmV2aWV3XCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3ZlcmxheU1vZGUsXG4gICAgICAgICAgb3BhY2l0eTogMC44LCAvLyBTbGlnaHRseSB0cmFuc3BhcmVudCBmb3IgcHJldmlld1xuICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICBjb2xvcjogXCIjZDFkNWRiXCIsXG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgXCJwcmludFwiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG92ZXJsYXlNb2RlLFxuICAgICAgICAgIG9wYWNpdHk6IDEuMCwgLy8gRnVsbCBvcGFjaXR5IGZvciBwcmludFxuICAgICAgICAgIGxpbmVXaWR0aDogMiwgLy8gVGhpY2tlciBsaW5lcyBmb3IgcHJpbnRcbiAgICAgICAgICBjb2xvcjogXCIjOWNhM2FmXCIsXG4gICAgICAgIH07XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwdXJwb3NlOiAke3B1cnBvc2V9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFuYWx5emUgZ3JpZCBjb250cmFzdCBhZ2FpbnN0IGJhY2tncm91bmRcbiAgICovXG4gIGFuYWx5emVHcmlkQ29udHJhc3QoXG4gICAgX2NhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXG4gICAgX2dyaWRNb2RlOiBzdHJpbmdcbiAgKToge1xuICAgIGF2ZXJhZ2VDb250cmFzdDogbnVtYmVyO1xuICAgIG1pbkNvbnRyYXN0OiBudW1iZXI7XG4gICAgbWF4Q29udHJhc3Q6IG51bWJlcjtcbiAgICByZWNvbW1lbmRhdGlvbjogXCJpbmNyZWFzZVwiIHwgXCJkZWNyZWFzZVwiIHwgXCJvcHRpbWFsXCI7XG4gIH0ge1xuICAgIC8vIENyZWF0ZSBhIHRlc3QgZ3JpZCBvdmVybGF5XG4gICAgLy8gY29uc3QgdGVzdENhbnZhcyA9IHRoaXMuY3JlYXRlR3JpZENhbnZhcyhncmlkTW9kZSwgMTAwKTsgLy8gRm9yIGZ1dHVyZSBjb250cmFzdCBhbmFseXNpc1xuICAgIC8vIGNvbnN0IGN0eCA9IHRlc3RDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpITsgLy8gRm9yIGZ1dHVyZSBjb250cmFzdCBhbmFseXNpc1xuICAgIC8vIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMTAwLCAxMDApOyAvLyBGb3IgZnV0dXJlIGNvbnRyYXN0IGFuYWx5c2lzXG5cbiAgICAvLyBTaW1wbGlmaWVkIGNvbnRyYXN0IGFuYWx5c2lzXG4gICAgLy8gSW4gYSBmdWxsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIGFuYWx5emUgYWN0dWFsIHBpeGVsIHZhbHVlc1xuICAgIGNvbnN0IG1vY2tDb250cmFzdCA9IDAuNzsgLy8gUGxhY2Vob2xkZXIgdmFsdWVcblxuICAgIHJldHVybiB7XG4gICAgICBhdmVyYWdlQ29udHJhc3Q6IG1vY2tDb250cmFzdCxcbiAgICAgIG1pbkNvbnRyYXN0OiBtb2NrQ29udHJhc3QgLSAwLjEsXG4gICAgICBtYXhDb250cmFzdDogbW9ja0NvbnRyYXN0ICsgMC4xLFxuICAgICAgcmVjb21tZW5kYXRpb246IG1vY2tDb250cmFzdCA+IDAuNiA/IFwib3B0aW1hbFwiIDogXCJpbmNyZWFzZVwiLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVidWcgbWV0aG9kIHRvIHRlc3QgZ3JpZCByZW5kZXJpbmdcbiAgICovXG4gIGRlYnVnR3JpZFJlbmRlcmluZyhzaXplOiBudW1iZXIgPSAyMDApOiB7XG4gICAgZGlhbW9uZEdyaWQ6IEhUTUxDYW52YXNFbGVtZW50O1xuICAgIGJveEdyaWQ6IEhUTUxDYW52YXNFbGVtZW50O1xuICAgIGNvbWJpbmVkR3JpZDogSFRNTENhbnZhc0VsZW1lbnQ7XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICBkaWFtb25kR3JpZDogdGhpcy5jcmVhdGVHcmlkQ2FudmFzKEdyaWRNb2RlLkRJQU1PTkQsIHNpemUpLFxuICAgICAgYm94R3JpZDogdGhpcy5jcmVhdGVHcmlkQ2FudmFzKEdyaWRNb2RlLkJPWCwgc2l6ZSksXG4gICAgICBjb21iaW5lZEdyaWQ6IHRoaXMuY3JlYXRlQ29tYmluZWRHcmlkT3ZlcmxheShzaXplKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEJhdGNoIGFwcGx5IGdyaWQgb3ZlcmxheXMgdG8gbXVsdGlwbGUgY2FudmFzZXNcbiAgICovXG4gIGJhdGNoQXBwbHlHcmlkcyhcbiAgICBjYW52YXNlczogSFRNTENhbnZhc0VsZW1lbnRbXSxcbiAgICBncmlkTW9kZXM6IHN0cmluZ1tdXG4gICk6IEhUTUxDYW52YXNFbGVtZW50W10ge1xuICAgIGlmIChjYW52YXNlcy5sZW5ndGggIT09IGdyaWRNb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBjb3VudCBtdXN0IG1hdGNoIGdyaWQgbW9kZSBjb3VudFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FudmFzZXMubWFwKChjYW52YXMsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBncmlkTW9kZSA9IGdyaWRNb2Rlc1tpbmRleF07XG4gICAgICByZXR1cm4gdGhpcy5hcHBseUNvbWJpbmVkR3JpZHMoY2FudmFzLCBncmlkTW9kZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHN1cHBvcnRlZCBncmlkIG1vZGVzXG4gICAqL1xuICBnZXRTdXBwb3J0ZWRHcmlkTW9kZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbR3JpZE1vZGUuRElBTU9ORCwgR3JpZE1vZGUuQk9YXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhbmQgbm9ybWFsaXplIGdyaWQgbW9kZVxuICAgKi9cbiAgbm9ybWFsaXplR3JpZE1vZGUoZ3JpZE1vZGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IGdyaWRNb2RlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuXG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlR3JpZE1vZGUobm9ybWFsaXplZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFVuc3VwcG9ydGVkIGdyaWQgbW9kZTogJHtncmlkTW9kZX0uIFN1cHBvcnRlZCBtb2RlczogJHt0aGlzLmdldFN1cHBvcnRlZEdyaWRNb2RlcygpLmpvaW4oXCIsIFwiKX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxpemVkO1xuICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiQUFXQSxTQUFTLGdCQUFnQjtBQUVsQixhQUFNLG1CQUFrRDtBQUFBO0FBQUEsRUFFN0QsT0FBd0IsZUFBZTtBQUFBO0FBQUEsRUFDdkMsT0FBd0IsYUFBYTtBQUFBO0FBQUEsRUFDckMsT0FBd0Isa0JBQWtCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU0xQyxtQkFDRSxRQUNBLGlCQUNtQjtBQUNuQixRQUFJLENBQUMsS0FBSyxpQkFBaUIsZUFBZSxHQUFHO0FBQzNDLFlBQU0sSUFBSSxNQUFNLHNCQUFzQixlQUFlLEVBQUU7QUFBQSxJQUN6RDtBQUdBLFVBQU0saUJBQWlCLFNBQVMsY0FBYyxRQUFRO0FBQ3RELG1CQUFlLFFBQVEsT0FBTztBQUM5QixtQkFBZSxTQUFTLE9BQU87QUFFL0IsVUFBTSxNQUFNLGVBQWUsV0FBVyxJQUFJO0FBQzFDLFFBQUksQ0FBQyxLQUFLO0FBQ1IsWUFBTSxJQUFJLE1BQU0sK0NBQStDO0FBQUEsSUFDakU7QUFHQSxRQUFJLFVBQVUsUUFBUSxHQUFHLENBQUM7QUFHMUIsVUFBTSxtQkFBbUIsS0FBSyxvQkFBb0IsZUFBZTtBQUNqRSxTQUFLO0FBQUEsTUFDSDtBQUFBLE1BQ0E7QUFBQSxNQUNBLE9BQU87QUFBQSxNQUNQLG1CQUFtQjtBQUFBLElBQ3JCO0FBRUEsV0FBTztBQUFBLEVBQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBTUEsZ0JBQ0UsS0FDQSxVQUNBLE1BQ0EsVUFBa0IsR0FDWjtBQUNOLFFBQUksQ0FBQyxLQUFLLGlCQUFpQixRQUFRLEdBQUc7QUFDcEMsWUFBTSxJQUFJ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
