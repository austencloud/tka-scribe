import.meta.env = {"BASE_URL": "/", "DEV": true, "MODE": "development", "PROD": false, "SSR": false};import {
  DEVICE_CONFIG,
  GAP_ADJUSTMENTS,
  getContainerAspect,
  getDeviceType,
  getLayoutCategory,
  LAYOUT_TEMPLATES
} from "/src/lib/components/construct/option-picker/config.ts";
import {
  detectFoldableDevice
} from "/src/lib/components/construct/option-picker/utils/deviceDetection.ts";
import {
  DEFAULT_COLUMNS,
  GRID_GAP_OVERRIDES,
  LAYOUT_RULES
} from "/src/lib/components/construct/option-picker/utils/layoutConfig.ts";
import { memoizeLRU } from "/src/lib/components/construct/option-picker/utils/memoizationUtils.ts";
export function getEnhancedDeviceType(width, isMobileUserAgent) {
  const foldableInfo = detectFoldableDevice();
  const baseDeviceType = getDeviceType(width, isMobileUserAgent);
  if (foldableInfo.isFoldable && foldableInfo.isUnfolded && foldableInfo.foldableType === "zfold") {
    return {
      deviceType: "tablet",
      isFoldable: true,
      foldableInfo
    };
  }
  return {
    deviceType: baseDeviceType,
    isFoldable: foldableInfo.isFoldable,
    foldableInfo
  };
}
export const getResponsiveLayout = memoizeLRU(
  (count, containerHeight = 0, containerWidth = 0, isMobileDevice = false, isPortraitMode = false, foldableInfoParam) => {
    if (containerHeight <= 0 || containerWidth <= 0) {
      if (import.meta.env.DEV) {
        console.debug(
          "getResponsiveLayout: Using default layout until container dimensions are available."
        );
      }
      return {
        gridColumns: "repeat(auto-fit, minmax(100px, 1fr))",
        optionSize: isMobileDevice ? "80px" : "100px",
        gridGap: "8px",
        gridClass: "",
        aspectClass: "",
        scaleFactor: isMobileDevice ? 0.95 : 1
      };
    }
    const foldableInfo = foldableInfoParam || detectFoldableDevice();
    const { deviceType: enhancedDeviceType } = getEnhancedDeviceType(
      containerWidth,
      isMobileDevice
    );
    const gridConfig = calculateGridConfiguration({
      count,
      containerWidth,
      containerHeight,
      isMobileDevice,
      isPortraitMode,
      foldableInfo
    });
    const optionSize = calculateOptionSize({
      count,
      containerWidth,
      containerHeight,
      gridConfig,
      isMobileDevice,
      isPortraitMode,
      foldableInfo
    });
    const gridGap = getGridGap({
      count,
      containerWidth,
      containerHeight,
      isMobileDevice,
      isPortraitMode,
      foldableInfo
    });
    const { gridClass, aspectClass } = getGridClasses(
      count,
      containerWidth,
      containerHeight,
      isPortraitMode,
      foldableInfo
    );
    const deviceConfig = DEVICE_CONFIG[enhancedDeviceType];
    let scaleFactor = deviceConfig?.scaleFactor ?? (isMobileDevice ? 0.95 : 1);
    if (foldableInfo.isFoldable && foldableInfo.isUnfolded) {
      scaleFactor = Math.max(0.9, scaleFactor * 0.95);
    }
    return {
      gridColumns: gridConfig.template,
      optionSize,
      gridGap,
      gridClass,
      aspectClass,
      scaleFactor
    };
  },
  100,
  (count, containerHeight = 0, containerWidth = 0, isMobileDevice, isPortraitMode, foldableInfo) => {
    const roundedWidth = Math.round(containerWidth / 10) * 10;
    const roundedHeight = Math.round(containerHeight / 10) * 10;
    const foldableKey = foldableInfo?.isFoldable ? `${foldableInfo.foldableType}-${foldableInfo.isUnfolded ? "unfolded" : "folded"}` : "none";
    return `${count}:${roundedHeight}:${roundedWidth}:${isMobileDevice}:${isPortraitMode}:${foldableKey}`;
  }
);
function doesRuleMatch(rule, params) {
  if (rule.when.count !== void 0 && rule.when.count !== params.count)
    return false;
  if (rule.when.minCount !== void 0 && params.count < rule.when.minCount)
    return false;
  if (rule.when.maxCount !== void 0 && params.count > rule.when.maxCount)
    return false;
  if (rule.when.device === "desktop" && params.isMobileDevice) return false;
  if (rule.when.device === "mobile" && !params.isMobileDevice) return false;
  if (rule.when.aspect && rule.when.aspect !== params.containerAspect)
    return false;
  if (rule.when.aspects && params.containerAspect && !rule.when.aspects.includes(params.containerAspect))
    return false;
  if (rule.when.orientation === "portrait" && !params.isPortraitMode)
    return false;
  if (rule.when.orientation === "landscape" && params.isPortraitMode)
    return false;
  if (rule.when.extraCheck && !rule.when.extraCheck(params.containerWidth, params.containerHeight, params))
    return false;
  return true;
}
const calculateGridConfiguration = memoizeLRU(
  (params) => {
    const layoutCategory = getLayoutCategory(params.count);
    const containerAspect = getContainerAspect(
      params.containerWidth,
      params.containerHeight
    );
    let columns = getBaseColumnCount(
      layoutCategory,
      containerAspect,
      params.isPortraitMode
    );
    const fullParams = {
      ...params,
      containerAspect,
      layoutCategory
    };
    for (const rule of LAYOUT_RULES) {
      if (doesRuleMatch(rule, fullParams)) {
        if (rule.columns === "+1") {
          columns = Math.min(8, columns + 1);
        } else if (typeof rule.columns === "number") {
          columns = rule.columns;
        }
        break;
      }
    }
    columns = Math.max(1, columns);
    if (params.foldableInfo?.isFoldable && params.foldableInfo.isUnfolded) {
      if (params.foldableInfo.foldableType === "zfold" && !params.isPortraitMode && columns > 2) {
        columns = Math.min(columns, 5);
      }
    }
    const template = `repeat(${columns}, minmax(0, 1fr))`;
    return { columns, template };
  },
  100,
  (params) => {
    const {
      count,
      containerWidth,
      containerHeight,
      isMobileDevice,
      isPortraitMode,
      foldableInfo
    } = params;
    const roundedWidth = Math.round(containerWidth / 10) * 10;
    const roundedHeight = Math.round(containerHeight / 10) * 10;
    const foldableKey = foldableInfo?.isFoldable ? `${foldableInfo.foldableType}-${foldableInfo.isUnfolded ? "unfolded" : "folded"}` : "none";
    return `${count}:${roundedHeight}:${roundedWidth}:${isMobileDevice}:${isPortraitMode}:${foldableKey}`;
  }
);
function getGridGap(params) {
  const layoutCategory = getLayoutCategory(params.count);
  const deviceType = getDeviceType(
    params.containerWidth,
    params.isMobileDevice
  );
  const containerAspect = getContainerAspect(
    params.containerWidth,
    params.containerHeight
  );
  for (const override of GRID_GAP_OVERRIDES) {
    const fullParams = {
      ...params,
      containerAspect,
      layoutCategory
    };
    if (doesRuleMatch(override, fullParams)) {
      return override.gap;
    }
  }
  const deviceConfig = DEVICE_CONFIG[deviceType] || DEVICE_CONFIG.desktop;
  let gapSize = deviceConfig.gap + (GAP_ADJUSTMENTS[layoutCategory] || 0);
  if (params.foldableInfo?.isFoldable && params.foldableInfo.isUnfolded) {
    gapSize = Math.max(2, gapSize - 2);
  }
  return `${Math.max(6, gapSize)}px`;
}
function getGridClasses(count, containerWidth, containerHeight, isPortraitMode, foldableInfo) {
  const layoutCategory = getLayoutCategory(count);
  const containerAspect = getContainerAspect(containerWidth, containerHeight);
  let gridClass = "";
  if (layoutCategory === "singleItem") {
    gridClass = LAYOUT_TEMPLATES.singleItem.class;
  } else if (layoutCategory === "twoItems") {
    const useVerticalLayout = containerAspect === "tall" || containerAspect === "square" && isPortraitMode;
    gridClass = useVerticalLayout ? LAYOUT_TEMPLATES.twoItems.vertical.class : LAYOUT_TEMPLATES.twoItems.horizontal.class;
  } else {
    const deviceOrientation = isPortraitMode ? "portraitDevice" : "landscapeDevice";
    gridClass = LAYOUT_TEMPLATES[layoutCategory][deviceOrientation].class;
  }
  if (foldableInfo?.isFoldable) {
    gridClass += ` foldable-${foldableInfo.foldableType}`;
    gridClass += foldableInfo.isUnfolded ? " unfolded" : " folded";
  }
  const aspectClass = `${containerAspect}-aspect-container`;
  return { gridClass, aspectClass };
}
const calculateOptionSize = memoizeLRU(
  (config) => {
    const {
      count,
      containerWidth,
      containerHeight,
      gridConfig,
      isMobileDevice,
      foldableInfo
    } = config;
    const { columns } = gridConfig;
    if (containerWidth <= 0 || containerHeight <= 0 || columns <= 0) {
      return isMobileDevice ? "80px" : "100px";
    }
    const { deviceType } = getEnhancedDeviceType(
      containerWidth,
      isMobileDevice
    );
    const deviceConfig = DEVICE_CONFIG[deviceType] || DEVICE_CONFIG.desktop;
    const horizontalPadding = deviceConfig.padding.horizontal * 2;
    const verticalPadding = deviceConfig.padding.vertical * 2;
    const gapSize = deviceConfig.gap;
    const totalHorizontalGap = Math.max(0, columns - 1) * gapSize;
    const totalVerticalGap = Math.max(0, Math.ceil(count / columns) - 1) * gapSize;
    const availableWidth = containerWidth - horizontalPadding - totalHorizontalGap;
    const availableHeight = containerHeight - verticalPadding - totalVerticalGap;
    const widthPerItem = availableWidth / columns;
    const heightPerItem = availableHeight / Math.ceil(count / columns);
    let calculatedSize = Math.min(widthPerItem, heightPerItem);
    let scaleFactor = deviceConfig.scaleFactor;
    if (foldableInfo?.isFoldable && foldableInfo.isUnfolded) {
      if (foldableInfo.foldableType === "zfold") {
        scaleFactor *= 0.95;
      }
    }
    calculatedSize *= scaleFactor;
    calculatedSize = Math.max(deviceConfig.minItemSize, calculatedSize);
    calculatedSize = Math.min(deviceConfig.maxItemSize, calculatedSize);
    return `${Math.floor(calculatedSize)}px`;
  },
  100,
  (config) => {
    const {
      count,
      containerWidth,
      containerHeight,
      gridConfig,
      isMobileDevice,
      foldableInfo
    } = config;
    const roundedWidth = Math.round(containerWidth / 10) * 10;
    const roundedHeight = Math.round(containerHeight / 10) * 10;
    const foldableKey = foldableInfo?.isFoldable ? `${foldableInfo.foldableType}-${foldableInfo.isUnfolded ? "unfolded" : "folded"}` : "none";
    return `${count}:${roundedHeight}:${roundedWidth}:${gridConfig.columns}:${isMobileDevice}:${foldableKey}`;
  }
);
function getBaseColumnCount(layoutCategory, aspect, isPortrait) {
  if (layoutCategory === "singleItem") {
    return DEFAULT_COLUMNS.singleItem;
  }
  if (layoutCategory === "twoItems") {
    const useVerticalLayout = aspect === "tall" || aspect === "square" && isPortrait;
    return useVerticalLayout ? DEFAULT_COLUMNS.twoItems.vertical : DEFAULT_COLUMNS.twoItems.horizontal;
  }
  return DEFAULT_COLUMNS[layoutCategory] || 4;
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL2NvbXBvbmVudHMvY29uc3RydWN0L29wdGlvbi1waWNrZXIvdXRpbHMvbGF5b3V0VXRpbHMudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vIHNyYy9saWIvY29tcG9uZW50cy9jb25zdHJ1Y3Qvb3B0aW9uLXBpY2tlci91dGlscy9sYXlvdXRVdGlscy50c1xuXG5pbXBvcnQge1xuICBERVZJQ0VfQ09ORklHLFxuICBHQVBfQURKVVNUTUVOVFMsXG4gIGdldENvbnRhaW5lckFzcGVjdCxcbiAgZ2V0RGV2aWNlVHlwZSxcbiAgZ2V0TGF5b3V0Q2F0ZWdvcnksXG4gIExBWU9VVF9URU1QTEFURVMsXG59IGZyb20gXCIuLi9jb25maWdcIjtcbmltcG9ydCB7XG4gIGRldGVjdEZvbGRhYmxlRGV2aWNlLFxuICB0eXBlIEZvbGRhYmxlRGV0ZWN0aW9uUmVzdWx0LFxufSBmcm9tIFwiLi9kZXZpY2VEZXRlY3Rpb25cIjtcbmltcG9ydCB7XG4gIERFRkFVTFRfQ09MVU1OUyxcbiAgR1JJRF9HQVBfT1ZFUlJJREVTLFxuICBMQVlPVVRfUlVMRVMsXG59IGZyb20gXCIuL2xheW91dENvbmZpZ1wiO1xuaW1wb3J0IHsgbWVtb2l6ZUxSVSB9IGZyb20gXCIuL21lbW9pemF0aW9uVXRpbHNcIjtcblxuaW1wb3J0IHR5cGUge1xuICBDb250YWluZXJBc3BlY3QsXG4gIERldmljZVR5cGUsXG4gIExheW91dENhdGVnb3J5LFxuICBSZXNwb25zaXZlTGF5b3V0Q29uZmlnLFxufSBmcm9tIFwiLi4vY29uZmlnXCI7XG5cbmludGVyZmFjZSBMYXlvdXRSdWxlIHtcbiAgd2hlbjoge1xuICAgIGNvdW50PzogbnVtYmVyO1xuICAgIG1pbkNvdW50PzogbnVtYmVyO1xuICAgIG1heENvdW50PzogbnVtYmVyO1xuICAgIGRldmljZT86IFwiZGVza3RvcFwiIHwgXCJtb2JpbGVcIjtcbiAgICBhc3BlY3Q/OiBDb250YWluZXJBc3BlY3Q7XG4gICAgYXNwZWN0cz86IENvbnRhaW5lckFzcGVjdFtdO1xuICAgIG9yaWVudGF0aW9uPzogXCJwb3J0cmFpdFwiIHwgXCJsYW5kc2NhcGVcIjtcbiAgICBleHRyYUNoZWNrPzogKFxuICAgICAgd2lkdGg6IG51bWJlcixcbiAgICAgIGhlaWdodDogbnVtYmVyLFxuICAgICAgcGFyYW1zOiBHcmlkQ29uZmlnUGFyYW1zXG4gICAgKSA9PiBib29sZWFuO1xuICB9O1xuICBjb2x1bW5zPzogbnVtYmVyIHwgXCIrMVwiO1xuICBnYXA/OiBudW1iZXIgfCBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbmhhbmNlZERldmljZVR5cGUoXG4gIHdpZHRoOiBudW1iZXIsXG4gIGlzTW9iaWxlVXNlckFnZW50OiBib29sZWFuXG4pOiB7XG4gIGRldmljZVR5cGU6IERldmljZVR5cGU7XG4gIGlzRm9sZGFibGU6IGJvb2xlYW47XG4gIGZvbGRhYmxlSW5mbzogRm9sZGFibGVEZXRlY3Rpb25SZXN1bHQ7XG59IHtcbiAgY29uc3QgZm9sZGFibGVJbmZvID0gZGV0ZWN0Rm9sZGFibGVEZXZpY2UoKTtcbiAgY29uc3QgYmFzZURldmljZVR5cGUgPSBnZXREZXZpY2VUeXBlKHdpZHRoLCBpc01vYmlsZVVzZXJBZ2VudCk7XG5cbiAgaWYgKFxuICAgIGZvbGRhYmxlSW5mby5pc0ZvbGRhYmxlICYmXG4gICAgZm9sZGFibGVJbmZvLmlzVW5mb2xkZWQgJiZcbiAgICBmb2xkYWJsZUluZm8uZm9sZGFibGVUeXBlID09PSBcInpmb2xkXCJcbiAgKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRldmljZVR5cGU6IFwidGFibGV0XCIsXG4gICAgICBpc0ZvbGRhYmxlOiB0cnVlLFxuICAgICAgZm9sZGFibGVJbmZvLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRldmljZVR5cGU6IGJhc2VEZXZpY2VUeXBlLFxuICAgIGlzRm9sZGFibGU6IGZvbGRhYmxlSW5mby5pc0ZvbGRhYmxlLFxuICAgIGZvbGRhYmxlSW5mbyxcbiAgfTtcbn1cblxuaW50ZXJmYWNlIEdyaWRDb25maWdQYXJhbXMge1xuICBjb3VudDogbnVtYmVyO1xuICBjb250YWluZXJXaWR0aDogbnVtYmVyO1xuICBjb250YWluZXJIZWlnaHQ6IG51bWJlcjtcbiAgaXNNb2JpbGVEZXZpY2U6IGJvb2xlYW47XG4gIGlzUG9ydHJhaXRNb2RlOiBib29sZWFuO1xuICBmb2xkYWJsZUluZm8/OiBGb2xkYWJsZURldGVjdGlvblJlc3VsdDtcbiAgY29udGFpbmVyQXNwZWN0PzogQ29udGFpbmVyQXNwZWN0OyAvLyBBZGRlZCBjb250YWluZXJBc3BlY3QgcHJvcGVydHlcbn1cblxuZXhwb3J0IGNvbnN0IGdldFJlc3BvbnNpdmVMYXlvdXQgPSBtZW1vaXplTFJVKFxuICAoXG4gICAgY291bnQ6IG51bWJlcixcbiAgICBjb250YWluZXJIZWlnaHQ6IG51bWJlciA9IDAsXG4gICAgY29udGFpbmVyV2lkdGg6IG51bWJlciA9IDAsXG4gICAgaXNNb2JpbGVEZXZpY2U6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICBpc1BvcnRyYWl0TW9kZTogYm9vbGVhbiA9IGZhbHNlLFxuICAgIGZvbGRhYmxlSW5mb1BhcmFtPzogRm9sZGFibGVEZXRlY3Rpb25SZXN1bHRcbiAgKTogUmVzcG9uc2l2ZUxheW91dENvbmZpZyA9PiB7XG4gICAgLy8gUHJvdmlkZSBzZW5zaWJsZSBkZWZhdWx0cyB3aGVuIGRpbWVuc2lvbnMgYXJlbid0IGF2YWlsYWJsZSB5ZXRcbiAgICAvLyBUaGlzIGlzIGNvbW1vbiBkdXJpbmcgaW5pdGlhbCByZW5kZXJpbmcgYmVmb3JlIGxheW91dCBpcyBjYWxjdWxhdGVkXG4gICAgaWYgKGNvbnRhaW5lckhlaWdodCA8PSAwIHx8IGNvbnRhaW5lcldpZHRoIDw9IDApIHtcbiAgICAgIC8vIE9ubHkgbG9nIGluIGRldmVsb3BtZW50IHRvIGF2b2lkIGNvbnNvbGUgc3BhbVxuICAgICAgaWYgKGltcG9ydC5tZXRhLmVudi5ERVYpIHtcbiAgICAgICAgLy8gVXNlIGRlYnVnIGxldmVsIGluc3RlYWQgb2Ygd2FybiB0byByZWR1Y2Ugbm9pc2VcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICBcImdldFJlc3BvbnNpdmVMYXlvdXQ6IFVzaW5nIGRlZmF1bHQgbGF5b3V0IHVudGlsIGNvbnRhaW5lciBkaW1lbnNpb25zIGFyZSBhdmFpbGFibGUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIHNlbnNpYmxlIGRlZmF1bHRzIGJhc2VkIG9uIGRldmljZSB0eXBlXG4gICAgICByZXR1cm4ge1xuICAgICAgICBncmlkQ29sdW1uczogXCJyZXBlYXQoYXV0by1maXQsIG1pbm1heCgxMDBweCwgMWZyKSlcIixcbiAgICAgICAgb3B0aW9uU2l6ZTogaXNNb2JpbGVEZXZpY2UgPyBcIjgwcHhcIiA6IFwiMTAwcHhcIixcbiAgICAgICAgZ3JpZEdhcDogXCI4cHhcIixcbiAgICAgICAgZ3JpZENsYXNzOiBcIlwiLFxuICAgICAgICBhc3BlY3RDbGFzczogXCJcIixcbiAgICAgICAgc2NhbGVGYWN0b3I6IGlzTW9iaWxlRGV2aWNlID8gMC45NSA6IDEuMCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgZm9sZGFibGVJbmZvID0gZm9sZGFibGVJbmZvUGFyYW0gfHwgZGV0ZWN0Rm9sZGFibGVEZXZpY2UoKTtcbiAgICBjb25zdCB7IGRldmljZVR5cGU6IGVuaGFuY2VkRGV2aWNlVHlwZSB9ID0gZ2V0RW5oYW5jZWREZXZpY2VUeXBlKFxuICAgICAgY29udGFpbmVyV2lkdGgsXG4gICAgICBpc01vYmlsZURldmljZVxuICAgICk7XG5cbiAgICBjb25zdCBncmlkQ29uZmlnID0gY2FsY3VsYXRlR3JpZENvbmZpZ3VyYXRpb24oe1xuICAgICAgY291bnQsXG4gICAgICBjb250YWluZXJXaWR0aCxcbiAgICAgIGNvbnRhaW5lckhlaWdodCxcbiAgICAgIGlzTW9iaWxlRGV2aWNlLFxuICAgICAgaXNQb3J0cmFpdE1vZGUsXG4gICAgICBmb2xkYWJsZUluZm8sXG4gICAgfSk7XG5cbiAgICBjb25zdCBvcHRpb25TaXplID0gY2FsY3VsYXRlT3B0aW9uU2l6ZSh7XG4gICAgICBjb3VudCxcbiAgICAgIGNvbnRhaW5lcldpZHRoLFxuICAgICAgY29udGFpbmVySGVpZ2h0LFxuICAgICAgZ3JpZENvbmZpZyxcbiAgICAgIGlzTW9iaWxlRGV2aWNlLFxuICAgICAgaXNQb3J0cmFpdE1vZGUsXG4gICAgICBmb2xkYWJsZUluZm8sXG4gICAgfSk7XG5cbiAgICAvLyBjb25zdCBjb250YWluZXJBc3BlY3QgPSBnZXRDb250YWluZXJBc3BlY3QoY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCk7XG5cbiAgICBjb25zdCBncmlkR2FwID0gZ2V0R3JpZEdhcCh7XG4gICAgICBjb3VudCxcbiAgICAgIGNvbnRhaW5lcldpZHRoLFxuICAgICAgY29udGFpbmVySGVpZ2h0LFxuICAgICAgaXNNb2JpbGVEZXZpY2UsXG4gICAgICBpc1BvcnRyYWl0TW9kZSxcbiAgICAgIGZvbGRhYmxlSW5mbyxcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgZ3JpZENsYXNzLCBhc3BlY3RDbGFzcyB9ID0gZ2V0R3JpZENsYXNzZXMoXG4gICAgICBjb3VudCxcbiAgICAgIGNvbnRhaW5lcldpZHRoLFxuICAgICAgY29udGFpbmVySGVpZ2h0LFxuICAgICAgaXNQb3J0cmFpdE1vZGUsXG4gICAgICBmb2xkYWJsZUluZm9cbiAgICApO1xuXG4gICAgY29uc3QgZGV2aWNlQ29uZmlnID0gREVWSUNFX0NPTkZJR1tlbmhhbmNlZERldmljZVR5cGVdO1xuICAgIGxldCBzY2FsZUZhY3RvciA9XG4gICAgICBkZXZpY2VDb25maWc/LnNjYWxlRmFjdG9yID8/IChpc01vYmlsZURldmljZSA/IDAuOTUgOiAxLjApO1xuXG4gICAgaWYgKGZvbGRhYmxlSW5mby5pc0ZvbGRhYmxlICYmIGZvbGRhYmxlSW5mby5pc1VuZm9sZGVkKSB7XG4gICAgICBzY2FsZUZhY3RvciA9IE1hdGgubWF4KDAuOSwgc2NhbGVGYWN0b3IgKiAwLjk1KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ3JpZENvbHVtbnM6IGdyaWRDb25maWcudGVtcGxhdGUsXG4gICAgICBvcHRpb25TaXplLFxuICAgICAgZ3JpZEdhcCxcbiAgICAgIGdyaWRDbGFzcyxcbiAgICAgIGFzcGVjdENsYXNzLFxuICAgICAgc2NhbGVGYWN0b3IsXG4gICAgfTtcbiAgfSxcbiAgMTAwLFxuICAoXG4gICAgY291bnQsXG4gICAgY29udGFpbmVySGVpZ2h0ID0gMCxcbiAgICBjb250YWluZXJXaWR0aCA9IDAsXG4gICAgaXNNb2JpbGVEZXZpY2UsXG4gICAgaXNQb3J0cmFpdE1vZGUsXG4gICAgZm9sZGFibGVJbmZvXG4gICkgPT4ge1xuICAgIGNvbnN0IHJvdW5kZWRXaWR0aCA9IE1hdGgucm91bmQoY29udGFpbmVyV2lkdGggLyAxMCkgKiAxMDtcbiAgICBjb25zdCByb3VuZGVkSGVpZ2h0ID0gTWF0aC5yb3VuZChjb250YWluZXJIZWlnaHQgLyAxMCkgKiAxMDtcbiAgICBjb25zdCBmb2xkYWJsZUtleSA9IGZvbGRhYmxlSW5mbz8uaXNGb2xkYWJsZVxuICAgICAgPyBgJHtmb2xkYWJsZUluZm8uZm9sZGFibGVUeXBlfS0ke2ZvbGRhYmxlSW5mby5pc1VuZm9sZGVkID8gXCJ1bmZvbGRlZFwiIDogXCJmb2xkZWRcIn1gXG4gICAgICA6IFwibm9uZVwiO1xuICAgIHJldHVybiBgJHtjb3VudH06JHtyb3VuZGVkSGVpZ2h0fToke3JvdW5kZWRXaWR0aH06JHtpc01vYmlsZURldmljZX06JHtpc1BvcnRyYWl0TW9kZX06JHtmb2xkYWJsZUtleX1gO1xuICB9XG4pO1xuXG5mdW5jdGlvbiBkb2VzUnVsZU1hdGNoKFxuICBydWxlOiBMYXlvdXRSdWxlIHwgeyB3aGVuOiBMYXlvdXRSdWxlW1wid2hlblwiXTsgZ2FwOiBzdHJpbmcgfSxcbiAgcGFyYW1zOiBHcmlkQ29uZmlnUGFyYW1zXG4pOiBib29sZWFuIHtcbiAgaWYgKHJ1bGUud2hlbi5jb3VudCAhPT0gdW5kZWZpbmVkICYmIHJ1bGUud2hlbi5jb3VudCAhPT0gcGFyYW1zLmNvdW50KVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHJ1bGUud2hlbi5taW5Db3VudCAhPT0gdW5kZWZpbmVkICYmIHBhcmFtcy5jb3VudCA8IHJ1bGUud2hlbi5taW5Db3VudClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChydWxlLndoZW4ubWF4Q291bnQgIT09IHVuZGVmaW5lZCAmJiBwYXJhbXMuY291bnQgPiBydWxlLndoZW4ubWF4Q291bnQpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAocnVsZS53aGVuLmRldmljZSA9PT0gXCJkZXNrdG9wXCIgJiYgcGFyYW1zLmlzTW9iaWxlRGV2aWNlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChydWxlLndoZW4uZGV2aWNlID09PSBcIm1vYmlsZVwiICYmICFwYXJhbXMuaXNNb2JpbGVEZXZpY2UpIHJldHVybiBmYWxzZTtcbiAgaWYgKHJ1bGUud2hlbi5hc3BlY3QgJiYgcnVsZS53aGVuLmFzcGVjdCAhPT0gcGFyYW1zLmNvbnRhaW5lckFzcGVjdClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChcbiAgICBydWxlLndoZW4uYXNwZWN0cyAmJlxuICAgIHBhcmFtcy5jb250YWluZXJBc3BlY3QgJiZcbiAgICAhcnVsZS53aGVuLmFzcGVjdHMuaW5jbHVkZXMocGFyYW1zLmNvbnRhaW5lckFzcGVjdClcbiAgKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHJ1bGUud2hlbi5vcmllbnRhdGlvbiA9PT0gXCJwb3J0cmFpdFwiICYmICFwYXJhbXMuaXNQb3J0cmFpdE1vZGUpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAocnVsZS53aGVuLm9yaWVudGF0aW9uID09PSBcImxhbmRzY2FwZVwiICYmIHBhcmFtcy5pc1BvcnRyYWl0TW9kZSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChcbiAgICBydWxlLndoZW4uZXh0cmFDaGVjayAmJlxuICAgICFydWxlLndoZW4uZXh0cmFDaGVjayhwYXJhbXMuY29udGFpbmVyV2lkdGgsIHBhcmFtcy5jb250YWluZXJIZWlnaHQsIHBhcmFtcylcbiAgKVxuICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgY2FsY3VsYXRlR3JpZENvbmZpZ3VyYXRpb24gPSBtZW1vaXplTFJVKFxuICAocGFyYW1zOiBHcmlkQ29uZmlnUGFyYW1zKSA9PiB7XG4gICAgY29uc3QgbGF5b3V0Q2F0ZWdvcnkgPSBnZXRMYXlvdXRDYXRlZ29yeShwYXJhbXMuY291bnQpO1xuICAgIGNvbnN0IGNvbnRhaW5lckFzcGVjdCA9IGdldENvbnRhaW5lckFzcGVjdChcbiAgICAgIHBhcmFtcy5jb250YWluZXJXaWR0aCxcbiAgICAgIHBhcmFtcy5jb250YWluZXJIZWlnaHRcbiAgICApO1xuXG4gICAgbGV0IGNvbHVtbnMgPSBnZXRCYXNlQ29sdW1uQ291bnQoXG4gICAgICBsYXlvdXRDYXRlZ29yeSxcbiAgICAgIGNvbnRhaW5lckFzcGVjdCxcbiAgICAgIHBhcmFtcy5pc1BvcnRyYWl0TW9kZVxuICAgICk7XG5cbiAgICBjb25zdCBmdWxsUGFyYW1zID0ge1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgY29udGFpbmVyQXNwZWN0LFxuICAgICAgbGF5b3V0Q2F0ZWdvcnksXG4gICAgfTtcblxuICAgIGZvciAoY29uc3QgcnVsZSBvZiBMQVlPVVRfUlVMRVMpIHtcbiAgICAgIGlmIChkb2VzUnVsZU1hdGNoKHJ1bGUsIGZ1bGxQYXJhbXMpKSB7XG4gICAgICAgIGlmIChydWxlLmNvbHVtbnMgPT09IFwiKzFcIikge1xuICAgICAgICAgIGNvbHVtbnMgPSBNYXRoLm1pbig4LCBjb2x1bW5zICsgMSk7IC8vIERlZmF1bHQgbWF4IGNvbHVtbnMgdG8gOFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBydWxlLmNvbHVtbnMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBjb2x1bW5zID0gcnVsZS5jb2x1bW5zO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29sdW1ucyA9IE1hdGgubWF4KDEsIGNvbHVtbnMpO1xuXG4gICAgaWYgKHBhcmFtcy5mb2xkYWJsZUluZm8/LmlzRm9sZGFibGUgJiYgcGFyYW1zLmZvbGRhYmxlSW5mby5pc1VuZm9sZGVkKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHBhcmFtcy5mb2xkYWJsZUluZm8uZm9sZGFibGVUeXBlID09PSBcInpmb2xkXCIgJiZcbiAgICAgICAgIXBhcmFtcy5pc1BvcnRyYWl0TW9kZSAmJlxuICAgICAgICBjb2x1bW5zID4gMlxuICAgICAgKSB7XG4gICAgICAgIGNvbHVtbnMgPSBNYXRoLm1pbihjb2x1bW5zLCA1KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGByZXBlYXQoJHtjb2x1bW5zfSwgbWlubWF4KDAsIDFmcikpYDtcblxuICAgIHJldHVybiB7IGNvbHVtbnMsIHRlbXBsYXRlIH07XG4gIH0sXG4gIDEwMCxcbiAgKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvdW50LFxuICAgICAgY29udGFpbmVyV2lkdGgsXG4gICAgICBjb250YWluZXJIZWlnaHQsXG4gICAgICBpc01vYmlsZURldmljZSxcbiAgICAgIGlzUG9ydHJhaXRNb2RlLFxuICAgICAgZm9sZGFibGVJbmZvLFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3Qgcm91bmRlZFdpZHRoID0gTWF0aC5yb3VuZChjb250YWluZXJXaWR0aCAvIDEwKSAqIDEwO1xuICAgIGNvbnN0IHJvdW5kZWRIZWlnaHQgPSBNYXRoLnJvdW5kKGNvbnRhaW5lckhlaWdodCAvIDEwKSAqIDEwO1xuICAgIGNvbnN0IGZvbGRhYmxlS2V5ID0gZm9sZGFibGVJbmZvPy5pc0ZvbGRhYmxlXG4gICAgICA/IGAke2ZvbGRhYmxlSW5mby5mb2xkYWJsZVR5cGV9LSR7Zm9sZGFibGVJbmZvLmlzVW5mb2xkZWQgPyBcInVuZm9sZGVkXCIgOiBcImZvbGRlZFwifWBcbiAgICAgIDogXCJub25lXCI7XG4gICAgcmV0dXJuIGAke2NvdW50fToke3JvdW5kZWRIZWlnaHR9OiR7cm91bmRlZFdpZHRofToke2lzTW9iaWxlRGV2aWNlfToke2lzUG9ydHJhaXRNb2RlfToke2ZvbGRhYmxlS2V5fWA7XG4gIH1cbik7XG5cbmZ1bmN0aW9uIGdldEdyaWRHYXAocGFyYW1zOiB7XG4gIGNvdW50OiBudW1iZXI7XG4gIGNvbnRhaW5lcldpZHRoOiBudW1iZXI7XG4gIGNvbnRhaW5lckhlaWdodDogbnVtYmVyO1xuICBpc01vYmlsZURldmljZTogYm9vbGVhbjtcbiAgaXNQb3J0cmFpdE1vZGU6IGJvb2xlYW47XG4gIGZvbGRhYmxlSW5mbz86IEZvbGRhYmxlRGV0ZWN0aW9uUmVzdWx0O1xufSk6IHN0cmluZyB7XG4gIGNvbnN0IGxheW91dENhdGVnb3J5ID0gZ2V0TGF5b3V0Q2F0ZWdvcnkocGFyYW1zLmNvdW50KTtcbiAgY29uc3QgZGV2aWNlVHlwZSA9IGdldERldmljZVR5cGUoXG4gICAgcGFyYW1zLmNvbnRhaW5lcldpZHRoLFxuICAgIHBhcmFtcy5pc01vYmlsZURldmljZVxuICApO1xuICBjb25zdCBjb250YWluZXJBc3BlY3QgPSBnZXRDb250YWluZXJBc3BlY3QoXG4gICAgcGFyYW1zLmNvbnRhaW5lcldpZHRoLFxuICAgIHBhcmFtcy5jb250YWluZXJIZWlnaHRcbiAgKTtcblxuICBmb3IgKGNvbnN0IG92ZXJyaWRlIG9mIEdSSURfR0FQX09WRVJSSURFUykge1xuICAgIGNvbnN0IGZ1bGxQYXJhbXMgPSB7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBjb250YWluZXJBc3BlY3QsXG4gICAgICBsYXlvdXRDYXRlZ29yeSxcbiAgICB9O1xuXG4gICAgaWYgKGRvZXNSdWxlTWF0Y2gob3ZlcnJpZGUsIGZ1bGxQYXJhbXMpKSB7XG4gICAgICByZXR1cm4gb3ZlcnJpZGUuZ2FwO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRldmljZUNvbmZpZyA9XG4gICAgREVWSUNFX0NPTkZJR1tkZXZpY2VUeXBlIGFzIGtleW9mIHR5cGVvZiBERVZJQ0VfQ09ORklHXSB8fFxuICAgIERFVklDRV9DT05GSUcuZGVza3RvcDtcblxuICBsZXQgZ2FwU2l6ZSA9XG4gICAgZGV2aWNlQ29uZmlnLmdhcCArXG4gICAgKEdBUF9BREpVU1RNRU5UU1tsYXlvdXRDYXRlZ29yeSBhcyBrZXlvZiB0eXBlb2YgR0FQX0FESlVTVE1FTlRTXSB8fCAwKTtcblxuICBpZiAocGFyYW1zLmZvbGRhYmxlSW5mbz8uaXNGb2xkYWJsZSAmJiBwYXJhbXMuZm9sZGFibGVJbmZvLmlzVW5mb2xkZWQpIHtcbiAgICBnYXBTaXplID0gTWF0aC5tYXgoMiwgZ2FwU2l6ZSAtIDIpO1xuICB9XG5cbiAgLy8gRW5mb3JjZSBhIG1pbmltdW0gZ2FwIHNpemUgb2YgNnB4IHJlZ2FyZGxlc3Mgb2Ygc2NyZWVuIHdpZHRoIHRvIHByZXZlbnQgb3B0aW9ucyBzdGlja2luZyB0b2dldGhlclxuICByZXR1cm4gYCR7TWF0aC5tYXgoNiwgZ2FwU2l6ZSl9cHhgO1xufVxuXG5mdW5jdGlvbiBnZXRHcmlkQ2xhc3NlcyhcbiAgY291bnQ6IG51bWJlcixcbiAgY29udGFpbmVyV2lkdGg6IG51bWJlcixcbiAgY29udGFpbmVySGVpZ2h0OiBudW1iZXIsXG4gIGlzUG9ydHJhaXRNb2RlOiBib29sZWFuLFxuICBmb2xkYWJsZUluZm8/OiBGb2xkYWJsZURldGVjdGlvblJlc3VsdFxuKTogeyBncmlkQ2xhc3M6IHN0cmluZzsgYXNwZWN0Q2xhc3M6IHN0cmluZyB9IHtcbiAgY29uc3QgbGF5b3V0Q2F0ZWdvcnkgPSBnZXRMYXlvdXRDYXRlZ29yeShjb3VudCk7XG4gIGNvbnN0IGNvbnRhaW5lckFzcGVjdCA9IGdldENvbnRhaW5lckFzcGVjdChjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KTtcblxuICBsZXQgZ3JpZENsYXNzID0gXCJcIjtcblxuICBpZiAobGF5b3V0Q2F0ZWdvcnkgPT09IFwic2luZ2xlSXRlbVwiKSB7XG4gICAgZ3JpZENsYXNzID0gTEFZT1VUX1RFTVBMQVRFUy5zaW5nbGVJdGVtLmNsYXNzO1xuICB9IGVsc2UgaWYgKGxheW91dENhdGVnb3J5ID09PSBcInR3b0l0ZW1zXCIpIHtcbiAgICBjb25zdCB1c2VWZXJ0aWNhbExheW91dCA9XG4gICAgICBjb250YWluZXJBc3BlY3QgPT09IFwidGFsbFwiIHx8XG4gICAgICAoY29udGFpbmVyQXNwZWN0ID09PSBcInNxdWFyZVwiICYmIGlzUG9ydHJhaXRNb2RlKTtcbiAgICBncmlkQ2xhc3MgPSB1c2VWZXJ0aWNhbExheW91dFxuICAgICAgPyBMQVlPVVRfVEVNUExBVEVTLnR3b0l0ZW1zLnZlcnRpY2FsLmNsYXNzXG4gICAgICA6IExBWU9VVF9URU1QTEFURVMudHdvSXRlbXMuaG9yaXpvbnRhbC5jbGFzcztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkZXZpY2VPcmllbnRhdGlvbiA9IGlzUG9ydHJhaXRNb2RlXG4gICAgICA/IFwicG9ydHJhaXREZXZpY2VcIlxuICAgICAgOiBcImxhbmRzY2FwZURldmljZVwiO1xuICAgIGdyaWRDbGFzcyA9IExBWU9VVF9URU1QTEFURVNbbGF5b3V0Q2F0ZWdvcnldW2RldmljZU9yaWVudGF0aW9uXS5jbGFzcztcbiAgfVxuXG4gIGlmIChmb2xkYWJsZUluZm8/LmlzRm9sZGFibGUpIHtcbiAgICBncmlkQ2xhc3MgKz0gYCBmb2xkYWJsZS0ke2ZvbGRhYmxlSW5mby5mb2xkYWJsZVR5cGV9YDtcbiAgICBncmlkQ2xhc3MgKz0gZm9sZGFibGVJbmZvLmlzVW5mb2xkZWQgPyBcIiB1bmZvbGRlZFwiIDogXCIgZm9sZGVkXCI7XG4gIH1cblxuICBjb25zdCBhc3BlY3RDbGFzcyA9IGAke2NvbnRhaW5lckFzcGVjdH0tYXNwZWN0LWNvbnRhaW5lcmA7XG5cbiAgcmV0dXJuIHsgZ3JpZENsYXNzLCBhc3BlY3RDbGFzcyB9O1xufVxuXG5jb25zdCBjYWxjdWxhdGVPcHRpb25TaXplID0gbWVtb2l6ZUxSVShcbiAgKGNvbmZpZzoge1xuICAgIGNvdW50OiBudW1iZXI7XG4gICAgY29udGFpbmVyV2lkdGg6IG51bWJlcjtcbiAgICBjb250YWluZXJIZWlnaHQ6IG51bWJlcjtcbiAgICBncmlkQ29uZmlnOiB7IGNvbHVtbnM6IG51bWJlcjsgdGVtcGxhdGU6IHN0cmluZyB9O1xuICAgIGlzTW9iaWxlRGV2aWNlOiBib29sZWFuO1xuICAgIGlzUG9ydHJhaXRNb2RlOiBib29sZWFuO1xuICAgIGZvbGRhYmxlSW5mbz86IEZvbGRhYmxlRGV0ZWN0aW9uUmVzdWx0O1xuICB9KTogc3RyaW5nID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjb3VudCxcbiAgICAgIGNvbnRhaW5lcldpZHRoLFxuICAgICAgY29udGFpbmVySGVpZ2h0LFxuICAgICAgZ3JpZENvbmZpZyxcbiAgICAgIGlzTW9iaWxlRGV2aWNlLFxuICAgICAgZm9sZGFibGVJbmZvLFxuICAgIH0gPSBjb25maWc7XG4gICAgY29uc3QgeyBjb2x1bW5zIH0gPSBncmlkQ29uZmlnO1xuXG4gICAgaWYgKGNvbnRhaW5lcldpZHRoIDw9IDAgfHwgY29udGFpbmVySGVpZ2h0IDw9IDAgfHwgY29sdW1ucyA8PSAwKSB7XG4gICAgICByZXR1cm4gaXNNb2JpbGVEZXZpY2UgPyBcIjgwcHhcIiA6IFwiMTAwcHhcIjtcbiAgICB9XG5cbiAgICBjb25zdCB7IGRldmljZVR5cGUgfSA9IGdldEVuaGFuY2VkRGV2aWNlVHlwZShcbiAgICAgIGNvbnRhaW5lcldpZHRoLFxuICAgICAgaXNNb2JpbGVEZXZpY2VcbiAgICApO1xuICAgIGNvbnN0IGRldmljZUNvbmZpZyA9XG4gICAgICBERVZJQ0VfQ09ORklHW2RldmljZVR5cGUgYXMga2V5b2YgdHlwZW9mIERFVklDRV9DT05GSUddIHx8XG4gICAgICBERVZJQ0VfQ09ORklHLmRlc2t0b3A7XG5cbiAgICBjb25zdCBob3Jpem9udGFsUGFkZGluZyA9IGRldmljZUNvbmZpZy5wYWRkaW5nLmhvcml6b250YWwgKiAyO1xuICAgIGNvbnN0IHZlcnRpY2FsUGFkZGluZyA9IGRldmljZUNvbmZpZy5wYWRkaW5nLnZlcnRpY2FsICogMjtcbiAgICBjb25zdCBnYXBTaXplID0gZGV2aWNlQ29uZmlnLmdhcDtcbiAgICBjb25zdCB0b3RhbEhvcml6b250YWxHYXAgPSBNYXRoLm1heCgwLCBjb2x1bW5zIC0gMSkgKiBnYXBTaXplO1xuICAgIGNvbnN0IHRvdGFsVmVydGljYWxHYXAgPVxuICAgICAgTWF0aC5tYXgoMCwgTWF0aC5jZWlsKGNvdW50IC8gY29sdW1ucykgLSAxKSAqIGdhcFNpemU7XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPVxuICAgICAgY29udGFpbmVyV2lkdGggLSBob3Jpem9udGFsUGFkZGluZyAtIHRvdGFsSG9yaXpvbnRhbEdhcDtcbiAgICBjb25zdCBhdmFpbGFibGVIZWlnaHQgPVxuICAgICAgY29udGFpbmVySGVpZ2h0IC0gdmVydGljYWxQYWRkaW5nIC0gdG90YWxWZXJ0aWNhbEdhcDtcblxuICAgIGNvbnN0IHdpZHRoUGVySXRlbSA9IGF2YWlsYWJsZVdpZHRoIC8gY29sdW1ucztcbiAgICBjb25zdCBoZWlnaHRQZXJJdGVtID0gYXZhaWxhYmxlSGVpZ2h0IC8gTWF0aC5jZWlsKGNvdW50IC8gY29sdW1ucyk7XG5cbiAgICBsZXQgY2FsY3VsYXRlZFNpemUgPSBNYXRoLm1pbih3aWR0aFBlckl0ZW0sIGhlaWdodFBlckl0ZW0pO1xuXG4gICAgbGV0IHNjYWxlRmFjdG9yID0gZGV2aWNlQ29uZmlnLnNjYWxlRmFjdG9yO1xuXG4gICAgaWYgKGZvbGRhYmxlSW5mbz8uaXNGb2xkYWJsZSAmJiBmb2xkYWJsZUluZm8uaXNVbmZvbGRlZCkge1xuICAgICAgaWYgKGZvbGRhYmxlSW5mby5mb2xkYWJsZVR5cGUgPT09IFwiemZvbGRcIikge1xuICAgICAgICBzY2FsZUZhY3RvciAqPSAwLjk1O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGN1bGF0ZWRTaXplICo9IHNjYWxlRmFjdG9yO1xuXG4gICAgY2FsY3VsYXRlZFNpemUgPSBNYXRoLm1heChkZXZpY2VDb25maWcubWluSXRlbVNpemUsIGNhbGN1bGF0ZWRTaXplKTtcbiAgICBjYWxjdWxhdGVkU2l6ZSA9IE1hdGgubWluKGRldmljZUNvbmZpZy5tYXhJdGVtU2l6ZSwgY2FsY3VsYXRlZFNpemUpO1xuXG4gICAgcmV0dXJuIGAke01hdGguZmxvb3IoY2FsY3VsYXRlZFNpemUpfXB4YDtcbiAgfSxcbiAgMTAwLFxuICAoY29uZmlnKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY291bnQsXG4gICAgICBjb250YWluZXJXaWR0aCxcbiAgICAgIGNvbnRhaW5lckhlaWdodCxcbiAgICAgIGdyaWRDb25maWcsXG4gICAgICBpc01vYmlsZURldmljZSxcbiAgICAgIGZvbGRhYmxlSW5mbyxcbiAgICB9ID0gY29uZmlnO1xuICAgIGNvbnN0IHJvdW5kZWRXaWR0aCA9IE1hdGgucm91bmQoY29udGFpbmVyV2lkdGggLyAxMCkgKiAxMDtcbiAgICBjb25zdCByb3VuZGVkSGVpZ2h0ID0gTWF0aC5yb3VuZChjb250YWluZXJIZWlnaHQgLyAxMCkgKiAxMDtcbiAgICBjb25zdCBmb2xkYWJsZUtleSA9IGZvbGRhYmxlSW5mbz8uaXNGb2xkYWJsZVxuICAgICAgPyBgJHtmb2xkYWJsZUluZm8uZm9sZGFibGVUeXBlfS0ke2ZvbGRhYmxlSW5mby5pc1VuZm9sZGVkID8gXCJ1bmZvbGRlZFwiIDogXCJmb2xkZWRcIn1gXG4gICAgICA6IFwibm9uZVwiO1xuICAgIHJldHVybiBgJHtjb3VudH06JHtyb3VuZGVkSGVpZ2h0fToke3JvdW5kZWRXaWR0aH06JHtncmlkQ29uZmlnLmNvbHVtbnN9OiR7aXNNb2JpbGVEZXZpY2V9OiR7Zm9sZGFibGVLZXl9YDtcbiAgfVxuKTtcblxuZnVuY3Rpb24gZ2V0QmFzZUNvbHVtbkNvdW50KFxuICBsYXlvdXRDYXRlZ29yeTogTGF5b3V0Q2F0ZWdvcnksXG4gIGFzcGVjdDogQ29udGFpbmVyQXNwZWN0LFxuICBpc1BvcnRyYWl0OiBib29sZWFuXG4pOiBudW1iZXIge1xuICBpZiAobGF5b3V0Q2F0ZWdvcnkgPT09IFwic2luZ2xlSXRlbVwiKSB7XG4gICAgcmV0dXJuIERFRkFVTFRfQ09MVU1OUy5zaW5nbGVJdGVtO1xuICB9XG5cbiAgaWYgKGxheW91dENhdGVnb3J5ID09PSBcInR3b0l0ZW1zXCIpIHtcbiAgICAvLyBEZXRlcm1pbmUgdmVydGljYWwgdnMgaG9yaXpvbnRhbCBsYXlvdXRcbiAgICBjb25zdCB1c2VWZXJ0aWNhbExheW91dCA9XG4gICAgICBhc3BlY3QgPT09IFwidGFsbFwiIHx8IChhc3BlY3QgPT09IFwic3F1YXJlXCIgJiYgaXNQb3J0cmFpdCk7XG4gICAgcmV0dXJuIHVzZVZlcnRpY2FsTGF5b3V0XG4gICAgICA/IERFRkFVTFRfQ09MVU1OUy50d29JdGVtcy52ZXJ0aWNhbFxuICAgICAgOiBERUZBVUxUX0NPTFVNTlMudHdvSXRlbXMuaG9yaXpvbnRhbDtcbiAgfVxuXG4gIC8vIEZvciBncmlkIGxheW91dHMsIGp1c3QgdXNlIHRoZSBkZWZhdWx0IGNvbHVtbiBjb3VudFxuICByZXR1cm4gREVGQVVMVF9DT0xVTU5TW2xheW91dENhdGVnb3J5XSB8fCA0O1xufVxuIl0sCiAgIm1hcHBpbmdzIjogIkFBRUE7QUFBQSxFQUNFO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxPQUNLO0FBQ1A7QUFBQSxFQUNFO0FBQUEsT0FFSztBQUNQO0FBQUEsRUFDRTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsT0FDSztBQUNQLFNBQVMsa0JBQWtCO0FBNEJwQixnQkFBUyxzQkFDZCxPQUNBLG1CQUtBO0FBQ0EsUUFBTSxlQUFlLHFCQUFxQjtBQUMxQyxRQUFNLGlCQUFpQixjQUFjLE9BQU8saUJBQWlCO0FBRTdELE1BQ0UsYUFBYSxjQUNiLGFBQWEsY0FDYixhQUFhLGlCQUFpQixTQUM5QjtBQUNBLFdBQU87QUFB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
