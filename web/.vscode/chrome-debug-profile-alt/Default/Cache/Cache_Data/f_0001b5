import { createHotContext as __vite__createHotContext } from "/@vite/client";import.meta.hot = __vite__createHotContext("/src/lib/components/construct/StartPositionPicker.svelte");import "/node_modules/.vite/deps/svelte_internal_disclose-version.js?v=474c1bba";

StartPositionPicker[$.FILENAME] = 'src/lib/components/construct/StartPositionPicker.svelte';

import * as $ from "/node_modules/.vite/deps/svelte_internal_client.js?v=474c1bba";
import { resolve } from "/src/lib/services/bootstrap.ts?t=1755802820664";
import { onMount } from "/node_modules/.vite/deps/svelte.js?v=474c1bba";
import { GridMode } from "/src/lib/domain/index.ts";
import LoadingState from "/src/lib/components/construct/start-position/ui/LoadingState.svelte";
import ErrorState from "/src/lib/components/construct/start-position/ui/ErrorState.svelte";
import PictographGrid from "/src/lib/components/construct/start-position/ui/PictographGrid.svelte?t=1755802820664";
import TransitionOverlay from "/src/lib/components/construct/start-position/ui/TransitionOverlay.svelte";
import { sequenceStateService } from "/src/lib/services/SequenceStateService.svelte.ts";

var root = $.add_locations($.from_html(`<div class="start-pos-picker s-V6OxA4DJ9E7q" data-testid="start-position-picker"><!> <div style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 5px; font-size: 10px;" class="s-V6OxA4DJ9E7q"> </div> <!></div>`), StartPositionPicker[$.FILENAME], [[139, 0, [[158, 2]]]]);

function StartPositionPicker($$anchor, $$props) {
	$.check_target(new.target);
	$.push($$props, true, StartPositionPicker);

	const gridMode = $.prop($$props, 'gridMode', 19, () => GridMode.DIAMOND);
	let isLoading = $.tag($.state(true), 'isLoading');
	let startPositions = $.tag($.state($.proxy([])), 'startPositions');
	let loadingError = $.tag($.state(false), 'loadingError');
	let selectedStartPos = $.tag($.state(null), 'selectedStartPos');
	let isTransitioning = $.tag($.state(false), 'isTransitioning');
	let startPositionService = null;
	let selectionService = null;

	function initializeServices() {
		try {
			console.log("StartPositionPicker: Attempting to resolve services...");

			try {
				startPositionService = resolve("IStartPositionService");
				console.log("StartPositionPicker: \u2705 IStartPositionService resolved");
			} catch(error) {
				console.log(...$.log_if_contains_state('log', "StartPositionPicker: \u274C Failed to resolve IStartPositionService:", error));

				return false;
			}

			try {
				selectionService = resolve("IStartPositionSelectionService");
				console.log("StartPositionPicker: \u2705 IStartPositionSelectionService resolved");
			} catch(error) {
				console.log(...$.log_if_contains_state('log', "StartPositionPicker: \u274C Failed to resolve IStartPositionSelectionService:", error));

				return false;
			}

			return true;
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "StartPositionPicker: Failed to resolve services:", error));

			return false;
		}
	}

	async function loadStartPositions() {
		console.log("StartPositionPicker: loadStartPositions called");

		if (!startPositionService) {
			console.log("StartPositionPicker: Service not available, trying to initialize...");

			if (!initializeServices()) {
				console.log("StartPositionPicker: Failed to initialize services");

				return;
			}
		}

		if (!startPositionService) {
			console.log("StartPositionPicker: Still no service available");

			return;
		}

		try {
			console.log("StartPositionPicker: Setting loading to true");
			$.set(isLoading, true);
			$.set(loadingError, false);
			console.log(...$.log_if_contains_state('log', "StartPositionPicker: Calling getDefaultStartPositions with gridMode:", gridMode()));

			const positions = (await $.track_reactivity_loss(startPositionService.getDefaultStartPositions(gridMode())))();

			console.log(...$.log_if_contains_state('log', "StartPositionPicker: Received positions:", positions?.length || 0));
			$.set(startPositions, positions || [], true);
			console.log("StartPositionPicker: Setting loading to false");
			$.set(isLoading, false);
			console.log(...$.log_if_contains_state('log', "StartPositionPicker: Final state - isLoading:", $.get(isLoading), "positions:", $.get(startPositions).length));
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "StartPositionPicker: Error loading start positions:", error));
			$.set(loadingError, true);
			$.set(startPositions, [], true);
			$.set(isLoading, false);
		}
	}

	async function handleSelect(startPosPictograph) {
		if (!selectionService || !startPositionService) {
			console.error("Services not available for start position selection");

			return;
		}

		try {
			$.set(isTransitioning, true);
			$.set(selectedStartPos, startPosPictograph, true);
			(await $.track_reactivity_loss(selectionService.selectStartPosition(startPosPictograph, startPositionService)))();

			setTimeout(
				() => {
					$.set(isTransitioning, false);
				},
				200
			);
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "StartPositionPicker: Error selecting start position:", error));
			$.set(isTransitioning, false);
			alert(`Failed to select start position: ${error instanceof Error ? error.message : "Unknown error"}`);
		}
	}

	onMount(() => {
		console.log("StartPositionPicker: onMount called");
		loadStartPositions();
	});

	$.user_effect(() => {
		if (gridMode()) {
			loadStartPositions();
		}
	});

	$.user_effect(() => {
		const currentSequence = sequenceStateService.currentSequence;

		if (currentSequence && currentSequence.startPosition && $.get(isTransitioning)) {
			$.set(isTransitioning, false);
		}
	});

	var div = root();
	var node = $.child(div);

	{
		var consequent = ($$anchor) => {
			var fragment = $.comment();
			var node_1 = $.first_child(fragment);

			$.add_svelte_meta(() => LoadingState(node_1, {}), 'component', StartPositionPicker, 141, 4, { componentTag: 'LoadingState' });
			$.append($$anchor, fragment);
		};

		var alternate_2 = ($$anchor) => {
			var fragment_1 = $.comment();
			var node_2 = $.first_child(fragment_1);

			{
				var consequent_1 = ($$anchor) => {
					var fragment_2 = $.comment();
					var node_3 = $.first_child(fragment_2);

					$.add_svelte_meta(() => ErrorState(node_3, {}), 'component', StartPositionPicker, 143, 4, { componentTag: 'ErrorState' });
					$.append($$anchor, fragment_2);
				};

				var alternate_1 = ($$anchor) => {
					var fragment_3 = $.comment();
					var node_4 = $.first_child(fragment_3);

					{
						var consequent_2 = ($$anchor) => {
							var fragment_4 = $.comment();
							var node_5 = $.first_child(fragment_4);

							$.add_svelte_meta(
								() => ErrorState(node_5, {
									message: 'No valid start positions found for the current configuration.',
									hasRefreshButton: false
								}),
								'component',
								StartPositionPicker,
								145,
								4,
								{ componentTag: 'ErrorState' }
							);

							$.append($$anchor, fragment_4);
						};

						var alternate = ($$anchor) => {
							var fragment_5 = $.comment();
							var node_6 = $.first_child(fragment_5);

							$.add_svelte_meta(
								() => PictographGrid(node_6, {
									get pictographs() {
										return $.get(startPositions);
									},

									get selectedPictograph() {
										return $.get(selectedStartPos);
									},

									onPictographSelect: handleSelect
								}),
								'component',
								StartPositionPicker,
								150,
								4,
								{ componentTag: 'PictographGrid' }
							);

							$.append($$anchor, fragment_5);
						};

						$.add_svelte_meta(
							() => $.if(
								node_4,
								($$render) => {
									if ($.strict_equals($.get(startPositions).length, 0)) $$render(consequent_2); else $$render(alternate, false);
								},
								true
							),
							'if',
							StartPositionPicker,
							144,
							2
						);
					}

					$.append($$anchor, fragment_3);
				};

				$.add_svelte_meta(
					() => $.if(
						node_2,
						($$render) => {
							if ($.get(loadingError)) $$render(consequent_1); else $$render(alternate_1, false);
						},
						true
					),
					'if',
					StartPositionPicker,
					142,
					2
				);
			}

			$.append($$anchor, fragment_1);
		};

		$.add_svelte_meta(
			() => $.if(node, ($$render) => {
				if ($.get(isLoading)) $$render(consequent); else $$render(alternate_2, false);
			}),
			'if',
			StartPositionPicker,
			140,
			2
		);
	}

	var div_1 = $.sibling(node, 2);
	var text = $.child(div_1);

	$.reset(div_1);

	var node_7 = $.sibling(div_1, 2);

	{
		var consequent_3 = ($$anchor) => {
			var fragment_6 = $.comment();
			var node_8 = $.first_child(fragment_6);

			$.add_svelte_meta(() => TransitionOverlay(node_8, {}), 'component', StartPositionPicker, 166, 4, { componentTag: 'TransitionOverlay' });
			$.append($$anchor, fragment_6);
		};

		$.add_svelte_meta(
			() => $.if(node_7, ($$render) => {
				if ($.get(isTransitioning)) $$render(consequent_3);
			}),
			'if',
			StartPositionPicker,
			165,
			2
		);
	}

	$.reset(div);
	$.template_effect(() => $.set_text(text, `Debug: isLoading=${$.get(isLoading) ?? ''}, pictographs=${$.get(startPositions).length ?? ''}, error=${$.get(loadingError) ?? ''}`));
	$.append($$anchor, div);

	return $.pop({ ...$.legacy_api() });
}

if (import.meta.hot) {
	StartPositionPicker = $.hmr(StartPositionPicker, () => StartPositionPicker[$.HMR].source);

	import.meta.hot.acceptExports(["default"],(module) => {
		$.cleanup_styles('s-V6OxA4DJ9E7q');
		module.default[$.HMR].source = StartPositionPicker[$.HMR].source;
		$.set(StartPositionPicker[$.HMR].source, module.default[$.HMR].original);
	});
}

export default StartPositionPicker;
import "/src/lib/components/construct/StartPositionPicker.svelte?svelte&type=style&lang.css";

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6Ijs7Ozs7U0FPVyxlQUFnQjtTQUtsQjtTQUNBO09BU0gsa0JBQWlCO09BQ2pCLGdCQUFlO09BQ2Ysb0JBQW1CO09BQ25CLHVCQUF5QjtTQXVNcEIsNEJBQUs7Ozs7Z0RBaE9oQixDQUFDOzs7O09BZ0NVLDBEQUFxQjtLQU94QiwwQkFBWTtLQUNkO0tBQ0UsNkJBQVE7S0FBQSxpQ0FDTjtLQUFBLGdDQUNBO0tBR0o7S0FFQSxtQkFBSTs7VUFHQTtNQUNGO0dBQ0YsUUFBUyw0REFBTzs7T0FHWjtJQUNGO0lBQ0EsUUFBTztHQUNUO0lBRUEsUUFBTyxzQ0FDVCx3RUFDRTs7V0FFRjtHQUNGOztPQUlVO0lBRUgsMkJBQXNCO0lBQ3pCLFFBQVEsSUFDTjtHQUVGLFFBQUs7SUFDSCxRQUFRLHNDQUNSLGlGQUNGOztXQUdHO0dBQ0g7O1VBRUY7RUFFQSxRQUFJO0dBQ0YsUUFBUSwwQ0FBSSxvREFBOEM7O1VBQzFEO0VBQ0E7Q0FFQTs7Z0JBR0E7RUFDQSxRQUFNLG9EQUN1Qjs7T0FHM0I7R0FDQSxZQUNGOztRQUdBLHNCQUFZO0lBQ1osUUFBWTs7O0dBR1Y7RUFBQTs7T0FHQSxzQkFBZTtHQUNqQjs7O0VBRUE7O01BRUU7R0FDRjtTQUNBO1NBQ0EsY0FBaUI7R0FFbkIsOENBQ0Ysd0VBR0E7O1NBRVksMkNBQ1I7O0dBR0UsOENBRUYsNENBQ0EscUJBQW1CO1NBSWpCO0dBRUY7U0FHQSxXQUFXO0dBRVgsUUFBTSxzQ0FDUix1REFDRSxZQUNFLG9CQUNBO0VBRUY7R0FHQSxrREFDRSx1REFDRjtTQUVKO1NBR0E7U0FDRSxXQUFZO0VBQ1o7Q0FDRDs7Z0JBS0csYUFBbUI7T0FDckI7R0FDRDs7O0VBS0Q7O01BSU07U0FFSjtTQUNEO2tDQUdTLGlCQUFpQixvQkFDdEIsb0JBQ0Y7O0dBSUE7VUFBQTtXQUNDLGlCQUFrQjtJQUNsQjtJQUFBOztFQUNGLFFBQUM7R0FDRCxRQUFJLDBDQUNILHdEQUNDO1NBRUEsaUJBQWtCOzZDQUlKO0VBRWhCO0NBQ0Y7OztFQUlFLFFBQUcsSUFBUSxxQ0FBNEI7RUFDdkM7Q0FDSjs7O01BSU07R0FDSDtFQUNDO0NBQ0o7O0NBS0Esb0JBQWdCO1FBQ1osa0JBQXVCOztNQUdwQiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiU3RhcnRQb3NpdGlvblBpY2tlci5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPCEtLSBTdGFydFBvc2l0aW9uUGlja2VyLnN2ZWx0ZSAtIENsZWFuIGNvbXBvbmVudCBmb2xsb3dpbmcgVEtBIGFyY2hpdGVjdHVyZSAtLT5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gIGltcG9ydCB0eXBlIHsgUGljdG9ncmFwaERhdGEgfSBmcm9tIFwiJGRvbWFpbi9QaWN0b2dyYXBoRGF0YVwiO1xuICBpbXBvcnQgeyByZXNvbHZlIH0gZnJvbSBcIiRzZXJ2aWNlcy9ib290c3RyYXBcIjtcbiAgaW1wb3J0IHR5cGUgeyBJU3RhcnRQb3NpdGlvblNlcnZpY2UgfSBmcm9tIFwiJHNlcnZpY2VzL2ludGVyZmFjZXMvYXBwbGljYXRpb24taW50ZXJmYWNlc1wiO1xuICBpbXBvcnQgdHlwZSB7IElTdGFydFBvc2l0aW9uU2VsZWN0aW9uU2VydmljZSB9IGZyb20gXCIkbGliL3NlcnZpY2VzL2ludGVyZmFjZXMvSVN0YXJ0UG9zaXRpb25TZWxlY3Rpb25TZXJ2aWNlXCI7XG4gIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gIGltcG9ydCB7IEdyaWRNb2RlIH0gZnJvbSBcIiRsaWIvZG9tYWluXCI7XG5cbiAgLy8gVUkgQ29tcG9uZW50c1xuICBpbXBvcnQgTG9hZGluZ1N0YXRlIGZyb20gXCIuL3N0YXJ0LXBvc2l0aW9uL3VpL0xvYWRpbmdTdGF0ZS5zdmVsdGVcIjtcbiAgaW1wb3J0IEVycm9yU3RhdGUgZnJvbSBcIi4vc3RhcnQtcG9zaXRpb24vdWkvRXJyb3JTdGF0ZS5zdmVsdGVcIjtcbiAgaW1wb3J0IFBpY3RvZ3JhcGhHcmlkIGZyb20gXCIuL3N0YXJ0LXBvc2l0aW9uL3VpL1BpY3RvZ3JhcGhHcmlkLnN2ZWx0ZVwiO1xuICBpbXBvcnQgVHJhbnNpdGlvbk92ZXJsYXkgZnJvbSBcIi4vc3RhcnQtcG9zaXRpb24vdWkvVHJhbnNpdGlvbk92ZXJsYXkuc3ZlbHRlXCI7XG5cbiAgLy8gUHJvcHMgdXNpbmcgcnVuZXNcbiAgY29uc3QgeyBncmlkTW9kZSA9IEdyaWRNb2RlLkRJQU1PTkQgfSA9ICRwcm9wczx7XG4gICAgZ3JpZE1vZGU/OiBHcmlkTW9kZTtcbiAgfT4oKTtcblxuICAvLyBTaW1wbGUgcmVhY3RpdmUgc3RhdGUgZGlyZWN0bHkgaW4gY29tcG9uZW50XG4gIGxldCBpc0xvYWRpbmcgPSAkc3RhdGUodHJ1ZSk7XG4gIGxldCBzdGFydFBvc2l0aW9ucyA9ICRzdGF0ZTxQaWN0b2dyYXBoRGF0YVtdPihbXSk7XG4gIGxldCBsb2FkaW5nRXJyb3IgPSAkc3RhdGUoZmFsc2UpO1xuICBsZXQgc2VsZWN0ZWRTdGFydFBvcyA9ICRzdGF0ZTxQaWN0b2dyYXBoRGF0YSB8IG51bGw+KG51bGwpO1xuICBsZXQgaXNUcmFuc2l0aW9uaW5nID0gJHN0YXRlKGZhbHNlKTtcblxuICAvLyBTZXJ2aWNlc1xuICBsZXQgc3RhcnRQb3NpdGlvblNlcnZpY2U6IElTdGFydFBvc2l0aW9uU2VydmljZSB8IG51bGwgPSBudWxsO1xuICBsZXQgc2VsZWN0aW9uU2VydmljZTogSVN0YXJ0UG9zaXRpb25TZWxlY3Rpb25TZXJ2aWNlIHwgbnVsbCA9IG51bGw7XG5cbiAgLy8gSW5pdGlhbGl6ZSBzZXJ2aWNlcyBvbmNlXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVTZXJ2aWNlcygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coXCJTdGFydFBvc2l0aW9uUGlja2VyOiBBdHRlbXB0aW5nIHRvIHJlc29sdmUgc2VydmljZXMuLi5cIik7XG5cbiAgICAgIC8vIFJlc29sdmUgc2VydmljZXNcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXJ0UG9zaXRpb25TZXJ2aWNlID0gcmVzb2x2ZShcIklTdGFydFBvc2l0aW9uU2VydmljZVwiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJTdGFydFBvc2l0aW9uUGlja2VyOiDinIUgSVN0YXJ0UG9zaXRpb25TZXJ2aWNlIHJlc29sdmVkXCIpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgXCJTdGFydFBvc2l0aW9uUGlja2VyOiDinYwgRmFpbGVkIHRvIHJlc29sdmUgSVN0YXJ0UG9zaXRpb25TZXJ2aWNlOlwiLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gQ29udGFpbmVyIG5vdCByZWFkeSB5ZXRcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZWN0aW9uU2VydmljZSA9IHJlc29sdmUoXCJJU3RhcnRQb3NpdGlvblNlbGVjdGlvblNlcnZpY2VcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIFwiU3RhcnRQb3NpdGlvblBpY2tlcjog4pyFIElTdGFydFBvc2l0aW9uU2VsZWN0aW9uU2VydmljZSByZXNvbHZlZFwiXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIlN0YXJ0UG9zaXRpb25QaWNrZXI6IOKdjCBGYWlsZWQgdG8gcmVzb2x2ZSBJU3RhcnRQb3NpdGlvblNlbGVjdGlvblNlcnZpY2U6XCIsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBDb250YWluZXIgbm90IHJlYWR5IHlldFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlN0YXJ0UG9zaXRpb25QaWNrZXI6IEZhaWxlZCB0byByZXNvbHZlIHNlcnZpY2VzOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gTG9hZCBzdGFydCBwb3NpdGlvbnMgZGlyZWN0bHlcbiAgYXN5bmMgZnVuY3Rpb24gbG9hZFN0YXJ0UG9zaXRpb25zKCkge1xuICAgIGNvbnNvbGUubG9nKFwiU3RhcnRQb3NpdGlvblBpY2tlcjogbG9hZFN0YXJ0UG9zaXRpb25zIGNhbGxlZFwiKTtcblxuICAgIGlmICghc3RhcnRQb3NpdGlvblNlcnZpY2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBcIlN0YXJ0UG9zaXRpb25QaWNrZXI6IFNlcnZpY2Ugbm90IGF2YWlsYWJsZSwgdHJ5aW5nIHRvIGluaXRpYWxpemUuLi5cIlxuICAgICAgKTtcbiAgICAgIGlmICghaW5pdGlhbGl6ZVNlcnZpY2VzKCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJTdGFydFBvc2l0aW9uUGlja2VyOiBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBzZXJ2aWNlc1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc3RhcnRQb3NpdGlvblNlcnZpY2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiU3RhcnRQb3NpdGlvblBpY2tlcjogU3RpbGwgbm8gc2VydmljZSBhdmFpbGFibGVcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiU3RhcnRQb3NpdGlvblBpY2tlcjogU2V0dGluZyBsb2FkaW5nIHRvIHRydWVcIik7XG4gICAgICBpc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgbG9hZGluZ0Vycm9yID0gZmFsc2U7XG5cbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBcIlN0YXJ0UG9zaXRpb25QaWNrZXI6IENhbGxpbmcgZ2V0RGVmYXVsdFN0YXJ0UG9zaXRpb25zIHdpdGggZ3JpZE1vZGU6XCIsXG4gICAgICAgIGdyaWRNb2RlXG4gICAgICApO1xuICAgICAgY29uc3QgcG9zaXRpb25zID1cbiAgICAgICAgYXdhaXQgc3RhcnRQb3NpdGlvblNlcnZpY2UuZ2V0RGVmYXVsdFN0YXJ0UG9zaXRpb25zKGdyaWRNb2RlKTtcblxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIFwiU3RhcnRQb3NpdGlvblBpY2tlcjogUmVjZWl2ZWQgcG9zaXRpb25zOlwiLFxuICAgICAgICBwb3NpdGlvbnM/Lmxlbmd0aCB8fCAwXG4gICAgICApO1xuICAgICAgc3RhcnRQb3NpdGlvbnMgPSBwb3NpdGlvbnMgfHwgW107XG5cbiAgICAgIGNvbnNvbGUubG9nKFwiU3RhcnRQb3NpdGlvblBpY2tlcjogU2V0dGluZyBsb2FkaW5nIHRvIGZhbHNlXCIpO1xuICAgICAgaXNMb2FkaW5nID0gZmFsc2U7XG5cbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBcIlN0YXJ0UG9zaXRpb25QaWNrZXI6IEZpbmFsIHN0YXRlIC0gaXNMb2FkaW5nOlwiLFxuICAgICAgICBpc0xvYWRpbmcsXG4gICAgICAgIFwicG9zaXRpb25zOlwiLFxuICAgICAgICBzdGFydFBvc2l0aW9ucy5sZW5ndGhcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiU3RhcnRQb3NpdGlvblBpY2tlcjogRXJyb3IgbG9hZGluZyBzdGFydCBwb3NpdGlvbnM6XCIsXG4gICAgICAgIGVycm9yXG4gICAgICApO1xuICAgICAgbG9hZGluZ0Vycm9yID0gdHJ1ZTtcbiAgICAgIHN0YXJ0UG9zaXRpb25zID0gW107XG4gICAgICBpc0xvYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgc3RhcnQgcG9zaXRpb24gc2VsZWN0aW9uIHVzaW5nIHNlcnZpY2VcbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlU2VsZWN0KHN0YXJ0UG9zUGljdG9ncmFwaDogUGljdG9ncmFwaERhdGEpIHtcbiAgICBpZiAoIXNlbGVjdGlvblNlcnZpY2UgfHwgIXN0YXJ0UG9zaXRpb25TZXJ2aWNlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiU2VydmljZXMgbm90IGF2YWlsYWJsZSBmb3Igc3RhcnQgcG9zaXRpb24gc2VsZWN0aW9uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBTZXQgdHJhbnNpdGlvbiBzdGF0ZVxuICAgICAgaXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICAgIHNlbGVjdGVkU3RhcnRQb3MgPSBzdGFydFBvc1BpY3RvZ3JhcGg7XG5cbiAgICAgIC8vIFVzZSBzZWxlY3Rpb24gc2VydmljZSB0byBoYW5kbGUgdGhlIGNvbXBsZXggYnVzaW5lc3MgbG9naWNcbiAgICAgIGF3YWl0IHNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0U3RhcnRQb3NpdGlvbihcbiAgICAgICAgc3RhcnRQb3NQaWN0b2dyYXBoLFxuICAgICAgICBzdGFydFBvc2l0aW9uU2VydmljZVxuICAgICAgKTtcblxuICAgICAgLy8gQ2xlYXIgdHJhbnNpdGlvbiBzdGF0ZSBhZnRlciBhIHNob3J0IGRlbGF5XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB9LCAyMDApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlN0YXJ0UG9zaXRpb25QaWNrZXI6IEVycm9yIHNlbGVjdGluZyBzdGFydCBwb3NpdGlvbjpcIixcbiAgICAgICAgZXJyb3JcbiAgICAgICk7XG4gICAgICBpc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcblxuICAgICAgLy8gU2hvdyB1c2VyLWZyaWVuZGx5IGVycm9yXG4gICAgICBhbGVydChcbiAgICAgICAgYEZhaWxlZCB0byBzZWxlY3Qgc3RhcnQgcG9zaXRpb246ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgb24gbW91bnRcbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJTdGFydFBvc2l0aW9uUGlja2VyOiBvbk1vdW50IGNhbGxlZFwiKTtcbiAgICBsb2FkU3RhcnRQb3NpdGlvbnMoKTtcbiAgfSk7XG5cbiAgLy8gUmVsb2FkIHdoZW4gZ3JpZCBtb2RlIGNoYW5nZXNcbiAgJGVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGdyaWRNb2RlKSB7XG4gICAgICBsb2FkU3RhcnRQb3NpdGlvbnMoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIExpc3RlbiBmb3Igc2VxdWVuY2Ugc3RhdGUgY2hhbmdlcyB0byBjbGVhciB0cmFuc2l0aW9uIHN0YXRlXG4gIGltcG9ydCB7IHNlcXVlbmNlU3RhdGVTZXJ2aWNlIH0gZnJvbSBcIiRsaWIvc2VydmljZXMvU2VxdWVuY2VTdGF0ZVNlcnZpY2Uuc3ZlbHRlXCI7XG5cbiAgJGVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudFNlcXVlbmNlID0gc2VxdWVuY2VTdGF0ZVNlcnZpY2UuY3VycmVudFNlcXVlbmNlO1xuXG4gICAgLy8gSWYgYSBzZXF1ZW5jZSB3aXRoIHN0YXJ0UG9zaXRpb24gZXhpc3RzIGFuZCB3ZSdyZSB0cmFuc2l0aW9uaW5nLCBjbGVhciB0aGUgdHJhbnNpdGlvblxuICAgIGlmIChjdXJyZW50U2VxdWVuY2UgJiYgY3VycmVudFNlcXVlbmNlLnN0YXJ0UG9zaXRpb24gJiYgaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICBpc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJzdGFydC1wb3MtcGlja2VyXCIgZGF0YS10ZXN0aWQ9XCJzdGFydC1wb3NpdGlvbi1waWNrZXJcIj5cbiAgeyNpZiBpc0xvYWRpbmd9XG4gICAgPExvYWRpbmdTdGF0ZSAvPlxuICB7OmVsc2UgaWYgbG9hZGluZ0Vycm9yfVxuICAgIDxFcnJvclN0YXRlIC8+XG4gIHs6ZWxzZSBpZiBzdGFydFBvc2l0aW9ucy5sZW5ndGggPT09IDB9XG4gICAgPEVycm9yU3RhdGVcbiAgICAgIG1lc3NhZ2U9XCJObyB2YWxpZCBzdGFydCBwb3NpdGlvbnMgZm91bmQgZm9yIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24uXCJcbiAgICAgIGhhc1JlZnJlc2hCdXR0b249e2ZhbHNlfVxuICAgIC8+XG4gIHs6ZWxzZX1cbiAgICA8UGljdG9ncmFwaEdyaWRcbiAgICAgIHBpY3RvZ3JhcGhzPXtzdGFydFBvc2l0aW9uc31cbiAgICAgIHNlbGVjdGVkUGljdG9ncmFwaD17c2VsZWN0ZWRTdGFydFBvc31cbiAgICAgIG9uUGljdG9ncmFwaFNlbGVjdD17aGFuZGxlU2VsZWN0fVxuICAgIC8+XG4gIHsvaWZ9XG5cbiAgPCEtLSBEZWJ1ZyBpbmZvIC0tPlxuICA8ZGl2XG4gICAgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMTBweDsgcmlnaHQ6IDEwcHg7IGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMC44KTsgY29sb3I6IHdoaXRlOyBwYWRkaW5nOiA1cHg7IGZvbnQtc2l6ZTogMTBweDtcIlxuICA+XG4gICAgRGVidWc6IGlzTG9hZGluZz17aXNMb2FkaW5nfSwgcGljdG9ncmFwaHM9e3N0YXJ0UG9zaXRpb25zLmxlbmd0aH0sIGVycm9yPXtsb2FkaW5nRXJyb3J9XG4gIDwvZGl2PlxuXG4gIDwhLS0gTG9hZGluZyBvdmVybGF5IGR1cmluZyB0cmFuc2l0aW9uIC0tPlxuICB7I2lmIGlzVHJhbnNpdGlvbmluZ31cbiAgICA8VHJhbnNpdGlvbk92ZXJsYXkgLz5cbiAgey9pZn1cbjwvZGl2PlxuXG48c3R5bGU+XG4gIC5zdGFydC1wb3MtcGlja2VyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgcGFkZGluZzogdmFyKC0tc3BhY2luZy1sZyk7XG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB9XG48L3N0eWxlPlxuIl0sImZpbGUiOiJDOi9US0Evd2ViL3NyYy9saWIvY29tcG9uZW50cy9jb25zdHJ1Y3QvU3RhcnRQb3NpdGlvblBpY2tlci5zdmVsdGUifQ==