import {
  GridMode,
  MotionType,
  MotionColor,
  RotationDirection,
  Location,
  Orientation
} from "/src/lib/domain/enums.ts";
import { PngMetadataExtractor } from "/src/lib/utils/png-metadata-extractor.ts";
export class SequenceService {
  constructor(sequenceDomainService, persistenceService) {
    this.sequenceDomainService = sequenceDomainService;
    this.persistenceService = persistenceService;
  }
  /**
   * Create a new sequence
   */
  async createSequence(request) {
    try {
      const sequence = this.sequenceDomainService.createSequence(request);
      await this.persistenceService.saveSequence(sequence);
      return sequence;
    } catch (error) {
      console.error("Failed to create sequence:", error);
      throw new Error(
        `Failed to create sequence: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Update a beat in a sequence
   */
  async updateBeat(sequenceId, beatIndex, beatData) {
    try {
      const currentSequence = await this.persistenceService.loadSequence(sequenceId);
      if (!currentSequence) {
        throw new Error(`Sequence ${sequenceId} not found`);
      }
      const updatedSequence = this.sequenceDomainService.updateBeat(
        currentSequence,
        beatIndex,
        beatData
      );
      await this.persistenceService.saveSequence(updatedSequence);
    } catch (error) {
      console.error("Failed to update beat:", error);
      throw new Error(
        `Failed to update beat: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Set the start position for a sequence
   */
  async setSequenceStartPosition(sequenceId, startPosition) {
    try {
      const currentSequence = await this.persistenceService.loadSequence(sequenceId);
      if (!currentSequence) {
        throw new Error(`Sequence ${sequenceId} not found`);
      }
      const updatedSequence = {
        ...currentSequence,
        startPosition
      };
      await this.persistenceService.saveSequence(updatedSequence);
    } catch (error) {
      console.error("Failed to set start position:", error);
      throw new Error(
        `Failed to set start position: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Delete a sequence
   */
  async deleteSequence(id) {
    try {
      await this.persistenceService.deleteSequence(id);
    } catch (error) {
      console.error("Failed to delete sequence:", error);
      throw new Error(
        `Failed to delete sequence: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Get a sequence by ID
   */
  async getSequence(id) {
    try {
      let sequence = await this.persistenceService.loadSequence(id);
      if (!sequence) {
        console.log(
          `ðŸŽ¬ Sequence ${id} not found, attempting to load from PNG metadata`
        );
        try {
          sequence = await this.loadSequenceFromPNG(id);
          if (sequence) {
            await this.persistenceService.saveSequence(sequence);
          }
        } catch (error) {
          console.error(`Failed to load sequence ${id} from PNG:`, error);
          return null;
        }
      }
      return sequence;
    } catch (error) {
      console.error(`Failed to get sequence ${id}:`, error);
      return null;
    }
  }
  /**
   * Get all sequences
   */
  async getAllSequences() {
    try {
      return await this.persistenceService.loadAllSequences();
    } catch (error) {
      console.error("Failed to get all sequences:", error);
      return [];
    }
  }
  /**
   * Add a beat to a sequence
   */
  async addBeat(sequenceId, beatData) {
    try {
      const sequence = await this.getSequence(sequenceId);
      if (!sequence) {
        throw new Error(`Sequence ${sequenceId} not found`);
      }
      const nextBeatNumber = sequence.beats.length + 1;
      const newBeat = {
        id: crypto.randomUUID(),
        beatNumber: nextBeatNumber,
        duration: 1,
        blueReversal: false,
        redReversal: false,
        isBlank: true,
        pictographData: null,
        metadata: {},
        ...beatData
      };
      const updatedSequence = {
        ...sequence,
        beats: [...sequence.beats, newBeat]
      };
      await this.persistenceService.saveSequence(updatedSequence);
    } catch (error) {
      console.error("Failed to add beat:", error);
      throw new Error(
        `Failed to add beat: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Remove a beat from a sequence
   */
  async removeBeat(sequenceId, beatIndex) {
    try {
      const sequence = await this.getSequence(sequenceId);
      if (!sequence) {
        throw new Error(`Sequence ${sequenceId} not found`);
      }
      if (beatIndex < 0 || beatIndex >= sequence.beats.length) {
        throw new Error(`Beat index ${beatIndex} is out of range`);
      }
      const newBeats = sequence.beats.filter((_, index) => index !== beatIndex).map((beat, index) => ({ ...beat, beatNumber: index + 1 }));
      const updatedSequence = { ...sequence, beats: newBeats };
      await this.persistenceService.saveSequence(updatedSequence);
    } catch (error) {
      console.error("Failed to remove beat:", error);
      throw new Error(
        `Failed to remove beat: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Load sequence from PNG metadata using the reliable PNG metadata extractor
   */
  async loadSequenceFromPNG(id) {
    console.log(`ðŸŽ¬ Loading sequence from PNG metadata for ID: ${id}`);
    try {
      const pngMetadata = await PngMetadataExtractor.extractSequenceMetadata(
        id.toUpperCase()
      );
      if (!pngMetadata || pngMetadata.length === 0) {
        console.error(`No metadata found in PNG for sequence: ${id}`);
        return null;
      }
      const sequence = await this.convertPngMetadataToSequence(id, pngMetadata);
      console.log(`âœ… Loaded real sequence data from PNG for ${id}`);
      return sequence;
    } catch (error) {
      console.error(`Failed to load PNG metadata for ${id}:`, error);
      return this.createTestSequence(id);
    }
  }
  /**
   * Convert PNG metadata to SequenceData format
   */
  async convertPngMetadataToSequence(id, pngMetadata) {
    console.log(`ðŸ”„ Converting standalone data to web app format for ${id}`);
    const meta = pngMetadata[0];
    const steps = pngMetadata.slice(1);
    const beats = steps.filter((step) => typeof step.beat === "number" && step.beat > 0).map((step) => ({
      id: `${step.beat}-${step.letter}`,
      beatNumber: step.beat,
      duration: 1,
      blueReversal: false,
      redReversal: false,
      isBlank: false,
      pictographData: {
        id: `pictograph-${step.beat}`,
        gridData: {
          gridMode: meta.gridMode || GridMode.DIAMOND,
          center_x: 0,
          center_y: 0,
          radius: 100,
          gridPointData: {
            allHandPointsStrict: {},
            allHandPointsNormal: {},
            allLayer2PointsStrict: {},
            allLayer2PointsNormal: {},
            allOuterPoints: {},
            centerPoint: { coordinates: { x: 0, y: 0 } }
          }
        },
        arrows: {},
        props: {},
        motions: {
          blue: {
            color: MotionColor.BLUE,
            // âœ… FIXED: Added required color property
            motionType: step.blueAttributes?.motionType || MotionType.STATIC,
            startLocation: step.blueAttributes?.startLocation || Location.SOUTH,
            endLocation: step.blueAttributes?.endLocation || Location.SOUTH,
            startOrientation: step.blueAttributes?.startOrientation || Orientation.IN,
            endOrientation: step.blueAttributes?.endOrientation,
            // Don't set default - let it be undefined
            rotationDirection: step.blueAttributes?.rotationDirection || RotationDirection.NO_ROTATION,
            turns: step.blueAttributes?.turns || 0,
            isVisible: true
          },
          red: {
            color: MotionColor.RED,
            // âœ… FIXED: Added required color property
            motionType: step.redAttributes?.motionType || MotionType.STATIC,
            startLocation: step.redAttributes?.startLocation || Location.SOUTH,
            endLocation: step.redAttributes?.endLocation || Location.SOUTH,
            startOrientation: step.redAttributes?.startOrientation || Orientation.IN,
            endOrientation: step.redAttributes?.endOrientation,
            // Don't set default - let it be undefined
            rotationDirection: step.redAttributes?.rotationDirection || RotationDirection.NO_ROTATION,
            turns: step.redAttributes?.turns || 0,
            isVisible: true
          }
        },
        letter: step.letter || "",
        beat: step.beat,
        isBlank: false,
        isMirrored: false,
        metadata: {}
      },
      metadata: {}
    }));
    console.log(`âœ… Converted to web app format: ${beats.length} beats`);
    return {
      id,
      name: meta.word || id.toUpperCase(),
      word: meta.word || id.toUpperCase(),
      beats,
      thumbnails: [`${id.toUpperCase()}_ver1.png`],
      sequence_length: beats.length,
      author: meta.author || "Unknown",
      level: meta.level || 1,
      date_added: new Date(meta.date_added || Date.now()),
      gridMode: meta.gridMode || GridMode.DIAMOND,
      propType: meta.propType || "unknown",
      is_favorite: meta.is_favorite || false,
      is_circular: meta.is_circular || false,
      starting_position: meta.sequence_start_position || "beta",
      difficulty_level: this.mapLevelToDifficulty(meta.level || 1),
      tags: ["flow", "practice"],
      metadata: {
        source: "png_metadata",
        extracted_at: (/* @__PURE__ */ new Date()).toISOString(),
        ...meta
      }
    };
  }
  /**
   * Map numeric level to difficulty string
   */
  mapLevelToDifficulty(level) {
    if (level <= 1) return "beginner";
    if (level <= 2) return "intermediate";
    return "advanced";
  }
  /**
   * Load sequence from PNG metadata or create fallback
   */
  async createTestSequence(id) {
    console.log(`ðŸŽ¬ Loading sequence from PNG metadata for ID: ${id}`);
    try {
      const sequenceData = await this.loadSequenceFromPNG(id);
      if (sequenceData) {
        console.log(`âœ… Loaded real sequence data from PNG for ${id}`);
        return sequenceData;
      }
    } catch (error) {
      console.warn(`âš ï¸ Failed to load PNG metadata for ${id}:`, error);
    }
    throw new Error(
      `No PNG metadata found for sequence ${id}. Please ensure the sequence has a valid PNG thumbnail with embedded metadata.`
    );
  }
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3NlcnZpY2VzL2ltcGxlbWVudGF0aW9ucy9zZXF1ZW5jZS9TZXF1ZW5jZVNlcnZpY2UudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogU2VxdWVuY2UgU2VydmljZSAtIEFwcGxpY2F0aW9uIExheWVyXG4gKlxuICogQ29vcmRpbmF0ZXMgYmV0d2VlbiBkb21haW4gbG9naWMgYW5kIHBlcnNpc3RlbmNlIGZvciBzZXF1ZW5jZSBvcGVyYXRpb25zLlxuICogVGhpcyBzZXJ2aWNlIG9yY2hlc3RyYXRlcyB0aGUgYnVzaW5lc3Mgd29ya2Zsb3dzIGZvciBzZXF1ZW5jZSBtYW5hZ2VtZW50LlxuICovXG5cbmltcG9ydCB0eXBlIHsgQmVhdERhdGEsIFNlcXVlbmNlRGF0YSB9IGZyb20gXCIkbGliL2RvbWFpblwiO1xuaW1wb3J0IHtcbiAgR3JpZE1vZGUsXG4gIE1vdGlvblR5cGUsXG4gIE1vdGlvbkNvbG9yLFxuICBSb3RhdGlvbkRpcmVjdGlvbixcbiAgTG9jYXRpb24sXG4gIE9yaWVudGF0aW9uLFxufSBmcm9tIFwiJGxpYi9kb21haW4vZW51bXNcIjtcblxuaW1wb3J0IHsgUG5nTWV0YWRhdGFFeHRyYWN0b3IgfSBmcm9tIFwiJGxpYi91dGlscy9wbmctbWV0YWRhdGEtZXh0cmFjdG9yXCI7XG5pbXBvcnQgdHlwZSB7XG4gIElQZXJzaXN0ZW5jZVNlcnZpY2UsXG4gIElTZXF1ZW5jZURvbWFpblNlcnZpY2UsXG4gIElTZXF1ZW5jZVNlcnZpY2UsXG4gIFNlcXVlbmNlQ3JlYXRlUmVxdWVzdCxcbn0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXMvc2VxdWVuY2UtaW50ZXJmYWNlc1wiO1xuXG5leHBvcnQgY2xhc3MgU2VxdWVuY2VTZXJ2aWNlIGltcGxlbWVudHMgSVNlcXVlbmNlU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgc2VxdWVuY2VEb21haW5TZXJ2aWNlOiBJU2VxdWVuY2VEb21haW5TZXJ2aWNlLFxuICAgIHByaXZhdGUgcGVyc2lzdGVuY2VTZXJ2aWNlOiBJUGVyc2lzdGVuY2VTZXJ2aWNlXG4gICkge31cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHNlcXVlbmNlXG4gICAqL1xuICBhc3luYyBjcmVhdGVTZXF1ZW5jZShyZXF1ZXN0OiBTZXF1ZW5jZUNyZWF0ZVJlcXVlc3QpOiBQcm9taXNlPFNlcXVlbmNlRGF0YT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgZG9tYWluIHNlcnZpY2UgdG8gY3JlYXRlIHRoZSBzZXF1ZW5jZVxuICAgICAgY29uc3Qgc2VxdWVuY2UgPSB0aGlzLnNlcXVlbmNlRG9tYWluU2VydmljZS5jcmVhdGVTZXF1ZW5jZShyZXF1ZXN0KTtcbiAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2VTZXJ2aWNlLnNhdmVTZXF1ZW5jZShzZXF1ZW5jZSk7XG4gICAgICByZXR1cm4gc2VxdWVuY2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIHNlcXVlbmNlOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gY3JlYXRlIHNlcXVlbmNlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGEgYmVhdCBpbiBhIHNlcXVlbmNlXG4gICAqL1xuICBhc3luYyB1cGRhdGVCZWF0KFxuICAgIHNlcXVlbmNlSWQ6IHN0cmluZyxcbiAgICBiZWF0SW5kZXg6IG51bWJlcixcbiAgICBiZWF0RGF0YTogQmVhdERhdGFcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIExvYWQgdGhlIGN1cnJlbnQgc2VxdWVuY2VcbiAgICAgIGNvbnN0IGN1cnJlbnRTZXF1ZW5jZSA9XG4gICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2VTZXJ2aWNlLmxvYWRTZXF1ZW5jZShzZXF1ZW5jZUlkKTtcbiAgICAgIGlmICghY3VycmVudFNlcXVlbmNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VxdWVuY2UgJHtzZXF1ZW5jZUlkfSBub3QgZm91bmRgKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNlIGRvbWFpbiBzZXJ2aWNlIHRvIHVwZGF0ZSB0aGUgYmVhdFxuICAgICAgY29uc3QgdXBkYXRlZFNlcXVlbmNlID0gdGhpcy5zZXF1ZW5jZURvbWFpblNlcnZpY2UudXBkYXRlQmVhdChcbiAgICAgICAgY3VycmVudFNlcXVlbmNlLFxuICAgICAgICBiZWF0SW5kZXgsXG4gICAgICAgIGJlYXREYXRhXG4gICAgICApO1xuXG4gICAgICBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlU2VydmljZS5zYXZlU2VxdWVuY2UodXBkYXRlZFNlcXVlbmNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byB1cGRhdGUgYmVhdDpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHVwZGF0ZSBiZWF0OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzdGFydCBwb3NpdGlvbiBmb3IgYSBzZXF1ZW5jZVxuICAgKi9cbiAgYXN5bmMgc2V0U2VxdWVuY2VTdGFydFBvc2l0aW9uKFxuICAgIHNlcXVlbmNlSWQ6IHN0cmluZyxcbiAgICBzdGFydFBvc2l0aW9uOiBCZWF0RGF0YVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gTG9hZCB0aGUgY3VycmVudCBzZXF1ZW5jZVxuICAgICAgY29uc3QgY3VycmVudFNlcXVlbmNlID1cbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZVNlcnZpY2UubG9hZFNlcXVlbmNlKHNlcXVlbmNlSWQpO1xuICAgICAgaWYgKCFjdXJyZW50U2VxdWVuY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXF1ZW5jZSAke3NlcXVlbmNlSWR9IG5vdCBmb3VuZGApO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGhlIHNlcXVlbmNlIHdpdGggdGhlIHN0YXJ0IHBvc2l0aW9uXG4gICAgICBjb25zdCB1cGRhdGVkU2VxdWVuY2UgPSB7XG4gICAgICAgIC4uLmN1cnJlbnRTZXF1ZW5jZSxcbiAgICAgICAgc3RhcnRQb3NpdGlvbjogc3RhcnRQb3NpdGlvbixcbiAgICAgIH0gYXMgU2VxdWVuY2VEYXRhO1xuXG4gICAgICBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlU2VydmljZS5zYXZlU2VxdWVuY2UodXBkYXRlZFNlcXVlbmNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzZXQgc3RhcnQgcG9zaXRpb246XCIsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBzZXQgc3RhcnQgcG9zaXRpb246ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBzZXF1ZW5jZVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlU2VxdWVuY2UoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlU2VydmljZS5kZWxldGVTZXF1ZW5jZShpZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZGVsZXRlIHNlcXVlbmNlOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZGVsZXRlIHNlcXVlbmNlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgc2VxdWVuY2UgYnkgSURcbiAgICovXG4gIGFzeW5jIGdldFNlcXVlbmNlKGlkOiBzdHJpbmcpOiBQcm9taXNlPFNlcXVlbmNlRGF0YSB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IHNlcXVlbmNlID0gYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZVNlcnZpY2UubG9hZFNlcXVlbmNlKGlkKTtcblxuICAgICAgLy8gSWYgc2VxdWVuY2Ugbm90IGZvdW5kLCB0cnkgdG8gbG9hZCBmcm9tIFBORyBtZXRhZGF0YVxuICAgICAgaWYgKCFzZXF1ZW5jZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBg8J+OrCBTZXF1ZW5jZSAke2lkfSBub3QgZm91bmQsIGF0dGVtcHRpbmcgdG8gbG9hZCBmcm9tIFBORyBtZXRhZGF0YWBcbiAgICAgICAgKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZXF1ZW5jZSA9IGF3YWl0IHRoaXMubG9hZFNlcXVlbmNlRnJvbVBORyhpZCk7XG4gICAgICAgICAgLy8gU2F2ZSBpdCB0byBsb2NhbFN0b3JhZ2UgZm9yIGZ1dHVyZSB1c2VcbiAgICAgICAgICBpZiAoc2VxdWVuY2UpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2VTZXJ2aWNlLnNhdmVTZXF1ZW5jZShzZXF1ZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBsb2FkIHNlcXVlbmNlICR7aWR9IGZyb20gUE5HOmAsIGVycm9yKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VxdWVuY2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBnZXQgc2VxdWVuY2UgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgc2VxdWVuY2VzXG4gICAqL1xuICBhc3luYyBnZXRBbGxTZXF1ZW5jZXMoKTogUHJvbWlzZTxTZXF1ZW5jZURhdGFbXT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZVNlcnZpY2UubG9hZEFsbFNlcXVlbmNlcygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGdldCBhbGwgc2VxdWVuY2VzOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGJlYXQgdG8gYSBzZXF1ZW5jZVxuICAgKi9cbiAgYXN5bmMgYWRkQmVhdChcbiAgICBzZXF1ZW5jZUlkOiBzdHJpbmcsXG4gICAgYmVhdERhdGE/OiBQYXJ0aWFsPEJlYXREYXRhPlxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VxdWVuY2UgPSBhd2FpdCB0aGlzLmdldFNlcXVlbmNlKHNlcXVlbmNlSWQpO1xuICAgICAgaWYgKCFzZXF1ZW5jZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcXVlbmNlICR7c2VxdWVuY2VJZH0gbm90IGZvdW5kYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBuZXcgYmVhdCB3aXRoIG5leHQgYmVhdCBudW1iZXJcbiAgICAgIGNvbnN0IG5leHRCZWF0TnVtYmVyID0gc2VxdWVuY2UuYmVhdHMubGVuZ3RoICsgMTtcbiAgICAgIGNvbnN0IG5ld0JlYXQ6IEJlYXREYXRhID0ge1xuICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcbiAgICAgICAgYmVhdE51bWJlcjogbmV4dEJlYXROdW1iZXIsXG4gICAgICAgIGR1cmF0aW9uOiAxLjAsXG4gICAgICAgIGJsdWVSZXZlcnNhbDogZmFsc2UsXG4gICAgICAgIHJlZFJldmVyc2FsOiBmYWxzZSxcbiAgICAgICAgaXNCbGFuazogdHJ1ZSxcbiAgICAgICAgcGljdG9ncmFwaERhdGE6IG51bGwsXG4gICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgLi4uYmVhdERhdGEsXG4gICAgICB9O1xuICAgICAgY29uc3QgdXBkYXRlZFNlcXVlbmNlID0ge1xuICAgICAgICAuLi5zZXF1ZW5jZSxcbiAgICAgICAgYmVhdHM6IFsuLi5zZXF1ZW5jZS5iZWF0cywgbmV3QmVhdF0sXG4gICAgICB9IGFzIFNlcXVlbmNlRGF0YTtcbiAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2VTZXJ2aWNlLnNhdmVTZXF1ZW5jZSh1cGRhdGVkU2VxdWVuY2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGFkZCBiZWF0OlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gYWRkIGJlYXQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBiZWF0IGZyb20gYSBzZXF1ZW5jZVxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQmVhdChzZXF1ZW5jZUlkOiBzdHJpbmcsIGJlYXRJbmRleDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlcXVlbmNlID0gYXdhaXQgdGhpcy5nZXRTZXF1ZW5jZShzZXF1ZW5jZUlkKTtcbiAgICAgIGlmICghc2VxdWVuY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXF1ZW5jZSAke3NlcXVlbmNlSWR9IG5vdCBmb3VuZGApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmVhdEluZGV4IDwgMCB8fCBiZWF0SW5kZXggPj0gc2VxdWVuY2UuYmVhdHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQmVhdCBpbmRleCAke2JlYXRJbmRleH0gaXMgb3V0IG9mIHJhbmdlYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgYmVhdCBhbmQgcmVudW1iZXIgcmVtYWluaW5nIGJlYXRzXG4gICAgICBjb25zdCBuZXdCZWF0cyA9IHNlcXVlbmNlLmJlYXRzXG4gICAgICAgIC5maWx0ZXIoKF8sIGluZGV4KSA9PiBpbmRleCAhPT0gYmVhdEluZGV4KVxuICAgICAgICAubWFwKChiZWF0LCBpbmRleCkgPT4gKHsgLi4uYmVhdCwgYmVhdE51bWJlcjogaW5kZXggKyAxIH0pKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRTZXF1ZW5jZSA9IHsgLi4uc2VxdWVuY2UsIGJlYXRzOiBuZXdCZWF0cyB9IGFzIFNlcXVlbmNlRGF0YTtcbiAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2VTZXJ2aWNlLnNhdmVTZXF1ZW5jZSh1cGRhdGVkU2VxdWVuY2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHJlbW92ZSBiZWF0OlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gcmVtb3ZlIGJlYXQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHNlcXVlbmNlIGZyb20gUE5HIG1ldGFkYXRhIHVzaW5nIHRoZSByZWxpYWJsZSBQTkcgbWV0YWRhdGEgZXh0cmFjdG9yXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGxvYWRTZXF1ZW5jZUZyb21QTkcoaWQ6IHN0cmluZyk6IFByb21pc2U8U2VxdWVuY2VEYXRhIHwgbnVsbD4ge1xuICAgIGNvbnNvbGUubG9nKGDwn46sIExvYWRpbmcgc2VxdWVuY2UgZnJvbSBQTkcgbWV0YWRhdGEgZm9yIElEOiAke2lkfWApO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEV4dHJhY3QgbWV0YWRhdGEgZnJvbSBQTkcgZmlsZSB1c2luZyB0aGUgcmVsaWFibGUgZXh0cmFjdG9yXG4gICAgICBjb25zdCBwbmdNZXRhZGF0YSA9IGF3YWl0IFBuZ01ldGFkYXRhRXh0cmFjdG9yLmV4dHJhY3RTZXF1ZW5jZU1ldGFkYXRhKFxuICAgICAgICBpZC50b1VwcGVyQ2FzZSgpXG4gICAgICApO1xuXG4gICAgICBpZiAoIXBuZ01ldGFkYXRhIHx8IHBuZ01ldGFkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBObyBtZXRhZGF0YSBmb3VuZCBpbiBQTkcgZm9yIHNlcXVlbmNlOiAke2lkfWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gQ29udmVydCBQTkcgbWV0YWRhdGEgdG8gd2ViIGFwcCBmb3JtYXRcbiAgICAgIGNvbnN0IHNlcXVlbmNlID0gYXdhaXQgdGhpcy5jb252ZXJ0UG5nTWV0YWRhdGFUb1NlcXVlbmNlKGlkLCBwbmdNZXRhZGF0YSk7XG4gICAgICBjb25zb2xlLmxvZyhg4pyFIExvYWRlZCByZWFsIHNlcXVlbmNlIGRhdGEgZnJvbSBQTkcgZm9yICR7aWR9YCk7XG4gICAgICByZXR1cm4gc2VxdWVuY2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBsb2FkIFBORyBtZXRhZGF0YSBmb3IgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgLy8gRmFsbGJhY2sgdG8gdGVzdCBzZXF1ZW5jZVxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGVzdFNlcXVlbmNlKGlkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBQTkcgbWV0YWRhdGEgdG8gU2VxdWVuY2VEYXRhIGZvcm1hdFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjb252ZXJ0UG5nTWV0YWRhdGFUb1NlcXVlbmNlKFxuICAgIGlkOiBzdHJpbmcsXG4gICAgcG5nTWV0YWRhdGE6IHVua25vd25bXVxuICApOiBQcm9taXNlPFNlcXVlbmNlRGF0YT4ge1xuICAgIGNvbnNvbGUubG9nKGDwn5SEIENvbnZlcnRpbmcgc3RhbmRhbG9uZSBkYXRhIHRvIHdlYiBhcHAgZm9ybWF0IGZvciAke2lkfWApO1xuXG4gICAgLy8gRXh0cmFjdCBtZXRhZGF0YSBmcm9tIGZpcnN0IGVsZW1lbnRcbiAgICBjb25zdCBtZXRhID0gcG5nTWV0YWRhdGFbMF0gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgY29uc3Qgc3RlcHMgPSBwbmdNZXRhZGF0YS5zbGljZSgxKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdOyAvLyBTa2lwIG1ldGFkYXRhLCBnZXQgYWN0dWFsIHN0ZXBzXG5cbiAgICAvLyBDb252ZXJ0IHN0ZXBzIHRvIGJlYXRzXG4gICAgY29uc3QgYmVhdHM6IEJlYXREYXRhW10gPSBzdGVwc1xuICAgICAgLmZpbHRlcigoc3RlcCkgPT4gdHlwZW9mIHN0ZXAuYmVhdCA9PT0gXCJudW1iZXJcIiAmJiBzdGVwLmJlYXQgPiAwKSAvLyBPbmx5IGFjdHVhbCBiZWF0cywgbm90IHN0YXJ0IHN0YXRlXG4gICAgICAubWFwKChzdGVwKSA9PiAoe1xuICAgICAgICBpZDogYCR7c3RlcC5iZWF0fS0ke3N0ZXAubGV0dGVyfWAsXG4gICAgICAgIGJlYXROdW1iZXI6IHN0ZXAuYmVhdCBhcyBudW1iZXIsXG4gICAgICAgIGR1cmF0aW9uOiAxLFxuICAgICAgICBibHVlUmV2ZXJzYWw6IGZhbHNlLFxuICAgICAgICByZWRSZXZlcnNhbDogZmFsc2UsXG4gICAgICAgIGlzQmxhbms6IGZhbHNlLFxuICAgICAgICBwaWN0b2dyYXBoRGF0YToge1xuICAgICAgICAgIGlkOiBgcGljdG9ncmFwaC0ke3N0ZXAuYmVhdH1gLFxuICAgICAgICAgIGdyaWREYXRhOiB7XG4gICAgICAgICAgICBncmlkTW9kZTogKG1ldGEuZ3JpZE1vZGUgYXMgR3JpZE1vZGUpIHx8IEdyaWRNb2RlLkRJQU1PTkQsXG4gICAgICAgICAgICBjZW50ZXJfeDogMCxcbiAgICAgICAgICAgIGNlbnRlcl95OiAwLFxuICAgICAgICAgICAgcmFkaXVzOiAxMDAsXG4gICAgICAgICAgICBncmlkUG9pbnREYXRhOiB7XG4gICAgICAgICAgICAgIGFsbEhhbmRQb2ludHNTdHJpY3Q6IHt9LFxuICAgICAgICAgICAgICBhbGxIYW5kUG9pbnRzTm9ybWFsOiB7fSxcbiAgICAgICAgICAgICAgYWxsTGF5ZXIyUG9pbnRzU3RyaWN0OiB7fSxcbiAgICAgICAgICAgICAgYWxsTGF5ZXIyUG9pbnRzTm9ybWFsOiB7fSxcbiAgICAgICAgICAgICAgYWxsT3V0ZXJQb2ludHM6IHt9LFxuICAgICAgICAgICAgICBjZW50ZXJQb2ludDogeyBjb29yZGluYXRlczogeyB4OiAwLCB5OiAwIH0gfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhcnJvd3M6IHt9LFxuICAgICAgICAgIHByb3BzOiB7fSxcbiAgICAgICAgICBtb3Rpb25zOiB7XG4gICAgICAgICAgICBibHVlOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiBNb3Rpb25Db2xvci5CTFVFLCAvLyDinIUgRklYRUQ6IEFkZGVkIHJlcXVpcmVkIGNvbG9yIHByb3BlcnR5XG4gICAgICAgICAgICAgIG1vdGlvblR5cGU6XG4gICAgICAgICAgICAgICAgKChzdGVwLmJsdWVBdHRyaWJ1dGVzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVxuICAgICAgICAgICAgICAgICAgPy5tb3Rpb25UeXBlIGFzIE1vdGlvblR5cGUpIHx8IE1vdGlvblR5cGUuU1RBVElDLFxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOlxuICAgICAgICAgICAgICAgICgoc3RlcC5ibHVlQXR0cmlidXRlcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilcbiAgICAgICAgICAgICAgICAgID8uc3RhcnRMb2NhdGlvbiBhcyBMb2NhdGlvbikgfHwgTG9jYXRpb24uU09VVEgsXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOlxuICAgICAgICAgICAgICAgICgoc3RlcC5ibHVlQXR0cmlidXRlcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilcbiAgICAgICAgICAgICAgICAgID8uZW5kTG9jYXRpb24gYXMgTG9jYXRpb24pIHx8IExvY2F0aW9uLlNPVVRILFxuICAgICAgICAgICAgICBzdGFydE9yaWVudGF0aW9uOlxuICAgICAgICAgICAgICAgICgoc3RlcC5ibHVlQXR0cmlidXRlcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilcbiAgICAgICAgICAgICAgICAgID8uc3RhcnRPcmllbnRhdGlvbiBhcyBPcmllbnRhdGlvbikgfHwgT3JpZW50YXRpb24uSU4sXG4gICAgICAgICAgICAgIGVuZE9yaWVudGF0aW9uOiAoc3RlcC5ibHVlQXR0cmlidXRlcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilcbiAgICAgICAgICAgICAgICA/LmVuZE9yaWVudGF0aW9uIGFzIE9yaWVudGF0aW9uLCAvLyBEb24ndCBzZXQgZGVmYXVsdCAtIGxldCBpdCBiZSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgcm90YXRpb25EaXJlY3Rpb246XG4gICAgICAgICAgICAgICAgKChzdGVwLmJsdWVBdHRyaWJ1dGVzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVxuICAgICAgICAgICAgICAgICAgPy5yb3RhdGlvbkRpcmVjdGlvbiBhcyBSb3RhdGlvbkRpcmVjdGlvbikgfHxcbiAgICAgICAgICAgICAgICBSb3RhdGlvbkRpcmVjdGlvbi5OT19ST1RBVElPTixcbiAgICAgICAgICAgICAgdHVybnM6XG4gICAgICAgICAgICAgICAgKChzdGVwLmJsdWVBdHRyaWJ1dGVzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVxuICAgICAgICAgICAgICAgICAgPy50dXJucyBhcyBudW1iZXIpIHx8IDAsXG4gICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWQ6IHtcbiAgICAgICAgICAgICAgY29sb3I6IE1vdGlvbkNvbG9yLlJFRCwgLy8g4pyFIEZJWEVEOiBBZGRlZCByZXF1aXJlZCBjb2xvciBwcm9wZXJ0eVxuICAgICAgICAgICAgICBtb3Rpb25UeXBlOlxuICAgICAgICAgICAgICAgICgoc3RlcC5yZWRBdHRyaWJ1dGVzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVxuICAgICAgICAgICAgICAgICAgPy5tb3Rpb25UeXBlIGFzIE1vdGlvblR5cGUpIHx8IE1vdGlvblR5cGUuU1RBVElDLFxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOlxuICAgICAgICAgICAgICAgICgoc3RlcC5yZWRBdHRyaWJ1dGVzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVxuICAgICAgICAgICAgICAgICAgPy5zdGFydExvY2F0aW9uIGFzIExvY2F0aW9uKSB8fCBMb2NhdGlvbi5TT1VUSCxcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246XG4gICAgICAgICAgICAgICAgKChzdGVwLnJlZEF0dHJpYnV0ZXMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pXG4gICAgICAgICAgICAgICAgICA/LmVuZExvY2F0aW9uIGFzIExvY2F0aW9uKSB8fCBMb2NhdGlvbi5TT1VUSCxcbiAgICAgICAgICAgICAgc3RhcnRPcmllbnRhdGlvbjpcbiAgICAgICAgICAgICAgICAoKHN0ZXAucmVkQXR0cmlidXRlcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilcbiAgICAgICAgICAgICAgICAgID8uc3RhcnRPcmllbnRhdGlvbiBhcyBPcmllbnRhdGlvbikgfHwgT3JpZW50YXRpb24uSU4sXG4gICAgICAgICAgICAgIGVuZE9yaWVudGF0aW9uOiAoc3RlcC5yZWRBdHRyaWJ1dGVzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVxuICAgICAgICAgICAgICAgID8uZW5kT3JpZW50YXRpb24gYXMgT3JpZW50YXRpb24sIC8vIERvbid0IHNldCBkZWZhdWx0IC0gbGV0IGl0IGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgICByb3RhdGlvbkRpcmVjdGlvbjpcbiAgICAgICAgICAgICAgICAoKHN0ZXAucmVkQXR0cmlidXRlcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilcbiAgICAgICAgICAgICAgICAgID8ucm90YXRpb25EaXJlY3Rpb24gYXMgUm90YXRpb25EaXJlY3Rpb24pIHx8XG4gICAgICAgICAgICAgICAgUm90YXRpb25EaXJlY3Rpb24uTk9fUk9UQVRJT04sXG4gICAgICAgICAgICAgIHR1cm5zOlxuICAgICAgICAgICAgICAgICgoc3RlcC5yZWRBdHRyaWJ1dGVzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVxuICAgICAgICAgICAgICAgICAgPy50dXJucyBhcyBudW1iZXIpIHx8IDAsXG4gICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBsZXR0ZXI6IChzdGVwLmxldHRlciBhcyBzdHJpbmcpIHx8IFwiXCIsXG4gICAgICAgICAgYmVhdDogc3RlcC5iZWF0IGFzIG51bWJlcixcbiAgICAgICAgICBpc0JsYW5rOiBmYWxzZSxcbiAgICAgICAgICBpc01pcnJvcmVkOiBmYWxzZSxcbiAgICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgIH0pKTtcblxuICAgIGNvbnNvbGUubG9nKGDinIUgQ29udmVydGVkIHRvIHdlYiBhcHAgZm9ybWF0OiAke2JlYXRzLmxlbmd0aH0gYmVhdHNgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIG5hbWU6IChtZXRhLndvcmQgYXMgc3RyaW5nKSB8fCBpZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgd29yZDogKG1ldGEud29yZCBhcyBzdHJpbmcpIHx8IGlkLnRvVXBwZXJDYXNlKCksXG4gICAgICBiZWF0cyxcbiAgICAgIHRodW1ibmFpbHM6IFtgJHtpZC50b1VwcGVyQ2FzZSgpfV92ZXIxLnBuZ2BdLFxuICAgICAgc2VxdWVuY2VfbGVuZ3RoOiBiZWF0cy5sZW5ndGgsXG4gICAgICBhdXRob3I6IChtZXRhLmF1dGhvciBhcyBzdHJpbmcpIHx8IFwiVW5rbm93blwiLFxuICAgICAgbGV2ZWw6IChtZXRhLmxldmVsIGFzIG51bWJlcikgfHwgMSxcbiAgICAgIGRhdGVfYWRkZWQ6IG5ldyBEYXRlKChtZXRhLmRhdGVfYWRkZWQgYXMgc3RyaW5nIHwgbnVtYmVyKSB8fCBEYXRlLm5vdygpKSxcbiAgICAgIGdyaWRNb2RlOiAobWV0YS5ncmlkTW9kZSBhcyBzdHJpbmcpIHx8IEdyaWRNb2RlLkRJQU1PTkQsXG4gICAgICBwcm9wVHlwZTogKG1ldGEucHJvcFR5cGUgYXMgc3RyaW5nKSB8fCBcInVua25vd25cIixcbiAgICAgIGlzX2Zhdm9yaXRlOiAobWV0YS5pc19mYXZvcml0ZSBhcyBib29sZWFuKSB8fCBmYWxzZSxcbiAgICAgIGlzX2NpcmN1bGFyOiAobWV0YS5pc19jaXJjdWxhciBhcyBib29sZWFuKSB8fCBmYWxzZSxcbiAgICAgIHN0YXJ0aW5nX3Bvc2l0aW9uOiAobWV0YS5zZXF1ZW5jZV9zdGFydF9wb3NpdGlvbiBhcyBzdHJpbmcpIHx8IFwiYmV0YVwiLFxuICAgICAgZGlmZmljdWx0eV9sZXZlbDogdGhpcy5tYXBMZXZlbFRvRGlmZmljdWx0eSgobWV0YS5sZXZlbCBhcyBudW1iZXIpIHx8IDEpLFxuICAgICAgdGFnczogW1wiZmxvd1wiLCBcInByYWN0aWNlXCJdLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgc291cmNlOiBcInBuZ19tZXRhZGF0YVwiLFxuICAgICAgICBleHRyYWN0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgLi4ubWV0YSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXAgbnVtZXJpYyBsZXZlbCB0byBkaWZmaWN1bHR5IHN0cmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBtYXBMZXZlbFRvRGlmZmljdWx0eShsZXZlbDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBpZiAobGV2ZWwgPD0gMSkgcmV0dXJuIFwiYmVnaW5uZXJcIjtcbiAgICBpZiAobGV2ZWwgPD0gMikgcmV0dXJuIFwiaW50ZXJtZWRpYXRlXCI7XG4gICAgcmV0dXJuIFwiYWR2YW5jZWRcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHNlcXVlbmNlIGZyb20gUE5HIG1ldGFkYXRhIG9yIGNyZWF0ZSBmYWxsYmFja1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVUZXN0U2VxdWVuY2UoaWQ6IHN0cmluZyk6IFByb21pc2U8U2VxdWVuY2VEYXRhPiB7XG4gICAgY29uc29sZS5sb2coYPCfjqwgTG9hZGluZyBzZXF1ZW5jZSBmcm9tIFBORyBtZXRhZGF0YSBmb3IgSUQ6ICR7aWR9YCk7XG5cbiAgICAvLyBUcnkgdG8gbG9hZCBmcm9tIFBORyBtZXRhZGF0YSBmaXJzdFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZXF1ZW5jZURhdGEgPSBhd2FpdCB0aGlzLmxvYWRTZXF1ZW5jZUZyb21QTkcoaWQpO1xuICAgICAgaWYgKHNlcXVlbmNlRGF0YSkge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIExvYWRlZCByZWFsIHNlcXVlbmNlIGRhdGEgZnJvbSBQTkcgZm9yICR7aWR9YCk7XG4gICAgICAgIHJldHVybiBzZXF1ZW5jZURhdGE7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIEZhaWxlZCB0byBsb2FkIFBORyBtZXRhZGF0YSBmb3IgJHtpZH06YCwgZXJyb3IpO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gZXJyb3IgLSBubyBmYWtlIHNlcXVlbmNlc1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBObyBQTkcgbWV0YWRhdGEgZm91bmQgZm9yIHNlcXVlbmNlICR7aWR9LiBQbGVhc2UgZW5zdXJlIHRoZSBzZXF1ZW5jZSBoYXMgYSB2YWxpZCBQTkcgdGh1bWJuYWlsIHdpdGggZW1iZWRkZWQgbWV0YWRhdGEuYFxuICAgICk7XG4gIH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICJBQVFBO0FBQUEsRUFDRTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsT0FDSztBQUVQLFNBQVMsNEJBQTRCO0FBUTlCLGFBQU0sZ0JBQTRDO0FBQUEsRUFDdkQsWUFDVSx1QkFDQSxvQkFDUjtBQUZRO0FBQ0E7QUFBQSxFQUNQO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLSCxNQUFNLGVBQWUsU0FBdUQ7QUFDMUUsUUFBSTtBQUVGLFlBQU0sV0FBVyxLQUFLLHNCQUFzQixlQUFlLE9BQU87QUFDbEUsWUFBTSxLQUFLLG1CQUFtQixhQUFhLFFBQVE7QUFDbkQsYUFBTztBQUFBLElBQ1QsU0FBUyxPQUFPO0FBQ2QsY0FBUSxNQUFNLDhCQUE4QixLQUFLO0FBQ2pELFlBQU0sSUFBSTtBQUFBLFFBQ1IsOEJBQThCLGlCQUFpQixRQUFRLE1BQU0sVUFBVSxlQUFlO0FBQUEsTUFDeEY7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsTUFBTSxXQUNKLFlBQ0EsV0FDQSxVQUNlO0FBQ2YsUUFBSTtBQUVGLFlBQU0sa0JBQ0osTUFBTSxLQUFLLG1CQUFtQixhQUFhLFVBQVU7QUFDdkQsVUFBSSxDQUFDLGlCQUFpQjtBQUNwQixjQUFNLElBQUksTUFBTSxZQUFZLFVBQVUsWUFBWTtBQUFBLE1BQ3BEO0FBR0EsWUFBTSxrQkFBa0IsS0FBSyxzQkFBc0I7QUFBQSxRQUNqRDtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUVBLFlBQU0sS0FBSyxtQkFBbUIsYUFBYSxlQUFlO0FBQUEsSUFDNUQsU0FBUyxPQUFPO0FBQ2QsY0FBUSxNQUFNLDBCQUEwQixLQUFLO0FBQzdDLFlBQU0sSUFBSTtBQUFBLFFBQ1IsMEJBQTBCLGlCQUFpQixRQUFRLE1BQU0sVUFBVSxlQUFlO0FBQUEsTUFDcEY7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsTUFBTSx5QkFDSixZQUNBLGVBQ2U7QUFDZixRQUFJO0FBRUYsWUFBTSxrQkFDSixNQUFNLEtBQUssbUJBQW1CLGFBQWEsVUFBVTtBQUN2RCxVQUFJLENBQUMsaUJBQWlCO0FBQ3BCLGNBQU0sSUFBSSxNQUFNLFlBQVksVUFBVSxZQUFZO0FBQUEsTUFDcEQ7QUFHQSxZQUFNLGtCQUFrQjtBQUFBLFFBQ3RCLEdBQUc7QUFBQSxRQUNIO0FBQUEsTUFDRjtBQUVBLFlBQU0sS0FBSyxtQkFBbUIsYUFBYSxlQUFlO0FBQUEsSUFDNUQsU0FBUyxPQUFPO0FBQ2QsY0FBUSxNQUFNLGlDQUFpQyxLQUFLO0FBQ3BELFlBQU0sSUFBSTtBQUFBLFFBQ1IsaUNBQWlDLGlCQUFpQixRQUFRLE1BQU0sVUFBVSxlQUFlO0FBQUEsTUFDM0Y7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsTUFBTSxlQUFlLElBQTJCO0FBQzlDLFFBQUk7QUFDRixZQUFNLEtBQUssbUJBQW1CLGVBQWUsRUFBRTtBQUFBLElBQ2pELFNBQVMsT0FBTztBQUNkLGNBQVEsTUFBTSw4QkFBOEIsS0FBSztBQUNqRCxZQUFNLElBQUk7QUFBQSxRQUNSLDhCQUE4QixpQkFBaUIsUUFBUSxNQUFNLFVBQVUsZUFBZTtBQUFBLE1BQ3hGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLE1BQU0sWUFBWSxJQUEwQztBQUMxRCxRQUFJO0FBQ0YsVUFBSSxXQUFXLE1BQU0sS0FBSyxtQkFBbUIsYUFBYSxFQUFFO0FBRzVELFVBQUksQ0FBQyxVQUFVO0FBQ2IsZ0JBQVE7QUFBQSxVQUNOLGVBQWUsRUFBRTtBQUFBLFFBQ25CO0FBQ0EsWUFBSTtBQUNGLHFCQUFXLE1BQU0sS0FBSyxvQkFBb0IsRUFBRTtBQUU1QyxjQUFJLFVBQVU7QUFDWixrQkFBTSxLQUFLLG1CQUFtQixhQUFhLFFBQVE7QUFBQSxVQUNyRDtBQUFBLFFBQ0YsU0FBUyxPQUFPO0FBQ2Qsa0JBQVEsTUFBTSwyQkFBMkIsRUFBRSxjQUFjLEtBQUs7QUFDOUQsaUJBQU87QUFBQSxRQUNUO0FBQUEsTUFDRjtBQUVBLGFBQU87QUFBQSxJQUNULFNBQVMsT0FBTztBQUNkLGNBQVEsTUFBTSwwQkFBMEIsRUFBRSxLQUFLLEtBQUs7QUFDcEQsYUFBTztBQUFBLElBQ1Q7QUFBQSxFQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxNQUFNLGtCQUEyQztBQUMvQyxRQUFJO0FBQ0YsYUFBTyxNQUFNLEtBQUssbUJBQW1CLGlCQUFpQjtBQUFBLElBQ3hELFNBQVMsT0FBTztBQUNkLGNBQVEsTUFBTSxnQ0FBZ0MsS0FBSztBQUNuRCxhQUFPLENBQUM7QUFBQSxJQUNWO0FBQUEsRUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsTUFBTSxRQUNKLFlBQ0EsVUFDZTtBQUNmLFFBQUk7QUFDRixZQUFNLFdBQVcsTUFBTSxLQUFLLFlBQVksVUFBVTtBQUNsRCxVQUFJLENBQUMsVUFBVTtBQUNiLGNBQU0sSUFBSSxNQUFNLFlBQVksVUFBVSxZQUFZO0FBQUEsTUFDcEQ7QUFHQSxZQUFNLGlCQUFpQixTQUFTLE1BQU0sU0FBUztBQUMvQyxZQUFNLFVBQW9CO0FBQUEsUUFDeEIsSUFBSSxPQUFPLFdBQVc7QUFBQSxRQUN0QixZQUFZO0FBQUEsUUFDWixVQUFVO0FBQUEsUUFDVixjQUFjO0FBQUEsUUFDZCxhQUFhO0FBQUEsUUFDYixTQUFTO0FBQUEsUUFDVCxnQkFBZ0I7QUFBQSxRQUNoQixVQUFVLENBQUM7QUFBQSxRQUNYLEdBQUc7QUFBQSxNQUNMO0FBQ0EsWUFBTSxrQkFBa0I7QUFBQSxRQUN0QixHQUFHO0FBQUEsUUFDSCxPQUFPLENBQUMsR0FBRyxTQUFTLE9BQU8sT0FBTztBQUFBLE1BQ3BDO0FBQ0EsWUFBTSxLQUFLLG1CQUFtQixhQUFhLGVBQWU7QUFBQSxJQUM1RCxTQUFTLE9BQU87QUFDZCxjQUFRLE1BQU0sdUJBQXVCLEtBQUs7QUFDMUMsWUFBTSxJQUFJO0FBQUEsUUFDUix1QkFBdUIsaUJBQWlCLFFBQVEsTUFBTSxVQUFVLGVBQWU7QUFBQSxNQUNqRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxNQUFNLFdBQVcsWUFBb0IsV0FBa0M7QUFDckUsUUFBSTtBQUNGLFlBQU0sV0FBVyxNQUFNLEtBQUssWUFBWSxVQUFVO0FBQ2xELFVBQUksQ0FBQyxVQUFVO0FBQ2IsY0FBTSxJQUFJLE1BQU0sWUFBWSxVQUFVLFlBQVk7QUFBQSxNQUNwRDtBQUVBLFVBQUksWUFBWSxLQUFLLGFBQWEsU0FBUyxNQUFNLFFBQVE7QUFDdkQsY0FBTSxJQUFJLE1BQU0sY0FBYyxTQUFTLGtCQUFrQjtBQUFBLE1BQzNEO0FBR0EsWUFBTSxXQUFXLFNBQVMsTUFDdkIsT0FBTyxDQUFDLEdBQUcsVUFBVSxVQUFVLFNBQVMsRUFDeEMsSUFBSSxDQUFDLE1BQU0sV0FBVyxFQUFFLEdBQUcsTUFBTSxZQUFZLFFBQVEsRUFBRSxFQUFFO0FBQzVELFlBQU0sa0JBQWtCLEVBQUUsR0FBRyxVQUFVLE9BQU8sU0FBUztBQUN2RCxZQUFNLEtBQUssbUJBQW1CLGFBQWEsZUFBZTtBQUFBLElBQzVELFNBQVMsT0FBTztBQUNkLGNBQVEsTUFBTSwwQkFBMEIsS0FBSztBQUM3QyxZQUFNLElBQUk7QUFBQSxRQUNSLDBCQUEwQixpQkFBaUIsUUFBUSxNQUFNLFVBQVUsZUFBZTtBQUFBLE1BQ3BGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLE1BQWMsb0JBQW9CLElBQTBDO0FBQzFFLFlBQVEsSUFBSSxpREFBaUQsRUFBRSxFQUFFO0FBRWpFLFFBQUk7QUFFRixZQUFNLGNBQWMsTUFBTSxxQkFBcUI7QUFBQSxRQUM3QyxHQUFHLFlBQVk7QUFBQSxNQUNqQjtBQUVBLFVBQUksQ0FBQyxlQUFlLFlBQVksV0FBVyxHQUFHO0FBQzVDLGdCQUFRLE1BQU0sMENBQTBDLEVBQUUsRUFBRTtBQUM1RCxlQUFPO0FBQUEsTUFDVDtBQUdBLFlBQU0sV0FBVyxNQUFNLEtBQUssNkJBQTZCLElBQUksV0FBVztBQUN4RSxjQUFRLElBQUksNENBQTRDLEVBQUUsRUFBRTtBQUM1RCxhQUFPO0FBQUEsSUFDVCxTQUFTLE9BQU87QUFDZCxjQUFRLE1BQU0sbUNBQW1DLEVBQUUsS0FBSyxLQUFLO0FBRTdELGFBQU8sS0FBSyxtQkFBbUIsRUFBRTtBQUFBLElBQ25DO0FBQUEsRUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsTUFBYyw2QkFDWixJQUNBLGFBQ3VCO0FBQ3ZCLFlBQVEsSUFBSSx1REFBdUQsRUFBRSxFQUFFO0FBR3ZFLFVBQU0sT0FBTyxZQUFZLENBQUM7QUFDMUIsVUFBTSxRQUFRLFlBQVksTUFBTSxDQUFDO0FBR2pDLFVBQU0sUUFBb0IsTUFDdkIsT0FBTyxDQUFDLFNBQVMsT0FBTyxLQUFLLFNBQVMsWUFBWSxLQUFLLE9BQU8sQ0FBQyxFQUMvRCxJQUFJLENBQUMsVUFBVTtBQUFBLE1BQ2QsSUFBSSxHQUFHLEtBQUssSUFBSSxJQUFJLEtBQUssTUFBTTtBQUFBLE1BQy9CLFlBQVksS0FBSztBQUFBLE1BQ2pCLFVBQVU7QUFBQSxNQUNWLGNBQWM7QUFBQSxNQUNkLGFBQWE7QUFBQSxNQUNiLFNBQVM7QUFBQSxNQUNULGdCQUFnQjtBQUFBLFFBQ2QsSUFBSSxjQUFjLEtBQUssSUFBSTtBQUFBLFFBQzNCLFVBQVU7QUFBQSxVQUNSLFVBQVcsS0FBSyxZQUF5QixTQUFTO0FBQUEsVUFDbEQsVUFBVTtBQUFBLFVBQ1YsVUFBVTtBQUFBLFVBQ1YsUUFBUTtBQUFBLFVBQ1IsZUFBZTtBQUFBLFlBQ2IscUJBQXFCLENBQUM7QUFBQSxZQUN0QixxQkFBcUIsQ0FBQztBQUFBLFlBQ3RCLHVCQUF1QixDQUFDO0FBQUEsWUFDeEIsdUJBQXVCLENBQUM7QUFBQSxZQUN4QixnQkFBZ0IsQ0FBQztBQUFBLFlBQ2pCLGFBQWEsRUFBRSxhQUFhLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxFQUFFO0FBQUEsVUFDN0M7QUFBQSxRQUNGO0FBQUEsUUFDQSxRQUFRLENBQUM7QUFBQSxRQUNULE9BQU8sQ0FBQztBQUFBLFFBQ1IsU0FBUztBQUFBLFVBQ1AsTUFBTTtBQUFBLFlBQ0osT0FBTyxZQUFZO0FBQUE7QUFBQSxZQUNuQixZQUNJLEtBQUssZ0JBQ0gsY0FBNkIsV0FBVztBQUFBLFlBQzlDLGVBQ0ksS0FBSyxnQkFDSCxpQkFBOEIsU0FBUztBQUFBLFlBQzdDLGFBQ0ksS0FBSyxnQkFDSCxlQUE0QixTQUFTO0FBQUEsWUFDM0Msa0JBQ0ksS0FBSyxnQkFDSCxvQkFBb0MsWUFBWTtBQUFBLFlBQ3RELGdCQUFpQixLQUFLLGdCQUNsQjtBQUFBO0FBQUEsWUFDSixtQkFDSSxLQUFLLGdCQUNILHFCQUNKLGtCQUFrQjtBQUFBLFlBQ3BCLE9BQ0ksS0FBSyxnQkFDSCxTQUFvQjtBQUFBLFlBQzFCLFdBQVc7QUFBQSxVQUNiO0FBQUEsVUFDQSxLQUFLO0FBQUEsWUFDSCxPQUFPLFlBQVk7QUFBQTtBQUFBLFlBQ25CLFlBQ0ksS0FBSyxlQUNILGNBQTZCLFdBQVc7QUFBQSxZQUM5QyxlQUNJLEtBQUssZUFDSCxpQkFBOEIsU0FBUztBQUFBLFlBQzdDLGFBQ0ksS0FBSyxlQUNILGVBQTRCLFNBQVM7QUFBQSxZQUMzQyxrQkFDSSxLQUFLLGVBQ0gsb0JBQW9DLFlBQVk7QUFBQSxZQUN0RCxnQkFBaUIsS0FBSyxlQUNsQjtBQUFBO0FBQUEsWUFDSixtQkFDSSxLQUFLLGVBQ0gscUJBQ0osa0JBQWtCO0FBQUEsWUFDcEIsT0FDSSxLQUFLLGVBQ0gsU0FBb0I7QUFBQSxZQUMxQixXQUFXO0FBQUEsVUFDYjtBQUFBLFFBQ0Y7QUFBQSxRQUNBLFFBQVMsS0FBSyxVQUFxQjtBQUFBLFFBQ25DLE1BQU0sS0FBSztBQUFBLFFBQ1gsU0FBUztBQUFBLFFBQ1QsWUFBWTtBQUFBLFFBQ1osVUFBVSxDQUFDO0FBQUEsTUFDYjtBQUFBLE1BQ0EsVUFBVSxDQUFDO0FBQUEsSUFDYixFQUFFO0FBRUosWUFBUSxJQUFJLGtDQUFrQyxNQUFNLE1BQU0sUUFBUTtBQUVsRSxXQUFPO0FBQUEsTUFDTDtBQUFBLE1BQ0EsTUFBTyxLQUFLLFFBQW1CLEdBQUcsWUFBWTtBQUFBLE1BQzlDLE1BQU8sS0FBSyxRQUFtQixHQUFHLFlBQVk7QUFBQSxNQUM5QztBQUFBLE1BQ0EsWUFBWSxDQUFDLEdBQUcsR0FBRyxZQUFZLENBQUMsV0FBVztBQUFBLE1BQzNDLGlCQUFpQixNQUFNO0FBQUEsTUFDdkIsUUFBUyxLQUFLLFVBQXFCO0FBQUEsTUFDbkMsT0FBUSxLQUFLLFNBQW9CO0FBQUEsTUFDakMsWUFBWSxJQUFJLEtBQU0sS0FBSyxjQUFrQyxLQUFLLElBQUksQ0FBQztBQUFBLE1BQ3ZFLFVBQVcsS0FBSyxZQUF1QixTQUFTO0FBQUEsTUFDaEQsVUFBVyxLQUFLLFlBQXVCO0FBQUEsTUFDdkMsYUFBYyxLQUFLLGVBQTJCO0FBQUEsTUFDOUMsYUFBYyxLQUFLLGVBQTJCO0FBQUEsTUFDOUMsbUJBQW9CLEtBQUssMkJBQXNDO0FBQUEsTUFDL0Qsa0JBQWtCLEtBQUsscUJBQXNCLEtBQUssU0FBb0IsQ0FBQztBQUFBLE1BQ3ZFLE1BQU0sQ0FBQyxRQUFRLFVBQVU7QUFBQSxNQUN6QixVQUFVO0FBQUEsUUFDUixRQUFRO0FBQUEsUUFDUixlQUFjLG9CQUFJLEtBQUssR0FBRSxZQUFZO0FBQUEsUUFDckMsR0FBRztBQUFBLE1BQ0w7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS1EscUJBQXFCLE9BQXVCO0FBQ2xELFFBQUksU0FBUyxFQUFHLFFBQU87QUFDdkIsUUFBSSxTQUFTLEVBQUcsUUFBTztBQUN2QixXQUFPO0FBQUEsRUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsTUFBYyxtQkFBbUIsSUFBbUM7QUFDbEUsWUFBUSxJQUFJLGlEQUFpRCxFQUFFLEVBQUU7QUFHakUsUUFBSTtBQUNGLFlBQU0sZUFBZSxNQUFNLEtBQUssb0JBQW9CLEVBQUU7QUFDdEQsVUFBSSxjQUFjO0FBQ2hCLGdCQUFRLElBQUksNENBQTRDLEVBQUUsRUFBRTtBQUM1RCxlQUFPO0FBQUEsTUFDVDtBQUFBLElBQ0YsU0FBUyxPQUFPO0FBQ2QsY0FBUSxLQUFLLHNDQUFzQyxFQUFFLEtBQUssS0FBSztBQUFBLElBQ2pFO0FBR0EsVUFBTSxJQUFJO0FBQUEsTUFDUixzQ0FBc0MsRUFBRTtBQUFBLElBQzFDO0FBQUEsRUFDRjtBQUNGOyIsCiAgIm5hbWVzIjogW10KfQo=
