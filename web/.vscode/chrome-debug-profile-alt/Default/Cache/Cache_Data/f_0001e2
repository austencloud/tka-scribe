import { MotionColor } from "/src/lib/domain/enums.ts";
export class ArrowRenderingService {
  constructor(config) {
    this.config = config;
  }
  /**
   * Get arrow SVG path based on motion type and properties (extracted from Arrow.svelte)
   */
  getArrowPath(arrowData, motionData) {
    if (!arrowData || !motionData) {
      console.warn(
        "ðŸš« ArrowRenderingService: Missing arrowData or motionData, cannot determine arrow path"
      );
      return null;
    }
    const { motionType, turns } = motionData;
    const baseDir = `/images/arrows/${motionType}`;
    if (["pro", "anti", "static"].includes(motionType)) {
      const startOrientation = motionData.startOrientation || "in";
      const endOrientation = motionData.endOrientation || "in";
      const isNonRadial = startOrientation === "clock" || startOrientation === "counter" || endOrientation === "clock" || endOrientation === "counter";
      const subDir = isNonRadial ? "from_nonradial" : "from_radial";
      const turnValue = typeof turns === "number" ? turns.toFixed(1) : "0.0";
      const path2 = `${baseDir}/${subDir}/${motionType}_${turnValue}.svg`;
      return path2;
    }
    const path = `${baseDir}.svg`;
    return path;
  }
  /**
   * Parse SVG to get proper dimensions and center point (extracted from Arrow.svelte)
   */
  parseArrowSvg(svgText) {
    const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
    const svg = doc.documentElement;
    const viewBoxValues = svg.getAttribute("viewBox")?.split(/\s+/) || [
      "0",
      "0",
      "100",
      "100"
    ];
    const viewBox = {
      width: parseFloat(viewBoxValues[2] || "100") || 100,
      height: parseFloat(viewBoxValues[3] || "100") || 100
    };
    let center = { x: viewBox.width / 2, y: viewBox.height / 2 };
    try {
      const centerElement = doc.getElementById("centerPoint");
      if (centerElement) {
        center = {
          x: parseFloat(centerElement.getAttribute("cx") || "0") || center.x,
          y: parseFloat(centerElement.getAttribute("cy") || "0") || center.y
        };
      }
    } catch {
    }
    return { viewBox, center };
  }
  /**
   * Apply color transformation to SVG content (extracted from Arrow.svelte)
   */
  applyColorToSvg(svgText, color) {
    const colorMap = /* @__PURE__ */ new Map([
      [MotionColor.BLUE, "#2E3192"],
      [MotionColor.RED, "#ED1C24"]
    ]);
    const targetColor = colorMap.get(color) || "#2E3192";
    let coloredSvg = svgText.replace(
      /fill="#[0-9A-Fa-f]{6}"/g,
      `fill="${targetColor}"`
    );
    coloredSvg = coloredSvg.replace(
      /fill:\s*#[0-9A-Fa-f]{6}/g,
      `fill:${targetColor}`
    );
    coloredSvg = coloredSvg.replace(
      /<circle[^>]*id="centerPoint"[^>]*\/?>/,
      ""
    );
    return coloredSvg;
  }
  /**
   * Load arrow SVG data with color transformation (extracted from Arrow.svelte)
   */
  async loadArrowSvgData(arrowData, motionData) {
    const path = this.getArrowPath(arrowData, motionData);
    if (!path) {
      throw new Error("No arrow path available - missing motion data");
    }
    const response = await fetch(path);
    if (!response.ok) {
      throw new Error(`Failed to fetch SVG: ${response.status}`);
    }
    const originalSvgText = await response.text();
    const { viewBox, center } = this.parseArrowSvg(originalSvgText);
    const coloredSvgText = this.applyColorToSvg(
      originalSvgText,
      motionData.color
    );
    const svgContent = this.extractSvgContent(coloredSvgText);
    return {
      imageSrc: svgContent,
      viewBox,
      center
    };
  }
  /**
   * Render arrow at sophisticated calculated position using real SVG assets
   */
  async renderArrowAtPosition(svg, color, position, motionData) {
    try {
      const arrowSvgPath = this.getArrowSvgPath(motionData);
      const response = await fetch(arrowSvgPath);
      if (!response.ok) {
        throw new Error(`Failed to load arrow SVG: ${response.status}`);
      }
      const svgContent = await response.text();
      const arrowGroup = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "g"
      );
      arrowGroup.setAttribute(
        "class",
        `arrow-${color} sophisticated-positioning`
      );
      arrowGroup.setAttribute("data-color", color);
      arrowGroup.setAttribute("data-position", `${position.x},${position.y}`);
      arrowGroup.setAttribute("data-rotation", position.rotation.toString());
      const transform = `translate(${position.x}, ${position.y}) rotate(${position.rotation})`;
      arrowGroup.setAttribute("transform", transform);
      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(svgContent, "image/svg+xml");
      const svgElement = svgDoc.documentElement;
      this.applyArrowColorTransformation(svgElement, color);
      const importedSvg = document.importNode(svgElement, true);
      arrowGroup.appendChild(importedSvg);
      svg.appendChild(arrowGroup);
    } catch (error) {
      console.error(`âŒ Error loading arrow SVG for ${color}:`, error);
      this.renderFallbackArrow(svg, color, position);
    }
  }
  /**
   * Get the correct arrow SVG path based on motion data (like ArrowSvgManager)
   */
  getArrowSvgPath(motionData) {
    if (!motionData) {
      return "/images/arrows/static/from_radial/static_0.svg";
    }
    const motionType = motionData.motionType;
    const turnsVal = motionData.turns;
    const startOrientation = motionData.startOrientation;
    if (motionType === "float") return "/images/arrows/float.svg";
    const radialPath = startOrientation === "in" ? "from_radial" : "from_nonradial";
    let turnsStr;
    if (turnsVal === "fl") {
      turnsStr = "fl";
    } else if (typeof turnsVal === "number") {
      turnsStr = turnsVal % 1 === 0 ? `${turnsVal}.0` : turnsVal.toString();
    } else {
      turnsStr = "0.0";
    }
    return `/images/arrows/${motionType}/${radialPath}/${motionType}_${turnsStr}.svg`;
  }
  /**
   * Apply color transformation to arrow SVG
   */
  applyArrowColorTransformation(svgElement, color) {
    const paths = svgElement.querySelectorAll("path");
    const fillColor = color === MotionColor.BLUE ? "#3b82f6" : "#ef4444";
    const strokeColor = color === MotionColor.BLUE ? "#1d4ed8" : "#dc2626";
    paths.forEach((path) => {
      path.setAttribute("fill", fillColor);
      path.setAttribute("stroke", strokeColor);
      path.setAttribute("stroke-width", "1");
    });
  }
  /**
   * Render fallback arrow if SVG loading fails
   */
  renderFallbackArrow(svg, color, position) {
    const arrowGroup = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "g"
    );
    arrowGroup.setAttribute("class", `arrow-${color} fallback`);
    arrowGroup.setAttribute(
      "transform",
      `translate(${position.x}, ${position.y}) rotate(${position.rotation})`
    );
    const arrowPath = this.createEnhancedArrowPath(color);
    arrowGroup.appendChild(arrowPath);
    svg.appendChild(arrowGroup);
  }
  /**
   * Create enhanced arrow SVG path with sophisticated styling
   */
  createEnhancedArrowPath(color) {
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", "M 0,-25 L 15,0 L 0,25 L -8,15 L -8,-15 Z");
    path.setAttribute("fill", color);
    path.setAttribute("stroke", "#000000");
    path.setAttribute("stroke-width", "2");
    path.setAttribute("opacity", "0.9");
    path.setAttribute("filter", "drop-shadow(1px 1px 2px rgba(0,0,0,0.3))");
    path.setAttribute("class", "sophisticated-arrow");
    return path;
  }
  extractSvgContent(svgText) {
    if (svgText.includes('width="0"') || svgText.includes("<svg") && svgText.includes("/>")) {
      return "";
    }
    const svgContentMatch = svgText.match(/<svg[^>]*>(.*)<\/svg>/s);
    if (!svgContentMatch) {
      console.warn("Could not extract SVG content from non-static arrow");
      return svgText;
    }
    return svgContentMatch[1];
  }
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiQzovVEtBL3dlYi9zcmMvbGliL3NlcnZpY2VzL2ltcGxlbWVudGF0aW9ucy9yZW5kZXJpbmcvQXJyb3dSZW5kZXJpbmdTZXJ2aWNlLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIEFycm93IFJlbmRlcmluZyBTZXJ2aWNlXG4gKlxuICogSGFuZGxlcyBhcnJvdyByZW5kZXJpbmcgd2l0aCBTVkcgYXNzZXRzLCBjb2xvciB0cmFuc2Zvcm1hdGlvbiwgYW5kIGZhbGxiYWNrcy5cbiAqIEV4dHJhY3RlZCBmcm9tIFBpY3RvZ3JhcGhSZW5kZXJpbmdTZXJ2aWNlIGFuZCBBcnJvdy5zdmVsdGUuXG4gKlxuICogQnVzaW5lc3MgbG9naWMgZXh0cmFjdGVkIGZyb20gQXJyb3cuc3ZlbHRlOlxuICogLSBhcnJvd1BhdGggY2FsY3VsYXRpb24gbG9naWNcbiAqIC0gcGFyc2VBcnJvd1N2ZyBmdW5jdGlvblxuICogLSBhcHBseUNvbG9yVG9TdmcgZnVuY3Rpb25cbiAqIC0gU1ZHIGxvYWRpbmcgbG9naWNcbiAqL1xuXG5pbXBvcnQgdHlwZSB7IE1vdGlvbkRhdGEsIEFycm93RGF0YSB9IGZyb20gXCIkbGliL2RvbWFpblwiO1xuaW1wb3J0IHsgTW90aW9uQ29sb3IgfSBmcm9tIFwiJGxpYi9kb21haW4vZW51bXNcIjtcbmltcG9ydCB0eXBlIHsgSVN2Z0NvbmZpZ3VyYXRpb24gfSBmcm9tIFwiLi9TdmdDb25maWd1cmF0aW9uXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXJyb3dQb3NpdGlvbiB7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xuICByb3RhdGlvbjogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFycm93U3ZnRGF0YSB7XG4gIGltYWdlU3JjOiBzdHJpbmc7IC8vIOKchSBGSVhFRDogQ2hhbmdlZCBmcm9tIHN2Z0NvbnRlbnQgdG8gbWF0Y2ggaW50ZXJmYWNlXG4gIHZpZXdCb3g6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfTtcbiAgY2VudGVyOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUFycm93UmVuZGVyaW5nU2VydmljZSB7XG4gIHJlbmRlckFycm93QXRQb3NpdGlvbihcbiAgICBzdmc6IFNWR0VsZW1lbnQsXG4gICAgY29sb3I6IE1vdGlvbkNvbG9yLFxuICAgIHBvc2l0aW9uOiBBcnJvd1Bvc2l0aW9uLFxuICAgIG1vdGlvbkRhdGE6IE1vdGlvbkRhdGEgfCB1bmRlZmluZWRcbiAgKTogUHJvbWlzZTx2b2lkPjtcblxuICAvLyBOZXcgbWV0aG9kcyBleHRyYWN0ZWQgZnJvbSBBcnJvdy5zdmVsdGVcbiAgZ2V0QXJyb3dQYXRoKGFycm93RGF0YTogQXJyb3dEYXRhLCBtb3Rpb25EYXRhOiBNb3Rpb25EYXRhKTogc3RyaW5nIHwgbnVsbDtcbiAgbG9hZEFycm93U3ZnRGF0YShcbiAgICBhcnJvd0RhdGE6IEFycm93RGF0YSxcbiAgICBtb3Rpb25EYXRhOiBNb3Rpb25EYXRhXG4gICk6IFByb21pc2U8QXJyb3dTdmdEYXRhPjtcbiAgcGFyc2VBcnJvd1N2ZyhzdmdUZXh0OiBzdHJpbmcpOiB7XG4gICAgdmlld0JveDogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9O1xuICAgIGNlbnRlcjogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuICB9O1xuICBhcHBseUNvbG9yVG9Tdmcoc3ZnVGV4dDogc3RyaW5nLCBjb2xvcjogTW90aW9uQ29sb3IpOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBBcnJvd1JlbmRlcmluZ1NlcnZpY2UgaW1wbGVtZW50cyBJQXJyb3dSZW5kZXJpbmdTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjb25maWc6IElTdmdDb25maWd1cmF0aW9uKSB7fVxuXG4gIC8qKlxuICAgKiBHZXQgYXJyb3cgU1ZHIHBhdGggYmFzZWQgb24gbW90aW9uIHR5cGUgYW5kIHByb3BlcnRpZXMgKGV4dHJhY3RlZCBmcm9tIEFycm93LnN2ZWx0ZSlcbiAgICovXG4gIGdldEFycm93UGF0aChhcnJvd0RhdGE6IEFycm93RGF0YSwgbW90aW9uRGF0YTogTW90aW9uRGF0YSk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICghYXJyb3dEYXRhIHx8ICFtb3Rpb25EYXRhKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwi8J+aqyBBcnJvd1JlbmRlcmluZ1NlcnZpY2U6IE1pc3NpbmcgYXJyb3dEYXRhIG9yIG1vdGlvbkRhdGEsIGNhbm5vdCBkZXRlcm1pbmUgYXJyb3cgcGF0aFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgeyBtb3Rpb25UeXBlLCB0dXJucyB9ID0gbW90aW9uRGF0YTtcbiAgICBjb25zdCBiYXNlRGlyID0gYC9pbWFnZXMvYXJyb3dzLyR7bW90aW9uVHlwZX1gO1xuXG4gICAgLy8gRm9yIG1vdGlvbiB0eXBlcyB0aGF0IGhhdmUgdHVybi1iYXNlZCBzdWJkaXJlY3RvcmllcyAocHJvLCBhbnRpLCBzdGF0aWMpXG4gICAgaWYgKFtcInByb1wiLCBcImFudGlcIiwgXCJzdGF0aWNcIl0uaW5jbHVkZXMobW90aW9uVHlwZSkpIHtcbiAgICAgIC8vIERldGVybWluZSBpZiB3ZSBzaG91bGQgdXNlIHJhZGlhbCB2cyBub24tcmFkaWFsIGFycm93c1xuICAgICAgLy8gVXNlIG5vbi1yYWRpYWwgb25seSBmb3IgY2xvY2svY291bnRlciBvcmllbnRhdGlvbnMsIHJhZGlhbCBmb3IgZXZlcnl0aGluZyBlbHNlXG4gICAgICAvLyDinIUgRklYRUQ6IE9yaWVudGF0aW9uIGRhdGEgY29tZXMgZnJvbSBNb3Rpb25EYXRhIG9ubHlcbiAgICAgIGNvbnN0IHN0YXJ0T3JpZW50YXRpb24gPSBtb3Rpb25EYXRhLnN0YXJ0T3JpZW50YXRpb24gfHwgXCJpblwiO1xuICAgICAgY29uc3QgZW5kT3JpZW50YXRpb24gPSBtb3Rpb25EYXRhLmVuZE9yaWVudGF0aW9uIHx8IFwiaW5cIjtcblxuICAgICAgY29uc3QgaXNOb25SYWRpYWwgPVxuICAgICAgICBzdGFydE9yaWVudGF0aW9uID09PSBcImNsb2NrXCIgfHxcbiAgICAgICAgc3RhcnRPcmllbnRhdGlvbiA9PT0gXCJjb3VudGVyXCIgfHxcbiAgICAgICAgZW5kT3JpZW50YXRpb24gPT09IFwiY2xvY2tcIiB8fFxuICAgICAgICBlbmRPcmllbnRhdGlvbiA9PT0gXCJjb3VudGVyXCI7XG5cbiAgICAgIGNvbnN0IHN1YkRpciA9IGlzTm9uUmFkaWFsID8gXCJmcm9tX25vbnJhZGlhbFwiIDogXCJmcm9tX3JhZGlhbFwiO1xuICAgICAgY29uc3QgdHVyblZhbHVlID0gdHlwZW9mIHR1cm5zID09PSBcIm51bWJlclwiID8gdHVybnMudG9GaXhlZCgxKSA6IFwiMC4wXCI7XG4gICAgICBjb25zdCBwYXRoID0gYCR7YmFzZURpcn0vJHtzdWJEaXJ9LyR7bW90aW9uVHlwZX1fJHt0dXJuVmFsdWV9LnN2Z2A7XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8vIEZvciBzaW1wbGUgbW90aW9uIHR5cGVzIChkYXNoLCBmbG9hdCkgLSB1c2UgYmFzZSBkaXJlY3RvcnlcbiAgICBjb25zdCBwYXRoID0gYCR7YmFzZURpcn0uc3ZnYDtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBTVkcgdG8gZ2V0IHByb3BlciBkaW1lbnNpb25zIGFuZCBjZW50ZXIgcG9pbnQgKGV4dHJhY3RlZCBmcm9tIEFycm93LnN2ZWx0ZSlcbiAgICovXG4gIHBhcnNlQXJyb3dTdmcoc3ZnVGV4dDogc3RyaW5nKToge1xuICAgIHZpZXdCb3g6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfTtcbiAgICBjZW50ZXI6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcbiAgfSB7XG4gICAgY29uc3QgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdmdUZXh0LCBcImltYWdlL3N2Zyt4bWxcIik7XG4gICAgY29uc3Qgc3ZnID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuICAgIC8vIEdldCB2aWV3Qm94IGRpbWVuc2lvbnNcbiAgICBjb25zdCB2aWV3Qm94VmFsdWVzID0gc3ZnLmdldEF0dHJpYnV0ZShcInZpZXdCb3hcIik/LnNwbGl0KC9cXHMrLykgfHwgW1xuICAgICAgXCIwXCIsXG4gICAgICBcIjBcIixcbiAgICAgIFwiMTAwXCIsXG4gICAgICBcIjEwMFwiLFxuICAgIF07XG4gICAgY29uc3Qgdmlld0JveCA9IHtcbiAgICAgIHdpZHRoOiBwYXJzZUZsb2F0KHZpZXdCb3hWYWx1ZXNbMl0gfHwgXCIxMDBcIikgfHwgMTAwLFxuICAgICAgaGVpZ2h0OiBwYXJzZUZsb2F0KHZpZXdCb3hWYWx1ZXNbM10gfHwgXCIxMDBcIikgfHwgMTAwLFxuICAgIH07XG5cbiAgICAvLyBHZXQgY2VudGVyIHBvaW50IGZyb20gU1ZHXG4gICAgbGV0IGNlbnRlciA9IHsgeDogdmlld0JveC53aWR0aCAvIDIsIHk6IHZpZXdCb3guaGVpZ2h0IC8gMiB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNlbnRlckVsZW1lbnQgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoXCJjZW50ZXJQb2ludFwiKTtcbiAgICAgIGlmIChjZW50ZXJFbGVtZW50KSB7XG4gICAgICAgIGNlbnRlciA9IHtcbiAgICAgICAgICB4OiBwYXJzZUZsb2F0KGNlbnRlckVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY3hcIikgfHwgXCIwXCIpIHx8IGNlbnRlci54LFxuICAgICAgICAgIHk6IHBhcnNlRmxvYXQoY2VudGVyRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjeVwiKSB8fCBcIjBcIikgfHwgY2VudGVyLnksXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBTVkcgY2VudGVyIGNhbGN1bGF0aW9uIGZhaWxlZCwgdXNpbmcgZGVmYXVsdCBjZW50ZXJcbiAgICB9XG5cbiAgICByZXR1cm4geyB2aWV3Qm94LCBjZW50ZXIgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBjb2xvciB0cmFuc2Zvcm1hdGlvbiB0byBTVkcgY29udGVudCAoZXh0cmFjdGVkIGZyb20gQXJyb3cuc3ZlbHRlKVxuICAgKi9cbiAgYXBwbHlDb2xvclRvU3ZnKHN2Z1RleHQ6IHN0cmluZywgY29sb3I6IE1vdGlvbkNvbG9yKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb2xvck1hcCA9IG5ldyBNYXAoW1xuICAgICAgW01vdGlvbkNvbG9yLkJMVUUsIFwiIzJFMzE5MlwiXSxcbiAgICAgIFtNb3Rpb25Db2xvci5SRUQsIFwiI0VEMUMyNFwiXSxcbiAgICBdKTtcblxuICAgIGNvbnN0IHRhcmdldENvbG9yID0gY29sb3JNYXAuZ2V0KGNvbG9yKSB8fCBcIiMyRTMxOTJcIjtcblxuICAgIC8vIFVzZSByZWdleCByZXBsYWNlbWVudCB0byBjaGFuZ2UgZmlsbCBjb2xvcnMgZGlyZWN0bHlcbiAgICBsZXQgY29sb3JlZFN2ZyA9IHN2Z1RleHQucmVwbGFjZShcbiAgICAgIC9maWxsPVwiI1swLTlBLUZhLWZdezZ9XCIvZyxcbiAgICAgIGBmaWxsPVwiJHt0YXJnZXRDb2xvcn1cImBcbiAgICApO1xuICAgIGNvbG9yZWRTdmcgPSBjb2xvcmVkU3ZnLnJlcGxhY2UoXG4gICAgICAvZmlsbDpcXHMqI1swLTlBLUZhLWZdezZ9L2csXG4gICAgICBgZmlsbDoke3RhcmdldENvbG9yfWBcbiAgICApO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBjZW50ZXJQb2ludCBjaXJjbGUgZW50aXJlbHkgdG8gcHJldmVudCB1bndhbnRlZCB2aXN1YWwgZWxlbWVudHNcbiAgICBjb2xvcmVkU3ZnID0gY29sb3JlZFN2Zy5yZXBsYWNlKFxuICAgICAgLzxjaXJjbGVbXj5dKmlkPVwiY2VudGVyUG9pbnRcIltePl0qXFwvPz4vLFxuICAgICAgXCJcIlxuICAgICk7XG5cbiAgICByZXR1cm4gY29sb3JlZFN2ZztcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGFycm93IFNWRyBkYXRhIHdpdGggY29sb3IgdHJhbnNmb3JtYXRpb24gKGV4dHJhY3RlZCBmcm9tIEFycm93LnN2ZWx0ZSlcbiAgICovXG4gIGFzeW5jIGxvYWRBcnJvd1N2Z0RhdGEoXG4gICAgYXJyb3dEYXRhOiBBcnJvd0RhdGEsXG4gICAgbW90aW9uRGF0YTogTW90aW9uRGF0YVxuICApOiBQcm9taXNlPEFycm93U3ZnRGF0YT4ge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLmdldEFycm93UGF0aChhcnJvd0RhdGEsIG1vdGlvbkRhdGEpO1xuICAgIGlmICghcGF0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXJyb3cgcGF0aCBhdmFpbGFibGUgLSBtaXNzaW5nIG1vdGlvbiBkYXRhXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocGF0aCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggU1ZHOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcmlnaW5hbFN2Z1RleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgY29uc3QgeyB2aWV3Qm94LCBjZW50ZXIgfSA9IHRoaXMucGFyc2VBcnJvd1N2ZyhvcmlnaW5hbFN2Z1RleHQpO1xuXG4gICAgLy8gQXBwbHkgY29sb3IgdHJhbnNmb3JtYXRpb24gdG8gdGhlIFNWR1xuICAgIGNvbnN0IGNvbG9yZWRTdmdUZXh0ID0gdGhpcy5hcHBseUNvbG9yVG9TdmcoXG4gICAgICBvcmlnaW5hbFN2Z1RleHQsXG4gICAgICBtb3Rpb25EYXRhLmNvbG9yXG4gICAgKTtcblxuICAgIC8vIEV4dHJhY3QganVzdCB0aGUgaW5uZXIgU1ZHIGNvbnRlbnQgKG5vIHNjYWxpbmcgbmVlZGVkIC0gYXJyb3dzIGFyZSBhbHJlYWR5IGNvcnJlY3RseSBzaXplZClcbiAgICBjb25zdCBzdmdDb250ZW50ID0gdGhpcy5leHRyYWN0U3ZnQ29udGVudChjb2xvcmVkU3ZnVGV4dCk7XG5cbiAgICAvLyDinIUgRklYRUQ6IFJldHVybiBpbWFnZVNyYyBpbnN0ZWFkIG9mIHN2Z0NvbnRlbnQgdG8gbWF0Y2ggaW50ZXJmYWNlXG4gICAgcmV0dXJuIHtcbiAgICAgIGltYWdlU3JjOiBzdmdDb250ZW50LFxuICAgICAgdmlld0JveCxcbiAgICAgIGNlbnRlcixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhcnJvdyBhdCBzb3BoaXN0aWNhdGVkIGNhbGN1bGF0ZWQgcG9zaXRpb24gdXNpbmcgcmVhbCBTVkcgYXNzZXRzXG4gICAqL1xuICBhc3luYyByZW5kZXJBcnJvd0F0UG9zaXRpb24oXG4gICAgc3ZnOiBTVkdFbGVtZW50LFxuICAgIGNvbG9yOiBNb3Rpb25Db2xvcixcbiAgICBwb3NpdGlvbjogQXJyb3dQb3NpdGlvbixcbiAgICBtb3Rpb25EYXRhOiBNb3Rpb25EYXRhIHwgdW5kZWZpbmVkXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgdGhlIGNvcnJlY3QgYXJyb3cgU1ZHIHBhdGhcbiAgICAgIGNvbnN0IGFycm93U3ZnUGF0aCA9IHRoaXMuZ2V0QXJyb3dTdmdQYXRoKG1vdGlvbkRhdGEpO1xuXG4gICAgICAvLyBMb2FkIHRoZSBhcnJvdyBTVkdcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYXJyb3dTdmdQYXRoKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBhcnJvdyBTVkc6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdmdDb250ZW50ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuXG4gICAgICAvLyBDcmVhdGUgYXJyb3cgZ3JvdXAgd2l0aCBtZXRhZGF0YVxuICAgICAgY29uc3QgYXJyb3dHcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcbiAgICAgICAgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgICAgICBcImdcIlxuICAgICAgKTtcbiAgICAgIGFycm93R3JvdXAuc2V0QXR0cmlidXRlKFxuICAgICAgICBcImNsYXNzXCIsXG4gICAgICAgIGBhcnJvdy0ke2NvbG9yfSBzb3BoaXN0aWNhdGVkLXBvc2l0aW9uaW5nYFxuICAgICAgKTtcbiAgICAgIGFycm93R3JvdXAuc2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiLCBjb2xvcik7XG4gICAgICBhcnJvd0dyb3VwLnNldEF0dHJpYnV0ZShcImRhdGEtcG9zaXRpb25cIiwgYCR7cG9zaXRpb24ueH0sJHtwb3NpdGlvbi55fWApO1xuICAgICAgYXJyb3dHcm91cC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJvdGF0aW9uXCIsIHBvc2l0aW9uLnJvdGF0aW9uLnRvU3RyaW5nKCkpO1xuXG4gICAgICAvLyBBcHBseSBzb3BoaXN0aWNhdGVkIHBvc2l0aW9uIGFuZCByb3RhdGlvbiB0cmFuc2Zvcm1cbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtwb3NpdGlvbi54fSwgJHtwb3NpdGlvbi55fSkgcm90YXRlKCR7cG9zaXRpb24ucm90YXRpb259KWA7XG4gICAgICBhcnJvd0dyb3VwLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pO1xuXG4gICAgICAvLyBQYXJzZSBhbmQgaW5zZXJ0IHRoZSBTVkcgY29udGVudFxuICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgY29uc3Qgc3ZnRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzdmdDb250ZW50LCBcImltYWdlL3N2Zyt4bWxcIik7XG4gICAgICBjb25zdCBzdmdFbGVtZW50ID0gc3ZnRG9jLmRvY3VtZW50RWxlbWVudCBhcyB1bmtub3duIGFzIFNWR0VsZW1lbnQ7XG5cbiAgICAgIC8vIEFwcGx5IGNvbG9yIHRyYW5zZm9ybWF0aW9uXG4gICAgICB0aGlzLmFwcGx5QXJyb3dDb2xvclRyYW5zZm9ybWF0aW9uKHN2Z0VsZW1lbnQsIGNvbG9yKTtcblxuICAgICAgLy8gSW1wb3J0IHRoZSBTVkcgY29udGVudCBpbnRvIHRoZSBhcnJvdyBncm91cFxuICAgICAgY29uc3QgaW1wb3J0ZWRTdmcgPSBkb2N1bWVudC5pbXBvcnROb2RlKHN2Z0VsZW1lbnQsIHRydWUpO1xuICAgICAgYXJyb3dHcm91cC5hcHBlbmRDaGlsZChpbXBvcnRlZFN2Zyk7XG5cbiAgICAgIHN2Zy5hcHBlbmRDaGlsZChhcnJvd0dyb3VwKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIGxvYWRpbmcgYXJyb3cgU1ZHIGZvciAke2NvbG9yfTpgLCBlcnJvcik7XG4gICAgICAvLyBGYWxsYmFjayB0byBzaW1wbGUgYXJyb3dcbiAgICAgIHRoaXMucmVuZGVyRmFsbGJhY2tBcnJvdyhzdmcsIGNvbG9yLCBwb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29ycmVjdCBhcnJvdyBTVkcgcGF0aCBiYXNlZCBvbiBtb3Rpb24gZGF0YSAobGlrZSBBcnJvd1N2Z01hbmFnZXIpXG4gICAqL1xuICBwcml2YXRlIGdldEFycm93U3ZnUGF0aChtb3Rpb25EYXRhOiBNb3Rpb25EYXRhIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgICBpZiAoIW1vdGlvbkRhdGEpIHtcbiAgICAgIHJldHVybiBcIi9pbWFnZXMvYXJyb3dzL3N0YXRpYy9mcm9tX3JhZGlhbC9zdGF0aWNfMC5zdmdcIjtcbiAgICB9XG4gICAgY29uc3QgbW90aW9uVHlwZSA9IG1vdGlvbkRhdGEubW90aW9uVHlwZTtcbiAgICBjb25zdCB0dXJuc1ZhbCA9IG1vdGlvbkRhdGEudHVybnM7XG4gICAgY29uc3Qgc3RhcnRPcmllbnRhdGlvbiA9IG1vdGlvbkRhdGEuc3RhcnRPcmllbnRhdGlvbjtcbiAgICBpZiAobW90aW9uVHlwZSA9PT0gXCJmbG9hdFwiKSByZXR1cm4gXCIvaW1hZ2VzL2Fycm93cy9mbG9hdC5zdmdcIjtcbiAgICBjb25zdCByYWRpYWxQYXRoID1cbiAgICAgIHN0YXJ0T3JpZW50YXRpb24gPT09IFwiaW5cIiA/IFwiZnJvbV9yYWRpYWxcIiA6IFwiZnJvbV9ub25yYWRpYWxcIjtcbiAgICBsZXQgdHVybnNTdHI6IHN0cmluZztcbiAgICBpZiAodHVybnNWYWwgPT09IFwiZmxcIikge1xuICAgICAgdHVybnNTdHIgPSBcImZsXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHVybnNWYWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHR1cm5zU3RyID0gdHVybnNWYWwgJSAxID09PSAwID8gYCR7dHVybnNWYWx9LjBgIDogdHVybnNWYWwudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHVybnNTdHIgPSBcIjAuMFwiO1xuICAgIH1cbiAgICByZXR1cm4gYC9pbWFnZXMvYXJyb3dzLyR7bW90aW9uVHlwZX0vJHtyYWRpYWxQYXRofS8ke21vdGlvblR5cGV9XyR7dHVybnNTdHJ9LnN2Z2A7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgY29sb3IgdHJhbnNmb3JtYXRpb24gdG8gYXJyb3cgU1ZHXG4gICAqL1xuICBwcml2YXRlIGFwcGx5QXJyb3dDb2xvclRyYW5zZm9ybWF0aW9uKFxuICAgIHN2Z0VsZW1lbnQ6IFNWR0VsZW1lbnQsXG4gICAgY29sb3I6IE1vdGlvbkNvbG9yXG4gICk6IHZvaWQge1xuICAgIC8vIEZpbmQgYWxsIHBhdGggZWxlbWVudHMgYW5kIGFwcGx5IGNvbG9yXG4gICAgY29uc3QgcGF0aHMgPSBzdmdFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJwYXRoXCIpO1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IGNvbG9yID09PSBNb3Rpb25Db2xvci5CTFVFID8gXCIjM2I4MmY2XCIgOiBcIiNlZjQ0NDRcIjtcbiAgICBjb25zdCBzdHJva2VDb2xvciA9IGNvbG9yID09PSBNb3Rpb25Db2xvci5CTFVFID8gXCIjMWQ0ZWQ4XCIgOiBcIiNkYzI2MjZcIjtcblxuICAgIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBmaWxsQ29sb3IpO1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgc3Ryb2tlQ29sb3IpO1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgXCIxXCIpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBmYWxsYmFjayBhcnJvdyBpZiBTVkcgbG9hZGluZyBmYWlsc1xuICAgKi9cbiAgcHJpdmF0ZSByZW5kZXJGYWxsYmFja0Fycm93KFxuICAgIHN2ZzogU1ZHRWxlbWVudCxcbiAgICBjb2xvcjogTW90aW9uQ29sb3IsXG4gICAgcG9zaXRpb246IEFycm93UG9zaXRpb25cbiAgKTogdm9pZCB7XG4gICAgLy8gQ3JlYXRlIGFycm93IGdyb3VwXG4gICAgY29uc3QgYXJyb3dHcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcbiAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgIFwiZ1wiXG4gICAgKTtcbiAgICBhcnJvd0dyb3VwLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGBhcnJvdy0ke2NvbG9yfSBmYWxsYmFja2ApO1xuICAgIGFycm93R3JvdXAuc2V0QXR0cmlidXRlKFxuICAgICAgXCJ0cmFuc2Zvcm1cIixcbiAgICAgIGB0cmFuc2xhdGUoJHtwb3NpdGlvbi54fSwgJHtwb3NpdGlvbi55fSkgcm90YXRlKCR7cG9zaXRpb24ucm90YXRpb259KWBcbiAgICApO1xuXG4gICAgLy8gQ3JlYXRlIHNpbXBsZSBhcnJvdyBwYXRoXG4gICAgY29uc3QgYXJyb3dQYXRoID0gdGhpcy5jcmVhdGVFbmhhbmNlZEFycm93UGF0aChjb2xvcik7XG4gICAgYXJyb3dHcm91cC5hcHBlbmRDaGlsZChhcnJvd1BhdGgpO1xuXG4gICAgc3ZnLmFwcGVuZENoaWxkKGFycm93R3JvdXApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBlbmhhbmNlZCBhcnJvdyBTVkcgcGF0aCB3aXRoIHNvcGhpc3RpY2F0ZWQgc3R5bGluZ1xuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVFbmhhbmNlZEFycm93UGF0aChjb2xvcjogTW90aW9uQ29sb3IpOiBTVkdFbGVtZW50IHtcbiAgICBjb25zdCBwYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJwYXRoXCIpO1xuXG4gICAgLy8gTW9yZSBzb3BoaXN0aWNhdGVkIGFycm93IHNoYXBlXG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIFwiTSAwLC0yNSBMIDE1LDAgTCAwLDI1IEwgLTgsMTUgTCAtOCwtMTUgWlwiKTtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgY29sb3IpO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwiIzAwMDAwMFwiKTtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBcIjJcIik7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJvcGFjaXR5XCIsIFwiMC45XCIpO1xuXG4gICAgLy8gQWRkIHNvcGhpc3RpY2F0ZWQgc3R5bGluZ1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwiZmlsdGVyXCIsIFwiZHJvcC1zaGFkb3coMXB4IDFweCAycHggcmdiYSgwLDAsMCwwLjMpKVwiKTtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwic29waGlzdGljYXRlZC1hcnJvd1wiKTtcblxuICAgIHJldHVybiBwYXRoO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0U3ZnQ29udGVudChzdmdUZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIEV4dHJhY3QgU1ZHIGNvbnRlbnQgKGV2ZXJ5dGhpbmcgaW5zaWRlIHRoZSA8c3ZnPiB0YWdzKVxuICAgIC8vIEFycm93cyBhcmUgYWxyZWFkeSBjb3JyZWN0bHkgc2l6ZWQgZm9yIDk1MHg5NTAgY29vcmRpbmF0ZSBzeXN0ZW1cblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYW4gZW1wdHkvc3RhdGljIFNWRyAoc2VsZi1jbG9zaW5nIG9yIHdpZHRoPVwiMFwiKVxuICAgIGlmIChcbiAgICAgIHN2Z1RleHQuaW5jbHVkZXMoJ3dpZHRoPVwiMFwiJykgfHxcbiAgICAgIChzdmdUZXh0LmluY2x1ZGVzKFwiPHN2Z1wiKSAmJiBzdmdUZXh0LmluY2x1ZGVzKFwiLz5cIikpXG4gICAgKSB7XG4gICAgICAvLyBTdGF0aWMgYXJyb3dzIGFyZSBpbnRlbnRpb25hbGx5IGVtcHR5IC0gcmV0dXJuIGVtcHR5IHN0cmluZ1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ZnQ29udGVudE1hdGNoID0gc3ZnVGV4dC5tYXRjaCgvPHN2Z1tePl0qPiguKik8XFwvc3ZnPi9zKTtcbiAgICBpZiAoIXN2Z0NvbnRlbnRNYXRjaCkge1xuICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGV4dHJhY3QgU1ZHIGNvbnRlbnQgZnJvbSBub24tc3RhdGljIGFycm93XCIpO1xuICAgICAgcmV0dXJuIHN2Z1RleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN2Z0NvbnRlbnRNYXRjaFsxXTtcbiAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIkFBY0EsU0FBUyxtQkFBbUI7QUFvQ3JCLGFBQU0sc0JBQXdEO0FBQUEsRUFDbkUsWUFBb0IsUUFBMkI7QUFBM0I7QUFBQSxFQUE0QjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS2hELGFBQWEsV0FBc0IsWUFBdUM7QUFDeEUsUUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZO0FBQzdCLGNBQVE7QUFBQSxRQUNOO0FBQUEsTUFDRjtBQUNBLGFBQU87QUFBQSxJQUNUO0FBRUEsVUFBTSxFQUFFLFlBQVksTUFBTSxJQUFJ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
