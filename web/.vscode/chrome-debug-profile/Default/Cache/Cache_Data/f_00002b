import { createPictographData } from "/src/lib/domain/PictographData.ts";
import {
  MotionType,
  Location,
  RotationDirection,
  GridPosition
} from "/src/lib/domain/enums.ts";
import { createMotionData } from "/src/lib/domain/MotionData.ts";
export class OptionDataService {
  pictographCache = null;
  loadingPromise = null;
  /**
   * Initialize the service - loads CSV data
   */
  async initialize() {
    try {
      if (!this.loadingPromise) {
        this.loadingPromise = this.loadPictographsFromCSV();
      }
      this.pictographCache = await this.loadingPromise;
    } catch (error) {
      console.error("❌ Failed to initialize OptionDataService:", error);
      throw error;
    }
  }
  /**
   * Get next options from end position - compatibility method with proper filtering
   */
  async getNextOptionsFromEndPosition(endPosition, _gridMode, _options) {
    try {
      if (!this.pictographCache) {
        await this.initialize();
      }
      const filteredOptions = this.filterByStartPosition(
        this.pictographCache || [],
        endPosition
      );
      return filteredOptions;
    } catch (error) {
      console.error("❌ Failed to get options from end position:", error);
      this.handleCSVLoadingError(error);
    }
  }
  /**
   * Get next options - loads real pictograph data from CSV files and filters by position
   */
  async getNextOptions(sequence) {
    try {
      if (!this.pictographCache) {
        if (!this.loadingPromise) {
          this.loadingPromise = this.loadPictographsFromCSV();
        }
        this.pictographCache = await this.loadingPromise;
      }
      if (sequence.length > 0) {
        const lastBeat = sequence[sequence.length - 1];
        const endPosition = this.extractEndPosition(lastBeat);
        if (endPosition) {
          const filteredOptions = this.filterByStartPosition(
            this.pictographCache,
            endPosition
          );
          return filteredOptions;
        }
      }
      return this.pictographCache;
    } catch (error) {
      console.error("❌ Failed to load pictographs:", error);
      this.handleCSVLoadingError(error);
    }
  }
  /**
   * Load pictographs from CSV files (real data)
   */
  async loadPictographsFromCSV() {
    try {
      const [diamondResponse, boxResponse] = await Promise.all([
        fetch("/DiamondPictographDataframe.csv"),
        fetch("/BoxPictographDataframe.csv")
      ]);
      if (!diamondResponse.ok || !boxResponse.ok) {
        throw new Error("Failed to load CSV files");
      }
      const [diamondCSV, boxCSV] = await Promise.all([
        diamondResponse.text(),
        boxResponse.text()
      ]);
      const diamondPictographs = this.parseCSVToPictographs(
        diamondCSV,
        "diamond"
      );
      const boxPictographs = this.parseCSVToPictographs(boxCSV, "box");
      const allPictographs = [...diamondPictographs, ...boxPictographs];
      return allPictographs;
    } catch (error) {
      console.error("❌ Failed to load CSV data:", error);
      throw error;
    }
  }
  /**
   * Parse CSV to PictographData objects
   */
  parseCSVToPictographs(csvText, gridMode) {
    const lines = csvText.trim().split("\n");
    if (lines.length < 2) return [];
    const headers = lines[0].split(",").map((h) => h.trim());
    const pictographs = [];
    for (let i = 1; i < lines.length; i++) {
      try {
        const values = lines[i].split(",").map((v) => v.trim());
        const row = {};
        headers.forEach((header, index) => {
          row[header] = values[index] || "";
        });
        const pictograph = this.createPictographFromCSVRow(row, gridMode);
        if (pictograph) {
          pictographs.push(pictograph);
        }
      } catch (error) {
        console.warn(`⚠️ Failed to parse CSV row ${i}:`, error);
      }
    }
    return pictographs;
  }
  /**
   * Create PictographData from CSV row
   */
  createPictographFromCSVRow(row, gridMode) {
    try {
      const letter = row.letter;
      if (!letter) {
        return null;
      }
      const blueMotion = createMotionData({
        motionType: this.mapMotionType(row.blueMotionType),
        rotationDirection: this.mapRotationDirection(row.blueRotationDirection),
        startLocation: this.mapLocation(row.blueStartLocation),
        endLocation: this.mapLocation(row.blueEndLocation),
        turns: 0,
        isVisible: true
      });
      const redMotion = createMotionData({
        motionType: this.mapMotionType(row.redMotionType),
        rotationDirection: this.mapRotationDirection(row.redRotationDirection),
        startLocation: this.mapLocation(row.redStartLocation),
        endLocation: this.mapLocation(row.redEndLocation),
        turns: 0,
        isVisible: true
      });
      return createPictographData({
        letter,
        motions: {
          blue: blueMotion,
          red: redMotion
        },
        startPosition: this.convertToGridPosition(row.startPosition),
        endPosition: this.convertToGridPosition(row.endPosition),
        gridMode,
        isBlank: false,
        metadata: {
          source: "csv",
          gridMode,
          originalRow: row
        }
      });
    } catch (error) {
      console.warn("⚠️ Failed to create pictograph from CSV row:", error);
      return null;
    }
  }
  /**
   * Calculate turns based on start/end locations and rotation direction
   * This replaces missing turn data in CSV files
   */
  calculateTurns(_startLocationStr, _endLocationStr, _rotationDirectionStr) {
    return 0;
  }
  /**
   * Extract end position from beat data
   */
  extractEndPosition(beat) {
    if (beat.metadata?.endPosition && typeof beat.metadata.endPosition === "string") {
      return beat.metadata.endPosition;
    }
    if (beat.pictographData?.metadata?.endPosition && typeof beat.pictographData.metadata.endPosition === "string") {
      return beat.pictographData.metadata.endPosition;
    }
    return null;
  }
  /**
   * Filter pictographs by start position - implements the core TKA algorithm:
   * if item.get("startPosition") == target_position: next_opts.append(item)
   */
  filterByStartPosition(pictographs, targetPosition) {
    const filtered = pictographs.filter((pictograph) => {
      const startPosition = pictograph.startPosition || pictograph.startPosition || pictograph.metadata?.startPosition || pictograph.metadata?.start_pos;
      return startPosition === targetPosition;
    });
    return filtered;
  }
  /**
   * Handle CSV loading errors by throwing descriptive errors instead of creating fallbacks
   */
  handleCSVLoadingError(error) {
    console.error("❌ CSV loading failed:", error);
    if (error instanceof Error) {
      throw new Error(
        `Failed to load pictograph data: ${error.message}. Please check that CSV files are available and properly formatted.`
      );
    } else {
      throw new Error(
        "Failed to load pictograph data: Unknown error occurred. Please check that CSV files are available and properly formatted."
      );
    }
  }
  /**
   * Filter options by letter types - exact port from legacy _filter_options_by_letter_type()
   */
  filterOptionsByLetterTypes(options, letterTypes) {
    if (!letterTypes || letterTypes.length === 0) {
      return options;
    }
    const letterTypeMap = {
      "Dual-Shift": [
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V"
      ],
      Shift: ["W", "X", "Y", "Z", "Σ", "Δ", "θ", "Ω"],
      "Cross-Shift": ["W-", "X-", "Y-", "Z-", "Σ-", "Δ-", "θ-", "Ω-"],
      Dash: ["Φ", "Ψ", "Λ"],
      "Dual-Dash": ["Φ-", "Ψ-", "Λ-"],
      Static: ["α", "β", "Γ"]
    };
    const selectedLetters = [];
    for (const letterType of letterTypes) {
      const letters = letterTypeMap[letterType];
      if (letters) {
        selectedLetters.push(...letters);
      }
    }
    const filteredOptions = options.filter(
      (option) => selectedLetters.includes(option.letter || "")
    );
    return filteredOptions.length > 0 ? filteredOptions : options;
  }
  /**
   * Filter options by rotation - exact port from legacy filter_options_by_rotation()
   */
  filterOptionsByRotation(options, blueRotationDirection, redRotationDirection) {
    const filtered = options.filter((option) => {
      const blueRot = option.motions?.blue?.rotationDirection || "noRotation";
      const redRot = option.motions?.red?.rotationDirection || "noRotation";
      const blueMatches = blueRot === blueRotationDirection || blueRot === "noRotation";
      const redMatches = redRot === redRotationDirection || redRot === "noRotation";
      return blueMatches && redMatches;
    });
    return filtered.length > 0 ? filtered : options;
  }
  /**
   * Get options summary for debugging
   */
  getOptionsSummary(options) {
    const summary = {
      total: options.length,
      byLetterType: {},
      byMotionType: {}
    };
    options.forEach((option) => {
      const letterType = this.getLetterType(option.letter || "");
      summary.byLetterType[letterType] = (summary.byLetterType[letterType] || 0) + 1;
      const blueMotion = option.motions?.blue?.motionType || "unknown";
      const redMotion = option.motions?.red?.motionType || "unknown";
      summary.byMotionType[blueMotion] = (summary.byMotionType[blueMotion] || 0) + 1;
      summary.byMotionType[redMotion] = (summary.byMotionType[redMotion] || 0) + 1;
    });
    return summary;
  }
  /**
   * Get letter type for a letter - exact mapping from legacy
   */
  getLetterType(letter) {
    const type1Letters = [
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V"
    ];
    const type2Letters = ["W", "X", "Y", "Z", "Σ", "Δ", "θ", "Ω"];
    const type3Letters = ["W-", "X-", "Y-", "Z-", "Σ-", "Δ-", "θ-", "Ω-"];
    const type4Letters = ["Φ", "Ψ", "Λ"];
    const type5Letters = ["Φ-", "Ψ-", "Λ-"];
    const type6Letters = ["α", "β", "Γ"];
    if (type1Letters.includes(letter)) return "Dual-Shift";
    if (type2Letters.includes(letter)) return "Shift";
    if (type3Letters.includes(letter)) return "Cross-Shift";
    if (type4Letters.includes(letter)) return "Dash";
    if (type5Letters.includes(letter)) return "Dual-Dash";
    if (type6Letters.includes(letter)) return "Static";
    return "Unknown";
  }
  /**
   * Clear cache (for testing or reloading)
   */
  clearCache() {
    this.pictographCache = null;
    this.loadingPromise = null;
  }
  /**
   * Map string motion types to enum values
   */
  mapMotionType(motionType) {
    if (!motionType) {
      return MotionType.STATIC;
    }
    switch (motionType.toLowerCase()) {
      case "pro":
        return MotionType.PRO;
      case "anti":
        return MotionType.ANTI;
      case "float":
        return MotionType.FLOAT;
      case "dash":
        return MotionType.DASH;
      case "static":
        return MotionType.STATIC;
      default:
        return MotionType.STATIC;
    }
  }
  /**
   * Map string rotation directions to enum values
   */
  mapRotationDirection(rotationDirection) {
    if (!rotationDirection) {
      return RotationDirection.NO_ROTATION;
    }
    switch (rotationDirection.toLowerCase()) {
      case "cw":
      case "clockwise":
        return RotationDirection.CLOCKWISE;
      case "ccw":
      case "counter_clockwise":
      case "counterclockwise":
        return RotationDirection.COUNTER_CLOCKWISE;
      case "noRotation":
        return RotationDirection.NO_ROTATION;
      default:
        return RotationDirection.NO_ROTATION;
    }
  }
  /**
   * Map string locations to enum values
   */
  mapLocation(location) {
    if (!location) {
      return Location.NORTH;
    }
    switch (location.toLowerCase()) {
      case "n":
        return Location.NORTH;
      case "e":
        return Location.EAST;
      case "s":
        return Location.SOUTH;
      case "w":
        return Location.WEST;
      case "ne":
        return Location.NORTHEAST;
      case "se":
        return Location.SOUTHEAST;
      case "sw":
        return Location.SOUTHWEST;
      case "nw":
        return Location.NORTHWEST;
      default:
        return Location.NORTH;
    }
  }
  /**
   * Convert string position to GridPosition enum
   */
  convertToGridPosition(positionString) {
    if (!positionString) return null;
    const lowerPosition = positionString.toLowerCase();
    const gridPositionValues = Object.values(GridPosition);
    for (const position of gridPositionValues) {
      if (position.toLowerCase() === lowerPosition) {
        return position;
      }
    }
    return null;
  }
  /**
   * Convert CSV row to PictographData - public method for other services
   */
  convertCsvRowToPictographData(row, _index) {
    return this.createPictographFromCSVRow(row, "diamond");
  }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIk9wdGlvbkRhdGFTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogT3B0aW9uIERhdGEgU2VydmljZSAtIEZpeGVkIGltcGxlbWVudGF0aW9uIHdpdGggcHJvcGVyIENTViBkYXRhIGxvYWRpbmdcbiAqXG4gKiBCcmlkZ2VzIGxlZ2FjeSBvcHRpb24gbG9hZGluZyBsb2dpYyB3aXRoIHdlYidzIGFjdHVhbCBwaWN0b2dyYXBoIGRhdGEgZnJvbSBDU1YgZmlsZXMuXG4gKiBObyBtb3JlIGZha2Ugc2VydmljZSByZXNvbHV0aW9uIC0gbG9hZHMgcmVhbCBkYXRhIGZyb20gc3RhdGljIGZpbGVzLlxuICovXG5cbmltcG9ydCB0eXBlIHsgUGljdG9ncmFwaERhdGEgfSBmcm9tIFwiJGxpYi9kb21haW4vUGljdG9ncmFwaERhdGFcIjtcbmltcG9ydCB0eXBlIHsgQmVhdERhdGEgfSBmcm9tIFwiJGxpYi9kb21haW4vQmVhdERhdGFcIjtcbmltcG9ydCB7IGNyZWF0ZVBpY3RvZ3JhcGhEYXRhIH0gZnJvbSBcIiRsaWIvZG9tYWluL1BpY3RvZ3JhcGhEYXRhXCI7XG5pbXBvcnQgdHlwZSB7IEdyaWRNb2RlIH0gZnJvbSBcIiRsaWIvZG9tYWluXCI7XG5pbXBvcnQge1xuICBNb3Rpb25UeXBlLFxuICBMb2NhdGlvbixcbiAgUm90YXRpb25EaXJlY3Rpb24sXG4gIEdyaWRQb3NpdGlvbixcbn0gZnJvbSBcIiRsaWIvZG9tYWluL2VudW1zXCI7XG5pbXBvcnQgeyBjcmVhdGVNb3Rpb25EYXRhIH0gZnJvbSBcIiRsaWIvZG9tYWluL01vdGlvbkRhdGFcIjtcblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25EYXRhU2VydmljZUludGVyZmFjZSB7XG4gIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPjtcbiAgZ2V0TmV4dE9wdGlvbnMoc2VxdWVuY2U6IEJlYXREYXRhW10pOiBQcm9taXNlPFBpY3RvZ3JhcGhEYXRhW10+O1xuICBnZXROZXh0T3B0aW9uc0Zyb21FbmRQb3NpdGlvbihcbiAgICBlbmRQb3NpdGlvbjogc3RyaW5nLFxuICAgIGdyaWRNb2RlOiBHcmlkTW9kZSxcbiAgICBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICApOiBQcm9taXNlPFBpY3RvZ3JhcGhEYXRhW10+O1xuICBmaWx0ZXJPcHRpb25zQnlMZXR0ZXJUeXBlcyhcbiAgICBvcHRpb25zOiBQaWN0b2dyYXBoRGF0YVtdLFxuICAgIGxldHRlclR5cGVzOiBzdHJpbmdbXVxuICApOiBQaWN0b2dyYXBoRGF0YVtdO1xuICBmaWx0ZXJPcHRpb25zQnlSb3RhdGlvbihcbiAgICBvcHRpb25zOiBQaWN0b2dyYXBoRGF0YVtdLFxuICAgIGJsdWVSb3RhdGlvbkRpcmVjdGlvbjogc3RyaW5nLFxuICAgIHJlZFJvdGF0aW9uRGlyZWN0aW9uOiBzdHJpbmdcbiAgKTogUGljdG9ncmFwaERhdGFbXTtcbn1cblxuZXhwb3J0IGNsYXNzIE9wdGlvbkRhdGFTZXJ2aWNlIGltcGxlbWVudHMgT3B0aW9uRGF0YVNlcnZpY2VJbnRlcmZhY2Uge1xuICBwcml2YXRlIHBpY3RvZ3JhcGhDYWNoZTogUGljdG9ncmFwaERhdGFbXSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGxvYWRpbmdQcm9taXNlOiBQcm9taXNlPFBpY3RvZ3JhcGhEYXRhW10+IHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHNlcnZpY2UgLSBsb2FkcyBDU1YgZGF0YVxuICAgKi9cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLmxvYWRpbmdQcm9taXNlKSB7XG4gICAgICAgIHRoaXMubG9hZGluZ1Byb21pc2UgPSB0aGlzLmxvYWRQaWN0b2dyYXBoc0Zyb21DU1YoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGljdG9ncmFwaENhY2hlID0gYXdhaXQgdGhpcy5sb2FkaW5nUHJvbWlzZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBPcHRpb25EYXRhU2VydmljZTpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBuZXh0IG9wdGlvbnMgZnJvbSBlbmQgcG9zaXRpb24gLSBjb21wYXRpYmlsaXR5IG1ldGhvZCB3aXRoIHByb3BlciBmaWx0ZXJpbmdcbiAgICovXG4gIGFzeW5jIGdldE5leHRPcHRpb25zRnJvbUVuZFBvc2l0aW9uKFxuICAgIGVuZFBvc2l0aW9uOiBzdHJpbmcsXG4gICAgX2dyaWRNb2RlOiBHcmlkTW9kZSxcbiAgICBfb3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgKTogUHJvbWlzZTxQaWN0b2dyYXBoRGF0YVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy5waWN0b2dyYXBoQ2FjaGUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpbHRlcmVkT3B0aW9ucyA9IHRoaXMuZmlsdGVyQnlTdGFydFBvc2l0aW9uKFxuICAgICAgICB0aGlzLnBpY3RvZ3JhcGhDYWNoZSB8fCBbXSxcbiAgICAgICAgZW5kUG9zaXRpb25cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBmaWx0ZXJlZE9wdGlvbnM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRmFpbGVkIHRvIGdldCBvcHRpb25zIGZyb20gZW5kIHBvc2l0aW9uOlwiLCBlcnJvcik7XG4gICAgICB0aGlzLmhhbmRsZUNTVkxvYWRpbmdFcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBuZXh0IG9wdGlvbnMgLSBsb2FkcyByZWFsIHBpY3RvZ3JhcGggZGF0YSBmcm9tIENTViBmaWxlcyBhbmQgZmlsdGVycyBieSBwb3NpdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0TmV4dE9wdGlvbnMoc2VxdWVuY2U6IEJlYXREYXRhW10pOiBQcm9taXNlPFBpY3RvZ3JhcGhEYXRhW10+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLnBpY3RvZ3JhcGhDYWNoZSkge1xuICAgICAgICBpZiAoIXRoaXMubG9hZGluZ1Byb21pc2UpIHtcbiAgICAgICAgICB0aGlzLmxvYWRpbmdQcm9taXNlID0gdGhpcy5sb2FkUGljdG9ncmFwaHNGcm9tQ1NWKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5waWN0b2dyYXBoQ2FjaGUgPSBhd2FpdCB0aGlzLmxvYWRpbmdQcm9taXNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VxdWVuY2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBsYXN0QmVhdCA9IHNlcXVlbmNlW3NlcXVlbmNlLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBlbmRQb3NpdGlvbiA9IHRoaXMuZXh0cmFjdEVuZFBvc2l0aW9uKGxhc3RCZWF0KTtcblxuICAgICAgICBpZiAoZW5kUG9zaXRpb24pIHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZE9wdGlvbnMgPSB0aGlzLmZpbHRlckJ5U3RhcnRQb3NpdGlvbihcbiAgICAgICAgICAgIHRoaXMucGljdG9ncmFwaENhY2hlLFxuICAgICAgICAgICAgZW5kUG9zaXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBmaWx0ZXJlZE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGljdG9ncmFwaENhY2hlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEZhaWxlZCB0byBsb2FkIHBpY3RvZ3JhcGhzOlwiLCBlcnJvcik7XG4gICAgICB0aGlzLmhhbmRsZUNTVkxvYWRpbmdFcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgcGljdG9ncmFwaHMgZnJvbSBDU1YgZmlsZXMgKHJlYWwgZGF0YSlcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgbG9hZFBpY3RvZ3JhcGhzRnJvbUNTVigpOiBQcm9taXNlPFBpY3RvZ3JhcGhEYXRhW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgW2RpYW1vbmRSZXNwb25zZSwgYm94UmVzcG9uc2VdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBmZXRjaChcIi9EaWFtb25kUGljdG9ncmFwaERhdGFmcmFtZS5jc3ZcIiksXG4gICAgICAgIGZldGNoKFwiL0JveFBpY3RvZ3JhcGhEYXRhZnJhbWUuY3N2XCIpLFxuICAgICAgXSk7XG5cbiAgICAgIGlmICghZGlhbW9uZFJlc3BvbnNlLm9rIHx8ICFib3hSZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBDU1YgZmlsZXNcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFtkaWFtb25kQ1NWLCBib3hDU1ZdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBkaWFtb25kUmVzcG9uc2UudGV4dCgpLFxuICAgICAgICBib3hSZXNwb25zZS50ZXh0KCksXG4gICAgICBdKTtcblxuICAgICAgY29uc3QgZGlhbW9uZFBpY3RvZ3JhcGhzID0gdGhpcy5wYXJzZUNTVlRvUGljdG9ncmFwaHMoXG4gICAgICAgIGRpYW1vbmRDU1YsXG4gICAgICAgIFwiZGlhbW9uZFwiXG4gICAgICApO1xuICAgICAgY29uc3QgYm94UGljdG9ncmFwaHMgPSB0aGlzLnBhcnNlQ1NWVG9QaWN0b2dyYXBocyhib3hDU1YsIFwiYm94XCIpO1xuXG4gICAgICBjb25zdCBhbGxQaWN0b2dyYXBocyA9IFsuLi5kaWFtb25kUGljdG9ncmFwaHMsIC4uLmJveFBpY3RvZ3JhcGhzXTtcblxuICAgICAgcmV0dXJuIGFsbFBpY3RvZ3JhcGhzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEZhaWxlZCB0byBsb2FkIENTViBkYXRhOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgQ1NWIHRvIFBpY3RvZ3JhcGhEYXRhIG9iamVjdHNcbiAgICovXG4gIHByaXZhdGUgcGFyc2VDU1ZUb1BpY3RvZ3JhcGhzKFxuICAgIGNzdlRleHQ6IHN0cmluZyxcbiAgICBncmlkTW9kZTogc3RyaW5nXG4gICk6IFBpY3RvZ3JhcGhEYXRhW10ge1xuICAgIGNvbnN0IGxpbmVzID0gY3N2VGV4dC50cmltKCkuc3BsaXQoXCJcXG5cIik7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA8IDIpIHJldHVybiBbXTtcblxuICAgIGNvbnN0IGhlYWRlcnMgPSBsaW5lc1swXS5zcGxpdChcIixcIikubWFwKChoKSA9PiBoLnRyaW0oKSk7XG4gICAgY29uc3QgcGljdG9ncmFwaHM6IFBpY3RvZ3JhcGhEYXRhW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGxpbmVzW2ldLnNwbGl0KFwiLFwiKS5tYXAoKHYpID0+IHYudHJpbSgpKTtcbiAgICAgICAgY29uc3Qgcm93OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgICAgICAgaGVhZGVycy5mb3JFYWNoKChoZWFkZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgcm93W2hlYWRlcl0gPSB2YWx1ZXNbaW5kZXhdIHx8IFwiXCI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHBpY3RvZ3JhcGggPSB0aGlzLmNyZWF0ZVBpY3RvZ3JhcGhGcm9tQ1NWUm93KHJvdywgZ3JpZE1vZGUpO1xuICAgICAgICBpZiAocGljdG9ncmFwaCkge1xuICAgICAgICAgIHBpY3RvZ3JhcGhzLnB1c2gocGljdG9ncmFwaCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIEZhaWxlZCB0byBwYXJzZSBDU1Ygcm93ICR7aX06YCwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwaWN0b2dyYXBocztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgUGljdG9ncmFwaERhdGEgZnJvbSBDU1Ygcm93XG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZVBpY3RvZ3JhcGhGcm9tQ1NWUm93KFxuICAgIHJvdzogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgICBncmlkTW9kZTogc3RyaW5nXG4gICk6IFBpY3RvZ3JhcGhEYXRhIHwgbnVsbCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGxldHRlciA9IHJvdy5sZXR0ZXI7XG4gICAgICBpZiAoIWxldHRlcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmx1ZU1vdGlvbiA9IGNyZWF0ZU1vdGlvbkRhdGEoe1xuICAgICAgICBtb3Rpb25UeXBlOiB0aGlzLm1hcE1vdGlvblR5cGUocm93LmJsdWVNb3Rpb25UeXBlKSxcbiAgICAgICAgcm90YXRpb25EaXJlY3Rpb246IHRoaXMubWFwUm90YXRpb25EaXJlY3Rpb24ocm93LmJsdWVSb3RhdGlvbkRpcmVjdGlvbiksXG4gICAgICAgIHN0YXJ0TG9jYXRpb246IHRoaXMubWFwTG9jYXRpb24ocm93LmJsdWVTdGFydExvY2F0aW9uKSxcbiAgICAgICAgZW5kTG9jYXRpb246IHRoaXMubWFwTG9jYXRpb24ocm93LmJsdWVFbmRMb2NhdGlvbiksXG4gICAgICAgIHR1cm5zOiAwLFxuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVkTW90aW9uID0gY3JlYXRlTW90aW9uRGF0YSh7XG4gICAgICAgIG1vdGlvblR5cGU6IHRoaXMubWFwTW90aW9uVHlwZShyb3cucmVkTW90aW9uVHlwZSksXG4gICAgICAgIHJvdGF0aW9uRGlyZWN0aW9uOiB0aGlzLm1hcFJvdGF0aW9uRGlyZWN0aW9uKHJvdy5yZWRSb3RhdGlvbkRpcmVjdGlvbiksXG4gICAgICAgIHN0YXJ0TG9jYXRpb246IHRoaXMubWFwTG9jYXRpb24ocm93LnJlZFN0YXJ0TG9jYXRpb24pLFxuICAgICAgICBlbmRMb2NhdGlvbjogdGhpcy5tYXBMb2NhdGlvbihyb3cucmVkRW5kTG9jYXRpb24pLFxuICAgICAgICB0dXJuczogMCxcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBjcmVhdGVQaWN0b2dyYXBoRGF0YSh7XG4gICAgICAgIGxldHRlcixcbiAgICAgICAgbW90aW9uczoge1xuICAgICAgICAgIGJsdWU6IGJsdWVNb3Rpb24sXG4gICAgICAgICAgcmVkOiByZWRNb3Rpb24sXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0UG9zaXRpb246IHRoaXMuY29udmVydFRvR3JpZFBvc2l0aW9uKHJvdy5zdGFydFBvc2l0aW9uKSxcbiAgICAgICAgZW5kUG9zaXRpb246IHRoaXMuY29udmVydFRvR3JpZFBvc2l0aW9uKHJvdy5lbmRQb3NpdGlvbiksXG4gICAgICAgIGdyaWRNb2RlOiBncmlkTW9kZSxcbiAgICAgICAgaXNCbGFuazogZmFsc2UsXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgc291cmNlOiBcImNzdlwiLFxuICAgICAgICAgIGdyaWRNb2RlLFxuICAgICAgICAgIG9yaWdpbmFsUm93OiByb3csXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIEZhaWxlZCB0byBjcmVhdGUgcGljdG9ncmFwaCBmcm9tIENTViByb3c6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdHVybnMgYmFzZWQgb24gc3RhcnQvZW5kIGxvY2F0aW9ucyBhbmQgcm90YXRpb24gZGlyZWN0aW9uXG4gICAqIFRoaXMgcmVwbGFjZXMgbWlzc2luZyB0dXJuIGRhdGEgaW4gQ1NWIGZpbGVzXG4gICAqL1xuICBwcml2YXRlIGNhbGN1bGF0ZVR1cm5zKFxuICAgIF9zdGFydExvY2F0aW9uU3RyOiBzdHJpbmcsXG4gICAgX2VuZExvY2F0aW9uU3RyOiBzdHJpbmcsXG4gICAgX3JvdGF0aW9uRGlyZWN0aW9uU3RyOiBzdHJpbmdcbiAgKTogbnVtYmVyIHtcbiAgICAvLyBJZiBubyByb3RhdGlvbiwgbm8gdHVybnNcblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgZW5kIHBvc2l0aW9uIGZyb20gYmVhdCBkYXRhXG4gICAqL1xuICBwcml2YXRlIGV4dHJhY3RFbmRQb3NpdGlvbihiZWF0OiBCZWF0RGF0YSk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmIChcbiAgICAgIGJlYXQubWV0YWRhdGE/LmVuZFBvc2l0aW9uICYmXG4gICAgICB0eXBlb2YgYmVhdC5tZXRhZGF0YS5lbmRQb3NpdGlvbiA9PT0gXCJzdHJpbmdcIlxuICAgICkge1xuICAgICAgcmV0dXJuIGJlYXQubWV0YWRhdGEuZW5kUG9zaXRpb247XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgYmVhdC5waWN0b2dyYXBoRGF0YT8ubWV0YWRhdGE/LmVuZFBvc2l0aW9uICYmXG4gICAgICB0eXBlb2YgYmVhdC5waWN0b2dyYXBoRGF0YS5tZXRhZGF0YS5lbmRQb3NpdGlvbiA9PT0gXCJzdHJpbmdcIlxuICAgICkge1xuICAgICAgcmV0dXJuIGJlYXQucGljdG9ncmFwaERhdGEubWV0YWRhdGEuZW5kUG9zaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRmlsdGVyIHBpY3RvZ3JhcGhzIGJ5IHN0YXJ0IHBvc2l0aW9uIC0gaW1wbGVtZW50cyB0aGUgY29yZSBUS0EgYWxnb3JpdGhtOlxuICAgKiBpZiBpdGVtLmdldChcInN0YXJ0UG9zaXRpb25cIikgPT0gdGFyZ2V0X3Bvc2l0aW9uOiBuZXh0X29wdHMuYXBwZW5kKGl0ZW0pXG4gICAqL1xuICBwcml2YXRlIGZpbHRlckJ5U3RhcnRQb3NpdGlvbihcbiAgICBwaWN0b2dyYXBoczogUGljdG9ncmFwaERhdGFbXSxcbiAgICB0YXJnZXRQb3NpdGlvbjogc3RyaW5nXG4gICk6IFBpY3RvZ3JhcGhEYXRhW10ge1xuICAgIGNvbnN0IGZpbHRlcmVkID0gcGljdG9ncmFwaHMuZmlsdGVyKChwaWN0b2dyYXBoKSA9PiB7XG4gICAgICBjb25zdCBzdGFydFBvc2l0aW9uID1cbiAgICAgICAgcGljdG9ncmFwaC5zdGFydFBvc2l0aW9uIHx8XG4gICAgICAgIHBpY3RvZ3JhcGguc3RhcnRQb3NpdGlvbiB8fFxuICAgICAgICBwaWN0b2dyYXBoLm1ldGFkYXRhPy5zdGFydFBvc2l0aW9uIHx8XG4gICAgICAgIHBpY3RvZ3JhcGgubWV0YWRhdGE/LnN0YXJ0X3BvcztcblxuICAgICAgcmV0dXJuIHN0YXJ0UG9zaXRpb24gPT09IHRhcmdldFBvc2l0aW9uO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpbHRlcmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBDU1YgbG9hZGluZyBlcnJvcnMgYnkgdGhyb3dpbmcgZGVzY3JpcHRpdmUgZXJyb3JzIGluc3RlYWQgb2YgY3JlYXRpbmcgZmFsbGJhY2tzXG4gICAqL1xuICBwcml2YXRlIGhhbmRsZUNTVkxvYWRpbmdFcnJvcihlcnJvcjogdW5rbm93bik6IG5ldmVyIHtcbiAgICBjb25zb2xlLmVycm9yKFwi4p2MIENTViBsb2FkaW5nIGZhaWxlZDpcIiwgZXJyb3IpO1xuXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBsb2FkIHBpY3RvZ3JhcGggZGF0YTogJHtlcnJvci5tZXNzYWdlfS4gUGxlYXNlIGNoZWNrIHRoYXQgQ1NWIGZpbGVzIGFyZSBhdmFpbGFibGUgYW5kIHByb3Blcmx5IGZvcm1hdHRlZC5gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRmFpbGVkIHRvIGxvYWQgcGljdG9ncmFwaCBkYXRhOiBVbmtub3duIGVycm9yIG9jY3VycmVkLiBQbGVhc2UgY2hlY2sgdGhhdCBDU1YgZmlsZXMgYXJlIGF2YWlsYWJsZSBhbmQgcHJvcGVybHkgZm9ybWF0dGVkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaWx0ZXIgb3B0aW9ucyBieSBsZXR0ZXIgdHlwZXMgLSBleGFjdCBwb3J0IGZyb20gbGVnYWN5IF9maWx0ZXJfb3B0aW9uc19ieV9sZXR0ZXJfdHlwZSgpXG4gICAqL1xuICBmaWx0ZXJPcHRpb25zQnlMZXR0ZXJUeXBlcyhcbiAgICBvcHRpb25zOiBQaWN0b2dyYXBoRGF0YVtdLFxuICAgIGxldHRlclR5cGVzOiBzdHJpbmdbXVxuICApOiBQaWN0b2dyYXBoRGF0YVtdIHtcbiAgICBpZiAoIWxldHRlclR5cGVzIHx8IGxldHRlclR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgY29uc3QgbGV0dGVyVHlwZU1hcDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmdbXSB9ID0ge1xuICAgICAgXCJEdWFsLVNoaWZ0XCI6IFtcbiAgICAgICAgXCJBXCIsXG4gICAgICAgIFwiQlwiLFxuICAgICAgICBcIkNcIixcbiAgICAgICAgXCJEXCIsXG4gICAgICAgIFwiRVwiLFxuICAgICAgICBcIkZcIixcbiAgICAgICAgXCJHXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcIklcIixcbiAgICAgICAgXCJKXCIsXG4gICAgICAgIFwiS1wiLFxuICAgICAgICBcIkxcIixcbiAgICAgICAgXCJNXCIsXG4gICAgICAgIFwiTlwiLFxuICAgICAgICBcIk9cIixcbiAgICAgICAgXCJQXCIsXG4gICAgICAgIFwiUVwiLFxuICAgICAgICBcIlJcIixcbiAgICAgICAgXCJTXCIsXG4gICAgICAgIFwiVFwiLFxuICAgICAgICBcIlVcIixcbiAgICAgICAgXCJWXCIsXG4gICAgICBdLFxuICAgICAgU2hpZnQ6IFtcIldcIiwgXCJYXCIsIFwiWVwiLCBcIlpcIiwgXCLOo1wiLCBcIs6UXCIsIFwizrhcIiwgXCLOqVwiXSxcbiAgICAgIFwiQ3Jvc3MtU2hpZnRcIjogW1wiVy1cIiwgXCJYLVwiLCBcIlktXCIsIFwiWi1cIiwgXCLOoy1cIiwgXCLOlC1cIiwgXCLOuC1cIiwgXCLOqS1cIl0sXG4gICAgICBEYXNoOiBbXCLOplwiLCBcIs6oXCIsIFwizptcIl0sXG4gICAgICBcIkR1YWwtRGFzaFwiOiBbXCLOpi1cIiwgXCLOqC1cIiwgXCLOmy1cIl0sXG4gICAgICBTdGF0aWM6IFtcIs6xXCIsIFwizrJcIiwgXCLOk1wiXSxcbiAgICB9O1xuXG4gICAgY29uc3Qgc2VsZWN0ZWRMZXR0ZXJzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgbGV0dGVyVHlwZSBvZiBsZXR0ZXJUeXBlcykge1xuICAgICAgY29uc3QgbGV0dGVycyA9IGxldHRlclR5cGVNYXBbbGV0dGVyVHlwZV07XG4gICAgICBpZiAobGV0dGVycykge1xuICAgICAgICBzZWxlY3RlZExldHRlcnMucHVzaCguLi5sZXR0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJlZE9wdGlvbnMgPSBvcHRpb25zLmZpbHRlcigob3B0aW9uKSA9PlxuICAgICAgc2VsZWN0ZWRMZXR0ZXJzLmluY2x1ZGVzKG9wdGlvbi5sZXR0ZXIgfHwgXCJcIilcbiAgICApO1xuXG4gICAgcmV0dXJuIGZpbHRlcmVkT3B0aW9ucy5sZW5ndGggPiAwID8gZmlsdGVyZWRPcHRpb25zIDogb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBGaWx0ZXIgb3B0aW9ucyBieSByb3RhdGlvbiAtIGV4YWN0IHBvcnQgZnJvbSBsZWdhY3kgZmlsdGVyX29wdGlvbnNfYnlfcm90YXRpb24oKVxuICAgKi9cbiAgZmlsdGVyT3B0aW9uc0J5Um90YXRpb24oXG4gICAgb3B0aW9uczogUGljdG9ncmFwaERhdGFbXSxcbiAgICBibHVlUm90YXRpb25EaXJlY3Rpb246IHN0cmluZyxcbiAgICByZWRSb3RhdGlvbkRpcmVjdGlvbjogc3RyaW5nXG4gICk6IFBpY3RvZ3JhcGhEYXRhW10ge1xuICAgIGNvbnN0IGZpbHRlcmVkID0gb3B0aW9ucy5maWx0ZXIoKG9wdGlvbikgPT4ge1xuICAgICAgY29uc3QgYmx1ZVJvdCA9IG9wdGlvbi5tb3Rpb25zPy5ibHVlPy5yb3RhdGlvbkRpcmVjdGlvbiB8fCBcIm5vUm90YXRpb25cIjtcbiAgICAgIGNvbnN0IHJlZFJvdCA9IG9wdGlvbi5tb3Rpb25zPy5yZWQ/LnJvdGF0aW9uRGlyZWN0aW9uIHx8IFwibm9Sb3RhdGlvblwiO1xuXG4gICAgICBjb25zdCBibHVlTWF0Y2hlcyA9XG4gICAgICAgIGJsdWVSb3QgPT09IGJsdWVSb3RhdGlvbkRpcmVjdGlvbiB8fCBibHVlUm90ID09PSBcIm5vUm90YXRpb25cIjtcbiAgICAgIGNvbnN0IHJlZE1hdGNoZXMgPVxuICAgICAgICByZWRSb3QgPT09IHJlZFJvdGF0aW9uRGlyZWN0aW9uIHx8IHJlZFJvdCA9PT0gXCJub1JvdGF0aW9uXCI7XG5cbiAgICAgIHJldHVybiBibHVlTWF0Y2hlcyAmJiByZWRNYXRjaGVzO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpbHRlcmVkLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZCA6IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG9wdGlvbnMgc3VtbWFyeSBmb3IgZGVidWdnaW5nXG4gICAqL1xuICBnZXRPcHRpb25zU3VtbWFyeShvcHRpb25zOiBQaWN0b2dyYXBoRGF0YVtdKToge1xuICAgIHRvdGFsOiBudW1iZXI7XG4gICAgYnlMZXR0ZXJUeXBlOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuICAgIGJ5TW90aW9uVHlwZTogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgfSB7XG4gICAgY29uc3Qgc3VtbWFyeSA9IHtcbiAgICAgIHRvdGFsOiBvcHRpb25zLmxlbmd0aCxcbiAgICAgIGJ5TGV0dGVyVHlwZToge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgICAgIGJ5TW90aW9uVHlwZToge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgICB9O1xuXG4gICAgb3B0aW9ucy5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICAgIGNvbnN0IGxldHRlclR5cGUgPSB0aGlzLmdldExldHRlclR5cGUob3B0aW9uLmxldHRlciB8fCBcIlwiKTtcbiAgICAgIHN1bW1hcnkuYnlMZXR0ZXJUeXBlW2xldHRlclR5cGVdID1cbiAgICAgICAgKHN1bW1hcnkuYnlMZXR0ZXJUeXBlW2xldHRlclR5cGVdIHx8IDApICsgMTtcblxuICAgICAgY29uc3QgYmx1ZU1vdGlvbiA9IG9wdGlvbi5tb3Rpb25zPy5ibHVlPy5tb3Rpb25UeXBlIHx8IFwidW5rbm93blwiO1xuICAgICAgY29uc3QgcmVkTW90aW9uID0gb3B0aW9uLm1vdGlvbnM/LnJlZD8ubW90aW9uVHlwZSB8fCBcInVua25vd25cIjtcbiAgICAgIHN1bW1hcnkuYnlNb3Rpb25UeXBlW2JsdWVNb3Rpb25dID1cbiAgICAgICAgKHN1bW1hcnkuYnlNb3Rpb25UeXBlW2JsdWVNb3Rpb25dIHx8IDApICsgMTtcbiAgICAgIHN1bW1hcnkuYnlNb3Rpb25UeXBlW3JlZE1vdGlvbl0gPVxuICAgICAgICAoc3VtbWFyeS5ieU1vdGlvblR5cGVbcmVkTW90aW9uXSB8fCAwKSArIDE7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3VtbWFyeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbGV0dGVyIHR5cGUgZm9yIGEgbGV0dGVyIC0gZXhhY3QgbWFwcGluZyBmcm9tIGxlZ2FjeVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRMZXR0ZXJUeXBlKGxldHRlcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCB0eXBlMUxldHRlcnMgPSBbXG4gICAgICBcIkFcIixcbiAgICAgIFwiQlwiLFxuICAgICAgXCJDXCIsXG4gICAgICBcIkRcIixcbiAgICAgIFwiRVwiLFxuICAgICAgXCJGXCIsXG4gICAgICBcIkdcIixcbiAgICAgIFwiSFwiLFxuICAgICAgXCJJXCIsXG4gICAgICBcIkpcIixcbiAgICAgIFwiS1wiLFxuICAgICAgXCJMXCIsXG4gICAgICBcIk1cIixcbiAgICAgIFwiTlwiLFxuICAgICAgXCJPXCIsXG4gICAgICBcIlBcIixcbiAgICAgIFwiUVwiLFxuICAgICAgXCJSXCIsXG4gICAgICBcIlNcIixcbiAgICAgIFwiVFwiLFxuICAgICAgXCJVXCIsXG4gICAgICBcIlZcIixcbiAgICBdO1xuICAgIGNvbnN0IHR5cGUyTGV0dGVycyA9IFtcIldcIiwgXCJYXCIsIFwiWVwiLCBcIlpcIiwgXCLOo1wiLCBcIs6UXCIsIFwizrhcIiwgXCLOqVwiXTtcbiAgICBjb25zdCB0eXBlM0xldHRlcnMgPSBbXCJXLVwiLCBcIlgtXCIsIFwiWS1cIiwgXCJaLVwiLCBcIs6jLVwiLCBcIs6ULVwiLCBcIs64LVwiLCBcIs6pLVwiXTtcbiAgICBjb25zdCB0eXBlNExldHRlcnMgPSBbXCLOplwiLCBcIs6oXCIsIFwizptcIl07XG4gICAgY29uc3QgdHlwZTVMZXR0ZXJzID0gW1wizqYtXCIsIFwizqgtXCIsIFwizpstXCJdO1xuICAgIGNvbnN0IHR5cGU2TGV0dGVycyA9IFtcIs6xXCIsIFwizrJcIiwgXCLOk1wiXTtcblxuICAgIGlmICh0eXBlMUxldHRlcnMuaW5jbHVkZXMobGV0dGVyKSkgcmV0dXJuIFwiRHVhbC1TaGlmdFwiO1xuICAgIGlmICh0eXBlMkxldHRlcnMuaW5jbHVkZXMobGV0dGVyKSkgcmV0dXJuIFwiU2hpZnRcIjtcbiAgICBpZiAodHlwZTNMZXR0ZXJzLmluY2x1ZGVzKGxldHRlcikpIHJldHVybiBcIkNyb3NzLVNoaWZ0XCI7XG4gICAgaWYgKHR5cGU0TGV0dGVycy5pbmNsdWRlcyhsZXR0ZXIpKSByZXR1cm4gXCJEYXNoXCI7XG4gICAgaWYgKHR5cGU1TGV0dGVycy5pbmNsdWRlcyhsZXR0ZXIpKSByZXR1cm4gXCJEdWFsLURhc2hcIjtcbiAgICBpZiAodHlwZTZMZXR0ZXJzLmluY2x1ZGVzKGxldHRlcikpIHJldHVybiBcIlN0YXRpY1wiO1xuXG4gICAgcmV0dXJuIFwiVW5rbm93blwiO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGNhY2hlIChmb3IgdGVzdGluZyBvciByZWxvYWRpbmcpXG4gICAqL1xuICBjbGVhckNhY2hlKCk6IHZvaWQge1xuICAgIHRoaXMucGljdG9ncmFwaENhY2hlID0gbnVsbDtcbiAgICB0aGlzLmxvYWRpbmdQcm9taXNlID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXAgc3RyaW5nIG1vdGlvbiB0eXBlcyB0byBlbnVtIHZhbHVlc1xuICAgKi9cbiAgcHJpdmF0ZSBtYXBNb3Rpb25UeXBlKG1vdGlvblR5cGU6IHN0cmluZyk6IE1vdGlvblR5cGUge1xuICAgIGlmICghbW90aW9uVHlwZSkge1xuICAgICAgcmV0dXJuIE1vdGlvblR5cGUuU1RBVElDOyAvLyBEZWZhdWx0IG1vdGlvbiB0eXBlXG4gICAgfVxuICAgIHN3aXRjaCAobW90aW9uVHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlIFwicHJvXCI6XG4gICAgICAgIHJldHVybiBNb3Rpb25UeXBlLlBSTztcbiAgICAgIGNhc2UgXCJhbnRpXCI6XG4gICAgICAgIHJldHVybiBNb3Rpb25UeXBlLkFOVEk7XG4gICAgICBjYXNlIFwiZmxvYXRcIjpcbiAgICAgICAgcmV0dXJuIE1vdGlvblR5cGUuRkxPQVQ7XG4gICAgICBjYXNlIFwiZGFzaFwiOlxuICAgICAgICByZXR1cm4gTW90aW9uVHlwZS5EQVNIO1xuICAgICAgY2FzZSBcInN0YXRpY1wiOlxuICAgICAgICByZXR1cm4gTW90aW9uVHlwZS5TVEFUSUM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gTW90aW9uVHlwZS5TVEFUSUM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hcCBzdHJpbmcgcm90YXRpb24gZGlyZWN0aW9ucyB0byBlbnVtIHZhbHVlc1xuICAgKi9cbiAgcHJpdmF0ZSBtYXBSb3RhdGlvbkRpcmVjdGlvbihyb3RhdGlvbkRpcmVjdGlvbjogc3RyaW5nKTogUm90YXRpb25EaXJlY3Rpb24ge1xuICAgIGlmICghcm90YXRpb25EaXJlY3Rpb24pIHtcbiAgICAgIHJldHVybiBSb3RhdGlvbkRpcmVjdGlvbi5OT19ST1RBVElPTjsgLy8gRGVmYXVsdCByb3RhdGlvbiBkaXJlY3Rpb25cbiAgICB9XG4gICAgc3dpdGNoIChyb3RhdGlvbkRpcmVjdGlvbi50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlIFwiY3dcIjpcbiAgICAgIGNhc2UgXCJjbG9ja3dpc2VcIjpcbiAgICAgICAgcmV0dXJuIFJvdGF0aW9uRGlyZWN0aW9uLkNMT0NLV0lTRTtcbiAgICAgIGNhc2UgXCJjY3dcIjpcbiAgICAgIGNhc2UgXCJjb3VudGVyX2Nsb2Nrd2lzZVwiOlxuICAgICAgY2FzZSBcImNvdW50ZXJjbG9ja3dpc2VcIjpcbiAgICAgICAgcmV0dXJuIFJvdGF0aW9uRGlyZWN0aW9uLkNPVU5URVJfQ0xPQ0tXSVNFO1xuICAgICAgY2FzZSBcIm5vUm90YXRpb25cIjpcbiAgICAgICAgcmV0dXJuIFJvdGF0aW9uRGlyZWN0aW9uLk5PX1JPVEFUSU9OO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFJvdGF0aW9uRGlyZWN0aW9uLk5PX1JPVEFUSU9OO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYXAgc3RyaW5nIGxvY2F0aW9ucyB0byBlbnVtIHZhbHVlc1xuICAgKi9cbiAgcHJpdmF0ZSBtYXBMb2NhdGlvbihsb2NhdGlvbjogc3RyaW5nKTogTG9jYXRpb24ge1xuICAgIGlmICghbG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBMb2NhdGlvbi5OT1JUSDsgLy8gRGVmYXVsdCBsb2NhdGlvblxuICAgIH1cbiAgICBzd2l0Y2ggKGxvY2F0aW9uLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJuXCI6XG4gICAgICAgIHJldHVybiBMb2NhdGlvbi5OT1JUSDtcbiAgICAgIGNhc2UgXCJlXCI6XG4gICAgICAgIHJldHVybiBMb2NhdGlvbi5FQVNUO1xuICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgcmV0dXJuIExvY2F0aW9uLlNPVVRIO1xuICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgcmV0dXJuIExvY2F0aW9uLldFU1Q7XG4gICAgICBjYXNlIFwibmVcIjpcbiAgICAgICAgcmV0dXJuIExvY2F0aW9uLk5PUlRIRUFTVDtcbiAgICAgIGNhc2UgXCJzZVwiOlxuICAgICAgICByZXR1cm4gTG9jYXRpb24uU09VVEhFQVNUO1xuICAgICAgY2FzZSBcInN3XCI6XG4gICAgICAgIHJldHVybiBMb2NhdGlvbi5TT1VUSFdFU1Q7XG4gICAgICBjYXNlIFwibndcIjpcbiAgICAgICAgcmV0dXJuIExvY2F0aW9uLk5PUlRIV0VTVDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBMb2NhdGlvbi5OT1JUSDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBzdHJpbmcgcG9zaXRpb24gdG8gR3JpZFBvc2l0aW9uIGVudW1cbiAgICovXG4gIHByaXZhdGUgY29udmVydFRvR3JpZFBvc2l0aW9uKFxuICAgIHBvc2l0aW9uU3RyaW5nOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkXG4gICk6IEdyaWRQb3NpdGlvbiB8IG51bGwge1xuICAgIGlmICghcG9zaXRpb25TdHJpbmcpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgbG93ZXJQb3NpdGlvbiA9IHBvc2l0aW9uU3RyaW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgZ3JpZFBvc2l0aW9uVmFsdWVzID0gT2JqZWN0LnZhbHVlcyhHcmlkUG9zaXRpb24pO1xuXG4gICAgZm9yIChjb25zdCBwb3NpdGlvbiBvZiBncmlkUG9zaXRpb25WYWx1ZXMpIHtcbiAgICAgIGlmIChwb3NpdGlvbi50b0xvd2VyQ2FzZSgpID09PSBsb3dlclBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbiBhcyBHcmlkUG9zaXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBDU1Ygcm93IHRvIFBpY3RvZ3JhcGhEYXRhIC0gcHVibGljIG1ldGhvZCBmb3Igb3RoZXIgc2VydmljZXNcbiAgICovXG4gIGNvbnZlcnRDc3ZSb3dUb1BpY3RvZ3JhcGhEYXRhKFxuICAgIHJvdzogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgICBfaW5kZXg6IG51bWJlclxuICApOiBQaWN0b2dyYXBoRGF0YSB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVBpY3RvZ3JhcGhGcm9tQ1NWUm93KHJvdywgXCJkaWFtb25kXCIpO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQVNBLFNBQVMsNEJBQTRCO0FBRXJDO0FBQUEsRUFDRTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLE9BQ0s7QUFDUCxTQUFTLHdCQUF3QjtBQXFCMUIsYUFBTSxrQkFBd0Q7QUFBQSxFQUMzRCxrQkFBMkM7QUFBQSxFQUMzQyxpQkFBbUQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUszRCxNQUFNLGFBQTRCO0FBQ2hDLFFBQUk7QUFDRixVQUFJLENBQUMsS0FBSyxnQkFBZ0I7QUFDeEIsYUFBSyxpQkFBaUIsS0FBSyx1QkFBdUI7QUFBQSxNQUNwRDtBQUNBLFdBQUssa0JBQWtCLE1BQU0sS0FBSztBQUFBLElBQ3BDLFNBQVMsT0FBTztBQUNkLGNBQVEsTUFBTSw2Q0FBNkMsS0FBSztBQUNoRSxZQUFNO0FBQUEsSUFDUjtBQUFBLEVBQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLE1BQU0sOEJBQ0osYUFDQSxXQUNBLFVBQzJCO0FBQzNCLFFBQUk7QUFDRixVQUFJLENBQUMsS0FBSyxpQkFBaUI7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