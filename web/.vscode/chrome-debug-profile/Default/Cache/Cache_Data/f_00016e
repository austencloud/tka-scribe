/* optionPickerRunes.svelte.ts generated by Svelte v5.38.1 */
import * as $ from "/node_modules/.vite/deps/svelte_internal_client.js?v=de368f3a";
import { resolve } from "/src/lib/services/bootstrap.ts";
import { createBeatData } from "/src/lib/domain/BeatData.ts";
import { determineGroupKey, getSortedGroupKeys, getSorter } from "/src/lib/components/construct/option-picker/services/OptionsService.ts";

function getStoredState() {
	if ($.strict_equals(typeof window, "undefined")) return {
		sortMethod: "type",
		isLoading: false,
		error: null,
		lastSelectedTab: {}
	};

	try {
		const stored = localStorage.getItem("optionPickerUIState");

		if (!stored) return {
			sortMethod: "type",
			isLoading: false,
			error: null,
			lastSelectedTab: { type: "all" }
		};

		const parsed = JSON.parse(stored);

		return {
			sortMethod: parsed.sortMethod || "type",
			isLoading: false,
			error: null,
			lastSelectedTab: parsed.lastSelectedTab || { type: "all" }
		};
	} catch(e) {
		console.error(...$.log_if_contains_state('error', "Error reading from localStorage:", e));

		return {
			sortMethod: "type",
			isLoading: false,
			error: null,
			lastSelectedTab: { type: "all" }
		};
	}
}

export function createOptionPickerRunes() {
	let sequenceData = $.tag($.state($.proxy([])), 'sequenceData');
	let optionsData = $.tag($.state($.proxy([])), 'optionsData');
	let selectedPictograph = $.tag($.state(null), 'selectedPictograph');
	const storedState = getStoredState();

	let uiState = $.tag(
		$.state($.proxy({
			sortMethod: storedState.sortMethod,
			isLoading: storedState.isLoading,
			error: storedState.error,
			lastSelectedTab: storedState.lastSelectedTab
		})),
		'uiState'
	);

	const filteredOptions = $.tag(
		$.derived(() => () => {
			const options = [...$.get(optionsData)];

			options.sort(getSorter($.get(uiState).sortMethod, $.get(sequenceData)));

			return options;
		}),
		'filteredOptions'
	);

	let cachedGroupedOptions = $.tag($.state($.proxy({})), 'cachedGroupedOptions');

	function computeGroupedOptions() {
		const groups = {};
		const options = $.get(filteredOptions)();

		options.forEach((option) => {
			const groupKey = determineGroupKey(option, $.get(uiState).sortMethod, $.get(sequenceData));

			if (!groups[groupKey]) groups[groupKey] = [];

			groups[groupKey].push(option);
		});

		const sortedKeys = getSortedGroupKeys(Object.keys(groups), $.get(uiState).sortMethod);
		const sortedGroups = {};

		sortedKeys.forEach((key) => {
			if (groups[key]) {
				sortedGroups[key] = groups[key];
			}
		});

		$.set(cachedGroupedOptions, sortedGroups, true);

		return sortedGroups;
	}

	const categoryKeys = $.tag($.derived(() => () => Object.keys($.get(cachedGroupedOptions))), 'categoryKeys');

	async function loadOptions(sequence) {
		$.set(sequenceData, sequence, true);

		try {
			const preloadedData = localStorage.getItem("preloaded_options");

			if (preloadedData) {
				const preloadedOptions = JSON.parse(preloadedData);

				$.set(optionsData, preloadedOptions || [], true);
				$.get(uiState).isLoading = false;
				$.get(uiState).error = null;
				localStorage.removeItem("preloaded_options");

				if (!$.get(uiState).lastSelectedTab[$.get(uiState).sortMethod] || $.strict_equals($.get(uiState).lastSelectedTab[$.get(uiState).sortMethod], null)) {
					setLastSelectedTabForSort($.get(uiState).sortMethod, "all");
				}

				return;
			}

			const allPreloadedData = localStorage.getItem("all_preloaded_options");

			if (allPreloadedData) {
				const allPreloadedOptions = JSON.parse(allPreloadedData);
				let targetEndPosition = null;

				if (sequence && sequence.length > 0) {
					const lastBeat = sequence[sequence.length - 1];
					const endPosition = lastBeat?.endPosition || lastBeat?.metadata?.endPosition;

					targetEndPosition = $.strict_equals(typeof endPosition, "string") ? endPosition : null;
				} else {
					const startPositionData = localStorage.getItem("startPosition");

					if (startPositionData) {
						const startPosition = JSON.parse(startPositionData);

						targetEndPosition = startPosition.endPosition || null;
					}
				}

				if (targetEndPosition && allPreloadedOptions[targetEndPosition]) {
					const optionsForPosition = allPreloadedOptions[targetEndPosition];

					$.set(optionsData, optionsForPosition || [], true);
					$.get(uiState).isLoading = false;
					$.get(uiState).error = null;

					if (!$.get(uiState).lastSelectedTab[$.get(uiState).sortMethod] || $.strict_equals($.get(uiState).lastSelectedTab[$.get(uiState).sortMethod], null)) {
						setLastSelectedTabForSort($.get(uiState).sortMethod, "all");
					}

					return;
				}
			}
		} catch(error) {
			console.warn(...$.log_if_contains_state('warn', "Failed to load preloaded options, falling back to normal loading:", error));
		}

		$.get(uiState).isLoading = true;
		$.get(uiState).error = null;

		try {
			let nextOptions = [];

			if (sequence && sequence.length > 0) {
				const lastBeat = sequence[sequence.length - 1];
				const endPosition = lastBeat?.endPosition || lastBeat?.metadata?.endPosition;

				if (endPosition && $.strict_equals(typeof endPosition, "string")) {
					const optionDataService = resolve("IOptionDataService");
					const minimalSequence = [createBeatData({ beatNumber: 1, metadata: { endPosition } })];

					nextOptions = (await $.track_reactivity_loss(optionDataService.getNextOptions(minimalSequence)))();
				} else {
					console.warn("No end position found in sequence");
				}
			} else {
				const startPositionData = localStorage.getItem("startPosition");

				if (startPositionData) {
					const startPosition = JSON.parse(startPositionData);
					const endPosition = $.strict_equals(typeof startPosition.endPosition, "string") ? startPosition.endPosition : null;

					if (endPosition) {
						const optionDataService = resolve("IOptionDataService");
						const minimalSequence = [createBeatData({ beatNumber: 1, metadata: { endPosition } })];

						nextOptions = (await $.track_reactivity_loss(optionDataService.getNextOptions(minimalSequence)))();
					}
				}
			}

			if (!nextOptions || $.strict_equals(nextOptions.length, 0)) {
				console.warn("No options available for the current sequence");
			}

			$.set(optionsData, nextOptions || [], true);
			$.get(uiState).isLoading = false;

			if (!$.get(uiState).lastSelectedTab[$.get(uiState).sortMethod] || $.strict_equals($.get(uiState).lastSelectedTab[$.get(uiState).sortMethod], null)) {
				setLastSelectedTabForSort($.get(uiState).sortMethod, "all");

				if ($.strict_equals(typeof document, "undefined", false)) {
					const viewChangeEvent = new CustomEvent("viewchange", { detail: { mode: "all" }, bubbles: true });

					document.dispatchEvent(viewChangeEvent);
				}
			}
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "Error loading options:", error));
			$.get(uiState).isLoading = false;
			$.get(uiState).error = error instanceof Error ? error.message : "Unknown error loading options";
			$.set(optionsData, [], true);
		}
	}

	function setSortMethod(method) {
		$.get(uiState).sortMethod = method;
	}

	function setReversalFilter(_filter) {}

	function setLastSelectedTabForSort(sortMethod, tabKey) {
		if ($.strict_equals($.get(uiState).lastSelectedTab[sortMethod], tabKey)) {
			return;
		}

		$.get(uiState).lastSelectedTab = { ...$.get(uiState).lastSelectedTab, [sortMethod]: tabKey };
	}

	async function selectOption(option) {
		$.set(selectedPictograph, option, true);

		if ($.strict_equals(typeof document, "undefined", false)) {
			const beatAddedEvent = new CustomEvent("beat-added", { detail: { beat: option }, bubbles: true });

			document.dispatchEvent(beatAddedEvent);

			const optionSelectedEvent = new CustomEvent("option-selected", { detail: { option }, bubbles: true });

			document.dispatchEvent(optionSelectedEvent);
		}
	}

	function reset() {
		$.set(optionsData, [], true);
		$.set(sequenceData, [], true);

		const currentSortMethod = $.get(uiState).sortMethod || "type";

		$.set(
			uiState,
			{
				sortMethod: currentSortMethod,
				isLoading: false,
				error: null,
				lastSelectedTab: $.get(uiState).lastSelectedTab || {}
			},
			true
		);

		setLastSelectedTabForSort(currentSortMethod, "all");
		$.set(selectedPictograph, null);
	}

	function setLoading(loading) {
		$.get(uiState).isLoading = loading;
	}

	function setError(error) {
		$.get(uiState).error = error;
	}

	return {
		// ✅ FIXED: Use getters that access the state directly for reactivity
		get optionsData() {
			return $.get(optionsData);
		},

		get sequenceData() {
			return $.get(sequenceData);
		},

		get selectedPictograph() {
			return $.get(selectedPictograph);
		},

		get filteredOptions() {
			return $.get(filteredOptions)();
		},

		get groupedOptions() {
			return computeGroupedOptions();
		},

		get categoryKeys() {
			return $.get(categoryKeys)();
		},

		// ✅ Keep getters for backward compatibility, but prefer direct access above
		get sequence() {
			return $.get(sequenceData);
		},

		get allOptions() {
			return $.get(optionsData);
		},

		get isLoading() {
			return $.get(uiState).isLoading;
		},

		get error() {
			return $.get(uiState).error;
		},

		get sortMethod() {
			return $.get(uiState).sortMethod;
		},

		get lastSelectedTab() {
			return $.get(uiState).lastSelectedTab;
		},

		// Actions
		loadOptions,

		setSortMethod,
		setReversalFilter,
		setLastSelectedTabForSort,
		selectOption,
		reset,
		setLoading,
		setError,

		// Direct state setters (for advanced use)
		setSequence: (seq) => {
			$.set(sequenceData, seq, true);
		},

		setOptions: (opts) => {
			$.set(optionsData, opts, true);
		},

		setSelectedPictograph: (opt) => {
			$.set(selectedPictograph, opt, true);
		}
	};
}
//# sourceMappingURL=data:application/json;base64,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LGFBQWE7Z0JBQ1IsU0FBUTtFQUNqQjs7TUFDSSxrQkFBa0I7Z0JBQ2IsU0FBUTtFQUNqQjs7O0VBR0E7O0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7OztFQUdBLGNBQWMsUUFBMEI7U0FDdEMsY0FBZTtFQUNqQjs7RUFDQSxhQUFhLFNBQTJCO1NBQ3RDLGFBQWM7RUFDaEI7O0VBQ0Esd0JBQXdCLFFBQStCO1NBQ3JELG9CQUFxQjtFQUN2Qjs7QUFFSiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsib3B0aW9uUGlja2VyUnVuZXMuc3ZlbHRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU29waGlzdGljYXRlZCBPcHRpb24gUGlja2VyIFN0YXRlIHVzaW5nIE9OTFkgU3ZlbHRlIDUgUnVuZXNcbiAqXG4gKiBDb21wbGV0ZSBwb3J0IG9mIHRoZSBsZWdhY3kgc3lzdGVtIHdpdGggYWR2YW5jZWQgZmVhdHVyZXMgdXNpbmcgcHVyZSBydW5lczpcbiAqIC0gQWR2YW5jZWQgc3RhdGUgbWFuYWdlbWVudFxuICogLSBTb3BoaXN0aWNhdGVkIGZpbHRlcmluZyBhbmQgZ3JvdXBpbmdcbiAqIC0gUmVhbCBvcHRpb24gZGF0YSBzZXJ2aWNlIGludGVncmF0aW9uXG4gKiAtIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnNcbiAqIC0gQ29tcGxleCByZWFjdGl2ZSBzdGF0ZSBkZXJpdmF0aW9uc1xuICovXG5cbmltcG9ydCB0eXBlIHsgUGljdG9ncmFwaERhdGEgfSBmcm9tIFwiJGxpYi9kb21haW4vUGljdG9ncmFwaERhdGFcIjtcbmltcG9ydCB7IHJlc29sdmUgfSBmcm9tIFwiJHNlcnZpY2VzL2Jvb3RzdHJhcFwiO1xuaW1wb3J0IHsgY3JlYXRlQmVhdERhdGEgfSBmcm9tIFwiJGxpYi9kb21haW4vQmVhdERhdGFcIjtcbmltcG9ydCB0eXBlIHsgUmV2ZXJzYWxGaWx0ZXIsIFNvcnRNZXRob2QgfSBmcm9tIFwiLi9jb25maWdcIjtcbmltcG9ydCB7XG4gIGRldGVybWluZUdyb3VwS2V5LFxuICBnZXRTb3J0ZWRHcm91cEtleXMsXG4gIGdldFNvcnRlcixcbn0gZnJvbSBcIi4vc2VydmljZXMvT3B0aW9uc1NlcnZpY2VcIjtcblxuLy8gPT09PT0gVHlwZXMgPT09PT1cbmV4cG9ydCB0eXBlIExhc3RTZWxlY3RlZFRhYlN0YXRlID0gUGFydGlhbDxSZWNvcmQ8U29ydE1ldGhvZCwgc3RyaW5nIHwgbnVsbD4+O1xuXG5pbnRlcmZhY2UgVUlTdGF0ZSB7XG4gIHNvcnRNZXRob2Q6IFNvcnRNZXRob2Q7XG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG4gIGxhc3RTZWxlY3RlZFRhYjogTGFzdFNlbGVjdGVkVGFiU3RhdGU7XG59XG5cbi8vID09PT09IEhlbHBlciBGdW5jdGlvbnMgPT09PT1cbmZ1bmN0aW9uIGdldFN0b3JlZFN0YXRlKCk6IFVJU3RhdGUge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICByZXR1cm4ge1xuICAgICAgc29ydE1ldGhvZDogXCJ0eXBlXCIsXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBsYXN0U2VsZWN0ZWRUYWI6IHt9LFxuICAgIH07XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm9wdGlvblBpY2tlclVJU3RhdGVcIik7XG5cbiAgICBpZiAoIXN0b3JlZClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvcnRNZXRob2Q6IFwidHlwZVwiLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgbGFzdFNlbGVjdGVkVGFiOiB7IHR5cGU6IFwiYWxsXCIgfSxcbiAgICAgIH07XG5cbiAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHN0b3JlZCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc29ydE1ldGhvZDogcGFyc2VkLnNvcnRNZXRob2QgfHwgXCJ0eXBlXCIsXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBsYXN0U2VsZWN0ZWRUYWI6IHBhcnNlZC5sYXN0U2VsZWN0ZWRUYWIgfHwgeyB0eXBlOiBcImFsbFwiIH0sXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWFkaW5nIGZyb20gbG9jYWxTdG9yYWdlOlwiLCBlKTtcbiAgICByZXR1cm4ge1xuICAgICAgc29ydE1ldGhvZDogXCJ0eXBlXCIsXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBsYXN0U2VsZWN0ZWRUYWI6IHsgdHlwZTogXCJhbGxcIiB9LFxuICAgIH07XG4gIH1cbn1cblxuXG5cbi8qKlxuICogQ3JlYXRlIHNvcGhpc3RpY2F0ZWQgb3B0aW9uIHBpY2tlciBzdGF0ZSB1c2luZyBPTkxZIFN2ZWx0ZSA1IHJ1bmVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPcHRpb25QaWNrZXJSdW5lcygpIHtcbiAgLy8gPT09PT0gQ29yZSBTdGF0ZSBVc2luZyBSdW5lcyA9PT09PVxuICBsZXQgc2VxdWVuY2VEYXRhID0gJHN0YXRlPFBpY3RvZ3JhcGhEYXRhW10+KFtdKTtcbiAgbGV0IG9wdGlvbnNEYXRhID0gJHN0YXRlPFBpY3RvZ3JhcGhEYXRhW10+KFtdKTtcbiAgbGV0IHNlbGVjdGVkUGljdG9ncmFwaCA9ICRzdGF0ZTxQaWN0b2dyYXBoRGF0YSB8IG51bGw+KG51bGwpO1xuXG4gIC8vID09PT09IFVJIFN0YXRlIFVzaW5nIFJ1bmVzID09PT09XG4gIGNvbnN0IHN0b3JlZFN0YXRlID0gZ2V0U3RvcmVkU3RhdGUoKTtcbiAgbGV0IHVpU3RhdGUgPSAkc3RhdGU8VUlTdGF0ZT4oe1xuICAgIHNvcnRNZXRob2Q6IHN0b3JlZFN0YXRlLnNvcnRNZXRob2QsXG4gICAgaXNMb2FkaW5nOiBzdG9yZWRTdGF0ZS5pc0xvYWRpbmcsXG4gICAgZXJyb3I6IHN0b3JlZFN0YXRlLmVycm9yLFxuICAgIGxhc3RTZWxlY3RlZFRhYjogc3RvcmVkU3RhdGUubGFzdFNlbGVjdGVkVGFiLFxuICB9KTtcblxuICAvLyA9PT09PSBEZXJpdmVkIFN0YXRlIFVzaW5nIFJ1bmVzID09PT09XG5cbiAgLy8gRmlsdGVyZWQgYW5kIHNvcnRlZCBvcHRpb25zXG4gIGNvbnN0IGZpbHRlcmVkT3B0aW9ucyA9ICRkZXJpdmVkKCgpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gWy4uLm9wdGlvbnNEYXRhXTtcbiAgICBvcHRpb25zLnNvcnQoZ2V0U29ydGVyKHVpU3RhdGUuc29ydE1ldGhvZCwgc2VxdWVuY2VEYXRhKSk7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH0pO1xuXG4gIC8vIFNpbXBsaWZpZWQgZ3JvdXBlZCBvcHRpb25zIC0gY29tcHV0ZSBvbmx5IHdoZW4gZXhwbGljaXRseSBuZWVkZWRcbiAgbGV0IGNhY2hlZEdyb3VwZWRPcHRpb25zID0gJHN0YXRlPFJlY29yZDxzdHJpbmcsIFBpY3RvZ3JhcGhEYXRhW10+Pih7fSk7XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUdyb3VwZWRPcHRpb25zKCk6IFJlY29yZDxzdHJpbmcsIFBpY3RvZ3JhcGhEYXRhW10+IHtcbiAgICBjb25zdCBncm91cHM6IFJlY29yZDxzdHJpbmcsIFBpY3RvZ3JhcGhEYXRhW10+ID0ge307XG4gICAgY29uc3Qgb3B0aW9ucyA9IGZpbHRlcmVkT3B0aW9ucygpO1xuICAgIG9wdGlvbnMuZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgICBjb25zdCBncm91cEtleSA9IGRldGVybWluZUdyb3VwS2V5KFxuICAgICAgICBvcHRpb24sXG4gICAgICAgIHVpU3RhdGUuc29ydE1ldGhvZCxcbiAgICAgICAgc2VxdWVuY2VEYXRhXG4gICAgICApO1xuICAgICAgaWYgKCFncm91cHNbZ3JvdXBLZXldKSBncm91cHNbZ3JvdXBLZXldID0gW107XG4gICAgICBncm91cHNbZ3JvdXBLZXldLnB1c2gob3B0aW9uKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHNvcnRlZEtleXMgPSBnZXRTb3J0ZWRHcm91cEtleXMoXG4gICAgICBPYmplY3Qua2V5cyhncm91cHMpLFxuICAgICAgdWlTdGF0ZS5zb3J0TWV0aG9kXG4gICAgKTtcbiAgICBjb25zdCBzb3J0ZWRHcm91cHM6IFJlY29yZDxzdHJpbmcsIFBpY3RvZ3JhcGhEYXRhW10+ID0ge307XG4gICAgc29ydGVkS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChncm91cHNba2V5XSkge1xuICAgICAgICBzb3J0ZWRHcm91cHNba2V5XSA9IGdyb3Vwc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNhY2hlZEdyb3VwZWRPcHRpb25zID0gc29ydGVkR3JvdXBzO1xuICAgIHJldHVybiBzb3J0ZWRHcm91cHM7XG4gIH1cblxuICAvLyBDYXRlZ29yeSBrZXlzIGF2YWlsYWJsZSAtIHNpbXBsaWZpZWRcbiAgY29uc3QgY2F0ZWdvcnlLZXlzID0gJGRlcml2ZWQoKCkgPT4gT2JqZWN0LmtleXMoY2FjaGVkR3JvdXBlZE9wdGlvbnMpKTtcblxuICAvLyA9PT09PSBTdGF0ZSBQZXJzaXN0ZW5jZSBFZmZlY3QgPT09PT1cbiAgLy8gRGlzYWJsZSBhdXRvbWF0aWMgc3RhdGUgcGVyc2lzdGVuY2UgdG8gcHJldmVudCByZWFjdGl2ZSBjYXNjYWRlc1xuICAvLyBPbmx5IHNhdmUgc3RhdGUgb24gZXhwbGljaXQgdXNlciBhY3Rpb25zXG4gIC8vICRlZmZlY3QoKCkgPT4ge1xuICAvLyAgIC8vIFNhdmUgc3RhdGUgY2hhbmdlcyB0byBsb2NhbFN0b3JhZ2VcbiAgLy8gICBzYXZlU3RhdGVUb0xvY2FsU3RvcmFnZSh1aVN0YXRlKTtcbiAgLy8gfSk7XG5cbiAgLy8gPT09PT0gQWN0aW9ucyA9PT09PVxuICBhc3luYyBmdW5jdGlvbiBsb2FkT3B0aW9ucyhzZXF1ZW5jZTogUGljdG9ncmFwaERhdGFbXSkge1xuICAgIHNlcXVlbmNlRGF0YSA9IHNlcXVlbmNlO1xuXG4gICAgLy8gKipDaGVjayBmb3IgcHJlbG9hZGVkIG9wdGlvbnMgZmlyc3QgdG8gYXZvaWQgbG9hZGluZyBzdGF0ZSoqXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0IGNoZWNrIGZvciBzcGVjaWZpYyBwcmVsb2FkZWQgb3B0aW9ucyAoZnJvbSBpbmRpdmlkdWFsIGNsaWNrcylcbiAgICAgIGNvbnN0IHByZWxvYWRlZERhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInByZWxvYWRlZF9vcHRpb25zXCIpO1xuICAgICAgaWYgKHByZWxvYWRlZERhdGEpIHtcbiAgICAgICAgY29uc3QgcHJlbG9hZGVkT3B0aW9ucyA9IEpTT04ucGFyc2UocHJlbG9hZGVkRGF0YSk7XG4gICAgICAgIG9wdGlvbnNEYXRhID0gcHJlbG9hZGVkT3B0aW9ucyB8fCBbXTtcbiAgICAgICAgdWlTdGF0ZS5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdWlTdGF0ZS5lcnJvciA9IG51bGw7XG5cbiAgICAgICAgLy8gQ2xlYXIgcHJlbG9hZGVkIGRhdGEgc28gaXQncyBvbmx5IHVzZWQgb25jZVxuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcInByZWxvYWRlZF9vcHRpb25zXCIpO1xuXG4gICAgICAgIC8vIFNldCBkZWZhdWx0IHRhYiBpZiBuZWVkZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgICF1aVN0YXRlLmxhc3RTZWxlY3RlZFRhYlt1aVN0YXRlLnNvcnRNZXRob2RdIHx8XG4gICAgICAgICAgdWlTdGF0ZS5sYXN0U2VsZWN0ZWRUYWJbdWlTdGF0ZS5zb3J0TWV0aG9kXSA9PT0gbnVsbFxuICAgICAgICApIHtcbiAgICAgICAgICBzZXRMYXN0U2VsZWN0ZWRUYWJGb3JTb3J0KHVpU3RhdGUuc29ydE1ldGhvZCwgXCJhbGxcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47IC8vIFNraXAgdGhlIGxvYWRpbmcgcHJvY2Vzc1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgYnVsayBwcmVsb2FkZWQgb3B0aW9ucyAoZnJvbSBjb21wb25lbnQgbG9hZClcbiAgICAgIGNvbnN0IGFsbFByZWxvYWRlZERhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImFsbF9wcmVsb2FkZWRfb3B0aW9uc1wiKTtcbiAgICAgIGlmIChhbGxQcmVsb2FkZWREYXRhKSB7XG4gICAgICAgIGNvbnN0IGFsbFByZWxvYWRlZE9wdGlvbnMgPSBKU09OLnBhcnNlKGFsbFByZWxvYWRlZERhdGEpO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgY3VycmVudCBlbmQgcG9zaXRpb24gd2UgbmVlZCBvcHRpb25zIGZvclxuICAgICAgICBsZXQgdGFyZ2V0RW5kUG9zaXRpb246IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGlmIChzZXF1ZW5jZSAmJiBzZXF1ZW5jZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgbGFzdEJlYXQgPSBzZXF1ZW5jZVtzZXF1ZW5jZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBjb25zdCBlbmRQb3NpdGlvbiA9XG4gICAgICAgICAgICBsYXN0QmVhdD8uZW5kUG9zaXRpb24gfHwgbGFzdEJlYXQ/Lm1ldGFkYXRhPy5lbmRQb3NpdGlvbjtcbiAgICAgICAgICB0YXJnZXRFbmRQb3NpdGlvbiA9XG4gICAgICAgICAgICB0eXBlb2YgZW5kUG9zaXRpb24gPT09IFwic3RyaW5nXCIgPyBlbmRQb3NpdGlvbiA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRm9yIGVtcHR5IHNlcXVlbmNlLCBnZXQgZnJvbSBzdGFydCBwb3NpdGlvblxuICAgICAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb25EYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdGFydFBvc2l0aW9uXCIpO1xuICAgICAgICAgIGlmIChzdGFydFBvc2l0aW9uRGF0YSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IEpTT04ucGFyc2Uoc3RhcnRQb3NpdGlvbkRhdGEpO1xuICAgICAgICAgICAgdGFyZ2V0RW5kUG9zaXRpb24gPSBzdGFydFBvc2l0aW9uLmVuZFBvc2l0aW9uIHx8IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBwcmVsb2FkZWQgb3B0aW9ucyBmb3IgdGhpcyBlbmQgcG9zaXRpb24sIHVzZSB0aGVtXG4gICAgICAgIGlmICh0YXJnZXRFbmRQb3NpdGlvbiAmJiBhbGxQcmVsb2FkZWRPcHRpb25zW3RhcmdldEVuZFBvc2l0aW9uXSkge1xuICAgICAgICAgIGNvbnN0IG9wdGlvbnNGb3JQb3NpdGlvbiA9IGFsbFByZWxvYWRlZE9wdGlvbnNbdGFyZ2V0RW5kUG9zaXRpb25dO1xuICAgICAgICAgIG9wdGlvbnNEYXRhID0gb3B0aW9uc0ZvclBvc2l0aW9uIHx8IFtdO1xuICAgICAgICAgIHVpU3RhdGUuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgdWlTdGF0ZS5lcnJvciA9IG51bGw7XG5cbiAgICAgICAgICAvLyBTZXQgZGVmYXVsdCB0YWIgaWYgbmVlZGVkXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXVpU3RhdGUubGFzdFNlbGVjdGVkVGFiW3VpU3RhdGUuc29ydE1ldGhvZF0gfHxcbiAgICAgICAgICAgIHVpU3RhdGUubGFzdFNlbGVjdGVkVGFiW3VpU3RhdGUuc29ydE1ldGhvZF0gPT09IG51bGxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHNldExhc3RTZWxlY3RlZFRhYkZvclNvcnQodWlTdGF0ZS5zb3J0TWV0aG9kLCBcImFsbFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47IC8vIFNraXAgdGhlIGxvYWRpbmcgcHJvY2Vzc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gbG9hZCBwcmVsb2FkZWQgb3B0aW9ucywgZmFsbGluZyBiYWNrIHRvIG5vcm1hbCBsb2FkaW5nOlwiLFxuICAgICAgICBlcnJvclxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWwgbG9hZGluZyBwcm9jZXNzIChvbmx5IGlmIG5vIHByZWxvYWRlZCBvcHRpb25zKVxuICAgIHVpU3RhdGUuaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICB1aVN0YXRlLmVycm9yID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICAvLyBFeHRyYWN0IGVuZCBwb3NpdGlvbiBmcm9tIHNlcXVlbmNlIGZvciB0aGUgcmVhbCBPcHRpb25EYXRhU2VydmljZVxuICAgICAgbGV0IG5leHRPcHRpb25zOiBQaWN0b2dyYXBoRGF0YVtdID0gW107XG5cbiAgICAgIGlmIChzZXF1ZW5jZSAmJiBzZXF1ZW5jZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGxhc3RCZWF0ID0gc2VxdWVuY2Vbc2VxdWVuY2UubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IGVuZFBvc2l0aW9uID1cbiAgICAgICAgICBsYXN0QmVhdD8uZW5kUG9zaXRpb24gfHwgbGFzdEJlYXQ/Lm1ldGFkYXRhPy5lbmRQb3NpdGlvbjtcblxuICAgICAgICBpZiAoZW5kUG9zaXRpb24gJiYgdHlwZW9mIGVuZFBvc2l0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgLy8gR2V0IHRoZSBvcHRpb24gZGF0YSBzZXJ2aWNlIHRocm91Z2ggRElcbiAgICAgICAgICBjb25zdCBvcHRpb25EYXRhU2VydmljZSA9IHJlc29sdmUoXCJJT3B0aW9uRGF0YVNlcnZpY2VcIikgYXMge1xuICAgICAgICAgICAgZ2V0TmV4dE9wdGlvbnMoc2VxdWVuY2U6IHVua25vd25bXSk6IFByb21pc2U8UGljdG9ncmFwaERhdGFbXT47XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIENyZWF0ZSBhIG1pbmltYWwgc2VxdWVuY2Ugd2l0aCBhIGJlYXQgdGhhdCBoYXMgdGhlIGVuZCBwb3NpdGlvblxuICAgICAgICAgIGNvbnN0IG1pbmltYWxTZXF1ZW5jZSA9IFtcbiAgICAgICAgICAgIGNyZWF0ZUJlYXREYXRhKHtcbiAgICAgICAgICAgICAgYmVhdE51bWJlcjogMSxcbiAgICAgICAgICAgICAgbWV0YWRhdGE6IHsgZW5kUG9zaXRpb246IGVuZFBvc2l0aW9uIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgbmV4dE9wdGlvbnMgPSBhd2FpdCBvcHRpb25EYXRhU2VydmljZS5nZXROZXh0T3B0aW9ucyhtaW5pbWFsU2VxdWVuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vIGVuZCBwb3NpdGlvbiBmb3VuZCBpbiBzZXF1ZW5jZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIGVtcHR5IHNlcXVlbmNlLCB0cnkgdG8gZ2V0IHN0YXJ0IHBvc2l0aW9uIGZyb20gbG9jYWxTdG9yYWdlXG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb25EYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdGFydFBvc2l0aW9uXCIpO1xuICAgICAgICBpZiAoc3RhcnRQb3NpdGlvbkRhdGEpIHtcbiAgICAgICAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gSlNPTi5wYXJzZShzdGFydFBvc2l0aW9uRGF0YSk7XG4gICAgICAgICAgY29uc3QgZW5kUG9zaXRpb24gPVxuICAgICAgICAgICAgdHlwZW9mIHN0YXJ0UG9zaXRpb24uZW5kUG9zaXRpb24gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgPyBzdGFydFBvc2l0aW9uLmVuZFBvc2l0aW9uXG4gICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICBpZiAoZW5kUG9zaXRpb24pIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgb3B0aW9uIGRhdGEgc2VydmljZSB0aHJvdWdoIERJXG4gICAgICAgICAgICBjb25zdCBvcHRpb25EYXRhU2VydmljZSA9IHJlc29sdmUoXCJJT3B0aW9uRGF0YVNlcnZpY2VcIikgYXMge1xuICAgICAgICAgICAgICBnZXROZXh0T3B0aW9ucyhzZXF1ZW5jZTogdW5rbm93bltdKTogUHJvbWlzZTxQaWN0b2dyYXBoRGF0YVtdPjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG1pbmltYWwgc2VxdWVuY2Ugd2l0aCBhIGJlYXQgdGhhdCBoYXMgdGhlIGVuZCBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3QgbWluaW1hbFNlcXVlbmNlID0gW1xuICAgICAgICAgICAgICBjcmVhdGVCZWF0RGF0YSh7XG4gICAgICAgICAgICAgICAgYmVhdE51bWJlcjogMSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogeyBlbmRQb3NpdGlvbjogZW5kUG9zaXRpb24gfSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBuZXh0T3B0aW9ucyA9XG4gICAgICAgICAgICAgIGF3YWl0IG9wdGlvbkRhdGFTZXJ2aWNlLmdldE5leHRPcHRpb25zKG1pbmltYWxTZXF1ZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGdvdCBubyBvcHRpb25zLCBsb2cgYSB3YXJuaW5nIGJ1dCBkb24ndCB0cmVhdCBpdCBhcyBhbiBlcnJvclxuICAgICAgaWYgKCFuZXh0T3B0aW9ucyB8fCBuZXh0T3B0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiTm8gb3B0aW9ucyBhdmFpbGFibGUgZm9yIHRoZSBjdXJyZW50IHNlcXVlbmNlXCIpO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zRGF0YSA9IG5leHRPcHRpb25zIHx8IFtdO1xuICAgICAgdWlTdGF0ZS5pc0xvYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gT25seSBzZXQgZGVmYXVsdCB0YWIgaWYgd2UgZG9uJ3QgaGF2ZSBhIHNlbGVjdGVkIHRhYiB5ZXRcbiAgICAgIGlmIChcbiAgICAgICAgIXVpU3RhdGUubGFzdFNlbGVjdGVkVGFiW3VpU3RhdGUuc29ydE1ldGhvZF0gfHxcbiAgICAgICAgdWlTdGF0ZS5sYXN0U2VsZWN0ZWRUYWJbdWlTdGF0ZS5zb3J0TWV0aG9kXSA9PT0gbnVsbFxuICAgICAgKSB7XG4gICAgICAgIHNldExhc3RTZWxlY3RlZFRhYkZvclNvcnQodWlTdGF0ZS5zb3J0TWV0aG9kLCBcImFsbFwiKTtcblxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgY29uc3Qgdmlld0NoYW5nZUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFwidmlld2NoYW5nZVwiLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHsgbW9kZTogXCJhbGxcIiB9LFxuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KHZpZXdDaGFuZ2VFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgb3B0aW9uczpcIiwgZXJyb3IpO1xuICAgICAgdWlTdGF0ZS5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgIHVpU3RhdGUuZXJyb3IgPVxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgICAgPyBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgOiBcIlVua25vd24gZXJyb3IgbG9hZGluZyBvcHRpb25zXCI7XG4gICAgICBvcHRpb25zRGF0YSA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFNvcnRNZXRob2QobWV0aG9kOiBTb3J0TWV0aG9kKSB7XG4gICAgdWlTdGF0ZS5zb3J0TWV0aG9kID0gbWV0aG9kO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UmV2ZXJzYWxGaWx0ZXIoX2ZpbHRlcjogUmV2ZXJzYWxGaWx0ZXIpIHtcbiAgICAvLyBOb3RlOiBSZXZlcnNhbEZpbHRlciB3b3VsZCBuZWVkIHRvIGJlIGFkZGVkIHRvIFVJU3RhdGUgaWYgbmVlZGVkXG4gIH1cblxuICBmdW5jdGlvbiBzZXRMYXN0U2VsZWN0ZWRUYWJGb3JTb3J0KFxuICAgIHNvcnRNZXRob2Q6IFNvcnRNZXRob2QsXG4gICAgdGFiS2V5OiBzdHJpbmcgfCBudWxsXG4gICkge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IHVwZGF0ZXMgaWYgdGhlIHZhbHVlIGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKHVpU3RhdGUubGFzdFNlbGVjdGVkVGFiW3NvcnRNZXRob2RdID09PSB0YWJLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1aVN0YXRlLmxhc3RTZWxlY3RlZFRhYiA9IHtcbiAgICAgIC4uLnVpU3RhdGUubGFzdFNlbGVjdGVkVGFiLFxuICAgICAgW3NvcnRNZXRob2RdOiB0YWJLZXksXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHNlbGVjdE9wdGlvbihvcHRpb246IFBpY3RvZ3JhcGhEYXRhKSB7XG4gICAgLy8gVXBkYXRlIHNlbGVjdGVkIHBpY3RvZ3JhcGhcbiAgICBzZWxlY3RlZFBpY3RvZ3JhcGggPSBvcHRpb247XG5cbiAgICAvLyBEaXNwYXRjaCBjdXN0b20gZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29uc3QgYmVhdEFkZGVkRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJiZWF0LWFkZGVkXCIsIHtcbiAgICAgICAgZGV0YWlsOiB7IGJlYXQ6IG9wdGlvbiB9LFxuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgfSk7XG4gICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGJlYXRBZGRlZEV2ZW50KTtcblxuICAgICAgY29uc3Qgb3B0aW9uU2VsZWN0ZWRFdmVudCA9IG5ldyBDdXN0b21FdmVudChcIm9wdGlvbi1zZWxlY3RlZFwiLCB7XG4gICAgICAgIGRldGFpbDogeyBvcHRpb24gfSxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIH0pO1xuICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChvcHRpb25TZWxlY3RlZEV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBvcHRpb25zRGF0YSA9IFtdO1xuICAgIHNlcXVlbmNlRGF0YSA9IFtdO1xuXG4gICAgLy8gUHJlc2VydmUgdXNlciBwcmVmZXJlbmNlc1xuICAgIGNvbnN0IGN1cnJlbnRTb3J0TWV0aG9kID0gdWlTdGF0ZS5zb3J0TWV0aG9kIHx8IFwidHlwZVwiO1xuICAgIHVpU3RhdGUgPSB7XG4gICAgICBzb3J0TWV0aG9kOiBjdXJyZW50U29ydE1ldGhvZCxcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBlcnJvcjogbnVsbCxcbiAgICAgIGxhc3RTZWxlY3RlZFRhYjogdWlTdGF0ZS5sYXN0U2VsZWN0ZWRUYWIgfHwge30sXG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSAnYWxsJyBpcyBzZXQgYXMgdGhlIGRlZmF1bHQgdGFiIGZvciB0aGUgY3VycmVudCBzb3J0IG1ldGhvZFxuICAgIHNldExhc3RTZWxlY3RlZFRhYkZvclNvcnQoY3VycmVudFNvcnRNZXRob2QsIFwiYWxsXCIpO1xuICAgIHNlbGVjdGVkUGljdG9ncmFwaCA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMb2FkaW5nKGxvYWRpbmc6IGJvb2xlYW4pIHtcbiAgICB1aVN0YXRlLmlzTG9hZGluZyA9IGxvYWRpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRFcnJvcihlcnJvcjogc3RyaW5nIHwgbnVsbCkge1xuICAgIHVpU3RhdGUuZXJyb3IgPSBlcnJvcjtcbiAgfVxuXG4gIC8vID09PT09IFJldHVybiBSZWFjdGl2ZSBJbnRlcmZhY2UgPT09PT1cbiAgcmV0dXJuIHtcbiAgICAvLyDinIUgRklYRUQ6IFVzZSBnZXR0ZXJzIHRoYXQgYWNjZXNzIHRoZSBzdGF0ZSBkaXJlY3RseSBmb3IgcmVhY3Rpdml0eVxuICAgIGdldCBvcHRpb25zRGF0YSgpIHtcbiAgICAgIHJldHVybiBvcHRpb25zRGF0YTtcbiAgICB9LFxuICAgIGdldCBzZXF1ZW5jZURhdGEoKSB7XG4gICAgICByZXR1cm4gc2VxdWVuY2VEYXRhO1xuICAgIH0sXG4gICAgZ2V0IHNlbGVjdGVkUGljdG9ncmFwaCgpIHtcbiAgICAgIHJldHVybiBzZWxlY3RlZFBpY3RvZ3JhcGg7XG4gICAgfSxcbiAgICBnZXQgZmlsdGVyZWRPcHRpb25zKCkge1xuICAgICAgcmV0dXJuIGZpbHRlcmVkT3B0aW9ucygpO1xuICAgIH0sXG4gICAgZ2V0IGdyb3VwZWRPcHRpb25zKCkge1xuICAgICAgcmV0dXJuIGNvbXB1dGVHcm91cGVkT3B0aW9ucygpO1xuICAgIH0sXG4gICAgZ2V0IGNhdGVnb3J5S2V5cygpIHtcbiAgICAgIHJldHVybiBjYXRlZ29yeUtleXMoKTtcbiAgICB9LFxuXG4gICAgLy8g4pyFIEtlZXAgZ2V0dGVycyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgYnV0IHByZWZlciBkaXJlY3QgYWNjZXNzIGFib3ZlXG4gICAgZ2V0IHNlcXVlbmNlKCkge1xuICAgICAgcmV0dXJuIHNlcXVlbmNlRGF0YTtcbiAgICB9LFxuICAgIGdldCBhbGxPcHRpb25zKCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnNEYXRhO1xuICAgIH0sXG4gICAgZ2V0IGlzTG9hZGluZygpIHtcbiAgICAgIHJldHVybiB1aVN0YXRlLmlzTG9hZGluZztcbiAgICB9LFxuICAgIGdldCBlcnJvcigpIHtcbiAgICAgIHJldHVybiB1aVN0YXRlLmVycm9yO1xuICAgIH0sXG4gICAgZ2V0IHNvcnRNZXRob2QoKSB7XG4gICAgICByZXR1cm4gdWlTdGF0ZS5zb3J0TWV0aG9kO1xuICAgIH0sXG4gICAgZ2V0IGxhc3RTZWxlY3RlZFRhYigpIHtcbiAgICAgIHJldHVybiB1aVN0YXRlLmxhc3RTZWxlY3RlZFRhYjtcbiAgICB9LFxuXG4gICAgLy8gQWN0aW9uc1xuICAgIGxvYWRPcHRpb25zLFxuICAgIHNldFNvcnRNZXRob2QsXG4gICAgc2V0UmV2ZXJzYWxGaWx0ZXIsXG4gICAgc2V0TGFzdFNlbGVjdGVkVGFiRm9yU29ydCxcbiAgICBzZWxlY3RPcHRpb24sXG4gICAgcmVzZXQsXG4gICAgc2V0TG9hZGluZyxcbiAgICBzZXRFcnJvcixcblxuICAgIC8vIERpcmVjdCBzdGF0ZSBzZXR0ZXJzIChmb3IgYWR2YW5jZWQgdXNlKVxuICAgIHNldFNlcXVlbmNlOiAoc2VxOiBQaWN0b2dyYXBoRGF0YVtdKSA9PiB7XG4gICAgICBzZXF1ZW5jZURhdGEgPSBzZXE7XG4gICAgfSxcbiAgICBzZXRPcHRpb25zOiAob3B0czogUGljdG9ncmFwaERhdGFbXSkgPT4ge1xuICAgICAgb3B0aW9uc0RhdGEgPSBvcHRzO1xuICAgIH0sXG4gICAgc2V0U2VsZWN0ZWRQaWN0b2dyYXBoOiAob3B0OiBQaWN0b2dyYXBoRGF0YSB8IG51bGwpID0+IHtcbiAgICAgIHNlbGVjdGVkUGljdG9ncmFwaCA9IG9wdDtcbiAgICB9LFxuICB9O1xufVxuLyoqXG4gKiBUeXBlIGZvciB0aGUgb3B0aW9uIHBpY2tlciBydW5lcyBpbnN0YW5jZVxuICovXG5leHBvcnQgdHlwZSBPcHRpb25QaWNrZXJSdW5lcyA9IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZU9wdGlvblBpY2tlclJ1bmVzPjtcbiJdLCJmaWxlIjoiRjovQ09ERS9US0Evd2ViL3NyYy9saWIvY29tcG9uZW50cy9jb25zdHJ1Y3Qvb3B0aW9uLXBpY2tlci9vcHRpb25QaWNrZXJSdW5lcy5zdmVsdGUudHMifQ==