/* debug-state.svelte.ts generated by Svelte v5.38.1 */
import * as $ from "/node_modules/.vite/deps/svelte_internal_client.js?v=de368f3a";
import { createPictographData } from "/src/lib/domain/PictographData.ts";
import { createGridData } from "/src/lib/domain/GridData.ts";
import { GridMode, Location } from "/src/lib/domain/enums.ts";
import { CodexService } from "/src/lib/services/codex/CodexService.ts";
import { ArrowLocationCalculator } from "/src/lib/services/positioning/arrows/calculation/ArrowLocationCalculator.ts";
import { ArrowCoordinateSystemService } from "/src/lib/services/positioning/arrows/coordinate_system/ArrowCoordinateSystemService.ts";
import { ArrowRotationCalculator } from "/src/lib/services/positioning/arrows/calculation/ArrowRotationCalculator.ts";
import { ArrowAdjustmentCalculator } from "/src/lib/services/positioning/arrows/calculation/ArrowAdjustmentCalculator.ts";

export function createDebugState() {
	let selectedPictograph = $.tag($.state(null), 'selectedPictograph');
	let selectedArrowColor = $.tag($.state("blue"), 'selectedArrowColor');
	let availablePictographs = $.tag($.state($.proxy([])), 'availablePictographs');
	let stepByStepMode = $.tag($.state(true), 'stepByStepMode');
	let currentStep = $.tag($.state(0), 'currentStep');
	const maxSteps = 4;
	let showCoordinateGrid = $.tag($.state(true), 'showCoordinateGrid');
	let showHandPoints = $.tag($.state(true), 'showHandPoints');
	let showLayer2Points = $.tag($.state(true), 'showLayer2Points');
	let showAdjustmentVectors = $.tag($.state(true), 'showAdjustmentVectors');
	let isCalculating = $.tag($.state(false), 'isCalculating');
	let autoUpdate = $.tag($.state(true), 'autoUpdate');
	let gridMode = $.tag($.state("diamond"), 'gridMode');
	let expandedSections = $.tag($.state($.proxy(/* @__PURE__ */ new Set(["input_data", "location_calculation"]))), 'expandedSections');
	const locationCalculator = new ArrowLocationCalculator();
	const rotationCalculator = new ArrowRotationCalculator();
	const adjustmentCalculator = new ArrowAdjustmentCalculator();
	const coordinateSystemService = new ArrowCoordinateSystemService();

	const currentDebugData = $.tag_proxy(
		$.proxy({
			pictographData: null,
			motionData: null,
			arrowData: null,
			calculatedLocation: null,
			locationDebugInfo: null,
			initialPosition: null,
			coordinateSystemDebugInfo: null,
			defaultAdjustment: null,
			defaultAdjustmentDebugInfo: null,
			specialAdjustment: null,
			specialAdjustmentDebugInfo: null,
			tupleProcessedAdjustment: null,
			tupleProcessingDebugInfo: null,
			finalPosition: null,
			finalRotation: 0,
			errors: [],
			timing: null
		}),
		'currentDebugData'
	);

	const currentMotionData = $.tag(
		$.derived(() => {
			if (!$.get(selectedPictograph)?.motions) return null;

			return $.get(selectedPictograph).motions[$.get(selectedArrowColor)] || null;
		}),
		'currentMotionData'
	);

	const currentArrowData = $.tag(
		$.derived(() => {
			if (!$.get(selectedPictograph)?.arrows) return null;

			return $.get(selectedPictograph).arrows[$.get(selectedArrowColor)] || null;
		}),
		'currentArrowData'
	);

	async function loadRealPictographs() {
		try {
			console.log("ðŸ”§ Loading real pictographs from CodexService...");

			const allPictographs = [];

			console.log(`âœ… Loaded ${allPictographs.length} real pictographs from CSV data`);

			return allPictographs;
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "âŒ Failed to load real pictographs:", error));

			return [];
		}
	}

	async function initializeRealData() {
		try {
			console.log("ðŸš€ Initializing Arrow Debug with real pictograph data...");

			const realPictographs = (await $.track_reactivity_loss(loadRealPictographs()))();

			$.set(availablePictographs, realPictographs, true);

			if (realPictographs.length > 0) {
				$.set(selectedPictograph, realPictographs[0], true);
				console.log(`âœ… Selected first pictograph: ${$.get(selectedPictograph).letter || $.get(selectedPictograph).id}`);
			}
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "âŒ Failed to initialize real data:", error));
		}
	}

	function toggleSection(section) {
		if ($.get(expandedSections).has(section)) {
			$.get(expandedSections).delete(section);
		} else {
			$.get(expandedSections).add(section);
		}

		$.set(expandedSections, new Set($.get(expandedSections)), true);
	}

	function setGridMode(mode) {
		$.set(gridMode, mode, true);

		if ($.get(selectedPictograph)) {
			const newGridMode = $.strict_equals(mode, "diamond") ? GridMode.DIAMOND : GridMode.BOX;

			$.set(
				selectedPictograph,
				createPictographData({
					...$.get(selectedPictograph),
					gridData: createGridData({ gridMode: newGridMode })
				}),
				true
			);

			if ($.get(autoUpdate)) {
				calculatePositioning();
			}
		}
	}

	function getCurrentStepData() {
		if (!$.get(stepByStepMode)) {
			return currentDebugData;
		}

		const stepData = {
			...currentDebugData,

			// Reset future steps based on current step
			calculatedLocation: $.get(currentStep) >= 1 ? currentDebugData.calculatedLocation : null,

			locationDebugInfo: $.get(currentStep) >= 1 ? currentDebugData.locationDebugInfo : null,
			initialPosition: $.get(currentStep) >= 2 ? currentDebugData.initialPosition : null,
			coordinateSystemDebugInfo: $.get(currentStep) >= 2 ? currentDebugData.coordinateSystemDebugInfo : null,
			finalRotation: $.get(currentStep) >= 3 ? currentDebugData.finalRotation : 0,
			defaultAdjustment: $.get(currentStep) >= 4 ? currentDebugData.defaultAdjustment : null,
			finalPosition: $.get(currentStep) >= 4 ? currentDebugData.finalPosition : null
		};

		return stepData;
	}

	function getCurrentStepName() {
		const stepNames = [
			"Input Data",
			"Location Calculation",
			"Coordinate System",
			"Rotation Calculation",
			"Adjustment Calculation"
		];

		return stepNames[$.get(currentStep)] || "Unknown Step";
	}

	async function calculatePositioning() {
		if (!$.get(selectedPictograph) || !$.get(currentMotionData) || !$.get(currentArrowData)) {
			return;
		}

		$.set(isCalculating, true);

		const startTime = performance.now();
		const stepTimes = {};

		try {
			currentDebugData.errors = [];
			currentDebugData.pictographData = $.get(selectedPictograph);
			currentDebugData.motionData = $.get(currentMotionData);
			currentDebugData.arrowData = $.get(currentArrowData);

			const locationStart = performance.now();

			try {
				const calculatedLocation = locationCalculator.calculateLocation($.get(currentMotionData), $.get(selectedPictograph));

				currentDebugData.calculatedLocation = calculatedLocation;

				currentDebugData.locationDebugInfo = {
					motionType: $.get(currentMotionData).motionType || "",
					startOrientation: $.get(currentMotionData).startOrientation || "",
					endOrientation: $.get(currentMotionData).endOrientation || "",
					calculationMethod: "ArrowLocationCalculator"
				};

				stepTimes.location_calculation = performance.now() - locationStart;
			} catch(error) {
				currentDebugData.errors.push({
					step: "location_calculation",
					error: error instanceof Error ? error.message : String(error),
					timestamp: Date.now()
				});
			}

			const coordinateStart = performance.now();

			try {
				if (currentDebugData.calculatedLocation) {
					const initialPosition = coordinateSystemService.getInitialPosition($.get(currentMotionData), currentDebugData.calculatedLocation);

					currentDebugData.initialPosition = initialPosition;

					const sceneCenter = coordinateSystemService.getSceneCenter();
					const sceneDimensions = coordinateSystemService.getSceneDimensions();
					const handPoints = coordinateSystemService.getAllHandPoints();
					const layer2Points = coordinateSystemService.getAllLayer2Points();

					currentDebugData.coordinateSystemDebugInfo = {
						sceneCenter,
						sceneDimensions,
						handPoints,
						layer2Points,
						usedCoordinateSet: $.strict_equals($.get(currentMotionData).motionType, "static") || $.strict_equals($.get(currentMotionData).motionType, "dash") ? "hand_points" : "layer2_points",
						coordinateSystemType: "TKA_950x950"
					};
				}

				stepTimes.coordinate_system = performance.now() - coordinateStart;
			} catch(error) {
				currentDebugData.errors.push({
					step: "coordinate_system",
					error: error instanceof Error ? error.message : String(error),
					timestamp: Date.now()
				});
			}

			const rotationStart = performance.now();

			try {
				if (currentDebugData.calculatedLocation) {
					const rotation = rotationCalculator.calculateRotation($.get(currentMotionData), currentDebugData.calculatedLocation);

					currentDebugData.finalRotation = rotation;
				}

				stepTimes.rotation_calculation = performance.now() - rotationStart;
			} catch(error) {
				currentDebugData.errors.push({
					step: "rotation_calculation",
					error: error instanceof Error ? error.message : String(error),
					timestamp: Date.now()
				});
			}

			const adjustmentStart = performance.now();

			try {
				if (currentDebugData.calculatedLocation) {
					const adjustment = (await $.track_reactivity_loss(adjustmentCalculator.calculateAdjustment($.get(selectedPictograph), $.get(currentMotionData), $.get(selectedPictograph).letter || "A", currentDebugData.calculatedLocation)))();

					currentDebugData.defaultAdjustment = adjustment;

					if (currentDebugData.initialPosition && adjustment) {
						currentDebugData.finalPosition = {
							x: currentDebugData.initialPosition.x + adjustment.x,
							y: currentDebugData.initialPosition.y + adjustment.y
						};
					} else {
						currentDebugData.finalPosition = currentDebugData.initialPosition;
					}
				}

				stepTimes.adjustment_calculation = performance.now() - adjustmentStart;
			} catch(error) {
				currentDebugData.errors.push({
					step: "adjustment_calculation",
					error: error instanceof Error ? error.message : String(error),
					timestamp: Date.now()
				});
			}

			const endTime = performance.now();

			currentDebugData.timing = { totalDuration: endTime - startTime, stepDurations: stepTimes };

			console.log(...$.log_if_contains_state('log', "ðŸŽ¯ Arrow positioning calculation completed:", {
				location: currentDebugData.calculatedLocation,
				initialPosition: currentDebugData.initialPosition,
				finalPosition: currentDebugData.finalPosition,
				rotation: currentDebugData.finalRotation,
				errors: currentDebugData.errors,
				timing: currentDebugData.timing
			}));
		} catch(error) {
			currentDebugData.errors.push({
				step: "overall_calculation",
				error: error instanceof Error ? error.message : String(error),
				timestamp: Date.now()
			});
		} finally {
			$.set(isCalculating, false);
		}
	}

	$.user_effect(() => {
		if ($.get(autoUpdate) && $.get(selectedPictograph) && $.get(currentMotionData) && $.get(currentArrowData)) {
			calculatePositioning();
		}
	});

	return {
		// State
		get selectedPictograph() {
			return $.get(selectedPictograph);
		},

		set selectedPictograph(value) {
			$.set(selectedPictograph, value, true);
		},

		get selectedArrowColor() {
			return $.get(selectedArrowColor);
		},

		set selectedArrowColor(value) {
			$.set(selectedArrowColor, value, true);
		},

		get availablePictographs() {
			return $.get(availablePictographs);
		},

		set availablePictographs(value) {
			$.set(availablePictographs, value, true);
		},

		get stepByStepMode() {
			return $.get(stepByStepMode);
		},

		set stepByStepMode(value) {
			$.set(stepByStepMode, value, true);
		},

		get currentStep() {
			return $.get(currentStep);
		},

		set currentStep(value) {
			$.set(currentStep, value, true);
		},

		get maxSteps() {
			return maxSteps;
		},

		get showCoordinateGrid() {
			return $.get(showCoordinateGrid);
		},

		set showCoordinateGrid(value) {
			$.set(showCoordinateGrid, value, true);
		},

		get showHandPoints() {
			return $.get(showHandPoints);
		},

		set showHandPoints(value) {
			$.set(showHandPoints, value, true);
		},

		get showLayer2Points() {
			return $.get(showLayer2Points);
		},

		set showLayer2Points(value) {
			$.set(showLayer2Points, value, true);
		},

		get showAdjustmentVectors() {
			return $.get(showAdjustmentVectors);
		},

		set showAdjustmentVectors(value) {
			$.set(showAdjustmentVectors, value, true);
		},

		get isCalculating() {
			return $.get(isCalculating);
		},

		get autoUpdate() {
			return $.get(autoUpdate);
		},

		set autoUpdate(value) {
			$.set(autoUpdate, value, true);
		},

		get expandedSections() {
			return $.get(expandedSections);
		},

		get currentDebugData() {
			return currentDebugData;
		},

		// Grid mode properties
		get gridMode() {
			return $.get(gridMode);
		},

		set gridMode(value) {
			setGridMode(value);
		},

		// Computed
		get currentMotionData() {
			return $.get(currentMotionData);
		},

		get currentArrowData() {
			return $.get(currentArrowData);
		},

		get currentStepData() {
			return getCurrentStepData();
		},

		get currentStepName() {
			return getCurrentStepName();
		},

		// Actions
		toggleSection,

		setGridMode,
		calculatePositioning,
		initializeRealData,
		getCurrentStepData,
		getCurrentStepName
	};
}
//# sourceMappingURL=data:application/json;base64,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QkFBbUI7VUFDZDtFQUNUOzs7TUFHSSxXQUFXO2dCQUNOO0VBQ1Q7O01BQ0ksU0FBUyxPQUEwQjtHQUNyQyxZQUFZLEtBQUs7RUFDbkI7OztNQUdJLG9CQUFvQjtnQkFDZjtFQUNUOztNQUNJLG1CQUFtQjtnQkFDZDtFQUNUOztNQUNJLGtCQUFrQjtVQUNiO0VBQ1Q7O01BQ0ksa0JBQWtCO1VBQ2I7RUFDVDs7O0VBR0E7O0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFSiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiZGVidWctc3RhdGUuc3ZlbHRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXJyb3cgRGVidWcgU3RhdGUgSW50ZWdyYXRpb25cbiAqIFByb3ZpZGVzIGEgc2ltcGxlciBpbnRlcmZhY2UgdG8gdGhlIGV4aXN0aW5nIGFycm93IGRlYnVnIHN0YXRlXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBQaWN0b2dyYXBoRGF0YSB9IGZyb20gXCIkbGliL2RvbWFpblwiO1xuaW1wb3J0IHsgY3JlYXRlUGljdG9ncmFwaERhdGEgfSBmcm9tIFwiJGxpYi9kb21haW4vUGljdG9ncmFwaERhdGFcIjtcbmltcG9ydCB7IGNyZWF0ZUdyaWREYXRhIH0gZnJvbSBcIiRsaWIvZG9tYWluL0dyaWREYXRhXCI7XG5pbXBvcnQgeyBHcmlkTW9kZSwgTG9jYXRpb24gfSBmcm9tIFwiJGxpYi9kb21haW4vZW51bXNcIjtcbmltcG9ydCB0eXBlIHsgRGVidWdTdGVwRGF0YSB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbi8vIEltcG9ydCByZWFsIGRhdGEgc2VydmljZXNcbmltcG9ydCB7IENvZGV4U2VydmljZSB9IGZyb20gXCIkbGliL3NlcnZpY2VzL2NvZGV4L0NvZGV4U2VydmljZVwiO1xuXG4vLyBJbXBvcnQgcmVhbCBhcnJvdyBwb3NpdGlvbmluZyBzZXJ2aWNlc1xuLy8gaW1wb3J0IHsgQXJyb3dQb3NpdGlvbmluZ09yY2hlc3RyYXRvciB9IGZyb20gXCIkbGliL3NlcnZpY2VzL3Bvc2l0aW9uaW5nL2Fycm93cy9vcmNoZXN0cmF0aW9uL0Fycm93UG9zaXRpb25pbmdPcmNoZXN0cmF0b3JcIjtcbmltcG9ydCB7IEFycm93TG9jYXRpb25DYWxjdWxhdG9yIH0gZnJvbSBcIiRsaWIvc2VydmljZXMvcG9zaXRpb25pbmcvYXJyb3dzL2NhbGN1bGF0aW9uL0Fycm93TG9jYXRpb25DYWxjdWxhdG9yXCI7XG5pbXBvcnQgeyBBcnJvd0Nvb3JkaW5hdGVTeXN0ZW1TZXJ2aWNlIH0gZnJvbSBcIiRsaWIvc2VydmljZXMvcG9zaXRpb25pbmcvYXJyb3dzL2Nvb3JkaW5hdGVfc3lzdGVtL0Fycm93Q29vcmRpbmF0ZVN5c3RlbVNlcnZpY2VcIjtcbmltcG9ydCB7IEFycm93Um90YXRpb25DYWxjdWxhdG9yIH0gZnJvbSBcIiRsaWIvc2VydmljZXMvcG9zaXRpb25pbmcvYXJyb3dzL2NhbGN1bGF0aW9uL0Fycm93Um90YXRpb25DYWxjdWxhdG9yXCI7XG5pbXBvcnQgeyBBcnJvd0FkanVzdG1lbnRDYWxjdWxhdG9yIH0gZnJvbSBcIiRsaWIvc2VydmljZXMvcG9zaXRpb25pbmcvYXJyb3dzL2NhbGN1bGF0aW9uL0Fycm93QWRqdXN0bWVudENhbGN1bGF0b3JcIjtcblxuLy8gU2ltcGxlIHJlYWN0aXZlIHN0YXRlIGZvciB0aGUgZGVidWcgY29tcG9uZW50c1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURlYnVnU3RhdGUoKSB7XG4gIGxldCBzZWxlY3RlZFBpY3RvZ3JhcGggPSAkc3RhdGU8UGljdG9ncmFwaERhdGEgfCBudWxsPihudWxsKTtcbiAgbGV0IHNlbGVjdGVkQXJyb3dDb2xvciA9ICRzdGF0ZTxcInJlZFwiIHwgXCJibHVlXCI+KFwiYmx1ZVwiKTtcbiAgbGV0IGF2YWlsYWJsZVBpY3RvZ3JhcGhzID0gJHN0YXRlPFBpY3RvZ3JhcGhEYXRhW10+KFtdKTtcblxuICBsZXQgc3RlcEJ5U3RlcE1vZGUgPSAkc3RhdGUodHJ1ZSk7XG4gIGxldCBjdXJyZW50U3RlcCA9ICRzdGF0ZSgwKTtcbiAgY29uc3QgbWF4U3RlcHMgPSAkc3RhdGUoNCk7IC8vIDA6IElucHV0LCAxOiBMb2NhdGlvbiwgMjogQ29vcmRpbmF0ZSBTeXN0ZW0sIDM6IFJvdGF0aW9uLCA0OiBBZGp1c3RtZW50c1xuXG4gIGxldCBzaG93Q29vcmRpbmF0ZUdyaWQgPSAkc3RhdGUodHJ1ZSk7XG4gIGxldCBzaG93SGFuZFBvaW50cyA9ICRzdGF0ZSh0cnVlKTtcbiAgbGV0IHNob3dMYXllcjJQb2ludHMgPSAkc3RhdGUodHJ1ZSk7XG4gIGxldCBzaG93QWRqdXN0bWVudFZlY3RvcnMgPSAkc3RhdGUodHJ1ZSk7XG5cbiAgbGV0IGlzQ2FsY3VsYXRpbmcgPSAkc3RhdGUoZmFsc2UpO1xuICBsZXQgYXV0b1VwZGF0ZSA9ICRzdGF0ZSh0cnVlKTtcblxuICAvLyBHcmlkIG1vZGUgc3RhdGUgKGRpYW1vbmQvYm94IHRvZ2dsZSlcbiAgbGV0IGdyaWRNb2RlID0gJHN0YXRlPFwiZGlhbW9uZFwiIHwgXCJib3hcIj4oXCJkaWFtb25kXCIpO1xuXG4gIGxldCBleHBhbmRlZFNlY3Rpb25zID0gJHN0YXRlKFxuICAgIG5ldyBTZXQoW1wiaW5wdXRfZGF0YVwiLCBcImxvY2F0aW9uX2NhbGN1bGF0aW9uXCJdKVxuICApO1xuXG4gIC8vIEluaXRpYWxpemUgcmVhbCBkYXRhIHNlcnZpY2VzXG4gIC8vIFRPRE86IFVzZSBESSBjb250YWluZXIgdG8gcmVzb2x2ZSBDb2RleFNlcnZpY2UgaW5zdGVhZCBvZiBkaXJlY3QgaW5zdGFudGlhdGlvblxuICAvLyBjb25zdCBjb2RleFNlcnZpY2UgPSBuZXcgQ29kZXhTZXJ2aWNlKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSByZWFsIGFycm93IHBvc2l0aW9uaW5nIHNlcnZpY2VzXG4gIGNvbnN0IGxvY2F0aW9uQ2FsY3VsYXRvciA9IG5ldyBBcnJvd0xvY2F0aW9uQ2FsY3VsYXRvcigpO1xuICBjb25zdCByb3RhdGlvbkNhbGN1bGF0b3IgPSBuZXcgQXJyb3dSb3RhdGlvbkNhbGN1bGF0b3IoKTtcbiAgY29uc3QgYWRqdXN0bWVudENhbGN1bGF0b3IgPSBuZXcgQXJyb3dBZGp1c3RtZW50Q2FsY3VsYXRvcigpO1xuICBjb25zdCBjb29yZGluYXRlU3lzdGVtU2VydmljZSA9IG5ldyBBcnJvd0Nvb3JkaW5hdGVTeXN0ZW1TZXJ2aWNlKCk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBvcmNoZXN0cmF0b3Igd2l0aCByZWFsIHNlcnZpY2VzXG4gIC8vIE5vdGU6IEN1cnJlbnRseSB1bnVzZWQgYnV0IGtlcHQgZm9yIGZ1dHVyZSBkZWJ1Z2dpbmcgZmVhdHVyZXNcbiAgLy8gY29uc3QgX2Fycm93UG9zaXRpb25pbmdPcmNoZXN0cmF0b3IgPSBuZXcgQXJyb3dQb3NpdGlvbmluZ09yY2hlc3RyYXRvcihcbiAgLy8gICBsb2NhdGlvbkNhbGN1bGF0b3IsXG4gIC8vICAgcm90YXRpb25DYWxjdWxhdG9yLFxuICAvLyAgIGFkanVzdG1lbnRDYWxjdWxhdG9yLFxuICAvLyAgIGNvb3JkaW5hdGVTeXN0ZW1TZXJ2aWNlXG4gIC8vICk7XG5cbiAgLy8gQ3JlYXRlIGRlYnVnIGRhdGEgd2l0aCBwcm9wZXIgc3RydWN0dXJlXG4gIGNvbnN0IGN1cnJlbnREZWJ1Z0RhdGEgPSAkc3RhdGU8RGVidWdTdGVwRGF0YT4oe1xuICAgIHBpY3RvZ3JhcGhEYXRhOiBudWxsLFxuICAgIG1vdGlvbkRhdGE6IG51bGwsXG4gICAgYXJyb3dEYXRhOiBudWxsLFxuICAgIGNhbGN1bGF0ZWRMb2NhdGlvbjogbnVsbCxcbiAgICBsb2NhdGlvbkRlYnVnSW5mbzogbnVsbCxcbiAgICBpbml0aWFsUG9zaXRpb246IG51bGwsXG4gICAgY29vcmRpbmF0ZVN5c3RlbURlYnVnSW5mbzogbnVsbCxcbiAgICBkZWZhdWx0QWRqdXN0bWVudDogbnVsbCxcbiAgICBkZWZhdWx0QWRqdXN0bWVudERlYnVnSW5mbzogbnVsbCxcbiAgICBzcGVjaWFsQWRqdXN0bWVudDogbnVsbCxcbiAgICBzcGVjaWFsQWRqdXN0bWVudERlYnVnSW5mbzogbnVsbCxcbiAgICB0dXBsZVByb2Nlc3NlZEFkanVzdG1lbnQ6IG51bGwsXG4gICAgdHVwbGVQcm9jZXNzaW5nRGVidWdJbmZvOiBudWxsLFxuICAgIGZpbmFsUG9zaXRpb246IG51bGwsXG4gICAgZmluYWxSb3RhdGlvbjogMCxcbiAgICBlcnJvcnM6IFtdLFxuICAgIHRpbWluZzogbnVsbCxcbiAgfSk7XG5cbiAgLy8gQ29tcHV0ZWQgdmFsdWVzXG4gIGNvbnN0IGN1cnJlbnRNb3Rpb25EYXRhID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgIGlmICghc2VsZWN0ZWRQaWN0b2dyYXBoPy5tb3Rpb25zKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gc2VsZWN0ZWRQaWN0b2dyYXBoLm1vdGlvbnNbc2VsZWN0ZWRBcnJvd0NvbG9yXSB8fCBudWxsO1xuICB9KTtcblxuICBjb25zdCBjdXJyZW50QXJyb3dEYXRhID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgIGlmICghc2VsZWN0ZWRQaWN0b2dyYXBoPy5hcnJvd3MpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBzZWxlY3RlZFBpY3RvZ3JhcGguYXJyb3dzW3NlbGVjdGVkQXJyb3dDb2xvcl0gfHwgbnVsbDtcbiAgfSk7XG5cbiAgLy8gTG9hZCByZWFsIHBpY3RvZ3JhcGhzIGZyb20gY29kZXggc2VydmljZVxuICBhc3luYyBmdW5jdGlvbiBsb2FkUmVhbFBpY3RvZ3JhcGhzKCk6IFByb21pc2U8UGljdG9ncmFwaERhdGFbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIvCflKcgTG9hZGluZyByZWFsIHBpY3RvZ3JhcGhzIGZyb20gQ29kZXhTZXJ2aWNlLi4uXCIpO1xuXG4gICAgICAvLyBUT0RPOiBMb2FkIGFsbCBwaWN0b2dyYXBocyBmcm9tIHRoZSBjb2RleCBzZXJ2aWNlIHZpYSBESSBjb250YWluZXJcbiAgICAgIC8vIGNvbnN0IGFsbFBpY3RvZ3JhcGhzID0gYXdhaXQgY29kZXhTZXJ2aWNlLmxvYWRBbGxQaWN0b2dyYXBocygpO1xuICAgICAgY29uc3QgYWxsUGljdG9ncmFwaHM6IGFueVtdID0gW107IC8vIFRlbXBvcmFyeSBwbGFjZWhvbGRlclxuXG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYOKchSBMb2FkZWQgJHthbGxQaWN0b2dyYXBocy5sZW5ndGh9IHJlYWwgcGljdG9ncmFwaHMgZnJvbSBDU1YgZGF0YWBcbiAgICAgICk7XG4gICAgICByZXR1cm4gYWxsUGljdG9ncmFwaHM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRmFpbGVkIHRvIGxvYWQgcmVhbCBwaWN0b2dyYXBoczpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgd2l0aCByZWFsIGRhdGFcbiAgYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZVJlYWxEYXRhKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIvCfmoAgSW5pdGlhbGl6aW5nIEFycm93IERlYnVnIHdpdGggcmVhbCBwaWN0b2dyYXBoIGRhdGEuLi5cIik7XG5cbiAgICAgIC8vIExvYWQgcmVhbCBwaWN0b2dyYXBocyBmcm9tIENTViBkYXRhXG4gICAgICBjb25zdCByZWFsUGljdG9ncmFwaHMgPSBhd2FpdCBsb2FkUmVhbFBpY3RvZ3JhcGhzKCk7XG4gICAgICBhdmFpbGFibGVQaWN0b2dyYXBocyA9IHJlYWxQaWN0b2dyYXBocztcblxuICAgICAgaWYgKHJlYWxQaWN0b2dyYXBocy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlbGVjdGVkUGljdG9ncmFwaCA9IHJlYWxQaWN0b2dyYXBoc1swXTtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYOKchSBTZWxlY3RlZCBmaXJzdCBwaWN0b2dyYXBoOiAke3NlbGVjdGVkUGljdG9ncmFwaC5sZXR0ZXIgfHwgc2VsZWN0ZWRQaWN0b2dyYXBoLmlkfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBGYWlsZWQgdG8gaW5pdGlhbGl6ZSByZWFsIGRhdGE6XCIsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvLyBUb2dnbGUgc2VjdGlvbiBleHBhbnNpb25cbiAgZnVuY3Rpb24gdG9nZ2xlU2VjdGlvbihzZWN0aW9uOiBzdHJpbmcpIHtcbiAgICBpZiAoZXhwYW5kZWRTZWN0aW9ucy5oYXMoc2VjdGlvbikpIHtcbiAgICAgIGV4cGFuZGVkU2VjdGlvbnMuZGVsZXRlKHNlY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBhbmRlZFNlY3Rpb25zLmFkZChzZWN0aW9uKTtcbiAgICB9XG4gICAgLy8gVHJpZ2dlciByZWFjdGl2aXR5XG4gICAgZXhwYW5kZWRTZWN0aW9ucyA9IG5ldyBTZXQoZXhwYW5kZWRTZWN0aW9ucyk7XG4gIH1cblxuICAvLyBTZXQgZ3JpZCBtb2RlIGFuZCB1cGRhdGUgcGljdG9ncmFwaCBkYXRhXG4gIGZ1bmN0aW9uIHNldEdyaWRNb2RlKG1vZGU6IFwiZGlhbW9uZFwiIHwgXCJib3hcIikge1xuICAgIGdyaWRNb2RlID0gbW9kZTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgc2VsZWN0ZWQgcGljdG9ncmFwaCdzIGdyaWQgZGF0YSBpZiBpdCBleGlzdHNcbiAgICBpZiAoc2VsZWN0ZWRQaWN0b2dyYXBoKSB7XG4gICAgICBjb25zdCBuZXdHcmlkTW9kZSA9IG1vZGUgPT09IFwiZGlhbW9uZFwiID8gR3JpZE1vZGUuRElBTU9ORCA6IEdyaWRNb2RlLkJPWDtcbiAgICAgIHNlbGVjdGVkUGljdG9ncmFwaCA9IGNyZWF0ZVBpY3RvZ3JhcGhEYXRhKHtcbiAgICAgICAgLi4uc2VsZWN0ZWRQaWN0b2dyYXBoLFxuICAgICAgICBncmlkRGF0YTogY3JlYXRlR3JpZERhdGEoeyBncmlkTW9kZTogbmV3R3JpZE1vZGUgfSksXG4gICAgICB9KTtcblxuICAgICAgLy8gVHJpZ2dlciByZWNhbGN1bGF0aW9uIGlmIGF1dG8tdXBkYXRlIGlzIGVuYWJsZWRcbiAgICAgIGlmIChhdXRvVXBkYXRlKSB7XG4gICAgICAgIGNhbGN1bGF0ZVBvc2l0aW9uaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IHN0ZXAtYnktc3RlcCBkYXRhIGZvciBjdXJyZW50IHN0ZXBcbiAgZnVuY3Rpb24gZ2V0Q3VycmVudFN0ZXBEYXRhKCkge1xuICAgIGlmICghc3RlcEJ5U3RlcE1vZGUpIHtcbiAgICAgIHJldHVybiBjdXJyZW50RGVidWdEYXRhO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgZGVidWcgZGF0YSBzaG93aW5nIG9ubHkgdXAgdG8gY3VycmVudCBzdGVwXG4gICAgY29uc3Qgc3RlcERhdGEgPSB7XG4gICAgICAuLi5jdXJyZW50RGVidWdEYXRhLFxuICAgICAgLy8gUmVzZXQgZnV0dXJlIHN0ZXBzIGJhc2VkIG9uIGN1cnJlbnQgc3RlcFxuICAgICAgY2FsY3VsYXRlZExvY2F0aW9uOlxuICAgICAgICBjdXJyZW50U3RlcCA+PSAxID8gY3VycmVudERlYnVnRGF0YS5jYWxjdWxhdGVkTG9jYXRpb24gOiBudWxsLFxuICAgICAgbG9jYXRpb25EZWJ1Z0luZm86XG4gICAgICAgIGN1cnJlbnRTdGVwID49IDEgPyBjdXJyZW50RGVidWdEYXRhLmxvY2F0aW9uRGVidWdJbmZvIDogbnVsbCxcbiAgICAgIGluaXRpYWxQb3NpdGlvbjpcbiAgICAgICAgY3VycmVudFN0ZXAgPj0gMiA/IGN1cnJlbnREZWJ1Z0RhdGEuaW5pdGlhbFBvc2l0aW9uIDogbnVsbCxcbiAgICAgIGNvb3JkaW5hdGVTeXN0ZW1EZWJ1Z0luZm86XG4gICAgICAgIGN1cnJlbnRTdGVwID49IDIgPyBjdXJyZW50RGVidWdEYXRhLmNvb3JkaW5hdGVTeXN0ZW1EZWJ1Z0luZm8gOiBudWxsLFxuICAgICAgZmluYWxSb3RhdGlvbjogY3VycmVudFN0ZXAgPj0gMyA/IGN1cnJlbnREZWJ1Z0RhdGEuZmluYWxSb3RhdGlvbiA6IDAsXG4gICAgICBkZWZhdWx0QWRqdXN0bWVudDpcbiAgICAgICAgY3VycmVudFN0ZXAgPj0gNCA/IGN1cnJlbnREZWJ1Z0RhdGEuZGVmYXVsdEFkanVzdG1lbnQgOiBudWxsLFxuICAgICAgZmluYWxQb3NpdGlvbjogY3VycmVudFN0ZXAgPj0gNCA/IGN1cnJlbnREZWJ1Z0RhdGEuZmluYWxQb3NpdGlvbiA6IG51bGwsXG4gICAgfTtcblxuICAgIHJldHVybiBzdGVwRGF0YTtcbiAgfVxuXG4gIC8vIEdldCBzdGVwIG5hbWUgZm9yIGN1cnJlbnQgc3RlcFxuICBmdW5jdGlvbiBnZXRDdXJyZW50U3RlcE5hbWUoKTogc3RyaW5nIHtcbiAgICBjb25zdCBzdGVwTmFtZXMgPSBbXG4gICAgICBcIklucHV0IERhdGFcIixcbiAgICAgIFwiTG9jYXRpb24gQ2FsY3VsYXRpb25cIixcbiAgICAgIFwiQ29vcmRpbmF0ZSBTeXN0ZW1cIixcbiAgICAgIFwiUm90YXRpb24gQ2FsY3VsYXRpb25cIixcbiAgICAgIFwiQWRqdXN0bWVudCBDYWxjdWxhdGlvblwiLFxuICAgIF07XG4gICAgcmV0dXJuIHN0ZXBOYW1lc1tjdXJyZW50U3RlcF0gfHwgXCJVbmtub3duIFN0ZXBcIjtcbiAgfVxuXG4gIC8vIFJlYWwgcG9zaXRpb25pbmcgY2FsY3VsYXRpb24gdXNpbmcgYXJyb3cgcG9zaXRpb25pbmcgc2VydmljZXNcbiAgYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25pbmcoKSB7XG4gICAgaWYgKCFzZWxlY3RlZFBpY3RvZ3JhcGggfHwgIWN1cnJlbnRNb3Rpb25EYXRhIHx8ICFjdXJyZW50QXJyb3dEYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNDYWxjdWxhdGluZyA9IHRydWU7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3Qgc3RlcFRpbWVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG5cbiAgICB0cnkge1xuICAgICAgLy8gQ2xlYXIgcHJldmlvdXMgZXJyb3JzXG4gICAgICBjdXJyZW50RGVidWdEYXRhLmVycm9ycyA9IFtdO1xuXG4gICAgICAvLyBVcGRhdGUgZGVidWcgZGF0YSB3aXRoIGN1cnJlbnQgaW5wdXRzXG4gICAgICBjdXJyZW50RGVidWdEYXRhLnBpY3RvZ3JhcGhEYXRhID0gc2VsZWN0ZWRQaWN0b2dyYXBoO1xuICAgICAgY3VycmVudERlYnVnRGF0YS5tb3Rpb25EYXRhID0gY3VycmVudE1vdGlvbkRhdGE7XG4gICAgICBjdXJyZW50RGVidWdEYXRhLmFycm93RGF0YSA9IGN1cnJlbnRBcnJvd0RhdGE7XG5cbiAgICAgIC8vIFNURVAgMTogQ2FsY3VsYXRlIGFycm93IGxvY2F0aW9uXG4gICAgICBjb25zdCBsb2NhdGlvblN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjYWxjdWxhdGVkTG9jYXRpb24gPSBsb2NhdGlvbkNhbGN1bGF0b3IuY2FsY3VsYXRlTG9jYXRpb24oXG4gICAgICAgICAgY3VycmVudE1vdGlvbkRhdGEsXG4gICAgICAgICAgc2VsZWN0ZWRQaWN0b2dyYXBoXG4gICAgICAgICk7XG4gICAgICAgIGN1cnJlbnREZWJ1Z0RhdGEuY2FsY3VsYXRlZExvY2F0aW9uID0gY2FsY3VsYXRlZExvY2F0aW9uO1xuICAgICAgICBjdXJyZW50RGVidWdEYXRhLmxvY2F0aW9uRGVidWdJbmZvID0ge1xuICAgICAgICAgIG1vdGlvblR5cGU6IGN1cnJlbnRNb3Rpb25EYXRhLm1vdGlvblR5cGUgfHwgXCJcIixcbiAgICAgICAgICBzdGFydE9yaWVudGF0aW9uOiBjdXJyZW50TW90aW9uRGF0YS5zdGFydE9yaWVudGF0aW9uIHx8IFwiXCIsXG4gICAgICAgICAgZW5kT3JpZW50YXRpb246IGN1cnJlbnRNb3Rpb25EYXRhLmVuZE9yaWVudGF0aW9uIHx8IFwiXCIsXG4gICAgICAgICAgY2FsY3VsYXRpb25NZXRob2Q6IFwiQXJyb3dMb2NhdGlvbkNhbGN1bGF0b3JcIixcbiAgICAgICAgfTtcbiAgICAgICAgc3RlcFRpbWVzLmxvY2F0aW9uX2NhbGN1bGF0aW9uID0gcGVyZm9ybWFuY2Uubm93KCkgLSBsb2NhdGlvblN0YXJ0O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY3VycmVudERlYnVnRGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgc3RlcDogXCJsb2NhdGlvbl9jYWxjdWxhdGlvblwiLFxuICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU1RFUCAyOiBHZXQgaW5pdGlhbCBwb3NpdGlvbiBmcm9tIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICBjb25zdCBjb29yZGluYXRlU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChjdXJyZW50RGVidWdEYXRhLmNhbGN1bGF0ZWRMb2NhdGlvbikge1xuICAgICAgICAgIGNvbnN0IGluaXRpYWxQb3NpdGlvbiA9IGNvb3JkaW5hdGVTeXN0ZW1TZXJ2aWNlLmdldEluaXRpYWxQb3NpdGlvbihcbiAgICAgICAgICAgIGN1cnJlbnRNb3Rpb25EYXRhLFxuICAgICAgICAgICAgY3VycmVudERlYnVnRGF0YS5jYWxjdWxhdGVkTG9jYXRpb24gYXMgTG9jYXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIGN1cnJlbnREZWJ1Z0RhdGEuaW5pdGlhbFBvc2l0aW9uID0gaW5pdGlhbFBvc2l0aW9uO1xuXG4gICAgICAgICAgY29uc3Qgc2NlbmVDZW50ZXIgPSBjb29yZGluYXRlU3lzdGVtU2VydmljZS5nZXRTY2VuZUNlbnRlcigpO1xuICAgICAgICAgIGNvbnN0IHNjZW5lRGltZW5zaW9ucyA9IGNvb3JkaW5hdGVTeXN0ZW1TZXJ2aWNlLmdldFNjZW5lRGltZW5zaW9ucygpO1xuICAgICAgICAgIGNvbnN0IGhhbmRQb2ludHMgPSBjb29yZGluYXRlU3lzdGVtU2VydmljZS5nZXRBbGxIYW5kUG9pbnRzKCk7XG4gICAgICAgICAgY29uc3QgbGF5ZXIyUG9pbnRzID0gY29vcmRpbmF0ZVN5c3RlbVNlcnZpY2UuZ2V0QWxsTGF5ZXIyUG9pbnRzKCk7XG5cbiAgICAgICAgICBjdXJyZW50RGVidWdEYXRhLmNvb3JkaW5hdGVTeXN0ZW1EZWJ1Z0luZm8gPSB7XG4gICAgICAgICAgICBzY2VuZUNlbnRlcixcbiAgICAgICAgICAgIHNjZW5lRGltZW5zaW9ucyxcbiAgICAgICAgICAgIGhhbmRQb2ludHMsXG4gICAgICAgICAgICBsYXllcjJQb2ludHMsXG4gICAgICAgICAgICB1c2VkQ29vcmRpbmF0ZVNldDpcbiAgICAgICAgICAgICAgY3VycmVudE1vdGlvbkRhdGEubW90aW9uVHlwZSA9PT0gXCJzdGF0aWNcIiB8fFxuICAgICAgICAgICAgICBjdXJyZW50TW90aW9uRGF0YS5tb3Rpb25UeXBlID09PSBcImRhc2hcIlxuICAgICAgICAgICAgICAgID8gXCJoYW5kX3BvaW50c1wiXG4gICAgICAgICAgICAgICAgOiBcImxheWVyMl9wb2ludHNcIixcbiAgICAgICAgICAgIGNvb3JkaW5hdGVTeXN0ZW1UeXBlOiBcIlRLQV85NTB4OTUwXCIsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwVGltZXMuY29vcmRpbmF0ZV9zeXN0ZW0gPSBwZXJmb3JtYW5jZS5ub3coKSAtIGNvb3JkaW5hdGVTdGFydDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGN1cnJlbnREZWJ1Z0RhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIHN0ZXA6IFwiY29vcmRpbmF0ZV9zeXN0ZW1cIixcbiAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNURVAgMzogQ2FsY3VsYXRlIHJvdGF0aW9uXG4gICAgICBjb25zdCByb3RhdGlvblN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoY3VycmVudERlYnVnRGF0YS5jYWxjdWxhdGVkTG9jYXRpb24pIHtcbiAgICAgICAgICBjb25zdCByb3RhdGlvbiA9IHJvdGF0aW9uQ2FsY3VsYXRvci5jYWxjdWxhdGVSb3RhdGlvbihcbiAgICAgICAgICAgIGN1cnJlbnRNb3Rpb25EYXRhLFxuICAgICAgICAgICAgY3VycmVudERlYnVnRGF0YS5jYWxjdWxhdGVkTG9jYXRpb24gYXMgTG9jYXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIGN1cnJlbnREZWJ1Z0RhdGEuZmluYWxSb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXBUaW1lcy5yb3RhdGlvbl9jYWxjdWxhdGlvbiA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcm90YXRpb25TdGFydDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGN1cnJlbnREZWJ1Z0RhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIHN0ZXA6IFwicm90YXRpb25fY2FsY3VsYXRpb25cIixcbiAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNURVAgNDogQ2FsY3VsYXRlIGFkanVzdG1lbnRzXG4gICAgICBjb25zdCBhZGp1c3RtZW50U3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChjdXJyZW50RGVidWdEYXRhLmNhbGN1bGF0ZWRMb2NhdGlvbikge1xuICAgICAgICAgIGNvbnN0IGFkanVzdG1lbnQgPSBhd2FpdCBhZGp1c3RtZW50Q2FsY3VsYXRvci5jYWxjdWxhdGVBZGp1c3RtZW50KFxuICAgICAgICAgICAgc2VsZWN0ZWRQaWN0b2dyYXBoLFxuICAgICAgICAgICAgY3VycmVudE1vdGlvbkRhdGEsXG4gICAgICAgICAgICBzZWxlY3RlZFBpY3RvZ3JhcGgubGV0dGVyIHx8IFwiQVwiLFxuICAgICAgICAgICAgY3VycmVudERlYnVnRGF0YS5jYWxjdWxhdGVkTG9jYXRpb24gYXMgTG9jYXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIGN1cnJlbnREZWJ1Z0RhdGEuZGVmYXVsdEFkanVzdG1lbnQgPSBhZGp1c3RtZW50O1xuXG4gICAgICAgICAgLy8gRm9yIG5vdywgdXNlIHRoZSBhZGp1c3RtZW50IGFzIGZpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgLy8gSW4gYSBtb3JlIHNvcGhpc3RpY2F0ZWQgaW1wbGVtZW50YXRpb24sIHdlJ2QgYXBwbHkgaXQgdG8gdGhlIGluaXRpYWwgcG9zaXRpb25cbiAgICAgICAgICBpZiAoY3VycmVudERlYnVnRGF0YS5pbml0aWFsUG9zaXRpb24gJiYgYWRqdXN0bWVudCkge1xuICAgICAgICAgICAgY3VycmVudERlYnVnRGF0YS5maW5hbFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICB4OiBjdXJyZW50RGVidWdEYXRhLmluaXRpYWxQb3NpdGlvbi54ICsgYWRqdXN0bWVudC54LFxuICAgICAgICAgICAgICB5OiBjdXJyZW50RGVidWdEYXRhLmluaXRpYWxQb3NpdGlvbi55ICsgYWRqdXN0bWVudC55LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudERlYnVnRGF0YS5maW5hbFBvc2l0aW9uID0gY3VycmVudERlYnVnRGF0YS5pbml0aWFsUG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ZXBUaW1lcy5hZGp1c3RtZW50X2NhbGN1bGF0aW9uID0gcGVyZm9ybWFuY2Uubm93KCkgLSBhZGp1c3RtZW50U3RhcnQ7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjdXJyZW50RGVidWdEYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBzdGVwOiBcImFkanVzdG1lbnRfY2FsY3VsYXRpb25cIixcbiAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0b3RhbCB0aW1pbmdcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGN1cnJlbnREZWJ1Z0RhdGEudGltaW5nID0ge1xuICAgICAgICB0b3RhbER1cmF0aW9uOiBlbmRUaW1lIC0gc3RhcnRUaW1lLFxuICAgICAgICBzdGVwRHVyYXRpb25zOiBzdGVwVGltZXMsXG4gICAgICB9O1xuXG4gICAgICBjb25zb2xlLmxvZyhcIvCfjq8gQXJyb3cgcG9zaXRpb25pbmcgY2FsY3VsYXRpb24gY29tcGxldGVkOlwiLCB7XG4gICAgICAgIGxvY2F0aW9uOiBjdXJyZW50RGVidWdEYXRhLmNhbGN1bGF0ZWRMb2NhdGlvbixcbiAgICAgICAgaW5pdGlhbFBvc2l0aW9uOiBjdXJyZW50RGVidWdEYXRhLmluaXRpYWxQb3NpdGlvbixcbiAgICAgICAgZmluYWxQb3NpdGlvbjogY3VycmVudERlYnVnRGF0YS5maW5hbFBvc2l0aW9uLFxuICAgICAgICByb3RhdGlvbjogY3VycmVudERlYnVnRGF0YS5maW5hbFJvdGF0aW9uLFxuICAgICAgICBlcnJvcnM6IGN1cnJlbnREZWJ1Z0RhdGEuZXJyb3JzLFxuICAgICAgICB0aW1pbmc6IGN1cnJlbnREZWJ1Z0RhdGEudGltaW5nLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGN1cnJlbnREZWJ1Z0RhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICBzdGVwOiBcIm92ZXJhbGxfY2FsY3VsYXRpb25cIixcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzQ2FsY3VsYXRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBBdXRvLXVwZGF0ZSBlZmZlY3RcbiAgJGVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKFxuICAgICAgYXV0b1VwZGF0ZSAmJlxuICAgICAgc2VsZWN0ZWRQaWN0b2dyYXBoICYmXG4gICAgICBjdXJyZW50TW90aW9uRGF0YSAmJlxuICAgICAgY3VycmVudEFycm93RGF0YVxuICAgICkge1xuICAgICAgY2FsY3VsYXRlUG9zaXRpb25pbmcoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgLy8gU3RhdGVcbiAgICBnZXQgc2VsZWN0ZWRQaWN0b2dyYXBoKCkge1xuICAgICAgcmV0dXJuIHNlbGVjdGVkUGljdG9ncmFwaDtcbiAgICB9LFxuICAgIHNldCBzZWxlY3RlZFBpY3RvZ3JhcGgodmFsdWU6IFBpY3RvZ3JhcGhEYXRhIHwgbnVsbCkge1xuICAgICAgc2VsZWN0ZWRQaWN0b2dyYXBoID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldCBzZWxlY3RlZEFycm93Q29sb3IoKSB7XG4gICAgICByZXR1cm4gc2VsZWN0ZWRBcnJvd0NvbG9yO1xuICAgIH0sXG4gICAgc2V0IHNlbGVjdGVkQXJyb3dDb2xvcih2YWx1ZTogXCJyZWRcIiB8IFwiYmx1ZVwiKSB7XG4gICAgICBzZWxlY3RlZEFycm93Q29sb3IgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0IGF2YWlsYWJsZVBpY3RvZ3JhcGhzKCkge1xuICAgICAgcmV0dXJuIGF2YWlsYWJsZVBpY3RvZ3JhcGhzO1xuICAgIH0sXG4gICAgc2V0IGF2YWlsYWJsZVBpY3RvZ3JhcGhzKHZhbHVlOiBQaWN0b2dyYXBoRGF0YVtdKSB7XG4gICAgICBhdmFpbGFibGVQaWN0b2dyYXBocyA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXQgc3RlcEJ5U3RlcE1vZGUoKSB7XG4gICAgICByZXR1cm4gc3RlcEJ5U3RlcE1vZGU7XG4gICAgfSxcbiAgICBzZXQgc3RlcEJ5U3RlcE1vZGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgIHN0ZXBCeVN0ZXBNb2RlID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldCBjdXJyZW50U3RlcCgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50U3RlcDtcbiAgICB9LFxuICAgIHNldCBjdXJyZW50U3RlcCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICBjdXJyZW50U3RlcCA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXQgbWF4U3RlcHMoKSB7XG4gICAgICByZXR1cm4gbWF4U3RlcHM7XG4gICAgfSxcblxuICAgIGdldCBzaG93Q29vcmRpbmF0ZUdyaWQoKSB7XG4gICAgICByZXR1cm4gc2hvd0Nvb3JkaW5hdGVHcmlkO1xuICAgIH0sXG4gICAgc2V0IHNob3dDb29yZGluYXRlR3JpZCh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgc2hvd0Nvb3JkaW5hdGVHcmlkID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldCBzaG93SGFuZFBvaW50cygpIHtcbiAgICAgIHJldHVybiBzaG93SGFuZFBvaW50cztcbiAgICB9LFxuICAgIHNldCBzaG93SGFuZFBvaW50cyh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgc2hvd0hhbmRQb2ludHMgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0IHNob3dMYXllcjJQb2ludHMoKSB7XG4gICAgICByZXR1cm4gc2hvd0xheWVyMlBvaW50cztcbiAgICB9LFxuICAgIHNldCBzaG93TGF5ZXIyUG9pbnRzKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICBzaG93TGF5ZXIyUG9pbnRzID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldCBzaG93QWRqdXN0bWVudFZlY3RvcnMoKSB7XG4gICAgICByZXR1cm4gc2hvd0FkanVzdG1lbnRWZWN0b3JzO1xuICAgIH0sXG4gICAgc2V0IHNob3dBZGp1c3RtZW50VmVjdG9ycyh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgc2hvd0FkanVzdG1lbnRWZWN0b3JzID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldCBpc0NhbGN1bGF0aW5nKCkge1xuICAgICAgcmV0dXJuIGlzQ2FsY3VsYXRpbmc7XG4gICAgfSxcbiAgICBnZXQgYXV0b1VwZGF0ZSgpIHtcbiAgICAgIHJldHVybiBhdXRvVXBkYXRlO1xuICAgIH0sXG4gICAgc2V0IGF1dG9VcGRhdGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgIGF1dG9VcGRhdGUgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0IGV4cGFuZGVkU2VjdGlvbnMoKSB7XG4gICAgICByZXR1cm4gZXhwYW5kZWRTZWN0aW9ucztcbiAgICB9LFxuICAgIGdldCBjdXJyZW50RGVidWdEYXRhKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnREZWJ1Z0RhdGE7XG4gICAgfSxcblxuICAgIC8vIEdyaWQgbW9kZSBwcm9wZXJ0aWVzXG4gICAgZ2V0IGdyaWRNb2RlKCkge1xuICAgICAgcmV0dXJuIGdyaWRNb2RlO1xuICAgIH0sXG4gICAgc2V0IGdyaWRNb2RlKHZhbHVlOiBcImRpYW1vbmRcIiB8IFwiYm94XCIpIHtcbiAgICAgIHNldEdyaWRNb2RlKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLy8gQ29tcHV0ZWRcbiAgICBnZXQgY3VycmVudE1vdGlvbkRhdGEoKSB7XG4gICAgICByZXR1cm4gY3VycmVudE1vdGlvbkRhdGE7XG4gICAgfSxcbiAgICBnZXQgY3VycmVudEFycm93RGF0YSgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50QXJyb3dEYXRhO1xuICAgIH0sXG4gICAgZ2V0IGN1cnJlbnRTdGVwRGF0YSgpIHtcbiAgICAgIHJldHVybiBnZXRDdXJyZW50U3RlcERhdGEoKTtcbiAgICB9LFxuICAgIGdldCBjdXJyZW50U3RlcE5hbWUoKSB7XG4gICAgICByZXR1cm4gZ2V0Q3VycmVudFN0ZXBOYW1lKCk7XG4gICAgfSxcblxuICAgIC8vIEFjdGlvbnNcbiAgICB0b2dnbGVTZWN0aW9uLFxuICAgIHNldEdyaWRNb2RlLFxuICAgIGNhbGN1bGF0ZVBvc2l0aW9uaW5nLFxuICAgIGluaXRpYWxpemVSZWFsRGF0YSxcbiAgICBnZXRDdXJyZW50U3RlcERhdGEsXG4gICAgZ2V0Q3VycmVudFN0ZXBOYW1lLFxuICB9O1xufVxuIl0sImZpbGUiOiJGOi9DT0RFL1RLQS93ZWIvc3JjL2xpYi9jb21wb25lbnRzL3RhYnMvYXJyb3ctZGVidWcvZGVidWctc3RhdGUuc3ZlbHRlLnRzIn0=