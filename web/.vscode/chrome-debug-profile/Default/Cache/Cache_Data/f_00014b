/* motion-tester-state.svelte.ts generated by Svelte v5.38.1 */
import * as $ from "/node_modules/.vite/deps/svelte_internal_client.js?v=de368f3a";
import { MotionParameterService } from "/src/routes/motion-tester/services/MotionParameterService.ts";
import { AnimationControlService } from "/src/routes/motion-tester/services/AnimationControlService.ts";
import { resolve } from "/src/lib/services/bootstrap.ts";
import { OrientationCalculationService } from "/src/lib/services/implementations/positioning/OrientationCalculationService.ts";
import { MotionType, MotionColor } from "/src/lib/domain/enums.ts";

export function createMotionTesterState() {
	const motionService = new MotionParameterService();
	const animationEngine = resolve("ISequenceAnimationEngine");
	const animationService = new AnimationControlService(animationEngine);
	const orientationService = new OrientationCalculationService();
	let blueMotionParams = $.tag($.state($.proxy(motionService.createDefaultParams())), 'blueMotionParams');

	let redMotionParams = $.tag(
		$.state($.proxy({
			...motionService.createDefaultParams(),
			startLocation: "e",
			endLocation: "w",
			motionType: MotionType.DASH
		})),
		'redMotionParams'
	);

	const propVisibility = $.tag_proxy($.proxy({ blue: true, red: true }), 'propVisibility');
	const animationState = $.tag_proxy($.proxy({ isPlaying: false, progress: 0, currentBeat: 0 }), 'animationState');
	let isEngineInitialized = $.tag($.state(false), 'isEngineInitialized');
	let gridType = $.tag($.state("diamond"), 'gridType');

	$.user_effect(() => {
		const { motionType, startLocation, endLocation, rotationDirection } = $.get(blueMotionParams);
		const newRotDir = motionService.calculateRotationDirection(motionType, startLocation, endLocation);

		if ($.strict_equals(newRotDir, rotationDirection, false)) {
			$.get(blueMotionParams).rotationDirection = newRotDir;
		}
	});

	$.user_effect(() => {
		const motionData = motionService.convertToMotionData($.get(blueMotionParams));
		const newEndOri = orientationService.calculateEndOrientation(motionData, MotionColor.BLUE);

		if ($.strict_equals(newEndOri, $.get(blueMotionParams).endOrientation, false)) {
			$.get(blueMotionParams).endOrientation = newEndOri;
		}
	});

	$.user_effect(() => {
		const { motionType, startLocation, endLocation, rotationDirection } = $.get(redMotionParams);

		console.log(`ðŸ”´ Red rotation effect triggered: ${startLocation}â†’${endLocation} (${motionType})`);

		const newRotDir = motionService.calculateRotationDirection(motionType, startLocation, endLocation);

		console.log(`ðŸ”´ Red rotation calculated: ${newRotDir}, current: ${rotationDirection}`);

		if ($.strict_equals(newRotDir, rotationDirection, false)) {
			console.log(`ðŸ”´ Red rotation updating from ${rotationDirection} to ${newRotDir}`);
			$.get(redMotionParams).rotationDirection = newRotDir;
		}
	});

	$.user_effect(() => {
		const motionData = motionService.convertToMotionData($.get(redMotionParams));
		const newEndOri = orientationService.calculateEndOrientation(motionData, MotionColor.RED);

		if ($.strict_equals(newEndOri, $.get(redMotionParams).endOrientation, false)) {
			$.get(redMotionParams).endOrientation = newEndOri;
		}
	});

	$.user_effect(() => {
		const initEngine = async () => {
			const blueParams = { ...$.get(blueMotionParams) };
			const redParams = { ...$.get(redMotionParams) };
			const success = (await $.track_reactivity_loss(animationService.initializeEngine(blueParams, redParams)))();

			$.set(isEngineInitialized, success, true);
		};

		initEngine();
	});

	$.user_effect(() => {
		animationState.progress = animationService.getProgress();
		animationState.currentBeat = animationService.getCurrentBeat();
		animationState.isPlaying = animationService.isPlaying();
	});

	return {
		// Reactive state getters
		get blueMotionParams() {
			return $.get(blueMotionParams);
		},

		get redMotionParams() {
			return $.get(redMotionParams);
		},

		get animationState() {
			return animationState;
		},

		get propVisibility() {
			return propVisibility;
		},

		get currentPropStates() {
			return animationService.getCurrentPropStates();
		},

		get isEngineInitialized() {
			return $.get(isEngineInitialized);
		},

		get gridType() {
			return $.get(gridType);
		},

		// Blue prop methods
		setBlueStartLocation: (location) => {
			$.get(blueMotionParams).startLocation = location;

			const updatedParams = motionService.updateMotionTypeForLocations($.get(blueMotionParams));

			$.set(blueMotionParams, updatedParams, true);
		},

		setBlueEndLocation: (location) => {
			$.get(blueMotionParams).endLocation = location;

			const updatedParams = motionService.updateMotionTypeForLocations($.get(blueMotionParams));

			$.set(blueMotionParams, updatedParams, true);
		},

		updateBlueMotionParam: (param, value) => {
			$.get(blueMotionParams)[param] = value;
		},

		// Red prop methods
		setRedStartLocation: (location) => {
			$.get(redMotionParams).startLocation = location;

			const updatedParams = motionService.updateMotionTypeForLocations($.get(redMotionParams));

			$.set(redMotionParams, updatedParams, true);
		},

		setRedEndLocation: (location) => {
			$.get(redMotionParams).endLocation = location;

			const updatedParams = motionService.updateMotionTypeForLocations($.get(redMotionParams));

			$.set(redMotionParams, updatedParams, true);
		},

		updateRedMotionParam: (param, value) => {
			$.get(redMotionParams)[param] = value;
		},

		// Animation control methods
		setProgress: (progress) => {
			animationService.setProgress(progress);
		},

		startAnimation: () => {
			animationService.startAnimation();
		},

		stopAnimation: () => {
			animationService.stopAnimation();
		},

		resetAnimation: () => {
			animationService.resetAnimation();
		},

		// Grid control methods
		setGridType: (newGridType) => {
			$.set(gridType, newGridType, true);
		}
	};
}
//# sourceMappingURL=data:application/json;base64,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Q0c7U0FDSCxpQkFBZ0IsS0FBSyxJQUFJO0VBQzNCOzs7RUFHQSxjQUFjLGFBQXFCO0dBQ2pDLGlCQUFpQixZQUFZLFFBQVE7RUFDdkM7O0VBRUEsc0JBQXNCO0dBQ3BCLGlCQUFpQjtFQUNuQjs7RUFFQSxxQkFBcUI7R0FDbkIsaUJBQWlCO0VBQ25COztFQUVBLHNCQUFzQjtHQUNwQixpQkFBaUI7RUFDbkI7OztFQUdBLGNBQWMsZ0JBQW1DO1NBQy9DLFVBQVc7RUFDYjs7QUFFSiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsibW90aW9uLXRlc3Rlci1zdGF0ZS5zdmVsdGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgTW90aW9uUGFyYW1ldGVyU2VydmljZSxcbiAgdHlwZSBNb3Rpb25UZXN0UGFyYW1zLFxufSBmcm9tIFwiLi4vc2VydmljZXMvTW90aW9uUGFyYW1ldGVyU2VydmljZVwiO1xuaW1wb3J0IHtcbiAgQW5pbWF0aW9uQ29udHJvbFNlcnZpY2UsXG4gIHR5cGUgQW5pbWF0aW9uU3RhdGUsXG4gIHR5cGUgUHJvcFZpc2liaWxpdHksXG4gIHR5cGUgUHJvcFN0YXRlcyxcbn0gZnJvbSBcIi4uL3NlcnZpY2VzL0FuaW1hdGlvbkNvbnRyb2xTZXJ2aWNlXCI7XG5pbXBvcnQgeyByZXNvbHZlIH0gZnJvbSBcIiRsaWIvc2VydmljZXMvYm9vdHN0cmFwXCI7XG5pbXBvcnQgdHlwZSB7IElTZXF1ZW5jZUFuaW1hdGlvbkVuZ2luZSB9IGZyb20gXCIkbGliL3NlcnZpY2VzL2RpL2ludGVyZmFjZXMvYW5pbWF0b3ItaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgT3JpZW50YXRpb25DYWxjdWxhdGlvblNlcnZpY2UgfSBmcm9tIFwiJGxpYi9zZXJ2aWNlcy9pbXBsZW1lbnRhdGlvbnMvcG9zaXRpb25pbmcvT3JpZW50YXRpb25DYWxjdWxhdGlvblNlcnZpY2VcIjtcblxuaW1wb3J0IHsgTW90aW9uVHlwZSwgTW90aW9uQ29sb3IgfSBmcm9tIFwiJGxpYi9kb21haW4vZW51bXNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBNb3Rpb25UZXN0ZXJTdGF0ZSB7XG4gIC8vIFJlYWN0aXZlIHN0YXRlIGdldHRlcnNcbiAgZ2V0IGJsdWVNb3Rpb25QYXJhbXMoKTogTW90aW9uVGVzdFBhcmFtcztcbiAgZ2V0IHJlZE1vdGlvblBhcmFtcygpOiBNb3Rpb25UZXN0UGFyYW1zO1xuICBnZXQgYW5pbWF0aW9uU3RhdGUoKTogQW5pbWF0aW9uU3RhdGU7XG4gIGdldCBwcm9wVmlzaWJpbGl0eSgpOiBQcm9wVmlzaWJpbGl0eTtcbiAgZ2V0IGN1cnJlbnRQcm9wU3RhdGVzKCk6IFByb3BTdGF0ZXM7XG4gIGdldCBpc0VuZ2luZUluaXRpYWxpemVkKCk6IGJvb2xlYW47XG4gIGdldCBncmlkVHlwZSgpOiBcImRpYW1vbmRcIiB8IFwiYm94XCI7XG5cbiAgLy8gQmx1ZSBwcm9wIG1ldGhvZHNcbiAgc2V0Qmx1ZVN0YXJ0TG9jYXRpb246IChsb2NhdGlvbjogc3RyaW5nKSA9PiB2b2lkO1xuICBzZXRCbHVlRW5kTG9jYXRpb246IChsb2NhdGlvbjogc3RyaW5nKSA9PiB2b2lkO1xuICB1cGRhdGVCbHVlTW90aW9uUGFyYW06IDxLIGV4dGVuZHMga2V5b2YgTW90aW9uVGVzdFBhcmFtcz4oXG4gICAgcGFyYW06IEssXG4gICAgdmFsdWU6IE1vdGlvblRlc3RQYXJhbXNbS11cbiAgKSA9PiB2b2lkO1xuXG4gIC8vIFJlZCBwcm9wIG1ldGhvZHNcbiAgc2V0UmVkU3RhcnRMb2NhdGlvbjogKGxvY2F0aW9uOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHNldFJlZEVuZExvY2F0aW9uOiAobG9jYXRpb246IHN0cmluZykgPT4gdm9pZDtcbiAgdXBkYXRlUmVkTW90aW9uUGFyYW06IDxLIGV4dGVuZHMga2V5b2YgTW90aW9uVGVzdFBhcmFtcz4oXG4gICAgcGFyYW06IEssXG4gICAgdmFsdWU6IE1vdGlvblRlc3RQYXJhbXNbS11cbiAgKSA9PiB2b2lkO1xuXG4gIC8vIEFuaW1hdGlvbiBjb250cm9sIG1ldGhvZHNcbiAgc2V0UHJvZ3Jlc3M6IChwcm9ncmVzczogbnVtYmVyKSA9PiB2b2lkO1xuICBzdGFydEFuaW1hdGlvbjogKCkgPT4gdm9pZDtcbiAgc3RvcEFuaW1hdGlvbjogKCkgPT4gdm9pZDtcbiAgcmVzZXRBbmltYXRpb246ICgpID0+IHZvaWQ7XG5cbiAgLy8gR3JpZCBjb250cm9sIG1ldGhvZHNcbiAgc2V0R3JpZFR5cGU6IChncmlkVHlwZTogXCJkaWFtb25kXCIgfCBcImJveFwiKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTW90aW9uVGVzdGVyU3RhdGUoKTogTW90aW9uVGVzdGVyU3RhdGUge1xuICAvLyBTZXJ2aWNlc1xuICBjb25zdCBtb3Rpb25TZXJ2aWNlID0gbmV3IE1vdGlvblBhcmFtZXRlclNlcnZpY2UoKTtcbiAgY29uc3QgYW5pbWF0aW9uRW5naW5lID0gcmVzb2x2ZShcbiAgICBcIklTZXF1ZW5jZUFuaW1hdGlvbkVuZ2luZVwiXG4gICkgYXMgSVNlcXVlbmNlQW5pbWF0aW9uRW5naW5lO1xuICBjb25zdCBhbmltYXRpb25TZXJ2aWNlID0gbmV3IEFuaW1hdGlvbkNvbnRyb2xTZXJ2aWNlKGFuaW1hdGlvbkVuZ2luZSk7XG4gIGNvbnN0IG9yaWVudGF0aW9uU2VydmljZSA9IG5ldyBPcmllbnRhdGlvbkNhbGN1bGF0aW9uU2VydmljZSgpO1xuXG4gIC8vIFJlYWN0aXZlIHN0YXRlXG4gIGxldCBibHVlTW90aW9uUGFyYW1zID0gJHN0YXRlPE1vdGlvblRlc3RQYXJhbXM+KFxuICAgIG1vdGlvblNlcnZpY2UuY3JlYXRlRGVmYXVsdFBhcmFtcygpXG4gICk7XG4gIGxldCByZWRNb3Rpb25QYXJhbXMgPSAkc3RhdGU8TW90aW9uVGVzdFBhcmFtcz4oe1xuICAgIC4uLm1vdGlvblNlcnZpY2UuY3JlYXRlRGVmYXVsdFBhcmFtcygpLFxuICAgIHN0YXJ0TG9jYXRpb246IFwiZVwiLFxuICAgIGVuZExvY2F0aW9uOiBcIndcIixcbiAgICBtb3Rpb25UeXBlOiBNb3Rpb25UeXBlLkRBU0gsXG4gIH0pO1xuXG4gIC8vIFByb3BzIGFyZSBhbHdheXMgdmlzaWJsZSAtIG5vIHVzZXIgY29udHJvbHMgbmVlZGVkXG4gIGNvbnN0IHByb3BWaXNpYmlsaXR5ID0gJHN0YXRlPFByb3BWaXNpYmlsaXR5Pih7XG4gICAgYmx1ZTogdHJ1ZSxcbiAgICByZWQ6IHRydWUsXG4gIH0pO1xuXG4gIGNvbnN0IGFuaW1hdGlvblN0YXRlID0gJHN0YXRlPEFuaW1hdGlvblN0YXRlPih7XG4gICAgaXNQbGF5aW5nOiBmYWxzZSxcbiAgICBwcm9ncmVzczogMCxcbiAgICBjdXJyZW50QmVhdDogMCxcbiAgfSk7XG5cbiAgbGV0IGlzRW5naW5lSW5pdGlhbGl6ZWQgPSAkc3RhdGUoZmFsc2UpO1xuICBsZXQgZ3JpZFR5cGUgPSAkc3RhdGU8XCJkaWFtb25kXCIgfCBcImJveFwiPihcImRpYW1vbmRcIik7XG5cbiAgLy8gQXV0by1jYWxjdWxhdGUgcm90YXRpb24gZGlyZWN0aW9uIGZvciBibHVlIHByb3BcbiAgJGVmZmVjdCgoKSA9PiB7XG4gICAgLy8gUHJvcGVybHkgYWNjZXNzIHJlYWN0aXZlIHN0YXRlXG4gICAgY29uc3QgeyBtb3Rpb25UeXBlLCBzdGFydExvY2F0aW9uLCBlbmRMb2NhdGlvbiwgcm90YXRpb25EaXJlY3Rpb24gfSA9XG4gICAgICBibHVlTW90aW9uUGFyYW1zO1xuICAgIGNvbnN0IG5ld1JvdERpciA9IG1vdGlvblNlcnZpY2UuY2FsY3VsYXRlUm90YXRpb25EaXJlY3Rpb24oXG4gICAgICBtb3Rpb25UeXBlLFxuICAgICAgc3RhcnRMb2NhdGlvbixcbiAgICAgIGVuZExvY2F0aW9uXG4gICAgKTtcbiAgICBpZiAobmV3Um90RGlyICE9PSByb3RhdGlvbkRpcmVjdGlvbikge1xuICAgICAgYmx1ZU1vdGlvblBhcmFtcy5yb3RhdGlvbkRpcmVjdGlvbiA9IG5ld1JvdERpcjtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEF1dG8tY2FsY3VsYXRlIGVuZCBvcmllbnRhdGlvbiBmb3IgYmx1ZSBwcm9wXG4gICRlZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG1vdGlvbkRhdGEgPSBtb3Rpb25TZXJ2aWNlLmNvbnZlcnRUb01vdGlvbkRhdGEoYmx1ZU1vdGlvblBhcmFtcyk7XG4gICAgY29uc3QgbmV3RW5kT3JpID0gb3JpZW50YXRpb25TZXJ2aWNlLmNhbGN1bGF0ZUVuZE9yaWVudGF0aW9uKFxuICAgICAgbW90aW9uRGF0YSxcbiAgICAgIE1vdGlvbkNvbG9yLkJMVUVcbiAgICApO1xuICAgIGlmIChuZXdFbmRPcmkgIT09IGJsdWVNb3Rpb25QYXJhbXMuZW5kT3JpZW50YXRpb24pIHtcbiAgICAgIGJsdWVNb3Rpb25QYXJhbXMuZW5kT3JpZW50YXRpb24gPSBuZXdFbmRPcmk7XG4gICAgfVxuICB9KTtcblxuICAvLyBBdXRvLWNhbGN1bGF0ZSByb3RhdGlvbiBkaXJlY3Rpb24gZm9yIHJlZCBwcm9wXG4gICRlZmZlY3QoKCkgPT4ge1xuICAgIC8vIFByb3Blcmx5IGFjY2VzcyByZWFjdGl2ZSBzdGF0ZVxuICAgIGNvbnN0IHsgbW90aW9uVHlwZSwgc3RhcnRMb2NhdGlvbiwgZW5kTG9jYXRpb24sIHJvdGF0aW9uRGlyZWN0aW9uIH0gPVxuICAgICAgcmVkTW90aW9uUGFyYW1zO1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYPCflLQgUmVkIHJvdGF0aW9uIGVmZmVjdCB0cmlnZ2VyZWQ6ICR7c3RhcnRMb2NhdGlvbn3ihpIke2VuZExvY2F0aW9ufSAoJHttb3Rpb25UeXBlfSlgXG4gICAgKTtcbiAgICBjb25zdCBuZXdSb3REaXIgPSBtb3Rpb25TZXJ2aWNlLmNhbGN1bGF0ZVJvdGF0aW9uRGlyZWN0aW9uKFxuICAgICAgbW90aW9uVHlwZSxcbiAgICAgIHN0YXJ0TG9jYXRpb24sXG4gICAgICBlbmRMb2NhdGlvblxuICAgICk7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBg8J+UtCBSZWQgcm90YXRpb24gY2FsY3VsYXRlZDogJHtuZXdSb3REaXJ9LCBjdXJyZW50OiAke3JvdGF0aW9uRGlyZWN0aW9ufWBcbiAgICApO1xuICAgIGlmIChuZXdSb3REaXIgIT09IHJvdGF0aW9uRGlyZWN0aW9uKSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYPCflLQgUmVkIHJvdGF0aW9uIHVwZGF0aW5nIGZyb20gJHtyb3RhdGlvbkRpcmVjdGlvbn0gdG8gJHtuZXdSb3REaXJ9YFxuICAgICAgKTtcbiAgICAgIHJlZE1vdGlvblBhcmFtcy5yb3RhdGlvbkRpcmVjdGlvbiA9IG5ld1JvdERpcjtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEF1dG8tY2FsY3VsYXRlIGVuZCBvcmllbnRhdGlvbiBmb3IgcmVkIHByb3BcbiAgJGVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbW90aW9uRGF0YSA9IG1vdGlvblNlcnZpY2UuY29udmVydFRvTW90aW9uRGF0YShyZWRNb3Rpb25QYXJhbXMpO1xuICAgIGNvbnN0IG5ld0VuZE9yaSA9IG9yaWVudGF0aW9uU2VydmljZS5jYWxjdWxhdGVFbmRPcmllbnRhdGlvbihcbiAgICAgIG1vdGlvbkRhdGEsXG4gICAgICBNb3Rpb25Db2xvci5SRURcbiAgICApO1xuICAgIGlmIChuZXdFbmRPcmkgIT09IHJlZE1vdGlvblBhcmFtcy5lbmRPcmllbnRhdGlvbikge1xuICAgICAgcmVkTW90aW9uUGFyYW1zLmVuZE9yaWVudGF0aW9uID0gbmV3RW5kT3JpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBlbmdpbmUgd2hlbiBtb3Rpb24gcGFyYW1ldGVycyBjaGFuZ2VcbiAgJGVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaW5pdEVuZ2luZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSBjb3BpZXMgdG8gcHJvcGVybHkgY2FwdHVyZSByZWFjdGl2ZSBzdGF0ZVxuICAgICAgY29uc3QgYmx1ZVBhcmFtcyA9IHsgLi4uYmx1ZU1vdGlvblBhcmFtcyB9O1xuICAgICAgY29uc3QgcmVkUGFyYW1zID0geyAuLi5yZWRNb3Rpb25QYXJhbXMgfTtcbiAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBhbmltYXRpb25TZXJ2aWNlLmluaXRpYWxpemVFbmdpbmUoXG4gICAgICAgIGJsdWVQYXJhbXMsXG4gICAgICAgIHJlZFBhcmFtc1xuICAgICAgKTtcbiAgICAgIGlzRW5naW5lSW5pdGlhbGl6ZWQgPSBzdWNjZXNzO1xuICAgIH07XG4gICAgaW5pdEVuZ2luZSgpO1xuICB9KTtcblxuICAvLyBVcGRhdGUgYW5pbWF0aW9uIHN0YXRlXG4gICRlZmZlY3QoKCkgPT4ge1xuICAgIGFuaW1hdGlvblN0YXRlLnByb2dyZXNzID0gYW5pbWF0aW9uU2VydmljZS5nZXRQcm9ncmVzcygpO1xuICAgIGFuaW1hdGlvblN0YXRlLmN1cnJlbnRCZWF0ID0gYW5pbWF0aW9uU2VydmljZS5nZXRDdXJyZW50QmVhdCgpO1xuICAgIGFuaW1hdGlvblN0YXRlLmlzUGxheWluZyA9IGFuaW1hdGlvblNlcnZpY2UuaXNQbGF5aW5nKCk7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgLy8gUmVhY3RpdmUgc3RhdGUgZ2V0dGVyc1xuICAgIGdldCBibHVlTW90aW9uUGFyYW1zKCkge1xuICAgICAgcmV0dXJuIGJsdWVNb3Rpb25QYXJhbXM7XG4gICAgfSxcbiAgICBnZXQgcmVkTW90aW9uUGFyYW1zKCkge1xuICAgICAgcmV0dXJuIHJlZE1vdGlvblBhcmFtcztcbiAgICB9LFxuICAgIGdldCBhbmltYXRpb25TdGF0ZSgpIHtcbiAgICAgIHJldHVybiBhbmltYXRpb25TdGF0ZTtcbiAgICB9LFxuICAgIGdldCBwcm9wVmlzaWJpbGl0eSgpIHtcbiAgICAgIHJldHVybiBwcm9wVmlzaWJpbGl0eTtcbiAgICB9LFxuICAgIGdldCBjdXJyZW50UHJvcFN0YXRlcygpIHtcbiAgICAgIHJldHVybiBhbmltYXRpb25TZXJ2aWNlLmdldEN1cnJlbnRQcm9wU3RhdGVzKCk7XG4gICAgfSxcbiAgICBnZXQgaXNFbmdpbmVJbml0aWFsaXplZCgpIHtcbiAgICAgIHJldHVybiBpc0VuZ2luZUluaXRpYWxpemVkO1xuICAgIH0sXG4gICAgZ2V0IGdyaWRUeXBlKCkge1xuICAgICAgcmV0dXJuIGdyaWRUeXBlO1xuICAgIH0sXG5cbiAgICAvLyBCbHVlIHByb3AgbWV0aG9kc1xuICAgIHNldEJsdWVTdGFydExvY2F0aW9uOiAobG9jYXRpb246IHN0cmluZykgPT4ge1xuICAgICAgYmx1ZU1vdGlvblBhcmFtcy5zdGFydExvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICBjb25zdCB1cGRhdGVkUGFyYW1zID1cbiAgICAgICAgbW90aW9uU2VydmljZS51cGRhdGVNb3Rpb25UeXBlRm9yTG9jYXRpb25zKGJsdWVNb3Rpb25QYXJhbXMpO1xuICAgICAgYmx1ZU1vdGlvblBhcmFtcyA9IHVwZGF0ZWRQYXJhbXM7XG4gICAgfSxcblxuICAgIHNldEJsdWVFbmRMb2NhdGlvbjogKGxvY2F0aW9uOiBzdHJpbmcpID0+IHtcbiAgICAgIGJsdWVNb3Rpb25QYXJhbXMuZW5kTG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgIGNvbnN0IHVwZGF0ZWRQYXJhbXMgPVxuICAgICAgICBtb3Rpb25TZXJ2aWNlLnVwZGF0ZU1vdGlvblR5cGVGb3JMb2NhdGlvbnMoYmx1ZU1vdGlvblBhcmFtcyk7XG4gICAgICBibHVlTW90aW9uUGFyYW1zID0gdXBkYXRlZFBhcmFtcztcbiAgICB9LFxuXG4gICAgdXBkYXRlQmx1ZU1vdGlvblBhcmFtOiA8SyBleHRlbmRzIGtleW9mIE1vdGlvblRlc3RQYXJhbXM+KFxuICAgICAgcGFyYW06IEssXG4gICAgICB2YWx1ZTogTW90aW9uVGVzdFBhcmFtc1tLXVxuICAgICkgPT4ge1xuICAgICAgYmx1ZU1vdGlvblBhcmFtc1twYXJhbV0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLy8gUmVkIHByb3AgbWV0aG9kc1xuICAgIHNldFJlZFN0YXJ0TG9jYXRpb246IChsb2NhdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICByZWRNb3Rpb25QYXJhbXMuc3RhcnRMb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgY29uc3QgdXBkYXRlZFBhcmFtcyA9XG4gICAgICAgIG1vdGlvblNlcnZpY2UudXBkYXRlTW90aW9uVHlwZUZvckxvY2F0aW9ucyhyZWRNb3Rpb25QYXJhbXMpO1xuICAgICAgcmVkTW90aW9uUGFyYW1zID0gdXBkYXRlZFBhcmFtcztcbiAgICB9LFxuXG4gICAgc2V0UmVkRW5kTG9jYXRpb246IChsb2NhdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICByZWRNb3Rpb25QYXJhbXMuZW5kTG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgIGNvbnN0IHVwZGF0ZWRQYXJhbXMgPVxuICAgICAgICBtb3Rpb25TZXJ2aWNlLnVwZGF0ZU1vdGlvblR5cGVGb3JMb2NhdGlvbnMocmVkTW90aW9uUGFyYW1zKTtcbiAgICAgIHJlZE1vdGlvblBhcmFtcyA9IHVwZGF0ZWRQYXJhbXM7XG4gICAgfSxcblxuICAgIHVwZGF0ZVJlZE1vdGlvblBhcmFtOiA8SyBleHRlbmRzIGtleW9mIE1vdGlvblRlc3RQYXJhbXM+KFxuICAgICAgcGFyYW06IEssXG4gICAgICB2YWx1ZTogTW90aW9uVGVzdFBhcmFtc1tLXVxuICAgICkgPT4ge1xuICAgICAgcmVkTW90aW9uUGFyYW1zW3BhcmFtXSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvLyBBbmltYXRpb24gY29udHJvbCBtZXRob2RzXG4gICAgc2V0UHJvZ3Jlc3M6IChwcm9ncmVzczogbnVtYmVyKSA9PiB7XG4gICAgICBhbmltYXRpb25TZXJ2aWNlLnNldFByb2dyZXNzKHByb2dyZXNzKTtcbiAgICB9LFxuXG4gICAgc3RhcnRBbmltYXRpb246ICgpID0+IHtcbiAgICAgIGFuaW1hdGlvblNlcnZpY2Uuc3RhcnRBbmltYXRpb24oKTtcbiAgICB9LFxuXG4gICAgc3RvcEFuaW1hdGlvbjogKCkgPT4ge1xuICAgICAgYW5pbWF0aW9uU2VydmljZS5zdG9wQW5pbWF0aW9uKCk7XG4gICAgfSxcblxuICAgIHJlc2V0QW5pbWF0aW9uOiAoKSA9PiB7XG4gICAgICBhbmltYXRpb25TZXJ2aWNlLnJlc2V0QW5pbWF0aW9uKCk7XG4gICAgfSxcblxuICAgIC8vIEdyaWQgY29udHJvbCBtZXRob2RzXG4gICAgc2V0R3JpZFR5cGU6IChuZXdHcmlkVHlwZTogXCJkaWFtb25kXCIgfCBcImJveFwiKSA9PiB7XG4gICAgICBncmlkVHlwZSA9IG5ld0dyaWRUeXBlO1xuICAgIH0sXG4gIH07XG59XG4iXSwiZmlsZSI6IkY6L0NPREUvVEtBL3dlYi9zcmMvcm91dGVzL21vdGlvbi10ZXN0ZXIvc3RhdGUvbW90aW9uLXRlc3Rlci1zdGF0ZS5zdmVsdGUudHMifQ==