import { createHotContext as __vite__createHotContext } from "/@vite/client";import.meta.hot = __vite__createHotContext("/src/lib/components/construct/StartPositionPicker.svelte");import "/node_modules/.vite/deps/svelte_internal_disclose-version.js?v=cc8aba6c";

StartPositionPicker[$.FILENAME] = 'src/lib/components/construct/StartPositionPicker.svelte';

import * as $ from "/node_modules/.vite/deps/svelte_internal_client.js?v=cc8aba6c";
import { GridMode } from "/src/lib/domain/enums.ts";
import { resolve } from "/src/lib/services/bootstrap.ts";
import { onMount } from "/node_modules/.vite/deps/svelte.js?v=cc8aba6c";

import {
	extractEndPosition,
	createStartPositionData,
	storeStartPositionData
} from "/src/lib/components/construct/start-position/utils/StartPositionUtils.ts";

import LoadingState from "/src/lib/components/construct/start-position/ui/LoadingState.svelte";
import ErrorState from "/src/lib/components/construct/start-position/ui/ErrorState.svelte";
import PictographGrid from "/src/lib/components/construct/start-position/ui/PictographGrid.svelte";
import TransitionOverlay from "/src/lib/components/construct/start-position/ui/TransitionOverlay.svelte";
import { sequenceStateService } from "/src/lib/services/SequenceStateService.svelte.ts";

var root = $.add_locations($.from_html(`<div class="start-pos-picker s-V6OxA4DJ9E7q" data-testid="start-position-picker"><!> <!></div>`), StartPositionPicker[$.FILENAME], [[147, 0]]);

function StartPositionPicker($$anchor, $$props) {
	$.check_target(new.target);
	$.push($$props, true, StartPositionPicker);

	const gridMode = $.prop($$props, 'gridMode', 3, "diamond");
	let startPositionPictographs = $.tag($.state($.proxy([])), 'startPositionPictographs');
	let selectedStartPos = $.tag($.state(null), 'selectedStartPos');
	let isLoading = $.tag($.state(true), 'isLoading');
	let loadingError = $.tag($.state(false), 'loadingError');
	let isTransitioning = $.tag($.state(false), 'isTransitioning');
	let startPositionService = $.tag($.state(null), 'startPositionService');
	let pictographRenderingService = $.tag($.state(null), 'pictographRenderingService');

	$.user_effect(() => {
		try {
			if (!$.get(startPositionService)) {
				try {
					$.set(startPositionService, resolve("IStartPositionService"), true);
				} catch {
					return;
				}
			}

			if (!$.get(pictographRenderingService)) {
				try {
					$.set(pictographRenderingService, resolve("IPictographRenderingService"), true);
				} catch {
					return;
				}
			}
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "StartPositionPicker: Failed to resolve services:", error));
		}
	});

	async function loadStartPositions() {
		$.set(isLoading, true);
		$.set(loadingError, false);

		try {
			if (!$.get(startPositionService)) {
				throw new Error("StartPositionService not available");
			}

			const startPositions = (await $.track_reactivity_loss($.get(startPositionService).getDefaultStartPositions(gridMode())))();

			$.set(startPositionPictographs, startPositions, true);
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "\u274C Error loading start positions:", error));
			$.set(loadingError, true);
			$.set(startPositionPictographs, [], true);
		} finally {
			$.set(isLoading, false);
		}
	}

	async function handleSelect(startPosPictograph) {
		try {
			$.set(isTransitioning, true);

			const endPosition = extractEndPosition(startPosPictograph);
			const startPositionData = createStartPositionData(startPosPictograph, endPosition);

			const startPositionBeat = {
				id: crypto.randomUUID(),
				beatNumber: 0,
				duration: 1,
				blueReversal: false,
				redReversal: false,
				isBlank: false,
				pictographData: startPosPictograph,
				metadata: { endPosition }
			};

			$.set(selectedStartPos, startPosPictograph, true);
			storeStartPositionData(startPositionData);

			try {
				const { resolve: resolve2 } = (await $.track_reactivity_loss(import("/src/lib/services/bootstrap.ts")))();
				const { ILetterQueryServiceInterface } = (await $.track_reactivity_loss(import("/src/lib/services/di/interfaces/codex-interfaces.ts")))();
				const letterQueryService = resolve2(ILetterQueryServiceInterface);

				console.log("\u2705 CSV data preloaded for option picker");
			} catch(preloadError) {
				console.warn(...$.log_if_contains_state('warn', "StartPositionPicker: Failed to preload options, will load normally:", preloadError));
			}

			if ($.get(startPositionService)) {
				(await $.track_reactivity_loss($.get(startPositionService).setStartPosition(startPositionBeat)))();
			}

			const event = new CustomEvent("start-position-selected", {
				detail: {
					startPosition: startPositionData,
					endPosition,
					isTransitioning: true,
					preloadedOptions: true

					// Signal that options are preloaded
				},

				bubbles: true
			});

			document.dispatchEvent(event);

			setTimeout(
				() => {
					$.set(isTransitioning, false);
				},
				200
			);
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "StartPositionPicker: Error selecting start position:", error));

			if (error instanceof Error) {
				console.error(...$.log_if_contains_state('error', "StartPositionPicker: Error stack:", error.stack));
				console.error(...$.log_if_contains_state('error', "StartPositionPicker: Error details:", { message: error.message, name: error.name, startPosPictograph }));
			}

			$.set(isTransitioning, false);
			alert(`Failed to select start position: ${error instanceof Error ? error.message : "Unknown error"}`);
		}
	}

	onMount(() => {
		loadStartPositions();
	});

	$.user_effect(() => {
		if (gridMode()) {
			loadStartPositions();
		}
	});

	$.user_effect(() => {
		const currentSequence = sequenceStateService.currentSequence;

		if (currentSequence && currentSequence.startPosition && $.get(isTransitioning)) {
			$.set(isTransitioning, false);
		}
	});

	var div = root();
	var node = $.child(div);

	{
		var consequent = ($$anchor) => {
			var fragment = $.comment();
			var node_1 = $.first_child(fragment);

			$.add_svelte_meta(() => LoadingState(node_1, {}), 'component', StartPositionPicker, 149, 4, { componentTag: 'LoadingState' });
			$.append($$anchor, fragment);
		};

		var alternate_2 = ($$anchor) => {
			var fragment_1 = $.comment();
			var node_2 = $.first_child(fragment_1);

			{
				var consequent_1 = ($$anchor) => {
					var fragment_2 = $.comment();
					var node_3 = $.first_child(fragment_2);

					$.add_svelte_meta(() => ErrorState(node_3, {}), 'component', StartPositionPicker, 151, 4, { componentTag: 'ErrorState' });
					$.append($$anchor, fragment_2);
				};

				var alternate_1 = ($$anchor) => {
					var fragment_3 = $.comment();
					var node_4 = $.first_child(fragment_3);

					{
						var consequent_2 = ($$anchor) => {
							var fragment_4 = $.comment();
							var node_5 = $.first_child(fragment_4);

							$.add_svelte_meta(
								() => ErrorState(node_5, {
									message: 'No valid start positions found for the current configuration.',
									hasRefreshButton: false
								}),
								'component',
								StartPositionPicker,
								153,
								4,
								{ componentTag: 'ErrorState' }
							);

							$.append($$anchor, fragment_4);
						};

						var alternate = ($$anchor) => {
							var fragment_5 = $.comment();
							var node_6 = $.first_child(fragment_5);

							$.add_svelte_meta(
								() => PictographGrid(node_6, {
									get pictographs() {
										return $.get(startPositionPictographs);
									},

									get selectedPictograph() {
										return $.get(selectedStartPos);
									},

									onPictographSelect: handleSelect
								}),
								'component',
								StartPositionPicker,
								158,
								4,
								{ componentTag: 'PictographGrid' }
							);

							$.append($$anchor, fragment_5);
						};

						$.add_svelte_meta(
							() => $.if(
								node_4,
								($$render) => {
									if ($.strict_equals($.get(startPositionPictographs).length, 0)) $$render(consequent_2); else $$render(alternate, false);
								},
								true
							),
							'if',
							StartPositionPicker,
							152,
							2
						);
					}

					$.append($$anchor, fragment_3);
				};

				$.add_svelte_meta(
					() => $.if(
						node_2,
						($$render) => {
							if ($.get(loadingError)) $$render(consequent_1); else $$render(alternate_1, false);
						},
						true
					),
					'if',
					StartPositionPicker,
					150,
					2
				);
			}

			$.append($$anchor, fragment_1);
		};

		$.add_svelte_meta(
			() => $.if(node, ($$render) => {
				if ($.get(isLoading)) $$render(consequent); else $$render(alternate_2, false);
			}),
			'if',
			StartPositionPicker,
			148,
			2
		);
	}

	var node_7 = $.sibling(node, 2);

	{
		var consequent_3 = ($$anchor) => {
			var fragment_6 = $.comment();
			var node_8 = $.first_child(fragment_6);

			$.add_svelte_meta(() => TransitionOverlay(node_8, {}), 'component', StartPositionPicker, 167, 4, { componentTag: 'TransitionOverlay' });
			$.append($$anchor, fragment_6);
		};

		$.add_svelte_meta(
			() => $.if(node_7, ($$render) => {
				if ($.get(isTransitioning)) $$render(consequent_3);
			}),
			'if',
			StartPositionPicker,
			166,
			2
		);
	}

	$.reset(div);
	$.append($$anchor, div);

	return $.pop({ ...$.legacy_api() });
}

if (import.meta.hot) {
	StartPositionPicker = $.hmr(StartPositionPicker, () => StartPositionPicker[$.HMR].source);

	import.meta.hot.acceptExports(["default"],(module) => {
		$.cleanup_styles('s-V6OxA4DJ9E7q');
		module.default[$.HMR].source = StartPositionPicker[$.HMR].source;
		$.set(StartPositionPicker[$.HMR].source, module.default[$.HMR].original);
	});
}

export default StartPositionPicker;
import "/src/lib/components/construct/StartPositionPicker.svelte?svelte&type=style&lang.css";

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6Ijs7Ozs7U0FXRTtTQUNFO1NBR0s7OztDQU1QO0NBR0E7Q0FLSTtPQUNBOztPQUdBLGtCQUFrQjtPQUdsQjtPQUNBO09BQ0Y7Ozs7O2dEQXRDSixDQUFDOzs7O09BMkNPO0tBT0U7S0FDRjtLQUNGO0tBQ0EsNkJBQUs7S0FDSCxnQ0FBSTtLQUlGO0tBQ0YsMkNBQ0Y7O0NBS0g7TUFHRDtjQUVFLHVCQUFlO1FBRVg7V0FFRyxzQkFBc0I7SUFDekIsUUFBVTs7SUFJWjtHQUNGOztjQUNFLDZCQUFjO1FBQ2Q7V0FDQSw0QkFBNEI7SUFDOUIsUUFBRTs7SUFHSjtHQUdBO0VBQ0UsUUFBSTtHQUVGLHNHQUFrQjtFQVdsQjtDQUEwQjs7Z0JBTXBCLHFCQUE4QjtRQUFBLFdBQzlCO1FBQWtCLGNBQ1Y7O01BRVo7Y0FFQSx1QkFBUztjQUNULE1BQWdCO0dBQ2hCOztTQUNFLHNEQUNGOztTQUNGO0VBR0E7R0FHQSwyRkFBd0M7U0FJeEMsY0FBSTtTQUVGO0VBQ0E7U0FHQSxXQUFNO0VBSU47Q0FBb0Q7O2dCQU1sRDtNQUNGO1NBS0YsaUJBQUk7O1NBV0EsY0FBa0I7U0FFcEIsb0JBQVMsd0JBQ1Ysb0JBQ0Q7O1NBTU87SUFDUCxJQUFRO0lBQ047SUFDQTtJQUNGO0lBQ0k7SUFDRixTQUFRO0lBQ1IsZ0JBQWM7SUFDWixZQUNBOzs7U0FNSjtHQUdGOztPQU1EO1lBSWUsU0FBQUEsbURBQUE7WUFDWix1RUFDRiwwQ0FDRDtVQUdRLHFCQUFBQSxTQUE0Qjs7SUFPakMseURBQWtCO0dBR3RCLFFBQU07b0RBRUUsdUVBQ0g7R0FHRjs7YUFHQyx1QkFBd0I7eUNBQ3hCLHNCQUF1QjtHQUN4Qjs7U0FJQyxZQUFrQixZQUFFO0lBQ3BCO0tBQ0Q7S0FDQzs7S0FFQyxrQkFBZ0I7Ozs7O0lBRWxCOzs7R0FFQTs7R0FHRjtVQUFpQjtXQUNoQixpQkFBYTtJQUNiO0lBQUs7O0VBQ0wsUUFBUSxPQUFRO0dBQ2hCLFFBQU0sMENBQ04sd0RBQ0E7O09BRUEsaUJBQXVCO0lBQ3ZCLFFBQVUsMENBQVE7SUFDcEIsMkZBQ0siLCJuYW1lcyI6WyJyZXNvbHZlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIlN0YXJ0UG9zaXRpb25QaWNrZXIuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjwhLS0gU3RhcnRQb3NpdGlvblBpY2tlci5zdmVsdGUgLSBNb2Rlcm4gaW1wbGVtZW50YXRpb24gdXBkYXRlZCBmb3IgcHJvcGVyIE9wdGlvblBpY2tlciBpbnRlZ3JhdGlvbiAtLT5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gIGltcG9ydCB0eXBlIHsgQmVhdERhdGEgfSBmcm9tIFwiJGRvbWFpbi9CZWF0RGF0YVwiO1xuICBpbXBvcnQgdHlwZSB7IFBpY3RvZ3JhcGhEYXRhIH0gZnJvbSBcIiRkb21haW4vUGljdG9ncmFwaERhdGFcIjtcbiAgaW1wb3J0IHsgR3JpZE1vZGUgfSBmcm9tIFwiJGRvbWFpbi9lbnVtc1wiO1xuICBpbXBvcnQgeyByZXNvbHZlIH0gZnJvbSBcIiRzZXJ2aWNlcy9ib290c3RyYXBcIjtcbiAgaW1wb3J0IHR5cGUgeyBJUGljdG9ncmFwaFJlbmRlcmluZ1NlcnZpY2UgfSBmcm9tIFwiJHNlcnZpY2VzL2ludGVyZmFjZXMvcGljdG9ncmFwaC1pbnRlcmZhY2VzXCI7XG4gIGltcG9ydCB0eXBlIHsgSVN0YXJ0UG9zaXRpb25TZXJ2aWNlIH0gZnJvbSBcIiRzZXJ2aWNlcy9pbnRlcmZhY2VzL2FwcGxpY2F0aW9uLWludGVyZmFjZXNcIjtcbiAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAvLyBFeHRyYWN0ZWQgdXRpbGl0aWVzIChrZWVwaW5nIG9yaWdpbmFsIGZ1bmN0aW9uYWxpdHkgaW50YWN0KVxuICBpbXBvcnQge1xuICAgIGV4dHJhY3RFbmRQb3NpdGlvbixcbiAgICBjcmVhdGVTdGFydFBvc2l0aW9uRGF0YSxcbiAgICBzdG9yZVN0YXJ0UG9zaXRpb25EYXRhLFxuICB9IGZyb20gXCIuL3N0YXJ0LXBvc2l0aW9uL3V0aWxzL1N0YXJ0UG9zaXRpb25VdGlsc1wiO1xuXG4gIC8vIFVJIENvbXBvbmVudHNcbiAgaW1wb3J0IExvYWRpbmdTdGF0ZSBmcm9tIFwiLi9zdGFydC1wb3NpdGlvbi91aS9Mb2FkaW5nU3RhdGUuc3ZlbHRlXCI7XG4gIGltcG9ydCBFcnJvclN0YXRlIGZyb20gXCIuL3N0YXJ0LXBvc2l0aW9uL3VpL0Vycm9yU3RhdGUuc3ZlbHRlXCI7XG4gIGltcG9ydCBQaWN0b2dyYXBoR3JpZCBmcm9tIFwiLi9zdGFydC1wb3NpdGlvbi91aS9QaWN0b2dyYXBoR3JpZC5zdmVsdGVcIjtcbiAgaW1wb3J0IFRyYW5zaXRpb25PdmVybGF5IGZyb20gXCIuL3N0YXJ0LXBvc2l0aW9uL3VpL1RyYW5zaXRpb25PdmVybGF5LnN2ZWx0ZVwiO1xuXG4gIC8vIFByb3BzIHVzaW5nIHJ1bmVzXG4gIGNvbnN0IHsgZ3JpZE1vZGUgPSBcImRpYW1vbmRcIiB9ID0gJHByb3BzPHtcbiAgICBncmlkTW9kZT86IFwiZGlhbW9uZFwiIHwgXCJib3hcIjtcbiAgfT4oKTtcblxuICAvLyBSdW5lcy1iYXNlZCByZWFjdGl2ZSBzdGF0ZSAocmVwbGFjaW5nIGxlZ2FjeSBzdG9yZXMpXG4gIGxldCBzdGFydFBvc2l0aW9uUGljdG9ncmFwaHMgPSAkc3RhdGU8UGljdG9ncmFwaERhdGFbXT4oW10pO1xuICBsZXQgc2VsZWN0ZWRTdGFydFBvcyA9ICRzdGF0ZTxQaWN0b2dyYXBoRGF0YSB8IG51bGw+KG51bGwpO1xuICBsZXQgaXNMb2FkaW5nID0gJHN0YXRlKHRydWUpO1xuICBsZXQgbG9hZGluZ0Vycm9yID0gJHN0YXRlKGZhbHNlKTtcbiAgbGV0IGlzVHJhbnNpdGlvbmluZyA9ICRzdGF0ZShmYWxzZSk7XG5cbiAgLy8gTW9kZXJuIHNlcnZpY2VzIChyZXBsYWNpbmcgbGVnYWN5IHNlcnZpY2UgY2FsbHMpXG4gIGxldCBzdGFydFBvc2l0aW9uU2VydmljZSA9ICRzdGF0ZTxJU3RhcnRQb3NpdGlvblNlcnZpY2UgfCBudWxsPihudWxsKTtcbiAgbGV0IHBpY3RvZ3JhcGhSZW5kZXJpbmdTZXJ2aWNlID0gJHN0YXRlPElQaWN0b2dyYXBoUmVuZGVyaW5nU2VydmljZSB8IG51bGw+KFxuICAgIG51bGxcbiAgKTtcblxuICAvLyBSZXNvbHZlIHNlcnZpY2VzIHdoZW4gY29udGFpbmVyIGlzIHJlYWR5XG4gICRlZmZlY3QoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgdG8gcmVzb2x2ZSBzZXJ2aWNlcywgYnV0IGhhbmRsZSBncmFjZWZ1bGx5IGlmIGNvbnRhaW5lciBub3QgcmVhZHlcbiAgICAgIGlmICghc3RhcnRQb3NpdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGFydFBvc2l0aW9uU2VydmljZSA9IHJlc29sdmUoXCJJU3RhcnRQb3NpdGlvblNlcnZpY2VcIik7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIENvbnRhaW5lciBub3QgcmVhZHkgeWV0LCB3aWxsIHJldHJ5IG9uIG5leHQgZWZmZWN0IHJ1blxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFwaWN0b2dyYXBoUmVuZGVyaW5nU2VydmljZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBpY3RvZ3JhcGhSZW5kZXJpbmdTZXJ2aWNlID0gcmVzb2x2ZShcIklQaWN0b2dyYXBoUmVuZGVyaW5nU2VydmljZVwiKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8gQ29udGFpbmVyIG5vdCByZWFkeSB5ZXQsIHdpbGwgcmV0cnkgb24gbmV4dCBlZmZlY3QgcnVuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJTdGFydFBvc2l0aW9uUGlja2VyOiBGYWlsZWQgdG8gcmVzb2x2ZSBzZXJ2aWNlczpcIiwgZXJyb3IpO1xuICAgICAgLy8gU2VydmljZXMgd2lsbCByZW1haW4gbnVsbCBhbmQgY29tcG9uZW50IHdpbGwgaGFuZGxlIGdyYWNlZnVsbHlcbiAgICB9XG4gIH0pO1xuXG4gIC8vIExvYWQgYXZhaWxhYmxlIHN0YXJ0IHBvc2l0aW9ucyAobW9kZXJuaXplZCBmcm9tIGxlZ2FjeSlcbiAgYXN5bmMgZnVuY3Rpb24gbG9hZFN0YXJ0UG9zaXRpb25zKCkge1xuICAgIGlzTG9hZGluZyA9IHRydWU7XG4gICAgbG9hZGluZ0Vycm9yID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgLy8gVXNlIG1vZGVybiBzZXJ2aWNlIHRvIGdldCBzdGFydCBwb3NpdGlvbnNcbiAgICAgIGlmICghc3RhcnRQb3NpdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhcnRQb3NpdGlvblNlcnZpY2Ugbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb25zID1cbiAgICAgICAgYXdhaXQgc3RhcnRQb3NpdGlvblNlcnZpY2UuZ2V0RGVmYXVsdFN0YXJ0UG9zaXRpb25zKGdyaWRNb2RlKTtcbiAgICAgIHN0YXJ0UG9zaXRpb25QaWN0b2dyYXBocyA9IHN0YXJ0UG9zaXRpb25zO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEVycm9yIGxvYWRpbmcgc3RhcnQgcG9zaXRpb25zOlwiLCBlcnJvcik7XG4gICAgICBsb2FkaW5nRXJyb3IgPSB0cnVlO1xuICAgICAgc3RhcnRQb3NpdGlvblBpY3RvZ3JhcGhzID0gW107XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzTG9hZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBzdGFydCBwb3NpdGlvbiBzZWxlY3Rpb24gKG1vZGVybml6ZWQgZnJvbSBsZWdhY3kgd2l0aCBwcm9wZXIgZGF0YSBmb3JtYXQpXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVNlbGVjdChzdGFydFBvc1BpY3RvZ3JhcGg6IFBpY3RvZ3JhcGhEYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFNob3cgdHJhbnNpdGlvbiBzdGF0ZVxuICAgICAgaXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcblxuICAgICAgLy8gKipDUklUSUNBTDogQ3JlYXRlIHRoZSBkYXRhIGZvcm1hdCB0aGF0IE9wdGlvblBpY2tlciBleHBlY3RzKipcbiAgICAgIC8vIEJhc2VkIG9uIGxlZ2FjeSBhbmFseXNpcywgT3B0aW9uUGlja2VyIGxvb2tzIGZvcjpcbiAgICAgIC8vIDEuIGxvY2FsU3RvcmFnZSAnc3RhcnRQb3NpdGlvbicgd2l0aCBlbmRQb3NpdGlvbiBmaWVsZFxuICAgICAgLy8gMi4gUHJvcGVyIHBpY3RvZ3JhcGggZGF0YSBzdHJ1Y3R1cmVcblxuICAgICAgLy8gRXh0cmFjdCBlbmQgcG9zaXRpb24gZnJvbSB0aGUgcGljdG9ncmFwaCBkYXRhXG4gICAgICBjb25zdCBlbmRQb3NpdGlvbiA9IGV4dHJhY3RFbmRQb3NpdGlvbihzdGFydFBvc1BpY3RvZ3JhcGgpO1xuXG4gICAgICAvLyBDcmVhdGUgc3RhcnQgcG9zaXRpb24gZGF0YSBpbiB0aGUgZm9ybWF0IHRoZSBPcHRpb25QaWNrZXIgZXhwZWN0cyAobGlrZSBsZWdhY3kpXG4gICAgICBjb25zdCBzdGFydFBvc2l0aW9uRGF0YSA9IGNyZWF0ZVN0YXJ0UG9zaXRpb25EYXRhKFxuICAgICAgICBzdGFydFBvc1BpY3RvZ3JhcGgsXG4gICAgICAgIGVuZFBvc2l0aW9uXG4gICAgICApO1xuXG4gICAgICAvLyBDcmVhdGUgc3RhcnQgcG9zaXRpb24gYmVhdCBkYXRhIGZvciBpbnRlcm5hbCB1c2VcbiAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb25CZWF0OiBCZWF0RGF0YSA9IHtcbiAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXG4gICAgICAgIGJlYXROdW1iZXI6IDAsXG4gICAgICAgIGR1cmF0aW9uOiAxLjAsXG4gICAgICAgIGJsdWVSZXZlcnNhbDogZmFsc2UsXG4gICAgICAgIHJlZFJldmVyc2FsOiBmYWxzZSxcbiAgICAgICAgaXNCbGFuazogZmFsc2UsXG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhOiBzdGFydFBvc1BpY3RvZ3JhcGgsXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgZW5kUG9zaXRpb246IGVuZFBvc2l0aW9uLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgLy8gVXBkYXRlIHNlbGVjdGVkIHN0YXRlXG4gICAgICBzZWxlY3RlZFN0YXJ0UG9zID0gc3RhcnRQb3NQaWN0b2dyYXBoO1xuXG4gICAgICAvLyAqKkNSSVRJQ0FMOiBTYXZlIHRvIGxvY2FsU3RvcmFnZSBpbiB0aGUgZm9ybWF0IE9wdGlvblBpY2tlciBleHBlY3RzKipcbiAgICAgIHN0b3JlU3RhcnRQb3NpdGlvbkRhdGEoc3RhcnRQb3NpdGlvbkRhdGEpO1xuXG4gICAgICAvLyAqKk5FVzogUHJlbG9hZCBvcHRpb25zIEJFRk9SRSB0cmlnZ2VyaW5nIHRoZSB0cmFuc2l0aW9uKipcbiAgICAgIC8vIFRoaXMgZW5zdXJlcyBvcHRpb25zIGFyZSByZWFkeSB3aGVuIHRoZSBvcHRpb24gcGlja2VyIGZhZGVzIGluXG4gICAgICB0cnkge1xuICAgICAgICAvLyBJbXBvcnQgYW5kIHVzZSB0aGUgTGV0dGVyUXVlcnlTZXJ2aWNlIHRvIHByZWxvYWQgb3B0aW9uc1xuICAgICAgICBjb25zdCB7IHJlc29sdmUgfSA9IGF3YWl0IGltcG9ydChcIiRzZXJ2aWNlcy9ib290c3RyYXBcIik7XG4gICAgICAgIGNvbnN0IHsgSUxldHRlclF1ZXJ5U2VydmljZUludGVyZmFjZSB9ID0gYXdhaXQgaW1wb3J0KFxuICAgICAgICAgIFwiJHNlcnZpY2VzL2RpL2ludGVyZmFjZXMvY29kZXgtaW50ZXJmYWNlc1wiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGxldHRlclF1ZXJ5U2VydmljZSA9IHJlc29sdmUoSUxldHRlclF1ZXJ5U2VydmljZUludGVyZmFjZSk7XG4gICAgICAgIC8vIExldHRlclF1ZXJ5U2VydmljZSBpbml0aWFsaXplcyBhdXRvbWF0aWNhbGx5IHdoZW4gZmlyc3QgdXNlZFxuXG4gICAgICAgIC8vIEZvciBub3csIGp1c3QgZW5zdXJlIENTViBkYXRhIGlzIGxvYWRlZCAtIG9wdGlvbiBnZW5lcmF0aW9uIGxvZ2ljIHdvdWxkIG5lZWQgdG8gYmUgaW1wbGVtZW50ZWRcbiAgICAgICAgY29uc29sZS5sb2coXCLinIUgQ1NWIGRhdGEgcHJlbG9hZGVkIGZvciBvcHRpb24gcGlja2VyXCIpO1xuXG4gICAgICAgIC8vIFN0b3JlIGVtcHR5IHByZWxvYWRlZCBvcHRpb25zIGZvciBub3cgLSBvcHRpb24gZ2VuZXJhdGlvbiBsb2dpYyB3b3VsZCBuZWVkIHRvIGJlIGltcGxlbWVudGVkXG4gICAgICB9IGNhdGNoIChwcmVsb2FkRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiU3RhcnRQb3NpdGlvblBpY2tlcjogRmFpbGVkIHRvIHByZWxvYWQgb3B0aW9ucywgd2lsbCBsb2FkIG5vcm1hbGx5OlwiLFxuICAgICAgICAgIHByZWxvYWRFcnJvclxuICAgICAgICApO1xuICAgICAgICAvLyBDb250aW51ZSB3aXRoIG5vcm1hbCBmbG93IGV2ZW4gaWYgcHJlbG9hZCBmYWlsc1xuICAgICAgfVxuXG4gICAgICAvLyBVc2UgbW9kZXJuIHNlcnZpY2UgdG8gc2V0IHN0YXJ0IHBvc2l0aW9uXG4gICAgICBpZiAoc3RhcnRQb3NpdGlvblNlcnZpY2UpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRQb3NpdGlvblNlcnZpY2Uuc2V0U3RhcnRQb3NpdGlvbihzdGFydFBvc2l0aW9uQmVhdCk7XG4gICAgICB9XG5cbiAgICAgIC8vICoqQ1JJVElDQUw6IEVtaXQgZXZlbnQgdGhhdCBjb29yZGluYXRpb24gc2VydmljZSBpcyBsaXN0ZW5pbmcgZm9yKipcbiAgICAgIC8vIE5PVEU6IFdlIG9ubHkgdXNlIGV2ZW50IGRpc3BhdGNoaW5nLCBub3QgY2FsbGJhY2ssIHRvIGF2b2lkIGR1cGxpY2F0ZSBoYW5kbGluZ1xuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJzdGFydC1wb3NpdGlvbi1zZWxlY3RlZFwiLCB7XG4gICAgICAgIGRldGFpbDoge1xuICAgICAgICAgIHN0YXJ0UG9zaXRpb246IHN0YXJ0UG9zaXRpb25EYXRhLFxuICAgICAgICAgIGVuZFBvc2l0aW9uOiBlbmRQb3NpdGlvbixcbiAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgICAgcHJlbG9hZGVkT3B0aW9uczogdHJ1ZSwgLy8gU2lnbmFsIHRoYXQgb3B0aW9ucyBhcmUgcHJlbG9hZGVkXG4gICAgICAgIH0sXG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICB9KTtcbiAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gICAgICAvLyBDbGVhciB0cmFuc2l0aW9uIHN0YXRlIGFmdGVyIGEgc2hvcnRlciBkZWxheSB0byByZWR1Y2UgZmxhc2ggZHVyYXRpb25cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIH0sIDIwMCk7IC8vIFJlZHVjZWQgZnJvbSA1MDBtcyB0byAyMDBtc1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlN0YXJ0UG9zaXRpb25QaWNrZXI6IEVycm9yIHNlbGVjdGluZyBzdGFydCBwb3NpdGlvbjpcIixcbiAgICAgICAgZXJyb3JcbiAgICAgICk7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiU3RhcnRQb3NpdGlvblBpY2tlcjogRXJyb3Igc3RhY2s6XCIsIGVycm9yLnN0YWNrKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlN0YXJ0UG9zaXRpb25QaWNrZXI6IEVycm9yIGRldGFpbHM6XCIsIHtcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgIG5hbWU6IGVycm9yLm5hbWUsXG4gICAgICAgICAgc3RhcnRQb3NQaWN0b2dyYXBoOiBzdGFydFBvc1BpY3RvZ3JhcGgsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICAvLyBDb25zaWRlciBzaG93aW5nIGFuIGVycm9yIG1lc3NhZ2UgdG8gdGhlIHVzZXJcbiAgICAgIGFsZXJ0KFxuICAgICAgICBgRmFpbGVkIHRvIHNlbGVjdCBzdGFydCBwb3NpdGlvbjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBvbiBtb3VudFxuICBvbk1vdW50KCgpID0+IHtcbiAgICBsb2FkU3RhcnRQb3NpdGlvbnMoKTtcbiAgfSk7XG5cbiAgLy8gUmVsb2FkIHdoZW4gZ3JpZCBtb2RlIGNoYW5nZXNcbiAgJGVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGdyaWRNb2RlKSB7XG4gICAgICBsb2FkU3RhcnRQb3NpdGlvbnMoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIENSSVRJQ0FMIEZJWDogTGlzdGVuIGZvciBzZXF1ZW5jZSBzdGF0ZSBjaGFuZ2VzIHRvIGNsZWFyIHRyYW5zaXRpb24gc3RhdGVcbiAgaW1wb3J0IHsgc2VxdWVuY2VTdGF0ZVNlcnZpY2UgfSBmcm9tIFwiJGxpYi9zZXJ2aWNlcy9TZXF1ZW5jZVN0YXRlU2VydmljZS5zdmVsdGVcIjtcblxuICAkZWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50U2VxdWVuY2UgPSBzZXF1ZW5jZVN0YXRlU2VydmljZS5jdXJyZW50U2VxdWVuY2U7XG5cbiAgICAvLyBJZiBhIHNlcXVlbmNlIHdpdGggc3RhcnRQb3NpdGlvbiBleGlzdHMgYW5kIHdlJ3JlIHRyYW5zaXRpb25pbmcsIGNsZWFyIHRoZSB0cmFuc2l0aW9uXG4gICAgaWYgKGN1cnJlbnRTZXF1ZW5jZSAmJiBjdXJyZW50U2VxdWVuY2Uuc3RhcnRQb3NpdGlvbiAmJiBpc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgIGlzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cInN0YXJ0LXBvcy1waWNrZXJcIiBkYXRhLXRlc3RpZD1cInN0YXJ0LXBvc2l0aW9uLXBpY2tlclwiPlxuICB7I2lmIGlzTG9hZGluZ31cbiAgICA8TG9hZGluZ1N0YXRlIC8+XG4gIHs6ZWxzZSBpZiBsb2FkaW5nRXJyb3J9XG4gICAgPEVycm9yU3RhdGUgLz5cbiAgezplbHNlIGlmIHN0YXJ0UG9zaXRpb25QaWN0b2dyYXBocy5sZW5ndGggPT09IDB9XG4gICAgPEVycm9yU3RhdGVcbiAgICAgIG1lc3NhZ2U9XCJObyB2YWxpZCBzdGFydCBwb3NpdGlvbnMgZm91bmQgZm9yIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24uXCJcbiAgICAgIGhhc1JlZnJlc2hCdXR0b249e2ZhbHNlfVxuICAgIC8+XG4gIHs6ZWxzZX1cbiAgICA8UGljdG9ncmFwaEdyaWRcbiAgICAgIHBpY3RvZ3JhcGhzPXtzdGFydFBvc2l0aW9uUGljdG9ncmFwaHN9XG4gICAgICBzZWxlY3RlZFBpY3RvZ3JhcGg9e3NlbGVjdGVkU3RhcnRQb3N9XG4gICAgICBvblBpY3RvZ3JhcGhTZWxlY3Q9e2hhbmRsZVNlbGVjdH1cbiAgICAvPlxuICB7L2lmfVxuXG4gIDwhLS0gTG9hZGluZyBvdmVybGF5IGR1cmluZyB0cmFuc2l0aW9uIC0tPlxuICB7I2lmIGlzVHJhbnNpdGlvbmluZ31cbiAgICA8VHJhbnNpdGlvbk92ZXJsYXkgLz5cbiAgey9pZn1cbjwvZGl2PlxuXG48c3R5bGU+XG4gIC5zdGFydC1wb3MtcGlja2VyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgcGFkZGluZzogdmFyKC0tc3BhY2luZy1sZyk7XG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB9XG48L3N0eWxlPlxuIl0sImZpbGUiOiJGOi9DT0RFL1RLQS93ZWIvc3JjL2xpYi9jb21wb25lbnRzL2NvbnN0cnVjdC9TdGFydFBvc2l0aW9uUGlja2VyLnN2ZWx0ZSJ9