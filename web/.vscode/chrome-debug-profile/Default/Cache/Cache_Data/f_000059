import { ArrowAdjustmentProcessor } from "/src/lib/services/positioning/arrows/orchestration/ArrowAdjustmentProcessor.ts";
import { ArrowCoordinateTransformer } from "/src/lib/services/positioning/arrows/orchestration/ArrowCoordinateTransformer.ts";
import { ArrowDataProcessor } from "/src/lib/services/positioning/arrows/orchestration/ArrowDataProcessor.ts";
export class ArrowPositionCalculator {
  locationCalculator;
  rotationCalculator;
  adjustmentCalculator;
  coordinateSystem;
  adjustmentProcessor;
  coordinateTransformer;
  dataProcessor;
  constructor(locationCalculator, rotationCalculator, adjustmentCalculator, coordinateSystem) {
    this.locationCalculator = locationCalculator;
    this.rotationCalculator = rotationCalculator;
    this.adjustmentCalculator = adjustmentCalculator;
    this.coordinateSystem = coordinateSystem;
    this.adjustmentProcessor = new ArrowAdjustmentProcessor();
    this.coordinateTransformer = new ArrowCoordinateTransformer();
    this.dataProcessor = new ArrowDataProcessor(coordinateSystem);
  }
  async calculateArrowPosition(arrowData, pictographData, motionData) {
    try {
      const motion = motionData || this.dataProcessor.getMotionFromPictograph(arrowData, pictographData);
      if (!motion) {
        console.warn("No motion data available for arrow positioning");
        const center = this.coordinateSystem.getSceneCenter();
        return [center.x, center.y, 0];
      }
      const location = this.locationCalculator.calculateLocation(
        motion,
        pictographData
      );
      const initialPosition = this.coordinateSystem.getInitialPosition(
        motion,
        location
      );
      const validPosition = this.dataProcessor.ensureValidPosition(initialPosition);
      const rotation = this.rotationCalculator.calculateRotation(
        motion,
        location
      );
      const adjustment = await this.adjustmentCalculator.calculateAdjustment(
        pictographData,
        motion,
        arrowData.color,
        location
      );
      const [adjustmentX, adjustmentY] = this.dataProcessor.extractAdjustmentValues(adjustment);
      const [transformedAdjustmentX, transformedAdjustmentY] = this.coordinateTransformer.transformAdjustmentByRotation(
        adjustmentX,
        adjustmentY,
        rotation
      );
      const finalX = validPosition.x + transformedAdjustmentX;
      const finalY = validPosition.y + transformedAdjustmentY;
      return [finalX, finalY, rotation];
    } catch (error) {
      console.error("Arrow positioning calculation failed:", error);
      const center = this.coordinateSystem.getSceneCenter();
      return [center.x, center.y, 0];
    }
  }
  async updateArrowPosition(pictographData, color, motionData) {
    try {
      const arrowData = pictographData.arrows?.[color];
      if (!arrowData) {
        console.warn(`No arrow data found for color: ${color}`);
        return pictographData;
      }
      const [x, y, rotation] = await this.calculateArrowPosition(
        arrowData,
        pictographData,
        motionData
      );
      const shouldMirror = this.shouldMirrorArrow(arrowData, pictographData);
      const updates = {
        position_x: x,
        position_y: y,
        rotation_angle: rotation,
        isMirrored: shouldMirror
      };
      return this.dataProcessor.updateArrowInPictograph(
        pictographData,
        color,
        updates
      );
    } catch (error) {
      console.error("Arrow position update failed:", error);
      return pictographData;
    }
  }
  async calculateAllArrowPositions(pictographData) {
    try {
      if (!pictographData.arrows) {
        return pictographData;
      }
      let updatedPictograph = { ...pictographData };
      for (const color of Object.keys(pictographData.arrows)) {
        const arrowData = pictographData.arrows[color];
        if (arrowData) {
          const [x, y, rotation] = await this.calculateArrowPosition(
            arrowData,
            updatedPictograph
          );
          const shouldMirror = this.shouldMirrorArrow(
            arrowData,
            updatedPictograph
          );
          const updates = {
            position_x: x,
            position_y: y,
            rotation_angle: rotation,
            isMirrored: shouldMirror
          };
          updatedPictograph = this.dataProcessor.updateArrowInPictograph(
            updatedPictograph,
            color,
            updates
          );
        }
      }
      return updatedPictograph;
    } catch (error) {
      console.error("Failed to calculate all arrow positions:", error);
      return pictographData;
    }
  }
  shouldMirrorArrow(arrowData, pictographData) {
    if (!pictographData?.motions) {
      console.warn(
        "ðŸš« shouldMirrorArrow: No motion data available, defaulting to no mirror"
      );
      return false;
    }
    const motion = pictographData.motions[arrowData.color];
    if (!motion) {
      console.warn(
        `ðŸš« shouldMirrorArrow: No motion found for color ${arrowData.color}, defaulting to no mirror`
      );
      return false;
    }
    const motionType = motion.motionType?.toLowerCase();
    const propRotDir = motion.rotationDirection?.toLowerCase();
    if (!motionType || !propRotDir) {
      console.warn(
        `ðŸš« shouldMirrorArrow: Missing motionType (${motionType}) or rotationDirection (${propRotDir}), defaulting to no mirror`
      );
      return false;
    }
    const mirrorConditions = {
      anti: { cw: true, ccw: false },
      other: { cw: false, ccw: true }
    };
    const conditionKey = motionType === "anti" ? "anti" : "other";
    const shouldMirror = mirrorConditions[conditionKey][propRotDir] ?? false;
    return shouldMirror;
  }
  applyMirrorTransform(arrowItem, shouldMirror) {
    if (shouldMirror) {
      arrowItem.style.transform = `${arrowItem.style.transform || ""} scaleX(-1)`;
    } else {
      const transform = arrowItem.style.transform || "";
      arrowItem.style.transform = transform.replace(/scaleX\(-1\)\s*/g, "").trim();
    }
  }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkFycm93UG9zaXRpb25DYWxjdWxhdG9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXJyb3cgUG9zaXRpb24gQ2FsY3VsYXRvclxuICpcbiAqIEhhbmRsZXMgdGhlIG1haW4gYXJyb3cgcG9zaXRpb25pbmcgY2FsY3VsYXRpb24gbG9naWMuXG4gKiBDb29yZGluYXRlcyB3aXRoIG90aGVyIHNlcnZpY2VzIHRvIGNvbXB1dGUgZmluYWwgYXJyb3cgcG9zaXRpb25zLlxuICovXG5cbmltcG9ydCB0eXBlIHsgQXJyb3dEYXRhLCBNb3Rpb25EYXRhLCBQaWN0b2dyYXBoRGF0YSB9IGZyb20gXCIkbGliL2RvbWFpblwiO1xuaW1wb3J0IHR5cGUge1xuICBJQXJyb3dBZGp1c3RtZW50Q2FsY3VsYXRvcixcbiAgSUFycm93Q29vcmRpbmF0ZVN5c3RlbVNlcnZpY2UsXG4gIElBcnJvd0xvY2F0aW9uQ2FsY3VsYXRvcixcbiAgSUFycm93UG9zaXRpb25pbmdPcmNoZXN0cmF0b3IsXG4gIElBcnJvd1JvdGF0aW9uQ2FsY3VsYXRvcixcbn0gZnJvbSBcIi4uLy4uL2NvcmUtc2VydmljZXNcIjtcbmltcG9ydCB7IEFycm93QWRqdXN0bWVudFByb2Nlc3NvciB9IGZyb20gXCIuL0Fycm93QWRqdXN0bWVudFByb2Nlc3NvclwiO1xuaW1wb3J0IHsgQXJyb3dDb29yZGluYXRlVHJhbnNmb3JtZXIgfSBmcm9tIFwiLi9BcnJvd0Nvb3JkaW5hdGVUcmFuc2Zvcm1lclwiO1xuaW1wb3J0IHsgQXJyb3dEYXRhUHJvY2Vzc29yIH0gZnJvbSBcIi4vQXJyb3dEYXRhUHJvY2Vzc29yXCI7XG5cbmV4cG9ydCBjbGFzcyBBcnJvd1Bvc2l0aW9uQ2FsY3VsYXRvciBpbXBsZW1lbnRzIElBcnJvd1Bvc2l0aW9uaW5nT3JjaGVzdHJhdG9yIHtcbiAgcHJpdmF0ZSBsb2NhdGlvbkNhbGN1bGF0b3I6IElBcnJvd0xvY2F0aW9uQ2FsY3VsYXRvcjtcbiAgcHJpdmF0ZSByb3RhdGlvbkNhbGN1bGF0b3I6IElBcnJvd1JvdGF0aW9uQ2FsY3VsYXRvcjtcbiAgcHJpdmF0ZSBhZGp1c3RtZW50Q2FsY3VsYXRvcjogSUFycm93QWRqdXN0bWVudENhbGN1bGF0b3I7XG4gIHByaXZhdGUgY29vcmRpbmF0ZVN5c3RlbTogSUFycm93Q29vcmRpbmF0ZVN5c3RlbVNlcnZpY2U7XG5cbiAgcHJpdmF0ZSBhZGp1c3RtZW50UHJvY2Vzc29yOiBBcnJvd0FkanVzdG1lbnRQcm9jZXNzb3I7XG4gIHByaXZhdGUgY29vcmRpbmF0ZVRyYW5zZm9ybWVyOiBBcnJvd0Nvb3JkaW5hdGVUcmFuc2Zvcm1lcjtcbiAgcHJpdmF0ZSBkYXRhUHJvY2Vzc29yOiBBcnJvd0RhdGFQcm9jZXNzb3I7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbG9jYXRpb25DYWxjdWxhdG9yOiBJQXJyb3dMb2NhdGlvbkNhbGN1bGF0b3IsXG4gICAgcm90YXRpb25DYWxjdWxhdG9yOiBJQXJyb3dSb3RhdGlvbkNhbGN1bGF0b3IsXG4gICAgYWRqdXN0bWVudENhbGN1bGF0b3I6IElBcnJvd0FkanVzdG1lbnRDYWxjdWxhdG9yLFxuICAgIGNvb3JkaW5hdGVTeXN0ZW06IElBcnJvd0Nvb3JkaW5hdGVTeXN0ZW1TZXJ2aWNlXG4gICkge1xuICAgIHRoaXMubG9jYXRpb25DYWxjdWxhdG9yID0gbG9jYXRpb25DYWxjdWxhdG9yO1xuICAgIHRoaXMucm90YXRpb25DYWxjdWxhdG9yID0gcm90YXRpb25DYWxjdWxhdG9yO1xuICAgIHRoaXMuYWRqdXN0bWVudENhbGN1bGF0b3IgPSBhZGp1c3RtZW50Q2FsY3VsYXRvcjtcbiAgICB0aGlzLmNvb3JkaW5hdGVTeXN0ZW0gPSBjb29yZGluYXRlU3lzdGVtO1xuXG4gICAgdGhpcy5hZGp1c3RtZW50UHJvY2Vzc29yID0gbmV3IEFycm93QWRqdXN0bWVudFByb2Nlc3NvcigpO1xuICAgIHRoaXMuY29vcmRpbmF0ZVRyYW5zZm9ybWVyID0gbmV3IEFycm93Q29vcmRpbmF0ZVRyYW5zZm9ybWVyKCk7XG4gICAgdGhpcy5kYXRhUHJvY2Vzc29yID0gbmV3IEFycm93RGF0YVByb2Nlc3Nvcihjb29yZGluYXRlU3lzdGVtKTtcbiAgfVxuXG4gIGFzeW5jIGNhbGN1bGF0ZUFycm93UG9zaXRpb24oXG4gICAgYXJyb3dEYXRhOiBBcnJvd0RhdGEsXG4gICAgcGljdG9ncmFwaERhdGE6IFBpY3RvZ3JhcGhEYXRhLFxuICAgIG1vdGlvbkRhdGE/OiBNb3Rpb25EYXRhXG4gICk6IFByb21pc2U8W251bWJlciwgbnVtYmVyLCBudW1iZXJdPiB7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGFycm93IHBvc2l0aW9uIGFzeW5jaHJvbm91c2x5IHdpdGggZnVsbCBzZXJ2aWNlIGNvb3JkaW5hdGlvbi5cbiAgICAgKi9cbiAgICB0cnkge1xuICAgICAgLy8gU1RFUCAxOiBFeHRyYWN0IG9yIHVzZSBwcm92aWRlZCBtb3Rpb24gZGF0YVxuICAgICAgY29uc3QgbW90aW9uID1cbiAgICAgICAgbW90aW9uRGF0YSB8fFxuICAgICAgICB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0TW90aW9uRnJvbVBpY3RvZ3JhcGgoYXJyb3dEYXRhLCBwaWN0b2dyYXBoRGF0YSk7XG4gICAgICBpZiAoIW1vdGlvbikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJObyBtb3Rpb24gZGF0YSBhdmFpbGFibGUgZm9yIGFycm93IHBvc2l0aW9uaW5nXCIpO1xuICAgICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0U2NlbmVDZW50ZXIoKTtcbiAgICAgICAgcmV0dXJuIFtjZW50ZXIueCwgY2VudGVyLnksIDBdO1xuICAgICAgfVxuXG4gICAgICAvLyBTVEVQIDI6IENhbGN1bGF0ZSBsb2NhdGlvbiBhbmQgaW5pdGlhbCBwb3NpdGlvblxuICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmxvY2F0aW9uQ2FsY3VsYXRvci5jYWxjdWxhdGVMb2NhdGlvbihcbiAgICAgICAgbW90aW9uLFxuICAgICAgICBwaWN0b2dyYXBoRGF0YVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGluaXRpYWxQb3NpdGlvbiA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbS5nZXRJbml0aWFsUG9zaXRpb24oXG4gICAgICAgIG1vdGlvbixcbiAgICAgICAgbG9jYXRpb25cbiAgICAgICk7XG4gICAgICBjb25zdCB2YWxpZFBvc2l0aW9uID1cbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yLmVuc3VyZVZhbGlkUG9zaXRpb24oaW5pdGlhbFBvc2l0aW9uKTtcblxuICAgICAgLy8gU1RFUCAzOiBDYWxjdWxhdGUgcm90YXRpb25cbiAgICAgIGNvbnN0IHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbkNhbGN1bGF0b3IuY2FsY3VsYXRlUm90YXRpb24oXG4gICAgICAgIG1vdGlvbixcbiAgICAgICAgbG9jYXRpb25cbiAgICAgICk7XG5cbiAgICAgIC8vIFNURVAgNDogQ2FsY3VsYXRlIGFkanVzdG1lbnQgdXNpbmcgc29waGlzdGljYXRlZCBzZXJ2aWNlXG4gICAgICBjb25zdCBhZGp1c3RtZW50ID0gYXdhaXQgdGhpcy5hZGp1c3RtZW50Q2FsY3VsYXRvci5jYWxjdWxhdGVBZGp1c3RtZW50KFxuICAgICAgICBwaWN0b2dyYXBoRGF0YSxcbiAgICAgICAgbW90aW9uLFxuICAgICAgICBhcnJvd0RhdGEuY29sb3IsXG4gICAgICAgIGxvY2F0aW9uXG4gICAgICApO1xuICAgICAgY29uc3QgW2FkanVzdG1lbnRYLCBhZGp1c3RtZW50WV0gPVxuICAgICAgICB0aGlzLmRhdGFQcm9jZXNzb3IuZXh0cmFjdEFkanVzdG1lbnRWYWx1ZXMoYWRqdXN0bWVudCk7XG5cbiAgICAgIC8vIFNURVAgNTogQXBwbHkgcm90YXRpb24gdHJhbnNmb3JtYXRpb24gdG8gYWRqdXN0bWVudCBjb29yZGluYXRlc1xuICAgICAgY29uc3QgW3RyYW5zZm9ybWVkQWRqdXN0bWVudFgsIHRyYW5zZm9ybWVkQWRqdXN0bWVudFldID1cbiAgICAgICAgdGhpcy5jb29yZGluYXRlVHJhbnNmb3JtZXIudHJhbnNmb3JtQWRqdXN0bWVudEJ5Um90YXRpb24oXG4gICAgICAgICAgYWRqdXN0bWVudFgsXG4gICAgICAgICAgYWRqdXN0bWVudFksXG4gICAgICAgICAgcm90YXRpb25cbiAgICAgICAgKTtcblxuICAgICAgLy8gU1RFUCA2OiBDb21iaW5lIGFsbCBwb3NpdGlvbmluZyBjYWxjdWxhdGlvbnNcbiAgICAgIGNvbnN0IGZpbmFsWCA9IHZhbGlkUG9zaXRpb24ueCArIHRyYW5zZm9ybWVkQWRqdXN0bWVudFg7XG4gICAgICBjb25zdCBmaW5hbFkgPSB2YWxpZFBvc2l0aW9uLnkgKyB0cmFuc2Zvcm1lZEFkanVzdG1lbnRZO1xuXG4gICAgICByZXR1cm4gW2ZpbmFsWCwgZmluYWxZLCByb3RhdGlvbl07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBcnJvdyBwb3NpdGlvbmluZyBjYWxjdWxhdGlvbiBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbS5nZXRTY2VuZUNlbnRlcigpO1xuICAgICAgcmV0dXJuIFtjZW50ZXIueCwgY2VudGVyLnksIDBdO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZUFycm93UG9zaXRpb24oXG4gICAgcGljdG9ncmFwaERhdGE6IFBpY3RvZ3JhcGhEYXRhLFxuICAgIGNvbG9yOiBzdHJpbmcsXG4gICAgbW90aW9uRGF0YT86IE1vdGlvbkRhdGFcbiAgKTogUHJvbWlzZTxQaWN0b2dyYXBoRGF0YT4ge1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhcnJvdyBwb3NpdGlvbiBpbiBwaWN0b2dyYXBoIGRhdGEuXG4gICAgICovXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFycm93RGF0YSA9IHBpY3RvZ3JhcGhEYXRhLmFycm93cz8uW2NvbG9yXTtcbiAgICAgIGlmICghYXJyb3dEYXRhKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgTm8gYXJyb3cgZGF0YSBmb3VuZCBmb3IgY29sb3I6ICR7Y29sb3J9YCk7XG4gICAgICAgIHJldHVybiBwaWN0b2dyYXBoRGF0YTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgW3gsIHksIHJvdGF0aW9uXSA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlQXJyb3dQb3NpdGlvbihcbiAgICAgICAgYXJyb3dEYXRhLFxuICAgICAgICBwaWN0b2dyYXBoRGF0YSxcbiAgICAgICAgbW90aW9uRGF0YVxuICAgICAgKTtcblxuICAgICAgLy8gQ1JJVElDQUw6IEFsc28gY2FsY3VsYXRlIG1pcnJvcmluZyBmb3IgdGhpcyBhcnJvd1xuICAgICAgY29uc3Qgc2hvdWxkTWlycm9yID0gdGhpcy5zaG91bGRNaXJyb3JBcnJvdyhhcnJvd0RhdGEsIHBpY3RvZ3JhcGhEYXRhKTtcblxuICAgICAgY29uc3QgdXBkYXRlczogUGFydGlhbDxBcnJvd0RhdGE+ID0ge1xuICAgICAgICBwb3NpdGlvbl94OiB4LFxuICAgICAgICBwb3NpdGlvbl95OiB5LFxuICAgICAgICByb3RhdGlvbl9hbmdsZTogcm90YXRpb24sXG4gICAgICAgIGlzTWlycm9yZWQ6IHNob3VsZE1pcnJvcixcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5kYXRhUHJvY2Vzc29yLnVwZGF0ZUFycm93SW5QaWN0b2dyYXBoKFxuICAgICAgICBwaWN0b2dyYXBoRGF0YSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHVwZGF0ZXNcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBcnJvdyBwb3NpdGlvbiB1cGRhdGUgZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gcGljdG9ncmFwaERhdGE7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgY2FsY3VsYXRlQWxsQXJyb3dQb3NpdGlvbnMoXG4gICAgcGljdG9ncmFwaERhdGE6IFBpY3RvZ3JhcGhEYXRhXG4gICk6IFByb21pc2U8UGljdG9ncmFwaERhdGE+IHtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgcG9zaXRpb25zIGZvciBhbGwgYXJyb3dzIGluIHRoZSBwaWN0b2dyYXBoLlxuICAgICAqL1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXBpY3RvZ3JhcGhEYXRhLmFycm93cykge1xuICAgICAgICByZXR1cm4gcGljdG9ncmFwaERhdGE7XG4gICAgICB9XG5cbiAgICAgIGxldCB1cGRhdGVkUGljdG9ncmFwaCA9IHsgLi4ucGljdG9ncmFwaERhdGEgfTtcblxuICAgICAgZm9yIChjb25zdCBjb2xvciBvZiBPYmplY3Qua2V5cyhwaWN0b2dyYXBoRGF0YS5hcnJvd3MpKSB7XG4gICAgICAgIGNvbnN0IGFycm93RGF0YSA9IHBpY3RvZ3JhcGhEYXRhLmFycm93c1tjb2xvcl07XG4gICAgICAgIGlmIChhcnJvd0RhdGEpIHtcbiAgICAgICAgICBjb25zdCBbeCwgeSwgcm90YXRpb25dID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVBcnJvd1Bvc2l0aW9uKFxuICAgICAgICAgICAgYXJyb3dEYXRhLFxuICAgICAgICAgICAgdXBkYXRlZFBpY3RvZ3JhcGhcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gQ1JJVElDQUw6IEFsc28gY2FsY3VsYXRlIG1pcnJvcmluZyBmb3IgdGhpcyBhcnJvd1xuICAgICAgICAgIGNvbnN0IHNob3VsZE1pcnJvciA9IHRoaXMuc2hvdWxkTWlycm9yQXJyb3coXG4gICAgICAgICAgICBhcnJvd0RhdGEsXG4gICAgICAgICAgICB1cGRhdGVkUGljdG9ncmFwaFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb25zdCB1cGRhdGVzOiBQYXJ0aWFsPEFycm93RGF0YT4gPSB7XG4gICAgICAgICAgICBwb3NpdGlvbl94OiB4LFxuICAgICAgICAgICAgcG9zaXRpb25feTogeSxcbiAgICAgICAgICAgIHJvdGF0aW9uX2FuZ2xlOiByb3RhdGlvbixcbiAgICAgICAgICAgIGlzTWlycm9yZWQ6IHNob3VsZE1pcnJvcixcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdXBkYXRlZFBpY3RvZ3JhcGggPSB0aGlzLmRhdGFQcm9jZXNzb3IudXBkYXRlQXJyb3dJblBpY3RvZ3JhcGgoXG4gICAgICAgICAgICB1cGRhdGVkUGljdG9ncmFwaCxcbiAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgdXBkYXRlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZWRQaWN0b2dyYXBoO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNhbGN1bGF0ZSBhbGwgYXJyb3cgcG9zaXRpb25zOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gcGljdG9ncmFwaERhdGE7XG4gICAgfVxuICB9XG5cbiAgc2hvdWxkTWlycm9yQXJyb3coXG4gICAgYXJyb3dEYXRhOiBBcnJvd0RhdGEsXG4gICAgcGljdG9ncmFwaERhdGE/OiBQaWN0b2dyYXBoRGF0YVxuICApOiBib29sZWFuIHtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgYXJyb3cgc2hvdWxkIGJlIG1pcnJvcmVkIGJhc2VkIG9uIG1vdGlvbiB0eXBlIGFuZCBwcm9wIHJvdGF0aW9uIGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIE1pcnJvciBjb25kaXRpb25zIChtYXRjaGluZyBkZXNrdG9wIGxvZ2ljKTpcbiAgICAgKiAtIEFudGkgbW90aW9uICsgY2xvY2t3aXNlIOKGkiBNaXJyb3IgPSBUcnVlXG4gICAgICogLSBBbnRpIG1vdGlvbiArIGNvdW50ZXJjbG9ja3dpc2Ug4oaSIE1pcnJvciA9IEZhbHNlXG4gICAgICogLSBQcm8gbW90aW9uICsgY2xvY2t3aXNlIOKGkiBNaXJyb3IgPSBGYWxzZVxuICAgICAqIC0gUHJvIG1vdGlvbiArIGNvdW50ZXJjbG9ja3dpc2Ug4oaSIE1pcnJvciA9IFRydWVcbiAgICAgKiAtIE90aGVyIG1vdGlvbnMgZm9sbG93IFwicHJvXCIgcnVsZXNcbiAgICAgKi9cblxuICAgIC8vIEdldCBtb3Rpb24gZGF0YSBmb3IgdGhpcyBhcnJvdydzIGNvbG9yXG4gICAgaWYgKCFwaWN0b2dyYXBoRGF0YT8ubW90aW9ucykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIvCfmqsgc2hvdWxkTWlycm9yQXJyb3c6IE5vIG1vdGlvbiBkYXRhIGF2YWlsYWJsZSwgZGVmYXVsdGluZyB0byBubyBtaXJyb3JcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBtb3Rpb24gPSBwaWN0b2dyYXBoRGF0YS5tb3Rpb25zW2Fycm93RGF0YS5jb2xvcl07XG4gICAgaWYgKCFtb3Rpb24pIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYPCfmqsgc2hvdWxkTWlycm9yQXJyb3c6IE5vIG1vdGlvbiBmb3VuZCBmb3IgY29sb3IgJHthcnJvd0RhdGEuY29sb3J9LCBkZWZhdWx0aW5nIHRvIG5vIG1pcnJvcmBcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgbW90aW9uVHlwZSA9IG1vdGlvbi5tb3Rpb25UeXBlPy50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHByb3BSb3REaXIgPSBtb3Rpb24ucm90YXRpb25EaXJlY3Rpb24/LnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoIW1vdGlvblR5cGUgfHwgIXByb3BSb3REaXIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYPCfmqsgc2hvdWxkTWlycm9yQXJyb3c6IE1pc3NpbmcgbW90aW9uVHlwZSAoJHttb3Rpb25UeXBlfSkgb3Igcm90YXRpb25EaXJlY3Rpb24gKCR7cHJvcFJvdERpcn0pLCBkZWZhdWx0aW5nIHRvIG5vIG1pcnJvcmBcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTWlycm9yIGNvbmRpdGlvbnMgbWF0Y2hpbmcgZGVza3RvcCBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IG1pcnJvckNvbmRpdGlvbnMgPSB7XG4gICAgICBhbnRpOiB7IGN3OiB0cnVlLCBjY3c6IGZhbHNlIH0sXG4gICAgICBvdGhlcjogeyBjdzogZmFsc2UsIGNjdzogdHJ1ZSB9LFxuICAgIH07XG5cbiAgICAvLyBVc2UgXCJhbnRpXCIgY29uZGl0aW9ucyBmb3IgYW50aSBtb3Rpb24sIFwib3RoZXJcIiBmb3IgZXZlcnl0aGluZyBlbHNlIChwcm8sIHN0YXRpYywgZGFzaCwgZmxvYXQpXG4gICAgY29uc3QgY29uZGl0aW9uS2V5ID0gbW90aW9uVHlwZSA9PT0gXCJhbnRpXCIgPyBcImFudGlcIiA6IFwib3RoZXJcIjtcbiAgICBjb25zdCBzaG91bGRNaXJyb3IgPVxuICAgICAgbWlycm9yQ29uZGl0aW9uc1tjb25kaXRpb25LZXldW1xuICAgICAgICBwcm9wUm90RGlyIGFzIGtleW9mIHR5cGVvZiBtaXJyb3JDb25kaXRpb25zLmFudGlcbiAgICAgIF0gPz8gZmFsc2U7XG5cbiAgICByZXR1cm4gc2hvdWxkTWlycm9yO1xuICB9XG5cbiAgYXBwbHlNaXJyb3JUcmFuc2Zvcm0oXG4gICAgYXJyb3dJdGVtOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsXG4gICAgc2hvdWxkTWlycm9yOiBib29sZWFuXG4gICk6IHZvaWQge1xuICAgIC8qKlxuICAgICAqIEFwcGx5IG1pcnJvciB0cmFuc2Zvcm1hdGlvbiB0byBhcnJvdyBncmFwaGljcyBpdGVtLlxuICAgICAqL1xuICAgIGlmIChzaG91bGRNaXJyb3IpIHtcbiAgICAgIGFycm93SXRlbS5zdHlsZS50cmFuc2Zvcm0gPSBgJHthcnJvd0l0ZW0uc3R5bGUudHJhbnNmb3JtIHx8IFwiXCJ9IHNjYWxlWCgtMSlgO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgbWlycm9yIHRyYW5zZm9ybWF0aW9uXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBhcnJvd0l0ZW0uc3R5bGUudHJhbnNmb3JtIHx8IFwiXCI7XG4gICAgICBhcnJvd0l0ZW0uc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4gICAgICAgIC5yZXBsYWNlKC9zY2FsZVhcXCgtMVxcKVxccyovZywgXCJcIilcbiAgICAgICAgLnRyaW0oKTtcbiAgICB9XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBZUEsU0FBUyxnQ0FBZ0M7QUFDekMsU0FBUyxrQ0FBa0M7QUFDM0MsU0FBUywwQkFBMEI7QUFFNUIsYUFBTSx3QkFBaUU7QUFBQSxFQUNwRTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBRUE7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBRVIsWUFDRSxvQkFDQSxvQkFDQSxzQkFDQSxrQkFDQTtBQUNBLFNBQUsscUJBQXFCO0FBQzFCLFNBQUsscUJBQXFCO0FBQzFCLFNBQUssdUJBQXVCO0FBQzVCLFNBQUssbUJBQW1CO0FBRXhCLFNBQUssc0JBQXNCLElBQUkseUJBQXlCO0FBQ3hELFNBQUssd0JBQXdCLElBQUksMkJBQTJCO0FBQzVELFNBQUssZ0JBQWdCLElBQUksbUJBQW1CLGdCQUFnQjtBQUFBLEVBQzlEO0FBQUEsRUFFQSxNQUFNLHVCQUNKLFdBQ0EsZ0JBQ0EsWUFDbUM7QUFJbkMsUUFBSTtBQUVGLFlBQU0sU0FDSixjQUNBLEtBQUssY0FBYyx3QkFBd0IsV0FBVyxjQUFjO0FBQ3RFLFVBQUksQ0FBQyxRQUFRO0FBQ1gsZ0JBQVEsS0FBSyxnREFBZ0Q7QUFDN0QsY0FBTSxTQUFTLEtBQUssaUJBQWlCLGVBQWU7QUFDcEQsZUFBTyxDQUFDLE9BQU8sR0FBRyxPQUFPLEdBQUcsQ0FBQztBQUFBLE1BQy9CO0FBR0EsWUFBTSxXQUFXLEtBQUssbUJBQW1CO0FBQUEsUUFDdkM7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUNBLFlBQU0sa0JBQWtCLEtBQUssaUJBQWlCO0FBQUEsUUFDNUM7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUNBLFlBQU0sZ0JBQ0osS0FBSyxjQUFjLG9CQUFvQixlQUFlO0FBR3hELFlBQU0sV0FBVyxLQUFLLG1CQUFt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