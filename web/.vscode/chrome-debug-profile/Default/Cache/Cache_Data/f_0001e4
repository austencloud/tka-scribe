import { createHotContext as __vite__createHotContext } from "/@vite/client";import.meta.hot = __vite__createHotContext("/src/lib/components/pictograph/Arrow.svelte");import.meta.env = {"BASE_URL": "/", "DEV": true, "MODE": "development", "PROD": false, "SSR": false};import "/node_modules/.vite/deps/svelte_internal_disclose-version.js?v=cc8aba6c";

Arrow[$.FILENAME] = 'src/lib/components/pictograph/Arrow.svelte';

import * as $ from "/node_modules/.vite/deps/svelte_internal_client.js?v=cc8aba6c";
import { MotionColor } from "/src/lib/domain/index.ts";
import { onMount } from "/node_modules/.vite/deps/svelte.js?v=cc8aba6c";

var root_1 = $.add_locations($.from_svg(`<circle r="10" fill="red" opacity="0.5" class="s-bHAPWzQ6V5Y0"></circle><text x="0" y="4" text-anchor="middle" font-size="8" fill="white" class="s-bHAPWzQ6V5Y0">!</text>`, 1), Arrow[$.FILENAME], [[144, 4], [145, 4]]);
var root_3 = $.add_locations($.from_svg(`<text x="0" y="4" text-anchor="middle" font-size="10" fill="gray" opacity="0.5" class="s-bHAPWzQ6V5Y0">No motion data</text>`), Arrow[$.FILENAME], [[148, 4]]);
var root_5 = $.add_locations($.from_svg(`<circle r="8" opacity="0.3" class="s-bHAPWzQ6V5Y0"></circle><animate attributeName="opacity" values="0.3;0.8;0.3" dur="1s" repeatCount="indefinite" class="s-bHAPWzQ6V5Y0"></animate>`, 1), Arrow[$.FILENAME], [[160, 4], [165, 4]]);
var root_7 = $.add_locations($.from_svg(`<image preserveAspectRatio="xMidYMid meet"></image>`), Arrow[$.FILENAME], [[173, 4]]);
var root_9 = $.add_locations($.from_svg(`<circle r="2" fill="red" opacity="0.5" class="s-bHAPWzQ6V5Y0"></circle><text x="0" y="-25" text-anchor="middle" font-size="6" fill="black" class="s-bHAPWzQ6V5Y0"> </text>`, 1), Arrow[$.FILENAME], [[207, 6], [208, 6]]);
var root_8 = $.add_locations($.from_svg(`<g opacity="0" aria-hidden="true" class="s-bHAPWzQ6V5Y0"><circle r="2" opacity="0.1" class="s-bHAPWzQ6V5Y0"></circle></g><!>`, 1), Arrow[$.FILENAME], [[197, 4, [[198, 6]]]]);
var root = $.add_locations($.from_svg(`<g><!></g>`), Arrow[$.FILENAME], [[135, 0]]);

function Arrow($$anchor, $$props) {
	$.check_target(new.target);
	$.push($$props, true, Arrow);

	let showArrow = $.prop($$props, 'showArrow', 3, true);
	let loaded = $.tag($.state(false), 'loaded');
	let error = $.tag($.state(null), 'error');
	let svgData = $.tag($.state(null), 'svgData');

	const position = $.tag(
		$.derived(() => () => {
			if (!$$props.arrowData) return { x: 475, y: 475, rotation: 0 };

			if ($$props.preCalculatedPosition) {
				return $$props.preCalculatedPosition;
			}

			if ($.strict_equals($$props.arrowData.position_x, 0, false) || $.strict_equals($$props.arrowData.position_y, 0, false)) {
				return {
					x: $$props.arrowData.position_x,
					y: $$props.arrowData.position_y,
					rotation: $$props.arrowData.rotation_angle || 0
				};
			}

			console.warn(`\u26A0\uFE0F Arrow.svelte: No position data available for ${$$props.arrowData.color}, using center fallback`);

			return { x: 475, y: 475, rotation: 0 };
		}),
		'position'
	);

	const calculatedPosition = $.tag($.derived(() => () => $.get(position)()), 'calculatedPosition');
	const shouldMirror = $.tag($.derived(() => () => $$props.preCalculatedMirroring ?? false), 'shouldMirror');

	const arrowPath = $.tag(
		$.derived(() => () => {
			if (!$$props.arrowData || !$$props.motionData) {
				console.warn("\u{1F6AB} Arrow.svelte: Missing arrowData or motionData, cannot determine arrow path");

				return null;
			}

			const { motionType, turns } = $$props.motionData;
			const baseDir = `/images/arrows/${motionType}`;

			if (["pro", "anti", "static"].includes(motionType)) {
				const startOrientation = $$props.arrowData.start_orientation || $$props.motionData.startOrientation || "in";
				const endOrientation = $$props.arrowData.end_orientation || $$props.motionData.endOrientation || "in";
				const isNonRadial = $.strict_equals(startOrientation, "clock") || $.strict_equals(startOrientation, "counter") || $.strict_equals(endOrientation, "clock") || $.strict_equals(endOrientation, "counter");
				const subDir = isNonRadial ? "from_nonradial" : "from_radial";
				const turnValue = $.strict_equals(typeof turns, "number") ? turns.toFixed(1) : "0.0";
				const path2 = `${baseDir}/${subDir}/${motionType}_${turnValue}.svg`;

				return path2;
			}

			const path = `${baseDir}.svg`;

			return path;
		}),
		'arrowPath'
	);

	const parseArrowSvg = (svgText) => {
		const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
		const svg = doc.documentElement;
		const viewBoxValues = svg.getAttribute("viewBox")?.split(/\s+/) || ["0", "0", "100", "100"];

		const viewBox = {
			width: parseFloat(viewBoxValues[2] || "100") || 100,
			height: parseFloat(viewBoxValues[3] || "100") || 100
		};

		let center = { x: viewBox.width / 2, y: viewBox.height / 2 };

		try {
			const centerElement = doc.getElementById("centerPoint");

			if (centerElement) {
				center = {
					x: parseFloat(centerElement.getAttribute("cx") || "0") || center.x,
					y: parseFloat(centerElement.getAttribute("cy") || "0") || center.y
				};
			}
		} catch {}

		return { viewBox, center };
	};

	const applyColorToSvg = (svgText, color) => {
		const colorMap = /* @__PURE__ */ new Map([[MotionColor.BLUE, "#2E3192"], [MotionColor.RED, "#ED1C24"]]);
		const targetColor = colorMap.get(color) || "#2E3192";
		let coloredSvg = svgText.replace(/fill="#[0-9A-Fa-f]{6}"/g, `fill="${targetColor}"`);

		coloredSvg = coloredSvg.replace(/fill:\s*#[0-9A-Fa-f]{6}/g, `fill:${targetColor}`);
		coloredSvg = coloredSvg.replace(/<circle[^>]*id="centerPoint"[^>]*\/?>/, "");

		return coloredSvg;
	};

	const loadSvg = async () => {
		try {
			if (!$$props.arrowData) throw new Error("No arrow data available");

			const path = $.get(arrowPath)();

			if (!path) throw new Error("No arrow path available - missing motion data");

			const response = (await $.track_reactivity_loss(fetch(path)))();

			if (!response.ok) throw new Error("Failed to fetch SVG");

			const originalSvgText = (await $.track_reactivity_loss(response.text()))();
			const { viewBox, center } = parseArrowSvg(originalSvgText);
			const coloredSvgText = applyColorToSvg(originalSvgText, $$props.arrowData.color);

			$.set(
				svgData,
				{
					imageSrc: `data:image/svg+xml;base64,${btoa(coloredSvgText)}`,
					viewBox,
					center
				},
				true
			);

			$.set(loaded, true);
			$$props.onLoaded?.(`${$$props.arrowData?.color}-arrow`);
		} catch(e) {
			$.set(error, `Failed to load arrow SVG: ${e}`);
			$$props.onError?.(`${$$props.arrowData?.color}-arrow`, $.get(error));
			$.set(loaded, true);
		}
	};

	onMount(() => {
		loadSvg();
	});

	var g = root();
	let classes;
	var node = $.child(g);

	{
		var consequent = ($$anchor) => {
			var fragment = root_1();

			$.next();
			$.append($$anchor, fragment);
		};

		var alternate_3 = ($$anchor) => {
			var fragment_1 = $.comment();
			var node_1 = $.first_child(fragment_1);

			{
				var consequent_1 = ($$anchor) => {
					var text = root_3();

					$.append($$anchor, text);
				};

				var alternate_2 = ($$anchor) => {
					var fragment_2 = $.comment();
					var node_2 = $.first_child(fragment_2);

					{
						var consequent_2 = ($$anchor) => {
							var fragment_3 = root_5();
							var circle = $.first_child(fragment_3);

							$.next();
							$.template_effect(() => $.set_attribute(circle, 'fill', $.strict_equals($$props.arrowData?.color, "blue") ? "#2E3192" : "#ED1C24"));
							$.append($$anchor, fragment_3);
						};

						var alternate_1 = ($$anchor) => {
							var fragment_4 = $.comment();
							var node_3 = $.first_child(fragment_4);

							{
								var consequent_3 = ($$anchor) => {
									var image = root_7();
									let classes_1;
									let styles;

									$.template_effect(
										($0, $1, $2, $3, $4, $5) => {
											$.set_attribute(image, 'href', $.get(svgData).imageSrc);

											$.set_attribute(image, 'transform', `
				translate(${$0 ?? ''}, ${$1 ?? ''})
				rotate(${$2 ?? ''})
				scale(${$3 ?? ''}, 1)
				translate(${-$.get(svgData).center.x}, ${-$.get(svgData).center.y})
			`);

											$.set_attribute(image, 'width', $.get(svgData).viewBox.width);
											$.set_attribute(image, 'height', $.get(svgData).viewBox.height);
											classes_1 = $.set_class(image, 0, `arrow-svg ${$$props.arrowData?.color ?? ''}-arrow-svg`, 's-bHAPWzQ6V5Y0', classes_1, $4);
											styles = $.set_style(image, '', styles, $5);
										},
										[
											() => $.get(calculatedPosition)().x,
											() => $.get(calculatedPosition)().y,
											() => $.get(calculatedPosition)().rotation || $$props.arrowData?.rotation_angle || 0,
											() => $.get(shouldMirror)() ? -1 : 1,
											() => ({ mirrored: $.get(shouldMirror) }),
											() => ({ opacity: showArrow() ? 1 : 0 })
										]
									);

									$.event('error', image, () => {
										$.set(error, "Failed to load arrow SVG");
										$$props.onError?.(`${$$props.arrowData?.color}-arrow`, $.get(error));
									});

									$.event('load', image, () => {
										// SVG loaded - no debug logging needed for performance
									});

									$.append($$anchor, image);
								};

								var alternate = ($$anchor) => {
									var fragment_5 = root_8();
									var g_1 = $.first_child(fragment_5);
									var circle_1 = $.child(g_1);

									$.reset(g_1);

									var node_4 = $.sibling(g_1);

									{
										var consequent_4 = ($$anchor) => {
											var fragment_6 = root_9();
											var text_1 = $.sibling($.first_child(fragment_6));
											var text_2 = $.child(text_1, true);

											$.reset(text_1);
											$.template_effect(() => $.set_text(text_2, $$props.arrowData?.location));
											$.append($$anchor, fragment_6);
										};

										$.add_svelte_meta(
											() => $.if(node_4, ($$render) => {
												if (import.meta.env.DEV) $$render(consequent_4);
											}),
											'if',
											Arrow,
											206,
											4
										);
									}

									$.template_effect(() => $.set_attribute(circle_1, 'fill', $.strict_equals($$props.arrowData?.color, "blue") ? "#2E3192" : "#ED1C24"));
									$.append($$anchor, fragment_5);
								};

								$.add_svelte_meta(
									() => $.if(
										node_3,
										($$render) => {
											if (showArrow()) $$render(consequent_3); else $$render(alternate, false);
										},
										true
									),
									'if',
									Arrow,
									171,
									2
								);
							}

							$.append($$anchor, fragment_4);
						};

						$.add_svelte_meta(
							() => $.if(
								node_2,
								($$render) => {
									if (!$.get(loaded) || !$.get(svgData)) $$render(consequent_2); else $$render(alternate_1, false);
								},
								true
							),
							'if',
							Arrow,
							158,
							2
						);
					}

					$.append($$anchor, fragment_2);
				};

				$.add_svelte_meta(
					() => $.if(
						node_1,
						($$render) => {
							if (!$.get(arrowPath)()) $$render(consequent_1); else $$render(alternate_2, false);
						},
						true
					),
					'if',
					Arrow,
					146,
					2
				);
			}

			$.append($$anchor, fragment_1);
		};

		$.add_svelte_meta(
			() => $.if(node, ($$render) => {
				if ($.get(error)) $$render(consequent); else $$render(alternate_3, false);
			}),
			'if',
			Arrow,
			142,
			2
		);
	}

	$.reset(g);

	$.template_effect(
		($0) => {
			classes = $.set_class(g, 0, `arrow-group ${$$props.arrowData?.color ?? ''}-arrow`, 's-bHAPWzQ6V5Y0', classes, $0);
			$.set_attribute(g, 'data-arrow-color', $$props.arrowData?.color);
			$.set_attribute(g, 'data-motion-type', $$props.motionData?.motionType);
			$.set_attribute(g, 'data-location', $$props.arrowData?.location);
		},
		[() => ({ loaded: $.get(loaded) })]
	);

	$.append($$anchor, g);

	return $.pop({ ...$.legacy_api() });
}

if (import.meta.hot) {
	Arrow = $.hmr(Arrow, () => Arrow[$.HMR].source);

	import.meta.hot.acceptExports(["default"],(module) => {
		$.cleanup_styles('s-bHAPWzQ6V5Y0');
		module.default[$.HMR].source = Arrow[$.HMR].source;
		$.set(Arrow[$.HMR].source, module.default[$.HMR].original);
	});
}

export default Arrow;
import "/src/lib/components/pictograph/Arrow.svelte?svelte&type=style&lang.css";

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6Ijs7Ozs7U0FNVyxtQkFBZTtTQWNwQjs7Ozs7Ozs7OztrQ0FwQk4sQ0FBQzs7OztLQWlEWSw0Q0FDRjtLQU9QLHVCQUFRO0tBQ047S0FDRix3QkFNSTs7T0FLRjt3QkFBUTtvQ0FDTjs7c0NBR0o7O0dBR0E7O3lDQVFRLFlBQ0osK0NBQVUsWUFBbUI7O0tBUS9CLHFCQUFlO0tBQ2YscUJBQU07S0FDTiw0QkFBdUIsa0JBQWM7O0dBR3ZDOztHQUtELDRGQVFJOztZQUVHLEdBQU0sS0FBSTtFQUdoQjs7OztPQUdFO09BQ0E7O09BR0E7d0JBQWtCO2tEQUNDO0lBQ3JCLGFBR0k7O1dBR0k7R0FDTjs7V0FFTyxZQUFXO1NBQ2QsNEJBQTRCOztRQUdsQyxPQUFRO1VBS1YscUNBR00sd0NBQW1FO1VBQ2pFLG1DQUNTLHNDQUFlO1VBRTdCLDhCQUVLLGtCQUFjLDRCQUdoQixrQkFBcUIsOEJBQ3ZCLDRDQUNBLGdCQUFvQjtVQUV0QixTQUFhLGNBQVc7VUFDdEI7VUFDUUEsV0FBQSxPQUFXOztXQUlyQkE7R0FDRTs7U0FJSzs7VUFDVDtFQUdBOzs7O09BSUksaUJBQ0EsWUFNQTtRQUNNLFVBQUUsWUFBb0IsZ0JBQWMsd0JBQWU7UUFHbkQ7UUFJSiw4REFDQSxLQUNGLEtBRUEsT0FDQTs7UUFFQTtHQUNBLGtCQUFhLGNBQWdCLE1BQVUsS0FBSztHQUU1QyxRQUFTOzs7TUFLWCxXQUFROztNQUtKOzs7T0FFRSxlQUFTO0lBQ2xCO0tBQ1EsY0FBYSxjQUFnQixhQUFPO0tBQ3JDOztHQUVGO0VBQ0osUUFBSyxDQUVIOztXQUVTLFNBQU07Q0FDbkI7O09BR0s7UUFDSyxxQ0FDSCxZQUFHLG1CQUNKLFlBQWEsY0FBTTtRQUduQixjQUFZO01BR1osYUFBSSxnQkFDTixvQ0FDSyxXQUFnQjs7RUFFekIsYUFBVSxtQkFDSixvQ0FDUSxXQUFJO0VBSWxCLGFBQWlCLFdBQVEsUUFDbkIseUNBQ0E7O1NBR0c7Q0FDVDs7T0FHSSxzQkFBVztNQUNYO3FDQUM0QixNQUFNOztTQUVuQzs7UUFDUSxnQkFDRyxNQUFRLCtDQUFjOztTQUV4QiwwQ0FBWSxNQUFXOztRQUN4QixTQUFTLGNBQWM7O1NBRTVCLGlEQUFlO1dBQ1AsU0FBUyxXQUFTLGNBQVU7U0FHOUIsaUJBQVE7OztJQUVkOztLQUNEO0tBQ0c7S0FDQTs7Ozs7U0FHUixRQUFZOzRDQUNtQixLQUFLO0VBQ3BDLFFBQVEsR0FBUTtTQUNWLG9DQUFDOzJDQUNBO1NBRUQsUUFBUztFQUNYO0NBQ0o7O0NBRUEsY0FBUztFQUNUO0NBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQkFrQlksU0FBTzs7Ozs7Ozs7Ozs7Ozs7OztjQUpoQixLQUFTOzs7Ozs7Ozs7Ozs7O2lFQU5WOzZEQUVvQjs4REFDUjswREFDWjs7Ozs7Ozs7Q0FSRiIsIm5hbWVzIjpbInBhdGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiQXJyb3cuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjwhLS1cbkFycm93IENvbXBvbmVudCAtIFJlbmRlcnMgU1ZHIGFycm93cyB3aXRoIHByb3BlciBwb3NpdGlvbmluZyBhbmQgbmF0dXJhbCBzaXppbmdcbkZvbGxvd3MgdGhlIHNhbWUgcGF0dGVybiBhcyBQcm9wIGNvbXBvbmVudCBmb3IgY29uc2lzdGVudCBzaXppbmcgYmVoYXZpb3Jcbi0tPlxuPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgaW1wb3J0IHsgTW90aW9uQ29sb3IsIHR5cGUgQXJyb3dEYXRhLCB0eXBlIE1vdGlvbkRhdGEgfSBmcm9tIFwiJGxpYi9kb21haW5cIjtcbiAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICBpbnRlcmZhY2UgUHJvcHMge1xuICAgIGFycm93RGF0YTogQXJyb3dEYXRhO1xuICAgIG1vdGlvbkRhdGE/OiBNb3Rpb25EYXRhOyAvLyBNb3Rpb25EYXRhIGZyb20gcGljdG9ncmFwaFxuICAgIHByZUNhbGN1bGF0ZWRQb3NpdGlvbj86XG4gICAgICB8IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHJvdGF0aW9uOiBudW1iZXIgfVxuICAgICAgfCB1bmRlZmluZWQ7IC8vIFByZS1jYWxjdWxhdGVkIHBvc2l0aW9uIGZyb20gcGFyZW50XG4gICAgcHJlQ2FsY3VsYXRlZE1pcnJvcmluZz86IGJvb2xlYW4gfCB1bmRlZmluZWQ7IC8vIFByZS1jYWxjdWxhdGVkIG1pcnJvcmluZyBmcm9tIHBhcmVudFxuICAgIHNob3dBcnJvdz86IGJvb2xlYW47IC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgYXJyb3cgKGNvb3JkaW5hdGlvbiBmbGFnKVxuICAgIG9uTG9hZGVkPzogKGNvbXBvbmVudFR5cGU6IHN0cmluZykgPT4gdm9pZDtcbiAgICBvbkVycm9yPzogKGNvbXBvbmVudFR5cGU6IHN0cmluZywgZXJyb3I6IHN0cmluZykgPT4gdm9pZDtcbiAgfVxuXG4gIGxldCB7XG4gICAgYXJyb3dEYXRhLFxuICAgIG1vdGlvbkRhdGEsXG4gICAgcHJlQ2FsY3VsYXRlZFBvc2l0aW9uLFxuICAgIHByZUNhbGN1bGF0ZWRNaXJyb3JpbmcsXG4gICAgc2hvd0Fycm93ID0gdHJ1ZSxcbiAgICBvbkxvYWRlZCxcbiAgICBvbkVycm9yLFxuICB9OiBQcm9wcyA9ICRwcm9wcygpO1xuXG4gIGxldCBsb2FkZWQgPSAkc3RhdGUoZmFsc2UpO1xuICBsZXQgZXJyb3IgPSAkc3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGxldCBzdmdEYXRhID0gJHN0YXRlPHtcbiAgICBpbWFnZVNyYzogc3RyaW5nO1xuICAgIHZpZXdCb3g6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfTtcbiAgICBjZW50ZXI6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcbiAgfSB8IG51bGw+KG51bGwpO1xuXG4gIC8vIFNJTkdMRSBTT1VSQ0UgT0YgVFJVVEg6IFVzZSBPTkxZIHByZS1jYWxjdWxhdGVkIHBvc2l0aW9ucyBmcm9tIEFycm93UG9zaXRpb25pbmdPcmNoZXN0cmF0b3JcbiAgY29uc3QgcG9zaXRpb24gPSAkZGVyaXZlZCgoKSA9PiB7XG4gICAgaWYgKCFhcnJvd0RhdGEpIHJldHVybiB7IHg6IDQ3NS4wLCB5OiA0NzUuMCwgcm90YXRpb246IDAgfTtcblxuICAgIC8vIE9OTFkgdXNlIHByZUNhbGN1bGF0ZWRQb3NpdGlvbiAtIG5vIG1vcmUgcmVkdW5kYW50IGNhbGN1bGF0aW9ucyFcbiAgICBpZiAocHJlQ2FsY3VsYXRlZFBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gcHJlQ2FsY3VsYXRlZFBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrOiB1c2UgcG9zaXRpb24gZGF0YSBmcm9tIGFycm93RGF0YSBpZiBhdmFpbGFibGUgKGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eSlcbiAgICBpZiAoYXJyb3dEYXRhLnBvc2l0aW9uX3ggIT09IDAgfHwgYXJyb3dEYXRhLnBvc2l0aW9uX3kgIT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGFycm93RGF0YS5wb3NpdGlvbl94LFxuICAgICAgICB5OiBhcnJvd0RhdGEucG9zaXRpb25feSxcbiAgICAgICAgcm90YXRpb246IGFycm93RGF0YS5yb3RhdGlvbl9hbmdsZSB8fCAwLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbCBmYWxsYmFjazogY2VudGVyIHBvc2l0aW9uXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYOKaoO+4jyBBcnJvdy5zdmVsdGU6IE5vIHBvc2l0aW9uIGRhdGEgYXZhaWxhYmxlIGZvciAke2Fycm93RGF0YS5jb2xvcn0sIHVzaW5nIGNlbnRlciBmYWxsYmFja2BcbiAgICApO1xuICAgIHJldHVybiB7IHg6IDQ3NS4wLCB5OiA0NzUuMCwgcm90YXRpb246IDAgfTtcbiAgfSk7XG5cbiAgLy8gU0lOR0xFIFNPVVJDRSBPRiBUUlVUSDogVXNlIG9ubHkgdGhlIHBvc2l0aW9uIGZyb20gdGhlIGRlcml2ZWQgZnVuY3Rpb25cbiAgY29uc3QgY2FsY3VsYXRlZFBvc2l0aW9uID0gJGRlcml2ZWQoKCkgPT4gcG9zaXRpb24oKSk7XG4gIGNvbnN0IHNob3VsZE1pcnJvciA9ICRkZXJpdmVkKCgpID0+IHByZUNhbGN1bGF0ZWRNaXJyb3JpbmcgPz8gZmFsc2UpO1xuXG4gIC8vIEdldCBhcnJvdyBTVkcgcGF0aCBiYXNlZCBvbiBtb3Rpb24gdHlwZSBhbmQgcHJvcGVydGllc1xuICBjb25zdCBhcnJvd1BhdGggPSAkZGVyaXZlZCgoKSA9PiB7XG4gICAgaWYgKCFhcnJvd0RhdGEgfHwgIW1vdGlvbkRhdGEpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCLwn5qrIEFycm93LnN2ZWx0ZTogTWlzc2luZyBhcnJvd0RhdGEgb3IgbW90aW9uRGF0YSwgY2Fubm90IGRldGVybWluZSBhcnJvdyBwYXRoXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB7IG1vdGlvblR5cGUsIHR1cm5zIH0gPSBtb3Rpb25EYXRhO1xuICAgIGNvbnN0IGJhc2VEaXIgPSBgL2ltYWdlcy9hcnJvd3MvJHttb3Rpb25UeXBlfWA7XG5cbiAgICAvLyBGb3IgbW90aW9uIHR5cGVzIHRoYXQgaGF2ZSB0dXJuLWJhc2VkIHN1YmRpcmVjdG9yaWVzIChwcm8sIGFudGksIHN0YXRpYylcbiAgICBpZiAoW1wicHJvXCIsIFwiYW50aVwiLCBcInN0YXRpY1wiXS5pbmNsdWRlcyhtb3Rpb25UeXBlKSkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCB1c2UgcmFkaWFsIHZzIG5vbi1yYWRpYWwgYXJyb3dzXG4gICAgICAvLyBVc2Ugbm9uLXJhZGlhbCBvbmx5IGZvciBjbG9jay9jb3VudGVyIG9yaWVudGF0aW9ucywgcmFkaWFsIGZvciBldmVyeXRoaW5nIGVsc2VcbiAgICAgIGNvbnN0IHN0YXJ0T3JpZW50YXRpb24gPVxuICAgICAgICBhcnJvd0RhdGEuc3RhcnRfb3JpZW50YXRpb24gfHwgbW90aW9uRGF0YS5zdGFydE9yaWVudGF0aW9uIHx8IFwiaW5cIjtcbiAgICAgIGNvbnN0IGVuZE9yaWVudGF0aW9uID1cbiAgICAgICAgYXJyb3dEYXRhLmVuZF9vcmllbnRhdGlvbiB8fCBtb3Rpb25EYXRhLmVuZE9yaWVudGF0aW9uIHx8IFwiaW5cIjtcblxuICAgICAgY29uc3QgaXNOb25SYWRpYWwgPVxuICAgICAgICBzdGFydE9yaWVudGF0aW9uID09PSBcImNsb2NrXCIgfHxcbiAgICAgICAgc3RhcnRPcmllbnRhdGlvbiA9PT0gXCJjb3VudGVyXCIgfHxcbiAgICAgICAgZW5kT3JpZW50YXRpb24gPT09IFwiY2xvY2tcIiB8fFxuICAgICAgICBlbmRPcmllbnRhdGlvbiA9PT0gXCJjb3VudGVyXCI7XG5cbiAgICAgIGNvbnN0IHN1YkRpciA9IGlzTm9uUmFkaWFsID8gXCJmcm9tX25vbnJhZGlhbFwiIDogXCJmcm9tX3JhZGlhbFwiO1xuICAgICAgY29uc3QgdHVyblZhbHVlID0gdHlwZW9mIHR1cm5zID09PSBcIm51bWJlclwiID8gdHVybnMudG9GaXhlZCgxKSA6IFwiMC4wXCI7XG4gICAgICBjb25zdCBwYXRoID0gYCR7YmFzZURpcn0vJHtzdWJEaXJ9LyR7bW90aW9uVHlwZX1fJHt0dXJuVmFsdWV9LnN2Z2A7XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8vIEZvciBzaW1wbGUgbW90aW9uIHR5cGVzIChkYXNoLCBmbG9hdCkgLSB1c2UgYmFzZSBkaXJlY3RvcnlcbiAgICBjb25zdCBwYXRoID0gYCR7YmFzZURpcn0uc3ZnYDtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSk7XG5cbiAgLy8gUGFyc2UgU1ZHIHRvIGdldCBwcm9wZXIgZGltZW5zaW9ucyBhbmQgY2VudGVyIHBvaW50IChzYW1lIGFzIFByb3AgY29tcG9uZW50KVxuICBjb25zdCBwYXJzZUFycm93U3ZnID0gKFxuICAgIHN2Z1RleHQ6IHN0cmluZ1xuICApOiB7XG4gICAgdmlld0JveDogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9O1xuICAgIGNlbnRlcjogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuICB9ID0+IHtcbiAgICBjb25zdCBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHN2Z1RleHQsIFwiaW1hZ2Uvc3ZnK3htbFwiKTtcbiAgICBjb25zdCBzdmcgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgLy8gR2V0IHZpZXdCb3ggZGltZW5zaW9uc1xuICAgIGNvbnN0IHZpZXdCb3hWYWx1ZXMgPSBzdmcuZ2V0QXR0cmlidXRlKFwidmlld0JveFwiKT8uc3BsaXQoL1xccysvKSB8fCBbXG4gICAgICBcIjBcIixcbiAgICAgIFwiMFwiLFxuICAgICAgXCIxMDBcIixcbiAgICAgIFwiMTAwXCIsXG4gICAgXTtcbiAgICBjb25zdCB2aWV3Qm94ID0ge1xuICAgICAgd2lkdGg6IHBhcnNlRmxvYXQodmlld0JveFZhbHVlc1syXSB8fCBcIjEwMFwiKSB8fCAxMDAsXG4gICAgICBoZWlnaHQ6IHBhcnNlRmxvYXQodmlld0JveFZhbHVlc1szXSB8fCBcIjEwMFwiKSB8fCAxMDAsXG4gICAgfTtcblxuICAgIC8vIEdldCBjZW50ZXIgcG9pbnQgZnJvbSBTVkdcbiAgICBsZXQgY2VudGVyID0geyB4OiB2aWV3Qm94LndpZHRoIC8gMiwgeTogdmlld0JveC5oZWlnaHQgLyAyIH07XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2VudGVyRWxlbWVudCA9IGRvYy5nZXRFbGVtZW50QnlJZChcImNlbnRlclBvaW50XCIpO1xuICAgICAgaWYgKGNlbnRlckVsZW1lbnQpIHtcbiAgICAgICAgY2VudGVyID0ge1xuICAgICAgICAgIHg6IHBhcnNlRmxvYXQoY2VudGVyRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjeFwiKSB8fCBcIjBcIikgfHwgY2VudGVyLngsXG4gICAgICAgICAgeTogcGFyc2VGbG9hdChjZW50ZXJFbGVtZW50LmdldEF0dHJpYnV0ZShcImN5XCIpIHx8IFwiMFwiKSB8fCBjZW50ZXIueSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIFNWRyBjZW50ZXIgY2FsY3VsYXRpb24gZmFpbGVkLCB1c2luZyBkZWZhdWx0IGNlbnRlclxuICAgIH1cblxuICAgIHJldHVybiB7IHZpZXdCb3gsIGNlbnRlciB9O1xuICB9O1xuXG4gIC8vIEFwcGx5IGNvbG9yIHRyYW5zZm9ybWF0aW9uIHRvIFNWRyBjb250ZW50IChzYW1lIGFzIFByb3AgY29tcG9uZW50KVxuICBjb25zdCBhcHBseUNvbG9yVG9TdmcgPSAoc3ZnVGV4dDogc3RyaW5nLCBjb2xvcjogTW90aW9uQ29sb3IpOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IGNvbG9yTWFwID0gbmV3IE1hcChbXG4gICAgICBbTW90aW9uQ29sb3IuQkxVRSwgXCIjMkUzMTkyXCJdLFxuICAgICAgW01vdGlvbkNvbG9yLlJFRCwgXCIjRUQxQzI0XCJdLFxuICAgIF0pO1xuXG4gICAgY29uc3QgdGFyZ2V0Q29sb3IgPSBjb2xvck1hcC5nZXQoY29sb3IpIHx8IFwiIzJFMzE5MlwiO1xuXG4gICAgLy8gVXNlIHJlZ2V4IHJlcGxhY2VtZW50IHRvIGNoYW5nZSBmaWxsIGNvbG9ycyBkaXJlY3RseVxuICAgIGxldCBjb2xvcmVkU3ZnID0gc3ZnVGV4dC5yZXBsYWNlKFxuICAgICAgL2ZpbGw9XCIjWzAtOUEtRmEtZl17Nn1cIi9nLFxuICAgICAgYGZpbGw9XCIke3RhcmdldENvbG9yfVwiYFxuICAgICk7XG4gICAgY29sb3JlZFN2ZyA9IGNvbG9yZWRTdmcucmVwbGFjZShcbiAgICAgIC9maWxsOlxccyojWzAtOUEtRmEtZl17Nn0vZyxcbiAgICAgIGBmaWxsOiR7dGFyZ2V0Q29sb3J9YFxuICAgICk7XG5cbiAgICAvLyBSZW1vdmUgdGhlIGNlbnRlclBvaW50IGNpcmNsZSBlbnRpcmVseSB0byBwcmV2ZW50IHVud2FudGVkIHZpc3VhbCBlbGVtZW50c1xuICAgIGNvbG9yZWRTdmcgPSBjb2xvcmVkU3ZnLnJlcGxhY2UoXG4gICAgICAvPGNpcmNsZVtePl0qaWQ9XCJjZW50ZXJQb2ludFwiW14+XSpcXC8/Pi8sXG4gICAgICBcIlwiXG4gICAgKTtcblxuICAgIHJldHVybiBjb2xvcmVkU3ZnO1xuICB9O1xuXG4gIC8vIExvYWQgU1ZHIGRhdGEgKHNhbWUgcGF0dGVybiBhcyBQcm9wIGNvbXBvbmVudClcbiAgY29uc3QgbG9hZFN2ZyA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFhcnJvd0RhdGEpIHRocm93IG5ldyBFcnJvcihcIk5vIGFycm93IGRhdGEgYXZhaWxhYmxlXCIpO1xuXG4gICAgICBjb25zdCBwYXRoID0gYXJyb3dQYXRoKCk7XG4gICAgICBpZiAoIXBhdGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFycm93IHBhdGggYXZhaWxhYmxlIC0gbWlzc2luZyBtb3Rpb24gZGF0YVwiKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChwYXRoKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBmZXRjaCBTVkdcIik7XG5cbiAgICAgIGNvbnN0IG9yaWdpbmFsU3ZnVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGNvbnN0IHsgdmlld0JveCwgY2VudGVyIH0gPSBwYXJzZUFycm93U3ZnKG9yaWdpbmFsU3ZnVGV4dCk7XG5cbiAgICAgIC8vIEFwcGx5IGNvbG9yIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBTVkdcbiAgICAgIGNvbnN0IGNvbG9yZWRTdmdUZXh0ID0gYXBwbHlDb2xvclRvU3ZnKG9yaWdpbmFsU3ZnVGV4dCwgYXJyb3dEYXRhLmNvbG9yKTtcblxuICAgICAgc3ZnRGF0YSA9IHtcbiAgICAgICAgaW1hZ2VTcmM6IGBkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LCR7YnRvYShjb2xvcmVkU3ZnVGV4dCl9YCxcbiAgICAgICAgdmlld0JveCxcbiAgICAgICAgY2VudGVyLFxuICAgICAgfTtcblxuICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICAgIG9uTG9hZGVkPy4oYCR7YXJyb3dEYXRhPy5jb2xvcn0tYXJyb3dgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvciA9IGBGYWlsZWQgdG8gbG9hZCBhcnJvdyBTVkc6ICR7ZX1gO1xuICAgICAgb25FcnJvcj8uKGAke2Fycm93RGF0YT8uY29sb3J9LWFycm93YCwgZXJyb3IpO1xuICAgICAgLy8gU3RpbGwgbWFyayBhcyBsb2FkZWQgdG8gcHJldmVudCBibG9ja2luZ1xuICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgbG9hZFN2ZygpO1xuICB9KTtcblxuICAvLyBSZWxvYWQgU1ZHIHdoZW4gYXJyb3cgcGF0aCBjaGFuZ2VzIC0gUkVNT1ZFRCAkZWZmZWN0IFRPIFBSRVZFTlQgSU5GSU5JVEUgTE9PUFxuICAvLyBTVkcgd2lsbCBiZSBsb2FkZWQgb25jZSBvbiBtb3VudCwgbm8gcmVhY3RpdmUgcmVsb2FkaW5nIHRvIGF2b2lkIGxvb3BzXG48L3NjcmlwdD5cblxuPCEtLSBBcnJvdyBHcm91cCAtLT5cbjxnXG4gIGNsYXNzPVwiYXJyb3ctZ3JvdXAge2Fycm93RGF0YT8uY29sb3J9LWFycm93XCJcbiAgY2xhc3M6bG9hZGVkXG4gIGRhdGEtYXJyb3ctY29sb3I9e2Fycm93RGF0YT8uY29sb3J9XG4gIGRhdGEtbW90aW9uLXR5cGU9e21vdGlvbkRhdGE/Lm1vdGlvblR5cGV9XG4gIGRhdGEtbG9jYXRpb249e2Fycm93RGF0YT8ubG9jYXRpb259XG4+XG4gIHsjaWYgZXJyb3J9XG4gICAgPCEtLSBFcnJvciBzdGF0ZSAtLT5cbiAgICA8Y2lyY2xlIHI9XCIxMFwiIGZpbGw9XCJyZWRcIiBvcGFjaXR5PVwiMC41XCIgLz5cbiAgICA8dGV4dCB4PVwiMFwiIHk9XCI0XCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIiBmb250LXNpemU9XCI4XCIgZmlsbD1cIndoaXRlXCI+ITwvdGV4dD5cbiAgezplbHNlIGlmICFhcnJvd1BhdGgoKX1cbiAgICA8IS0tIE5vIGFycm93IHBhdGggYXZhaWxhYmxlIChtaXNzaW5nIG1vdGlvbiBkYXRhKSAtLT5cbiAgICA8dGV4dFxuICAgICAgeD1cIjBcIlxuICAgICAgeT1cIjRcIlxuICAgICAgdGV4dC1hbmNob3I9XCJtaWRkbGVcIlxuICAgICAgZm9udC1zaXplPVwiMTBcIlxuICAgICAgZmlsbD1cImdyYXlcIlxuICAgICAgb3BhY2l0eT1cIjAuNVwiXG4gICAgPlxuICAgICAgTm8gbW90aW9uIGRhdGFcbiAgICA8L3RleHQ+XG4gIHs6ZWxzZSBpZiAhbG9hZGVkIHx8ICFzdmdEYXRhfVxuICAgIDwhLS0gTG9hZGluZyBzdGF0ZSAtLT5cbiAgICA8Y2lyY2xlXG4gICAgICByPVwiOFwiXG4gICAgICBmaWxsPXthcnJvd0RhdGE/LmNvbG9yID09PSBcImJsdWVcIiA/IFwiIzJFMzE5MlwiIDogXCIjRUQxQzI0XCJ9XG4gICAgICBvcGFjaXR5PVwiMC4zXCJcbiAgICAvPlxuICAgIDxhbmltYXRlXG4gICAgICBhdHRyaWJ1dGVOYW1lPVwib3BhY2l0eVwiXG4gICAgICB2YWx1ZXM9XCIwLjM7MC44OzAuM1wiXG4gICAgICBkdXI9XCIxc1wiXG4gICAgICByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIlxuICAgIC8+XG4gIHs6ZWxzZSBpZiBzaG93QXJyb3d9XG4gICAgPCEtLSBBY3R1YWwgYXJyb3cgU1ZHIHdpdGggbmF0dXJhbCBzaXppbmcgYW5kIGNlbnRlcmluZyAoc2FtZSBhcyBwcm9wcykgLS0+XG4gICAgPGltYWdlXG4gICAgICBocmVmPXtzdmdEYXRhLmltYWdlU3JjfVxuICAgICAgdHJhbnNmb3JtPVwiXG5cdFx0XHRcdHRyYW5zbGF0ZSh7Y2FsY3VsYXRlZFBvc2l0aW9uKCkueH0sIHtjYWxjdWxhdGVkUG9zaXRpb24oKS55fSlcblx0XHRcdFx0cm90YXRlKHtjYWxjdWxhdGVkUG9zaXRpb24oKS5yb3RhdGlvbiB8fCBhcnJvd0RhdGE/LnJvdGF0aW9uX2FuZ2xlIHx8IDB9KVxuXHRcdFx0XHRzY2FsZSh7c2hvdWxkTWlycm9yKCkgPyAtMSA6IDF9LCAxKVxuXHRcdFx0XHR0cmFuc2xhdGUoey1zdmdEYXRhLmNlbnRlci54fSwgey1zdmdEYXRhLmNlbnRlci55fSlcblx0XHRcdFwiXG4gICAgICB3aWR0aD17c3ZnRGF0YS52aWV3Qm94LndpZHRofVxuICAgICAgaGVpZ2h0PXtzdmdEYXRhLnZpZXdCb3guaGVpZ2h0fVxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIlxuICAgICAgY2xhc3M9XCJhcnJvdy1zdmcge2Fycm93RGF0YT8uY29sb3J9LWFycm93LXN2Z1wiXG4gICAgICBjbGFzczptaXJyb3JlZD17c2hvdWxkTWlycm9yfVxuICAgICAgc3R5bGU6b3BhY2l0eT17c2hvd0Fycm93ID8gMSA6IDB9XG4gICAgICBvbmVycm9yPXsoKSA9PiB7XG4gICAgICAgIGVycm9yID0gXCJGYWlsZWQgdG8gbG9hZCBhcnJvdyBTVkdcIjtcbiAgICAgICAgb25FcnJvcj8uKGAke2Fycm93RGF0YT8uY29sb3J9LWFycm93YCwgZXJyb3IpO1xuICAgICAgfX1cbiAgICAgIG9ubG9hZD17KCkgPT4ge1xuICAgICAgICAvLyBTVkcgbG9hZGVkIC0gbm8gZGVidWcgbG9nZ2luZyBuZWVkZWQgZm9yIHBlcmZvcm1hbmNlXG4gICAgICB9fVxuICAgIC8+XG4gIHs6ZWxzZX1cbiAgICA8IS0tIEhpZGRlbiBidXQgbG9hZGVkIGFycm93IChwb3NpdGlvbmluZyByZWFkeSBidXQgd2FpdGluZyBmb3IgY29vcmRpbmF0aW9uKSAtLT5cbiAgICA8ZyBvcGFjaXR5PVwiMFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgICAgPGNpcmNsZVxuICAgICAgICByPVwiMlwiXG4gICAgICAgIGZpbGw9e2Fycm93RGF0YT8uY29sb3IgPT09IFwiYmx1ZVwiID8gXCIjMkUzMTkyXCIgOiBcIiNFRDFDMjRcIn1cbiAgICAgICAgb3BhY2l0eT1cIjAuMVwiXG4gICAgICAvPlxuICAgIDwvZz5cblxuICAgIDwhLS0gRGVidWcgaW5mbyAoaWYgbmVlZGVkKSAtLT5cbiAgICB7I2lmIGltcG9ydC5tZXRhLmVudi5ERVZ9XG4gICAgICA8Y2lyY2xlIHI9XCIyXCIgZmlsbD1cInJlZFwiIG9wYWNpdHk9XCIwLjVcIiAvPlxuICAgICAgPHRleHQgeD1cIjBcIiB5PVwiLTI1XCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIiBmb250LXNpemU9XCI2XCIgZmlsbD1cImJsYWNrXCI+XG4gICAgICAgIHthcnJvd0RhdGE/LmxvY2F0aW9ufVxuICAgICAgPC90ZXh0PlxuICAgIHsvaWZ9XG4gIHsvaWZ9XG48L2c+XG5cbjxzdHlsZT5cbiAgLmFycm93LWdyb3VwIHtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4ycyBlYXNlO1xuICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlcjtcbiAgfVxuXG4gIC5hcnJvdy1ncm91cC5sb2FkZWQge1xuICAgIG9wYWNpdHk6IDE7XG4gIH1cblxuICAuYXJyb3ctc3ZnIHtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgfVxuXG4gIC8qIEVuc3VyZSBwcm9wZXIgbGF5ZXJpbmcgKi9cbiAgLmFycm93LWdyb3VwIHtcbiAgICB6LWluZGV4OiAyO1xuICB9XG48L3N0eWxlPlxuIl0sImZpbGUiOiJGOi9DT0RFL1RLQS93ZWIvc3JjL2xpYi9jb21wb25lbnRzL3BpY3RvZ3JhcGgvQXJyb3cuc3ZlbHRlIn0=