/* codex-state.svelte.ts generated by Svelte v5.38.1 */
import * as $ from "/node_modules/.vite/deps/svelte_internal_client.js?v=de368f3a";
import { getContext } from "/node_modules/.vite/deps/svelte.js?v=de368f3a";
import { ICodexServiceInterface } from "/src/lib/services/di/interfaces/codex-interfaces.ts";

export function createCodexState() {
	console.log("üîß createCodexState() called - creating new state instance");

	const getContainer = getContext("di-container");

	function getCodexService() {
		console.log("üîß getCodexService() called");

		const container = getContainer?.();

		if (!container) {
			throw new Error("DI container not yet available - this should not happen after layout initialization");
		}

		const service = container.resolve(ICodexServiceInterface);

		console.log("üîß Container resolved service:", !!service);

		return service;
	}

	let searchTerm = $.tag($.state(""), 'searchTerm');
	let isLoading = $.tag($.state(false), 'isLoading');
	let pictographs = $.tag($.state($.proxy([])), 'pictographs');
	let pictographsByLetter = $.tag($.state($.proxy({})), 'pictographsByLetter');
	let currentOrientation = $.tag($.state("Diamond"), 'currentOrientation');
	let error = $.tag($.state(null), 'error');
	let isProcessingOperation = $.tag($.state(false), 'isProcessingOperation');
	let letterRows = $.tag($.state($.proxy([])), 'letterRows');
	let isInitialized = $.tag($.state(false), 'isInitialized');

	const filteredPictographs = $.tag(
		$.derived(() => !$.get(searchTerm)
			? $.get(pictographs)
			: $.get(pictographs).filter((pictograph) => {
				const term = $.get(searchTerm).toLowerCase();
				const letter = pictograph.letter?.toLowerCase() || "";
				const id = pictograph.id?.toLowerCase() || "";

				return letter.includes(term) || id.includes(term) || letter.startsWith(term);
			})),
		'filteredPictographs'
	);

	const filteredPictographsByLetter = $.tag(
		$.derived(() => () => {
			if (!$.get(searchTerm)) return $.get(pictographsByLetter);

			const result = {};
			const term = $.get(searchTerm).toLowerCase();

			Object.entries($.get(pictographsByLetter)).forEach(([letter, pictograph]) => {
				if (pictograph && letter.toLowerCase().includes(term)) {
					result[letter] = pictograph;
				}
			});

			return result;
		}),
		'filteredPictographsByLetter'
	);

	async function loadAllPictographs() {
		console.log(...$.log_if_contains_state('log', "üîÑ loadAllPictographs() called, isLoading:", $.get(isLoading), "isInitialized:", $.get(isInitialized)));

		if ($.get(isLoading)) {
			console.log("‚ö†Ô∏è loadAllPictographs: Already loading, skipping");

			return;
		}

		$.set(isLoading, true);
		$.set(error, null);

		try {
			const codexService = getCodexService();

			console.log("üîç Loading all codex pictographs...");

			const allPictographs = (await $.track_reactivity_loss(codexService.loadAllPictographs()))();

			$.set(pictographs, allPictographs, true);
			$.set(pictographsByLetter, (await $.track_reactivity_loss(codexService.getAllPictographData()))(), true);

			if ($.strict_equals($.get(letterRows).length, 0)) {
				$.set(letterRows, codexService.getLettersByRow(), true);
			}

			$.set(isInitialized, true);
			console.log("‚úÖ Codex data loaded successfully");
		} catch(err) {
			console.error(...$.log_if_contains_state('error', "Failed to load pictographs:", err));
			$.set(error, "Failed to load pictographs. Please try again.");
			$.set(pictographs, [], true);
			$.set(pictographsByLetter, {}, true);
		} finally {
			$.set(isLoading, false);
		}
	}

	async function performRotateOperation() {
		if ($.get(isProcessingOperation)) return;

		$.set(isProcessingOperation, true);

		try {
			const codexService = getCodexService();

			console.log("üîÑ Performing rotate operation...");

			const rotatedPictographs = (await $.track_reactivity_loss(codexService.rotateAllPictographs($.get(pictographs))))();

			$.set(pictographs, rotatedPictographs, true);
			$.set(pictographsByLetter, (await $.track_reactivity_loss(codexService.getAllPictographData()))(), true);
		} catch(err) {
			console.error(...$.log_if_contains_state('error', "Failed to rotate pictographs:", err));
			$.set(error, "Failed to rotate pictographs. Please try again.");
		} finally {
			$.set(isProcessingOperation, false);
		}
	}

	async function performMirrorOperation() {
		if ($.get(isProcessingOperation)) return;

		$.set(isProcessingOperation, true);

		try {
			const codexService = getCodexService();

			console.log("ü™û Performing mirror operation...");

			const mirroredPictographs = (await $.track_reactivity_loss(codexService.mirrorAllPictographs($.get(pictographs))))();

			$.set(pictographs, mirroredPictographs, true);
			$.set(pictographsByLetter, (await $.track_reactivity_loss(codexService.getAllPictographData()))(), true);
		} catch(err) {
			console.error(...$.log_if_contains_state('error', "Failed to mirror pictographs:", err));
			$.set(error, "Failed to mirror pictographs. Please try again.");
		} finally {
			$.set(isProcessingOperation, false);
		}
	}

	async function performColorSwapOperation() {
		if ($.get(isProcessingOperation)) return;

		$.set(isProcessingOperation, true);

		try {
			const codexService = getCodexService();

			console.log("‚ö´‚ö™ Performing color swap operation...");

			const swappedPictographs = (await $.track_reactivity_loss(codexService.colorSwapAllPictographs($.get(pictographs))))();

			$.set(pictographs, swappedPictographs, true);
			$.set(pictographsByLetter, (await $.track_reactivity_loss(codexService.getAllPictographData()))(), true);
		} catch(err) {
			console.error(...$.log_if_contains_state('error', "Failed to swap colors:", err));
			$.set(error, "Failed to swap colors. Please try again.");
		} finally {
			$.set(isProcessingOperation, false);
		}
	}

	return {
		// Reactive getters
		get searchTerm() {
			return $.get(searchTerm);
		},

		get isLoading() {
			return $.get(isLoading);
		},

		get isInitialized() {
			return $.get(isInitialized);
		},

		get pictographs() {
			return $.get(pictographs);
		},

		get filteredPictographs() {
			return $.get(filteredPictographs);
		},

		get pictographsByLetter() {
			return $.get(pictographsByLetter);
		},

		get filteredPictographsByLetter() {
			return $.get(filteredPictographsByLetter);
		},

		get letterRows() {
			return $.get(letterRows);
		},

		get currentOrientation() {
			return $.get(currentOrientation);
		},

		get error() {
			return $.get(error);
		},

		get isProcessingOperation() {
			return $.get(isProcessingOperation);
		},

		// Methods
		setSearchTerm(term) {
			$.set(searchTerm, term, true);
		},

		setOrientation(orientation) {
			$.set(currentOrientation, orientation, true);
			console.log(...$.log_if_contains_state('log', "üîÑ Orientation changed to:", orientation));
		},

		async refreshPictographs() {
			(await $.track_reactivity_loss(loadAllPictographs()))();
		},

		async searchPictographs(term) {
			$.set(searchTerm, term, true);
		},

		async getPictographByLetter(letter) {
			const codexService = getCodexService();

			return (await $.track_reactivity_loss(codexService.getPictographByLetter(letter)))();
		},

		// Operation methods
		async rotatePictographs() {
			(await $.track_reactivity_loss(performRotateOperation()))();
		},

		async mirrorPictographs() {
			(await $.track_reactivity_loss(performMirrorOperation()))();
		},

		async colorSwapPictographs() {
			(await $.track_reactivity_loss(performColorSwapOperation()))();
		}
	};
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6Ijs7U0FTUyxrQkFBa0I7U0FFbEIsOEJBQThCOztnQkFHdkIsbUJBQW1CO0NBQ2pDLFFBQVEsSUFBSSw0REFBNEQ7O09BR2xFLGVBQ0osV0FBMEMsY0FBYzs7VUFFakQsa0JBQWlDO0VBQ3hDLFFBQVEsSUFBSSw2QkFBNkI7O1FBQ25DLFlBQVk7O09BQ2IsV0FBVzthQUNKLE1BQ1I7RUFFSjs7UUFFTSxVQUFVLFVBQVUsUUFBUSxzQkFBc0I7O0VBQ3hELFFBQVEsSUFBSSxvQ0FBb0MsT0FBTzs7U0FDaEQ7Q0FDVDs7S0FHSSwyQkFBNEIsRUFBRTtLQUM5QiwwQkFBNEIsS0FBSztLQUNqQztLQUNBO0tBQ0EsbUNBQW9DLFNBQVM7S0FDN0Msc0JBQThCLElBQUk7S0FDbEMsc0NBQXdDLEtBQUs7S0FHN0M7S0FDQSw4QkFBZ0MsS0FBSzs7T0FHbkM7eUJBQ0g7V0FDRztXQUNBLGFBQVksUUFBUSxlQUFlO1VBQzNCLGFBQU8sWUFBVztVQUNsQixTQUFTLFdBQVcsUUFBUSxpQkFBaUI7VUFDN0MsS0FBSyxXQUFXLElBQUksaUJBQWlCOztXQUd6QyxPQUFPLFNBQVMsSUFBSSxLQUNwQixHQUFHLFNBQVMsSUFBSSxLQUNoQixPQUFPLFdBQVcsSUFBSTtHQUUxQixDQUFDOzs7O09BSUQ7d0JBQTZDO2NBQzVDLDBCQUFtQjs7U0FFbEI7U0FDQSxhQUFPLFlBQVc7O0dBRXhCLE9BQU8sY0FBUSxtQkFBbUIsR0FBRSxVQUFVLFFBQVEsVUFBVSxNQUFNO1FBQ2hFLGNBQWMsT0FBTyxjQUFjLFNBQVMsSUFBSSxHQUFHO0tBQ3JELE9BQU8sTUFBTSxJQUFJO0lBQ25CO0dBQ0YsQ0FBQzs7VUFFTTtFQUNULENBQUM7Ozs7Z0JBR2MscUJBQXFCO0VBQ2xDLFFBQVEsc0NBQ04sb0RBQ0EsWUFDQSx3QkFDQTs7WUFHRSxZQUFXO0dBQ2IsUUFBUSxJQUFJLGtEQUFrRDs7O0VBRWhFOztRQUVBLFdBQVk7UUFDWixPQUFROztNQUVKO1NBQ0ksZUFBZTs7R0FDckIsUUFBUSxJQUFJLHFDQUFxQzs7U0FHM0MsZ0RBQXVCLGFBQWE7O1NBQzFDLGFBQWM7U0FHZCxvREFBNEIsYUFBYTs7NkJBR3JDLFlBQVcsUUFBVyxJQUFHO1VBQzNCLFlBQWEsYUFBYTtHQUM1Qjs7U0FFQSxlQUFnQjtHQUNoQixRQUFRLElBQUksa0NBQWtDO0VBQ2hELFFBQVMsS0FBSztHQUNaLFFBQVEsMENBQU0sK0JBQStCLEdBQUc7U0FDaEQsT0FBUTtTQUNSO1NBQ0E7RUFDRixVQUFFO1NBQ0EsV0FBWTtFQUNkO0NBQ0Y7O2dCQUdlLHlCQUF5QjtZQUNsQzs7UUFFSix1QkFBd0I7O01BQ3BCO1NBQ0ksZUFBZTs7R0FDckIsUUFBUSxJQUFJLG1DQUFtQzs7U0FDekMsb0RBQ0UsYUFBYSwyQkFBcUIsV0FBVzs7U0FDckQsYUFBYztTQUdkLG9EQUE0QixhQUFhO0VBQzNDLFFBQVMsS0FBSztHQUNaLFFBQVEsMENBQU0saUNBQWlDLEdBQUc7U0FDbEQsT0FBUTtFQUNWLFVBQUU7U0FDQSx1QkFBd0I7RUFDMUI7Q0FDRjs7Z0JBRWUseUJBQXlCO1lBQ2xDOztRQUVKLHVCQUF3Qjs7TUFDcEI7U0FDSSxlQUFlOztHQUNyQixRQUFRLElBQUksbUNBQW1DOztTQUN6QyxxREFDRSxhQUFhLDJCQUFxQixXQUFXOztTQUNyRCxhQUFjO1NBR2Qsb0RBQTRCLGFBQWE7RUFDM0MsUUFBUyxLQUFLO0dBQ1osUUFBUSwwQ0FBTSxpQ0FBaUMsR0FBRztTQUNsRCxPQUFRO0VBQ1YsVUFBRTtTQUNBLHVCQUF3QjtFQUMxQjtDQUNGOztnQkFFZSw0QkFBNEI7WUFDckM7O1FBRUosdUJBQXdCOztNQUNwQjtTQUNJLGVBQWU7O0dBQ3JCLFFBQVEsSUFBSSx1Q0FBdUM7O1NBQzdDLG9EQUNFLGFBQWEsOEJBQXdCLFdBQVc7O1NBQ3hELGFBQWM7U0FHZCxvREFBNEIsYUFBYTtFQUMzQyxRQUFTLEtBQUs7R0FDWixRQUFRLDBDQUFNLDBCQUEwQixHQUFHO1NBQzNDLE9BQVE7RUFDVixVQUFFO1NBQ0EsdUJBQXdCO0VBQzFCO0NBQ0Y7Ozs7TUFLTSxhQUFhO2dCQUNSO0VBQ1Q7O01BQ0ksWUFBWTtnQkFDUDtFQUNUOztNQUNJLGdCQUFnQjtnQkFDWDtFQUNUOztNQUNJLGNBQWM7Z0JBQ1Q7RUFDVDs7TUFDSSxzQkFBc0I7Z0JBQ2pCO0VBQ1Q7O01BQ0ksc0JBQXNCO2dCQUNqQjtFQUNUOztNQUNJLDhCQUE4QjtnQkFDekI7RUFDVDs7TUFDSSxhQUFhO2dCQUNSO0VBQ1Q7O01BQ0kscUJBQXFCO2dCQUNoQjtFQUNUOztNQUNJLFFBQVE7Z0JBQ0g7RUFDVDs7TUFDSSx3QkFBd0I7Z0JBQ25CO0VBQ1Q7OztFQUdBLGNBQWMsTUFBYztTQUMxQixZQUFhO0VBQ2Y7O0VBRUEsZUFBZSxhQUFxQjtTQUNsQyxvQkFBcUI7R0FDckIsUUFBUSxzQ0FBSSw4QkFBOEIsV0FBVztFQUN2RDs7UUFFTSxxQkFBcUI7a0NBQ25CO0VBQ1I7O1FBRU0sa0JBQWtCLE1BQWM7U0FDcEMsWUFBYTtFQUVmOztRQUVNLHNCQUFzQixRQUFnQjtTQUNwQyxlQUFlOzt5Q0FDUixhQUFhLHNCQUFzQixNQUFNO0VBQ3hEOzs7UUFHTSxvQkFBb0I7a0NBQ2xCO0VBQ1I7O1FBRU0sb0JBQW9CO2tDQUNsQjtFQUNSOztRQUVNLHVCQUF1QjtrQ0FDckI7RUFDUjs7QUFFSiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiY29kZXgtc3RhdGUuc3ZlbHRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29kZXggU3RhdGUgTWFuYWdlbWVudCB3aXRoIFN2ZWx0ZSA1IFJ1bmVzXG4gKlxuICogSGFuZGxlcyByZWFjdGl2ZSBzdGF0ZSBmb3IgdGhlIGNvZGV4IGNvbXBvbmVudCBpbmNsdWRpbmdcbiAqIHNlYXJjaCwgcGljdG9ncmFwaCBkYXRhLCBvcGVyYXRpb25zLCBhbmQgb3JpZW50YXRpb24gdXNpbmcgdGhlIENvZGV4U2VydmljZS5cbiAqIE1hdGNoZXMgZGVza3RvcCBmdW5jdGlvbmFsaXR5IHdpdGggcm93IG9yZ2FuaXphdGlvbiBhbmQgY29udHJvbCBvcGVyYXRpb25zLlxuICovXG5cbmltcG9ydCB0eXBlIHsgUGljdG9ncmFwaERhdGEgfSBmcm9tIFwiJGxpYi9kb21haW4vUGljdG9ncmFwaERhdGFcIjtcbmltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tIFwic3ZlbHRlXCI7XG5pbXBvcnQgdHlwZSB7IFNlcnZpY2VDb250YWluZXIgfSBmcm9tIFwiJGxpYi9zZXJ2aWNlcy9kaS9TZXJ2aWNlQ29udGFpbmVyXCI7XG5pbXBvcnQgeyBJQ29kZXhTZXJ2aWNlSW50ZXJmYWNlIH0gZnJvbSBcIiRsaWIvc2VydmljZXMvZGkvaW50ZXJmYWNlcy9jb2RleC1pbnRlcmZhY2VzXCI7XG5pbXBvcnQgdHlwZSB7IElDb2RleFNlcnZpY2UgfSBmcm9tIFwiJGxpYi9zZXJ2aWNlcy9jb2RleC9JQ29kZXhTZXJ2aWNlXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb2RleFN0YXRlKCkge1xuICBjb25zb2xlLmxvZyhcIvCflKcgY3JlYXRlQ29kZXhTdGF0ZSgpIGNhbGxlZCAtIGNyZWF0aW5nIG5ldyBzdGF0ZSBpbnN0YW5jZVwiKTtcblxuICAvLyBHZXQgdGhlIERJIGNvbnRhaW5lciBmcm9tIGNvbnRleHQgKHByb3ZpZGVkIGJ5IGxheW91dClcbiAgY29uc3QgZ2V0Q29udGFpbmVyID1cbiAgICBnZXRDb250ZXh0PCgpID0+IFNlcnZpY2VDb250YWluZXIgfCBudWxsPihcImRpLWNvbnRhaW5lclwiKTtcblxuICBmdW5jdGlvbiBnZXRDb2RleFNlcnZpY2UoKTogSUNvZGV4U2VydmljZSB7XG4gICAgY29uc29sZS5sb2coXCLwn5SnIGdldENvZGV4U2VydmljZSgpIGNhbGxlZFwiKTtcbiAgICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXI/LigpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiREkgY29udGFpbmVyIG5vdCB5ZXQgYXZhaWxhYmxlIC0gdGhpcyBzaG91bGQgbm90IGhhcHBlbiBhZnRlciBsYXlvdXQgaW5pdGlhbGl6YXRpb25cIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJ2aWNlID0gY29udGFpbmVyLnJlc29sdmUoSUNvZGV4U2VydmljZUludGVyZmFjZSk7XG4gICAgY29uc29sZS5sb2coXCLwn5SnIENvbnRhaW5lciByZXNvbHZlZCBzZXJ2aWNlOlwiLCAhIXNlcnZpY2UpO1xuICAgIHJldHVybiBzZXJ2aWNlO1xuICB9XG5cbiAgLy8gQ29yZSByZWFjdGl2ZSBzdGF0ZSB1c2luZyBTdmVsdGUgNSBydW5lc1xuICBsZXQgc2VhcmNoVGVybSA9ICRzdGF0ZTxzdHJpbmc+KFwiXCIpO1xuICBsZXQgaXNMb2FkaW5nID0gJHN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgbGV0IHBpY3RvZ3JhcGhzID0gJHN0YXRlPFBpY3RvZ3JhcGhEYXRhW10+KFtdKTtcbiAgbGV0IHBpY3RvZ3JhcGhzQnlMZXR0ZXIgPSAkc3RhdGU8UmVjb3JkPHN0cmluZywgUGljdG9ncmFwaERhdGEgfCBudWxsPj4oe30pO1xuICBsZXQgY3VycmVudE9yaWVudGF0aW9uID0gJHN0YXRlPHN0cmluZz4oXCJEaWFtb25kXCIpO1xuICBsZXQgZXJyb3IgPSAkc3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGxldCBpc1Byb2Nlc3NpbmdPcGVyYXRpb24gPSAkc3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIC8vIEdldCBsZXR0ZXIgcm93cyBmcm9tIHNlcnZpY2UgLSBpbml0aWFsaXplZCBhcyBlbXB0eSBhbmQgbG9hZGVkIHdoZW4gbmVlZGVkXG4gIGxldCBsZXR0ZXJSb3dzID0gJHN0YXRlPHN0cmluZ1tdW10+KFtdKTtcbiAgbGV0IGlzSW5pdGlhbGl6ZWQgPSAkc3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIC8vIERlcml2ZWQgcmVhY3RpdmUgdmFsdWVzXG4gIGNvbnN0IGZpbHRlcmVkUGljdG9ncmFwaHMgPSAkZGVyaXZlZChcbiAgICAhc2VhcmNoVGVybVxuICAgICAgPyBwaWN0b2dyYXBoc1xuICAgICAgOiBwaWN0b2dyYXBocy5maWx0ZXIoKHBpY3RvZ3JhcGgpID0+IHtcbiAgICAgICAgICBjb25zdCB0ZXJtID0gc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGNvbnN0IGxldHRlciA9IHBpY3RvZ3JhcGgubGV0dGVyPy50b0xvd2VyQ2FzZSgpIHx8IFwiXCI7XG4gICAgICAgICAgY29uc3QgaWQgPSBwaWN0b2dyYXBoLmlkPy50b0xvd2VyQ2FzZSgpIHx8IFwiXCI7XG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbGV0dGVyLmluY2x1ZGVzKHRlcm0pIHx8XG4gICAgICAgICAgICBpZC5pbmNsdWRlcyh0ZXJtKSB8fFxuICAgICAgICAgICAgbGV0dGVyLnN0YXJ0c1dpdGgodGVybSlcbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICApO1xuXG4gIC8vIEZpbHRlcmVkIHBpY3RvZ3JhcGhzIGJ5IGxldHRlciBmb3Igcm93IGRpc3BsYXlcbiAgY29uc3QgZmlsdGVyZWRQaWN0b2dyYXBoc0J5TGV0dGVyID0gJGRlcml2ZWQoKCkgPT4ge1xuICAgIGlmICghc2VhcmNoVGVybSkgcmV0dXJuIHBpY3RvZ3JhcGhzQnlMZXR0ZXI7XG5cbiAgICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIFBpY3RvZ3JhcGhEYXRhIHwgbnVsbD4gPSB7fTtcbiAgICBjb25zdCB0ZXJtID0gc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgT2JqZWN0LmVudHJpZXMocGljdG9ncmFwaHNCeUxldHRlcikuZm9yRWFjaCgoW2xldHRlciwgcGljdG9ncmFwaF0pID0+IHtcbiAgICAgIGlmIChwaWN0b2dyYXBoICYmIGxldHRlci50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHRlcm0pKSB7XG4gICAgICAgIHJlc3VsdFtsZXR0ZXJdID0gcGljdG9ncmFwaDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xuXG4gIC8vIExvYWQgYWxsIHBpY3RvZ3JhcGhzIGFuZCBvcmdhbml6ZSBieSBsZXR0ZXJcbiAgYXN5bmMgZnVuY3Rpb24gbG9hZEFsbFBpY3RvZ3JhcGhzKCkge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgXCLwn5SEIGxvYWRBbGxQaWN0b2dyYXBocygpIGNhbGxlZCwgaXNMb2FkaW5nOlwiLFxuICAgICAgaXNMb2FkaW5nLFxuICAgICAgXCJpc0luaXRpYWxpemVkOlwiLFxuICAgICAgaXNJbml0aWFsaXplZFxuICAgICk7XG5cbiAgICBpZiAoaXNMb2FkaW5nKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIuKaoO+4jyBsb2FkQWxsUGljdG9ncmFwaHM6IEFscmVhZHkgbG9hZGluZywgc2tpcHBpbmdcIik7XG4gICAgICByZXR1cm47IC8vIFByZXZlbnQgbXVsdGlwbGUgc2ltdWx0YW5lb3VzIGxvYWRzXG4gICAgfVxuXG4gICAgaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICBlcnJvciA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29kZXhTZXJ2aWNlID0gZ2V0Q29kZXhTZXJ2aWNlKCk7XG4gICAgICBjb25zb2xlLmxvZyhcIvCflI0gTG9hZGluZyBhbGwgY29kZXggcGljdG9ncmFwaHMuLi5cIik7XG5cbiAgICAgIC8vIExvYWQgcGljdG9ncmFwaHMgZnJvbSBzZXJ2aWNlXG4gICAgICBjb25zdCBhbGxQaWN0b2dyYXBocyA9IGF3YWl0IGNvZGV4U2VydmljZS5sb2FkQWxsUGljdG9ncmFwaHMoKTtcbiAgICAgIHBpY3RvZ3JhcGhzID0gYWxsUGljdG9ncmFwaHM7XG5cbiAgICAgIC8vIEFsc28gbG9hZCBvcmdhbml6ZWQgYnkgbGV0dGVyXG4gICAgICBwaWN0b2dyYXBoc0J5TGV0dGVyID0gYXdhaXQgY29kZXhTZXJ2aWNlLmdldEFsbFBpY3RvZ3JhcGhEYXRhKCk7XG5cbiAgICAgIC8vIExvYWQgbGV0dGVyIHJvd3MgaWYgbm90IGFscmVhZHkgbG9hZGVkXG4gICAgICBpZiAobGV0dGVyUm93cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbGV0dGVyUm93cyA9IGNvZGV4U2VydmljZS5nZXRMZXR0ZXJzQnlSb3coKTtcbiAgICAgIH1cblxuICAgICAgaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmxvZyhcIuKchSBDb2RleCBkYXRhIGxvYWRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgcGljdG9ncmFwaHM6XCIsIGVycik7XG4gICAgICBlcnJvciA9IFwiRmFpbGVkIHRvIGxvYWQgcGljdG9ncmFwaHMuIFBsZWFzZSB0cnkgYWdhaW4uXCI7XG4gICAgICBwaWN0b2dyYXBocyA9IFtdO1xuICAgICAgcGljdG9ncmFwaHNCeUxldHRlciA9IHt9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0xvYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBPcGVyYXRpb24gbWV0aG9kc1xuICBhc3luYyBmdW5jdGlvbiBwZXJmb3JtUm90YXRlT3BlcmF0aW9uKCkge1xuICAgIGlmIChpc1Byb2Nlc3NpbmdPcGVyYXRpb24pIHJldHVybjtcblxuICAgIGlzUHJvY2Vzc2luZ09wZXJhdGlvbiA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvZGV4U2VydmljZSA9IGdldENvZGV4U2VydmljZSgpO1xuICAgICAgY29uc29sZS5sb2coXCLwn5SEIFBlcmZvcm1pbmcgcm90YXRlIG9wZXJhdGlvbi4uLlwiKTtcbiAgICAgIGNvbnN0IHJvdGF0ZWRQaWN0b2dyYXBocyA9XG4gICAgICAgIGF3YWl0IGNvZGV4U2VydmljZS5yb3RhdGVBbGxQaWN0b2dyYXBocyhwaWN0b2dyYXBocyk7XG4gICAgICBwaWN0b2dyYXBocyA9IHJvdGF0ZWRQaWN0b2dyYXBocztcblxuICAgICAgLy8gUmVmcmVzaCB0aGUgb3JnYW5pemVkIGRhdGFcbiAgICAgIHBpY3RvZ3JhcGhzQnlMZXR0ZXIgPSBhd2FpdCBjb2RleFNlcnZpY2UuZ2V0QWxsUGljdG9ncmFwaERhdGEoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcm90YXRlIHBpY3RvZ3JhcGhzOlwiLCBlcnIpO1xuICAgICAgZXJyb3IgPSBcIkZhaWxlZCB0byByb3RhdGUgcGljdG9ncmFwaHMuIFBsZWFzZSB0cnkgYWdhaW4uXCI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzUHJvY2Vzc2luZ09wZXJhdGlvbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHBlcmZvcm1NaXJyb3JPcGVyYXRpb24oKSB7XG4gICAgaWYgKGlzUHJvY2Vzc2luZ09wZXJhdGlvbikgcmV0dXJuO1xuXG4gICAgaXNQcm9jZXNzaW5nT3BlcmF0aW9uID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29kZXhTZXJ2aWNlID0gZ2V0Q29kZXhTZXJ2aWNlKCk7XG4gICAgICBjb25zb2xlLmxvZyhcIvCfqp4gUGVyZm9ybWluZyBtaXJyb3Igb3BlcmF0aW9uLi4uXCIpO1xuICAgICAgY29uc3QgbWlycm9yZWRQaWN0b2dyYXBocyA9XG4gICAgICAgIGF3YWl0IGNvZGV4U2VydmljZS5taXJyb3JBbGxQaWN0b2dyYXBocyhwaWN0b2dyYXBocyk7XG4gICAgICBwaWN0b2dyYXBocyA9IG1pcnJvcmVkUGljdG9ncmFwaHM7XG5cbiAgICAgIC8vIFJlZnJlc2ggdGhlIG9yZ2FuaXplZCBkYXRhXG4gICAgICBwaWN0b2dyYXBoc0J5TGV0dGVyID0gYXdhaXQgY29kZXhTZXJ2aWNlLmdldEFsbFBpY3RvZ3JhcGhEYXRhKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIG1pcnJvciBwaWN0b2dyYXBoczpcIiwgZXJyKTtcbiAgICAgIGVycm9yID0gXCJGYWlsZWQgdG8gbWlycm9yIHBpY3RvZ3JhcGhzLiBQbGVhc2UgdHJ5IGFnYWluLlwiO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc1Byb2Nlc3NpbmdPcGVyYXRpb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBwZXJmb3JtQ29sb3JTd2FwT3BlcmF0aW9uKCkge1xuICAgIGlmIChpc1Byb2Nlc3NpbmdPcGVyYXRpb24pIHJldHVybjtcblxuICAgIGlzUHJvY2Vzc2luZ09wZXJhdGlvbiA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvZGV4U2VydmljZSA9IGdldENvZGV4U2VydmljZSgpO1xuICAgICAgY29uc29sZS5sb2coXCLimqvimqogUGVyZm9ybWluZyBjb2xvciBzd2FwIG9wZXJhdGlvbi4uLlwiKTtcbiAgICAgIGNvbnN0IHN3YXBwZWRQaWN0b2dyYXBocyA9XG4gICAgICAgIGF3YWl0IGNvZGV4U2VydmljZS5jb2xvclN3YXBBbGxQaWN0b2dyYXBocyhwaWN0b2dyYXBocyk7XG4gICAgICBwaWN0b2dyYXBocyA9IHN3YXBwZWRQaWN0b2dyYXBocztcblxuICAgICAgLy8gUmVmcmVzaCB0aGUgb3JnYW5pemVkIGRhdGFcbiAgICAgIHBpY3RvZ3JhcGhzQnlMZXR0ZXIgPSBhd2FpdCBjb2RleFNlcnZpY2UuZ2V0QWxsUGljdG9ncmFwaERhdGEoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gc3dhcCBjb2xvcnM6XCIsIGVycik7XG4gICAgICBlcnJvciA9IFwiRmFpbGVkIHRvIHN3YXAgY29sb3JzLiBQbGVhc2UgdHJ5IGFnYWluLlwiO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc1Byb2Nlc3NpbmdPcGVyYXRpb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG4gIHJldHVybiB7XG4gICAgLy8gUmVhY3RpdmUgZ2V0dGVyc1xuICAgIGdldCBzZWFyY2hUZXJtKCkge1xuICAgICAgcmV0dXJuIHNlYXJjaFRlcm07XG4gICAgfSxcbiAgICBnZXQgaXNMb2FkaW5nKCkge1xuICAgICAgcmV0dXJuIGlzTG9hZGluZztcbiAgICB9LFxuICAgIGdldCBpc0luaXRpYWxpemVkKCkge1xuICAgICAgcmV0dXJuIGlzSW5pdGlhbGl6ZWQ7XG4gICAgfSxcbiAgICBnZXQgcGljdG9ncmFwaHMoKSB7XG4gICAgICByZXR1cm4gcGljdG9ncmFwaHM7XG4gICAgfSxcbiAgICBnZXQgZmlsdGVyZWRQaWN0b2dyYXBocygpIHtcbiAgICAgIHJldHVybiBmaWx0ZXJlZFBpY3RvZ3JhcGhzO1xuICAgIH0sXG4gICAgZ2V0IHBpY3RvZ3JhcGhzQnlMZXR0ZXIoKSB7XG4gICAgICByZXR1cm4gcGljdG9ncmFwaHNCeUxldHRlcjtcbiAgICB9LFxuICAgIGdldCBmaWx0ZXJlZFBpY3RvZ3JhcGhzQnlMZXR0ZXIoKSB7XG4gICAgICByZXR1cm4gZmlsdGVyZWRQaWN0b2dyYXBoc0J5TGV0dGVyO1xuICAgIH0sXG4gICAgZ2V0IGxldHRlclJvd3MoKSB7XG4gICAgICByZXR1cm4gbGV0dGVyUm93cztcbiAgICB9LFxuICAgIGdldCBjdXJyZW50T3JpZW50YXRpb24oKSB7XG4gICAgICByZXR1cm4gY3VycmVudE9yaWVudGF0aW9uO1xuICAgIH0sXG4gICAgZ2V0IGVycm9yKCkge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0sXG4gICAgZ2V0IGlzUHJvY2Vzc2luZ09wZXJhdGlvbigpIHtcbiAgICAgIHJldHVybiBpc1Byb2Nlc3NpbmdPcGVyYXRpb247XG4gICAgfSxcblxuICAgIC8vIE1ldGhvZHNcbiAgICBzZXRTZWFyY2hUZXJtKHRlcm06IHN0cmluZykge1xuICAgICAgc2VhcmNoVGVybSA9IHRlcm07XG4gICAgfSxcblxuICAgIHNldE9yaWVudGF0aW9uKG9yaWVudGF0aW9uOiBzdHJpbmcpIHtcbiAgICAgIGN1cnJlbnRPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuICAgICAgY29uc29sZS5sb2coXCLwn5SEIE9yaWVudGF0aW9uIGNoYW5nZWQgdG86XCIsIG9yaWVudGF0aW9uKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVmcmVzaFBpY3RvZ3JhcGhzKCkge1xuICAgICAgYXdhaXQgbG9hZEFsbFBpY3RvZ3JhcGhzKCk7XG4gICAgfSxcblxuICAgIGFzeW5jIHNlYXJjaFBpY3RvZ3JhcGhzKHRlcm06IHN0cmluZykge1xuICAgICAgc2VhcmNoVGVybSA9IHRlcm07XG4gICAgICAvLyBUaGUgZGVyaXZlZCB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgdXBkYXRlIHRoZSBmaWx0ZXJlZCBsaXN0XG4gICAgfSxcblxuICAgIGFzeW5jIGdldFBpY3RvZ3JhcGhCeUxldHRlcihsZXR0ZXI6IHN0cmluZykge1xuICAgICAgY29uc3QgY29kZXhTZXJ2aWNlID0gZ2V0Q29kZXhTZXJ2aWNlKCk7XG4gICAgICByZXR1cm4gYXdhaXQgY29kZXhTZXJ2aWNlLmdldFBpY3RvZ3JhcGhCeUxldHRlcihsZXR0ZXIpO1xuICAgIH0sXG5cbiAgICAvLyBPcGVyYXRpb24gbWV0aG9kc1xuICAgIGFzeW5jIHJvdGF0ZVBpY3RvZ3JhcGhzKCkge1xuICAgICAgYXdhaXQgcGVyZm9ybVJvdGF0ZU9wZXJhdGlvbigpO1xuICAgIH0sXG5cbiAgICBhc3luYyBtaXJyb3JQaWN0b2dyYXBocygpIHtcbiAgICAgIGF3YWl0IHBlcmZvcm1NaXJyb3JPcGVyYXRpb24oKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY29sb3JTd2FwUGljdG9ncmFwaHMoKSB7XG4gICAgICBhd2FpdCBwZXJmb3JtQ29sb3JTd2FwT3BlcmF0aW9uKCk7XG4gICAgfSxcbiAgfTtcbn1cbiJdLCJmaWxlIjoiRjovQ09ERS9US0Evd2ViL3NyYy9saWIvc3RhdGUvY29kZXgtc3RhdGUuc3ZlbHRlLnRzIn0=