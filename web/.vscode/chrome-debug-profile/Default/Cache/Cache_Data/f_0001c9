/* debug-state.svelte.ts generated by Svelte v5.38.1 */
import * as $ from "/node_modules/.vite/deps/svelte_internal_client.js?v=cc8aba6c";
import { createPictographData } from "/src/lib/domain/PictographData.ts";
import { createGridData } from "/src/lib/domain/GridData.ts";
import { GridMode, Location } from "/src/lib/domain/enums.ts";
import { ArrowLocationCalculator } from "/src/lib/services/positioning/arrows/calculation/ArrowLocationCalculator.ts";
import { ArrowCoordinateSystemService } from "/src/lib/services/positioning/arrows/coordinate_system/ArrowCoordinateSystemService.ts";
import { ArrowRotationCalculator } from "/src/lib/services/positioning/arrows/calculation/ArrowRotationCalculator.ts";
import { ArrowAdjustmentCalculator } from "/src/lib/services/positioning/arrows/calculation/ArrowAdjustmentCalculator.ts";

export function createDebugState() {
	let selectedPictograph = $.tag($.state(null), 'selectedPictograph');
	let selectedArrowColor = $.tag($.state("blue"), 'selectedArrowColor');
	let availablePictographs = $.tag($.state($.proxy([])), 'availablePictographs');
	let stepByStepMode = $.tag($.state(true), 'stepByStepMode');
	let currentStep = $.tag($.state(0), 'currentStep');
	const maxSteps = 4;
	let showCoordinateGrid = $.tag($.state(true), 'showCoordinateGrid');
	let showHandPoints = $.tag($.state(true), 'showHandPoints');
	let showLayer2Points = $.tag($.state(true), 'showLayer2Points');
	let showAdjustmentVectors = $.tag($.state(true), 'showAdjustmentVectors');
	let isCalculating = $.tag($.state(false), 'isCalculating');
	let autoUpdate = $.tag($.state(true), 'autoUpdate');
	let gridMode = $.tag($.state("diamond"), 'gridMode');
	let expandedSections = $.tag($.state($.proxy(/* @__PURE__ */ new Set(["input_data", "location_calculation"]))), 'expandedSections');
	const locationCalculator = new ArrowLocationCalculator();
	const rotationCalculator = new ArrowRotationCalculator();
	const adjustmentCalculator = new ArrowAdjustmentCalculator();
	const coordinateSystemService = new ArrowCoordinateSystemService();

	const currentDebugData = $.tag_proxy(
		$.proxy({
			pictographData: null,
			motionData: null,
			arrowData: null,
			calculatedLocation: null,
			locationDebugInfo: null,
			initialPosition: null,
			coordinateSystemDebugInfo: null,
			defaultAdjustment: null,
			defaultAdjustmentDebugInfo: null,
			specialAdjustment: null,
			specialAdjustmentDebugInfo: null,
			tupleProcessedAdjustment: null,
			tupleProcessingDebugInfo: null,
			finalPosition: null,
			finalRotation: 0,
			errors: [],
			timing: null
		}),
		'currentDebugData'
	);

	const currentMotionData = $.tag(
		$.derived(() => {
			if (!$.get(selectedPictograph)?.motions) return null;

			return $.get(selectedPictograph).motions[$.get(selectedArrowColor)] || null;
		}),
		'currentMotionData'
	);

	const currentArrowData = $.tag(
		$.derived(() => {
			if (!$.get(selectedPictograph)?.arrows) return null;

			return $.get(selectedPictograph).arrows[$.get(selectedArrowColor)] || null;
		}),
		'currentArrowData'
	);

	async function loadRealPictographs() {
		try {
			console.log("ðŸ”§ Loading real pictographs from CodexService...");

			const allPictographs = [];

			console.log(`âœ… Loaded ${allPictographs.length} real pictographs from CSV data`);

			return allPictographs;
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "âŒ Failed to load real pictographs:", error));

			return [];
		}
	}

	async function initializeRealData() {
		try {
			console.log("ðŸš€ Initializing Arrow Debug with real pictograph data...");

			const realPictographs = (await $.track_reactivity_loss(loadRealPictographs()))();

			$.set(availablePictographs, realPictographs, true);

			if (realPictographs.length > 0) {
				$.set(selectedPictograph, realPictographs[0], true);
				console.log(`âœ… Selected first pictograph: ${$.get(selectedPictograph).letter || $.get(selectedPictograph).id}`);
			}
		} catch(error) {
			console.error(...$.log_if_contains_state('error', "âŒ Failed to initialize real data:", error));
		}
	}

	function toggleSection(section) {
		if ($.get(expandedSections).has(section)) {
			$.get(expandedSections).delete(section);
		} else {
			$.get(expandedSections).add(section);
		}

		$.set(expandedSections, new Set($.get(expandedSections)), true);
	}

	function setGridMode(mode) {
		$.set(gridMode, mode, true);

		if ($.get(selectedPictograph)) {
			const newGridMode = $.strict_equals(mode, "diamond") ? GridMode.DIAMOND : GridMode.BOX;

			$.set(
				selectedPictograph,
				createPictographData({
					...$.get(selectedPictograph),
					gridData: createGridData({ gridMode: newGridMode })
				}),
				true
			);

			if ($.get(autoUpdate)) {
				calculatePositioning();
			}
		}
	}

	function getCurrentStepData() {
		if (!$.get(stepByStepMode)) {
			return currentDebugData;
		}

		const stepData = {
			...currentDebugData,

			// Reset future steps based on current step
			calculatedLocation: $.get(currentStep) >= 1 ? currentDebugData.calculatedLocation : null,

			locationDebugInfo: $.get(currentStep) >= 1 ? currentDebugData.locationDebugInfo : null,
			initialPosition: $.get(currentStep) >= 2 ? currentDebugData.initialPosition : null,
			coordinateSystemDebugInfo: $.get(currentStep) >= 2 ? currentDebugData.coordinateSystemDebugInfo : null,
			finalRotation: $.get(currentStep) >= 3 ? currentDebugData.finalRotation : 0,
			defaultAdjustment: $.get(currentStep) >= 4 ? currentDebugData.defaultAdjustment : null,
			finalPosition: $.get(currentStep) >= 4 ? currentDebugData.finalPosition : null
		};

		return stepData;
	}

	function getCurrentStepName() {
		const stepNames = [
			"Input Data",
			"Location Calculation",
			"Coordinate System",
			"Rotation Calculation",
			"Adjustment Calculation"
		];

		return stepNames[$.get(currentStep)] || "Unknown Step";
	}

	async function calculatePositioning() {
		if (!$.get(selectedPictograph) || !$.get(currentMotionData) || !$.get(currentArrowData)) {
			return;
		}

		$.set(isCalculating, true);

		const startTime = performance.now();
		const stepTimes = {};

		try {
			currentDebugData.errors = [];
			currentDebugData.pictographData = $.get(selectedPictograph);
			currentDebugData.motionData = $.get(currentMotionData);
			currentDebugData.arrowData = $.get(currentArrowData);

			const locationStart = performance.now();

			try {
				const calculatedLocation = locationCalculator.calculateLocation($.get(currentMotionData), $.get(selectedPictograph));

				currentDebugData.calculatedLocation = calculatedLocation;

				currentDebugData.locationDebugInfo = {
					motionType: $.get(currentMotionData).motionType || "",
					startOrientation: $.get(currentMotionData).startOrientation || "",
					endOrientation: $.get(currentMotionData).endOrientation || "",
					calculationMethod: "ArrowLocationCalculator"
				};

				stepTimes.location_calculation = performance.now() - locationStart;
			} catch(error) {
				currentDebugData.errors.push({
					step: "location_calculation",
					error: error instanceof Error ? error.message : String(error),
					timestamp: Date.now()
				});
			}

			const coordinateStart = performance.now();

			try {
				if (currentDebugData.calculatedLocation) {
					const initialPosition = coordinateSystemService.getInitialPosition($.get(currentMotionData), currentDebugData.calculatedLocation);

					currentDebugData.initialPosition = initialPosition;

					const sceneCenter = coordinateSystemService.getSceneCenter();
					const sceneDimensions = coordinateSystemService.getSceneDimensions();
					const handPoints = coordinateSystemService.getAllHandPoints();
					const layer2Points = coordinateSystemService.getAllLayer2Points();

					currentDebugData.coordinateSystemDebugInfo = {
						sceneCenter,
						sceneDimensions,
						handPoints,
						layer2Points,
						usedCoordinateSet: $.strict_equals($.get(currentMotionData).motionType, "static") || $.strict_equals($.get(currentMotionData).motionType, "dash") ? "hand_points" : "layer2_points",
						coordinateSystemType: "TKA_950x950"
					};
				}

				stepTimes.coordinate_system = performance.now() - coordinateStart;
			} catch(error) {
				currentDebugData.errors.push({
					step: "coordinate_system",
					error: error instanceof Error ? error.message : String(error),
					timestamp: Date.now()
				});
			}

			const rotationStart = performance.now();

			try {
				if (currentDebugData.calculatedLocation) {
					const rotation = rotationCalculator.calculateRotation($.get(currentMotionData), currentDebugData.calculatedLocation);

					currentDebugData.finalRotation = rotation;
				}

				stepTimes.rotation_calculation = performance.now() - rotationStart;
			} catch(error) {
				currentDebugData.errors.push({
					step: "rotation_calculation",
					error: error instanceof Error ? error.message : String(error),
					timestamp: Date.now()
				});
			}

			const adjustmentStart = performance.now();

			try {
				if (currentDebugData.calculatedLocation) {
					const adjustment = (await $.track_reactivity_loss(adjustmentCalculator.calculateAdjustment($.get(selectedPictograph), $.get(currentMotionData), $.get(selectedPictograph).letter || "A", currentDebugData.calculatedLocation)))();

					currentDebugData.defaultAdjustment = adjustment;

					if (currentDebugData.initialPosition && adjustment) {
						currentDebugData.finalPosition = {
							x: currentDebugData.initialPosition.x + adjustment.x,
							y: currentDebugData.initialPosition.y + adjustment.y
						};
					} else {
						currentDebugData.finalPosition = currentDebugData.initialPosition;
					}
				}

				stepTimes.adjustment_calculation = performance.now() - adjustmentStart;
			} catch(error) {
				currentDebugData.errors.push({
					step: "adjustment_calculation",
					error: error instanceof Error ? error.message : String(error),
					timestamp: Date.now()
				});
			}

			const endTime = performance.now();

			currentDebugData.timing = { totalDuration: endTime - startTime, stepDurations: stepTimes };

			console.log(...$.log_if_contains_state('log', "ðŸŽ¯ Arrow positioning calculation completed:", {
				location: currentDebugData.calculatedLocation,
				initialPosition: currentDebugData.initialPosition,
				finalPosition: currentDebugData.finalPosition,
				rotation: currentDebugData.finalRotation,
				errors: currentDebugData.errors,
				timing: currentDebugData.timing
			}));
		} catch(error) {
			currentDebugData.errors.push({
				step: "overall_calculation",
				error: error instanceof Error ? error.message : String(error),
				timestamp: Date.now()
			});
		} finally {
			$.set(isCalculating, false);
		}
	}

	$.user_effect(() => {
		if ($.get(autoUpdate) && $.get(selectedPictograph) && $.get(currentMotionData) && $.get(currentArrowData)) {
			calculatePositioning();
		}
	});

	return {
		// State
		get selectedPictograph() {
			return $.get(selectedPictograph);
		},

		set selectedPictograph(value) {
			$.set(selectedPictograph, value, true);
		},

		get selectedArrowColor() {
			return $.get(selectedArrowColor);
		},

		set selectedArrowColor(value) {
			$.set(selectedArrowColor, value, true);
		},

		get availablePictographs() {
			return $.get(availablePictographs);
		},

		set availablePictographs(value) {
			$.set(availablePictographs, value, true);
		},

		get stepByStepMode() {
			return $.get(stepByStepMode);
		},

		set stepByStepMode(value) {
			$.set(stepByStepMode, value, true);
		},

		get currentStep() {
			return $.get(currentStep);
		},

		set currentStep(value) {
			$.set(currentStep, value, true);
		},

		get maxSteps() {
			return maxSteps;
		},

		get showCoordinateGrid() {
			return $.get(showCoordinateGrid);
		},

		set showCoordinateGrid(value) {
			$.set(showCoordinateGrid, value, true);
		},

		get showHandPoints() {
			return $.get(showHandPoints);
		},

		set showHandPoints(value) {
			$.set(showHandPoints, value, true);
		},

		get showLayer2Points() {
			return $.get(showLayer2Points);
		},

		set showLayer2Points(value) {
			$.set(showLayer2Points, value, true);
		},

		get showAdjustmentVectors() {
			return $.get(showAdjustmentVectors);
		},

		set showAdjustmentVectors(value) {
			$.set(showAdjustmentVectors, value, true);
		},

		get isCalculating() {
			return $.get(isCalculating);
		},

		get autoUpdate() {
			return $.get(autoUpdate);
		},

		set autoUpdate(value) {
			$.set(autoUpdate, value, true);
		},

		get expandedSections() {
			return $.get(expandedSections);
		},

		get currentDebugData() {
			return currentDebugData;
		},

		// Grid mode properties
		get gridMode() {
			return $.get(gridMode);
		},

		set gridMode(value) {
			setGridMode(value);
		},

		// Computed
		get currentMotionData() {
			return $.get(currentMotionData);
		},

		get currentArrowData() {
			return $.get(currentArrowData);
		},

		get currentStepData() {
			return getCurrentStepData();
		},

		get currentStepName() {
			return getCurrentStepName();
		},

		// Actions
		toggleSection,

		setGridMode,
		calculatePositioning,
		initializeRealData,
		getCurrentStepData,
		getCurrentStepName
	};
}
//# sourceMappingURL=data:application/json;base64,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Q1Q7OztNQUdJLFdBQVc7Z0JBQ047RUFDVDs7TUFDSSxTQUFTLE9BQTBCO0dBQ3JDLFlBQVksS0FBSztFQUNuQjs7O01BR0ksb0JBQW9CO2dCQUNmO0VBQ1Q7O01BQ0ksbUJBQW1CO2dCQUNkO0VBQ1Q7O01BQ0ksa0JBQWtCO1VBQ2I7RUFDVDs7TUFDSSxrQkFBa0I7VUFDYjtFQUNUOzs7RUFHQTs7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVKIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJkZWJ1Zy1zdGF0ZS5zdmVsdGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBcnJvdyBEZWJ1ZyBTdGF0ZSBJbnRlZ3JhdGlvblxuICogUHJvdmlkZXMgYSBzaW1wbGVyIGludGVyZmFjZSB0byB0aGUgZXhpc3RpbmcgYXJyb3cgZGVidWcgc3RhdGVcbiAqL1xuXG5pbXBvcnQgdHlwZSB7IFBpY3RvZ3JhcGhEYXRhIH0gZnJvbSBcIiRsaWIvZG9tYWluXCI7XG5pbXBvcnQgeyBjcmVhdGVQaWN0b2dyYXBoRGF0YSB9IGZyb20gXCIkbGliL2RvbWFpbi9QaWN0b2dyYXBoRGF0YVwiO1xuaW1wb3J0IHsgY3JlYXRlR3JpZERhdGEgfSBmcm9tIFwiJGxpYi9kb21haW4vR3JpZERhdGFcIjtcbmltcG9ydCB7IEdyaWRNb2RlLCBMb2NhdGlvbiB9IGZyb20gXCIkbGliL2RvbWFpbi9lbnVtc1wiO1xuaW1wb3J0IHR5cGUgeyBEZWJ1Z1N0ZXBEYXRhIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuLy8gSW1wb3J0IHJlYWwgYXJyb3cgcG9zaXRpb25pbmcgc2VydmljZXNcbi8vIGltcG9ydCB7IEFycm93UG9zaXRpb25pbmdPcmNoZXN0cmF0b3IgfSBmcm9tIFwiJGxpYi9zZXJ2aWNlcy9wb3NpdGlvbmluZy9hcnJvd3Mvb3JjaGVzdHJhdGlvbi9BcnJvd1Bvc2l0aW9uaW5nT3JjaGVzdHJhdG9yXCI7XG5pbXBvcnQgeyBBcnJvd0xvY2F0aW9uQ2FsY3VsYXRvciB9IGZyb20gXCIkbGliL3NlcnZpY2VzL3Bvc2l0aW9uaW5nL2Fycm93cy9jYWxjdWxhdGlvbi9BcnJvd0xvY2F0aW9uQ2FsY3VsYXRvclwiO1xuaW1wb3J0IHsgQXJyb3dDb29yZGluYXRlU3lzdGVtU2VydmljZSB9IGZyb20gXCIkbGliL3NlcnZpY2VzL3Bvc2l0aW9uaW5nL2Fycm93cy9jb29yZGluYXRlX3N5c3RlbS9BcnJvd0Nvb3JkaW5hdGVTeXN0ZW1TZXJ2aWNlXCI7XG5pbXBvcnQgeyBBcnJvd1JvdGF0aW9uQ2FsY3VsYXRvciB9IGZyb20gXCIkbGliL3NlcnZpY2VzL3Bvc2l0aW9uaW5nL2Fycm93cy9jYWxjdWxhdGlvbi9BcnJvd1JvdGF0aW9uQ2FsY3VsYXRvclwiO1xuaW1wb3J0IHsgQXJyb3dBZGp1c3RtZW50Q2FsY3VsYXRvciB9IGZyb20gXCIkbGliL3NlcnZpY2VzL3Bvc2l0aW9uaW5nL2Fycm93cy9jYWxjdWxhdGlvbi9BcnJvd0FkanVzdG1lbnRDYWxjdWxhdG9yXCI7XG5cbi8vIFNpbXBsZSByZWFjdGl2ZSBzdGF0ZSBmb3IgdGhlIGRlYnVnIGNvbXBvbmVudHNcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEZWJ1Z1N0YXRlKCkge1xuICBsZXQgc2VsZWN0ZWRQaWN0b2dyYXBoID0gJHN0YXRlPFBpY3RvZ3JhcGhEYXRhIHwgbnVsbD4obnVsbCk7XG4gIGxldCBzZWxlY3RlZEFycm93Q29sb3IgPSAkc3RhdGU8XCJyZWRcIiB8IFwiYmx1ZVwiPihcImJsdWVcIik7XG4gIGxldCBhdmFpbGFibGVQaWN0b2dyYXBocyA9ICRzdGF0ZTxQaWN0b2dyYXBoRGF0YVtdPihbXSk7XG5cbiAgbGV0IHN0ZXBCeVN0ZXBNb2RlID0gJHN0YXRlKHRydWUpO1xuICBsZXQgY3VycmVudFN0ZXAgPSAkc3RhdGUoMCk7XG4gIGNvbnN0IG1heFN0ZXBzID0gJHN0YXRlKDQpOyAvLyAwOiBJbnB1dCwgMTogTG9jYXRpb24sIDI6IENvb3JkaW5hdGUgU3lzdGVtLCAzOiBSb3RhdGlvbiwgNDogQWRqdXN0bWVudHNcblxuICBsZXQgc2hvd0Nvb3JkaW5hdGVHcmlkID0gJHN0YXRlKHRydWUpO1xuICBsZXQgc2hvd0hhbmRQb2ludHMgPSAkc3RhdGUodHJ1ZSk7XG4gIGxldCBzaG93TGF5ZXIyUG9pbnRzID0gJHN0YXRlKHRydWUpO1xuICBsZXQgc2hvd0FkanVzdG1lbnRWZWN0b3JzID0gJHN0YXRlKHRydWUpO1xuXG4gIGxldCBpc0NhbGN1bGF0aW5nID0gJHN0YXRlKGZhbHNlKTtcbiAgbGV0IGF1dG9VcGRhdGUgPSAkc3RhdGUodHJ1ZSk7XG5cbiAgLy8gR3JpZCBtb2RlIHN0YXRlIChkaWFtb25kL2JveCB0b2dnbGUpXG4gIGxldCBncmlkTW9kZSA9ICRzdGF0ZTxcImRpYW1vbmRcIiB8IFwiYm94XCI+KFwiZGlhbW9uZFwiKTtcblxuICBsZXQgZXhwYW5kZWRTZWN0aW9ucyA9ICRzdGF0ZShcbiAgICBuZXcgU2V0KFtcImlucHV0X2RhdGFcIiwgXCJsb2NhdGlvbl9jYWxjdWxhdGlvblwiXSlcbiAgKTtcblxuICAvLyBJbml0aWFsaXplIHJlYWwgZGF0YSBzZXJ2aWNlc1xuICAvLyBUT0RPOiBVc2UgREkgY29udGFpbmVyIHRvIHJlc29sdmUgQ29kZXhTZXJ2aWNlIGluc3RlYWQgb2YgZGlyZWN0IGluc3RhbnRpYXRpb25cbiAgLy8gY29uc3QgY29kZXhTZXJ2aWNlID0gbmV3IENvZGV4U2VydmljZSgpO1xuXG4gIC8vIEluaXRpYWxpemUgcmVhbCBhcnJvdyBwb3NpdGlvbmluZyBzZXJ2aWNlc1xuICBjb25zdCBsb2NhdGlvbkNhbGN1bGF0b3IgPSBuZXcgQXJyb3dMb2NhdGlvbkNhbGN1bGF0b3IoKTtcbiAgY29uc3Qgcm90YXRpb25DYWxjdWxhdG9yID0gbmV3IEFycm93Um90YXRpb25DYWxjdWxhdG9yKCk7XG4gIGNvbnN0IGFkanVzdG1lbnRDYWxjdWxhdG9yID0gbmV3IEFycm93QWRqdXN0bWVudENhbGN1bGF0b3IoKTtcbiAgY29uc3QgY29vcmRpbmF0ZVN5c3RlbVNlcnZpY2UgPSBuZXcgQXJyb3dDb29yZGluYXRlU3lzdGVtU2VydmljZSgpO1xuXG4gIC8vIENyZWF0ZSB0aGUgb3JjaGVzdHJhdG9yIHdpdGggcmVhbCBzZXJ2aWNlc1xuICAvLyBOb3RlOiBDdXJyZW50bHkgdW51c2VkIGJ1dCBrZXB0IGZvciBmdXR1cmUgZGVidWdnaW5nIGZlYXR1cmVzXG4gIC8vIGNvbnN0IF9hcnJvd1Bvc2l0aW9uaW5nT3JjaGVzdHJhdG9yID0gbmV3IEFycm93UG9zaXRpb25pbmdPcmNoZXN0cmF0b3IoXG4gIC8vICAgbG9jYXRpb25DYWxjdWxhdG9yLFxuICAvLyAgIHJvdGF0aW9uQ2FsY3VsYXRvcixcbiAgLy8gICBhZGp1c3RtZW50Q2FsY3VsYXRvcixcbiAgLy8gICBjb29yZGluYXRlU3lzdGVtU2VydmljZVxuICAvLyApO1xuXG4gIC8vIENyZWF0ZSBkZWJ1ZyBkYXRhIHdpdGggcHJvcGVyIHN0cnVjdHVyZVxuICBjb25zdCBjdXJyZW50RGVidWdEYXRhID0gJHN0YXRlPERlYnVnU3RlcERhdGE+KHtcbiAgICBwaWN0b2dyYXBoRGF0YTogbnVsbCxcbiAgICBtb3Rpb25EYXRhOiBudWxsLFxuICAgIGFycm93RGF0YTogbnVsbCxcbiAgICBjYWxjdWxhdGVkTG9jYXRpb246IG51bGwsXG4gICAgbG9jYXRpb25EZWJ1Z0luZm86IG51bGwsXG4gICAgaW5pdGlhbFBvc2l0aW9uOiBudWxsLFxuICAgIGNvb3JkaW5hdGVTeXN0ZW1EZWJ1Z0luZm86IG51bGwsXG4gICAgZGVmYXVsdEFkanVzdG1lbnQ6IG51bGwsXG4gICAgZGVmYXVsdEFkanVzdG1lbnREZWJ1Z0luZm86IG51bGwsXG4gICAgc3BlY2lhbEFkanVzdG1lbnQ6IG51bGwsXG4gICAgc3BlY2lhbEFkanVzdG1lbnREZWJ1Z0luZm86IG51bGwsXG4gICAgdHVwbGVQcm9jZXNzZWRBZGp1c3RtZW50OiBudWxsLFxuICAgIHR1cGxlUHJvY2Vzc2luZ0RlYnVnSW5mbzogbnVsbCxcbiAgICBmaW5hbFBvc2l0aW9uOiBudWxsLFxuICAgIGZpbmFsUm90YXRpb246IDAsXG4gICAgZXJyb3JzOiBbXSxcbiAgICB0aW1pbmc6IG51bGwsXG4gIH0pO1xuXG4gIC8vIENvbXB1dGVkIHZhbHVlc1xuICBjb25zdCBjdXJyZW50TW90aW9uRGF0YSA9ICRkZXJpdmVkLmJ5KCgpID0+IHtcbiAgICBpZiAoIXNlbGVjdGVkUGljdG9ncmFwaD8ubW90aW9ucykgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHNlbGVjdGVkUGljdG9ncmFwaC5tb3Rpb25zW3NlbGVjdGVkQXJyb3dDb2xvcl0gfHwgbnVsbDtcbiAgfSk7XG5cbiAgY29uc3QgY3VycmVudEFycm93RGF0YSA9ICRkZXJpdmVkLmJ5KCgpID0+IHtcbiAgICBpZiAoIXNlbGVjdGVkUGljdG9ncmFwaD8uYXJyb3dzKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gc2VsZWN0ZWRQaWN0b2dyYXBoLmFycm93c1tzZWxlY3RlZEFycm93Q29sb3JdIHx8IG51bGw7XG4gIH0pO1xuXG4gIC8vIExvYWQgcmVhbCBwaWN0b2dyYXBocyBmcm9tIGNvZGV4IHNlcnZpY2VcbiAgYXN5bmMgZnVuY3Rpb24gbG9hZFJlYWxQaWN0b2dyYXBocygpOiBQcm9taXNlPFBpY3RvZ3JhcGhEYXRhW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coXCLwn5SnIExvYWRpbmcgcmVhbCBwaWN0b2dyYXBocyBmcm9tIENvZGV4U2VydmljZS4uLlwiKTtcblxuICAgICAgLy8gVE9ETzogTG9hZCBhbGwgcGljdG9ncmFwaHMgZnJvbSB0aGUgY29kZXggc2VydmljZSB2aWEgREkgY29udGFpbmVyXG4gICAgICAvLyBjb25zdCBhbGxQaWN0b2dyYXBocyA9IGF3YWl0IGNvZGV4U2VydmljZS5sb2FkQWxsUGljdG9ncmFwaHMoKTtcbiAgICAgIGNvbnN0IGFsbFBpY3RvZ3JhcGhzOiBQaWN0b2dyYXBoRGF0YVtdID0gW107IC8vIFRlbXBvcmFyeSBwbGFjZWhvbGRlclxuXG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYOKchSBMb2FkZWQgJHthbGxQaWN0b2dyYXBocy5sZW5ndGh9IHJlYWwgcGljdG9ncmFwaHMgZnJvbSBDU1YgZGF0YWBcbiAgICAgICk7XG4gICAgICByZXR1cm4gYWxsUGljdG9ncmFwaHM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRmFpbGVkIHRvIGxvYWQgcmVhbCBwaWN0b2dyYXBoczpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgd2l0aCByZWFsIGRhdGFcbiAgYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZVJlYWxEYXRhKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIvCfmoAgSW5pdGlhbGl6aW5nIEFycm93IERlYnVnIHdpdGggcmVhbCBwaWN0b2dyYXBoIGRhdGEuLi5cIik7XG5cbiAgICAgIC8vIExvYWQgcmVhbCBwaWN0b2dyYXBocyBmcm9tIENTViBkYXRhXG4gICAgICBjb25zdCByZWFsUGljdG9ncmFwaHMgPSBhd2FpdCBsb2FkUmVhbFBpY3RvZ3JhcGhzKCk7XG4gICAgICBhdmFpbGFibGVQaWN0b2dyYXBocyA9IHJlYWxQaWN0b2dyYXBocztcblxuICAgICAgaWYgKHJlYWxQaWN0b2dyYXBocy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlbGVjdGVkUGljdG9ncmFwaCA9IHJlYWxQaWN0b2dyYXBoc1swXTtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYOKchSBTZWxlY3RlZCBmaXJzdCBwaWN0b2dyYXBoOiAke3NlbGVjdGVkUGljdG9ncmFwaC5sZXR0ZXIgfHwgc2VsZWN0ZWRQaWN0b2dyYXBoLmlkfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBGYWlsZWQgdG8gaW5pdGlhbGl6ZSByZWFsIGRhdGE6XCIsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvLyBUb2dnbGUgc2VjdGlvbiBleHBhbnNpb25cbiAgZnVuY3Rpb24gdG9nZ2xlU2VjdGlvbihzZWN0aW9uOiBzdHJpbmcpIHtcbiAgICBpZiAoZXhwYW5kZWRTZWN0aW9ucy5oYXMoc2VjdGlvbikpIHtcbiAgICAgIGV4cGFuZGVkU2VjdGlvbnMuZGVsZXRlKHNlY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBhbmRlZFNlY3Rpb25zLmFkZChzZWN0aW9uKTtcbiAgICB9XG4gICAgLy8gVHJpZ2dlciByZWFjdGl2aXR5XG4gICAgZXhwYW5kZWRTZWN0aW9ucyA9IG5ldyBTZXQoZXhwYW5kZWRTZWN0aW9ucyk7XG4gIH1cblxuICAvLyBTZXQgZ3JpZCBtb2RlIGFuZCB1cGRhdGUgcGljdG9ncmFwaCBkYXRhXG4gIGZ1bmN0aW9uIHNldEdyaWRNb2RlKG1vZGU6IFwiZGlhbW9uZFwiIHwgXCJib3hcIikge1xuICAgIGdyaWRNb2RlID0gbW9kZTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgc2VsZWN0ZWQgcGljdG9ncmFwaCdzIGdyaWQgZGF0YSBpZiBpdCBleGlzdHNcbiAgICBpZiAoc2VsZWN0ZWRQaWN0b2dyYXBoKSB7XG4gICAgICBjb25zdCBuZXdHcmlkTW9kZSA9IG1vZGUgPT09IFwiZGlhbW9uZFwiID8gR3JpZE1vZGUuRElBTU9ORCA6IEdyaWRNb2RlLkJPWDtcbiAgICAgIHNlbGVjdGVkUGljdG9ncmFwaCA9IGNyZWF0ZVBpY3RvZ3JhcGhEYXRhKHtcbiAgICAgICAgLi4uc2VsZWN0ZWRQaWN0b2dyYXBoLFxuICAgICAgICBncmlkRGF0YTogY3JlYXRlR3JpZERhdGEoeyBncmlkTW9kZTogbmV3R3JpZE1vZGUgfSksXG4gICAgICB9KTtcblxuICAgICAgLy8gVHJpZ2dlciByZWNhbGN1bGF0aW9uIGlmIGF1dG8tdXBkYXRlIGlzIGVuYWJsZWRcbiAgICAgIGlmIChhdXRvVXBkYXRlKSB7XG4gICAgICAgIGNhbGN1bGF0ZVBvc2l0aW9uaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IHN0ZXAtYnktc3RlcCBkYXRhIGZvciBjdXJyZW50IHN0ZXBcbiAgZnVuY3Rpb24gZ2V0Q3VycmVudFN0ZXBEYXRhKCkge1xuICAgIGlmICghc3RlcEJ5U3RlcE1vZGUpIHtcbiAgICAgIHJldHVybiBjdXJyZW50RGVidWdEYXRhO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgZGVidWcgZGF0YSBzaG93aW5nIG9ubHkgdXAgdG8gY3VycmVudCBzdGVwXG4gICAgY29uc3Qgc3RlcERhdGEgPSB7XG4gICAgICAuLi5jdXJyZW50RGVidWdEYXRhLFxuICAgICAgLy8gUmVzZXQgZnV0dXJlIHN0ZXBzIGJhc2VkIG9uIGN1cnJlbnQgc3RlcFxuICAgICAgY2FsY3VsYXRlZExvY2F0aW9uOlxuICAgICAgICBjdXJyZW50U3RlcCA+PSAxID8gY3VycmVudERlYnVnRGF0YS5jYWxjdWxhdGVkTG9jYXRpb24gOiBudWxsLFxuICAgICAgbG9jYXRpb25EZWJ1Z0luZm86XG4gICAgICAgIGN1cnJlbnRTdGVwID49IDEgPyBjdXJyZW50RGVidWdEYXRhLmxvY2F0aW9uRGVidWdJbmZvIDogbnVsbCxcbiAgICAgIGluaXRpYWxQb3NpdGlvbjpcbiAgICAgICAgY3VycmVudFN0ZXAgPj0gMiA/IGN1cnJlbnREZWJ1Z0RhdGEuaW5pdGlhbFBvc2l0aW9uIDogbnVsbCxcbiAgICAgIGNvb3JkaW5hdGVTeXN0ZW1EZWJ1Z0luZm86XG4gICAgICAgIGN1cnJlbnRTdGVwID49IDIgPyBjdXJyZW50RGVidWdEYXRhLmNvb3JkaW5hdGVTeXN0ZW1EZWJ1Z0luZm8gOiBudWxsLFxuICAgICAgZmluYWxSb3RhdGlvbjogY3VycmVudFN0ZXAgPj0gMyA/IGN1cnJlbnREZWJ1Z0RhdGEuZmluYWxSb3RhdGlvbiA6IDAsXG4gICAgICBkZWZhdWx0QWRqdXN0bWVudDpcbiAgICAgICAgY3VycmVudFN0ZXAgPj0gNCA/IGN1cnJlbnREZWJ1Z0RhdGEuZGVmYXVsdEFkanVzdG1lbnQgOiBudWxsLFxuICAgICAgZmluYWxQb3NpdGlvbjogY3VycmVudFN0ZXAgPj0gNCA/IGN1cnJlbnREZWJ1Z0RhdGEuZmluYWxQb3NpdGlvbiA6IG51bGwsXG4gICAgfTtcblxuICAgIHJldHVybiBzdGVwRGF0YTtcbiAgfVxuXG4gIC8vIEdldCBzdGVwIG5hbWUgZm9yIGN1cnJlbnQgc3RlcFxuICBmdW5jdGlvbiBnZXRDdXJyZW50U3RlcE5hbWUoKTogc3RyaW5nIHtcbiAgICBjb25zdCBzdGVwTmFtZXMgPSBbXG4gICAgICBcIklucHV0IERhdGFcIixcbiAgICAgIFwiTG9jYXRpb24gQ2FsY3VsYXRpb25cIixcbiAgICAgIFwiQ29vcmRpbmF0ZSBTeXN0ZW1cIixcbiAgICAgIFwiUm90YXRpb24gQ2FsY3VsYXRpb25cIixcbiAgICAgIFwiQWRqdXN0bWVudCBDYWxjdWxhdGlvblwiLFxuICAgIF07XG4gICAgcmV0dXJuIHN0ZXBOYW1lc1tjdXJyZW50U3RlcF0gfHwgXCJVbmtub3duIFN0ZXBcIjtcbiAgfVxuXG4gIC8vIFJlYWwgcG9zaXRpb25pbmcgY2FsY3VsYXRpb24gdXNpbmcgYXJyb3cgcG9zaXRpb25pbmcgc2VydmljZXNcbiAgYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25pbmcoKSB7XG4gICAgaWYgKCFzZWxlY3RlZFBpY3RvZ3JhcGggfHwgIWN1cnJlbnRNb3Rpb25EYXRhIHx8ICFjdXJyZW50QXJyb3dEYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNDYWxjdWxhdGluZyA9IHRydWU7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3Qgc3RlcFRpbWVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG5cbiAgICB0cnkge1xuICAgICAgLy8gQ2xlYXIgcHJldmlvdXMgZXJyb3JzXG4gICAgICBjdXJyZW50RGVidWdEYXRhLmVycm9ycyA9IFtdO1xuXG4gICAgICAvLyBVcGRhdGUgZGVidWcgZGF0YSB3aXRoIGN1cnJlbnQgaW5wdXRzXG4gICAgICBjdXJyZW50RGVidWdEYXRhLnBpY3RvZ3JhcGhEYXRhID0gc2VsZWN0ZWRQaWN0b2dyYXBoO1xuICAgICAgY3VycmVudERlYnVnRGF0YS5tb3Rpb25EYXRhID0gY3VycmVudE1vdGlvbkRhdGE7XG4gICAgICBjdXJyZW50RGVidWdEYXRhLmFycm93RGF0YSA9IGN1cnJlbnRBcnJvd0RhdGE7XG5cbiAgICAgIC8vIFNURVAgMTogQ2FsY3VsYXRlIGFycm93IGxvY2F0aW9uXG4gICAgICBjb25zdCBsb2NhdGlvblN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjYWxjdWxhdGVkTG9jYXRpb24gPSBsb2NhdGlvbkNhbGN1bGF0b3IuY2FsY3VsYXRlTG9jYXRpb24oXG4gICAgICAgICAgY3VycmVudE1vdGlvbkRhdGEsXG4gICAgICAgICAgc2VsZWN0ZWRQaWN0b2dyYXBoXG4gICAgICAgICk7XG4gICAgICAgIGN1cnJlbnREZWJ1Z0RhdGEuY2FsY3VsYXRlZExvY2F0aW9uID0gY2FsY3VsYXRlZExvY2F0aW9uO1xuICAgICAgICBjdXJyZW50RGVidWdEYXRhLmxvY2F0aW9uRGVidWdJbmZvID0ge1xuICAgICAgICAgIG1vdGlvblR5cGU6IGN1cnJlbnRNb3Rpb25EYXRhLm1vdGlvblR5cGUgfHwgXCJcIixcbiAgICAgICAgICBzdGFydE9yaWVudGF0aW9uOiBjdXJyZW50TW90aW9uRGF0YS5zdGFydE9yaWVudGF0aW9uIHx8IFwiXCIsXG4gICAgICAgICAgZW5kT3JpZW50YXRpb246IGN1cnJlbnRNb3Rpb25EYXRhLmVuZE9yaWVudGF0aW9uIHx8IFwiXCIsXG4gICAgICAgICAgY2FsY3VsYXRpb25NZXRob2Q6IFwiQXJyb3dMb2NhdGlvbkNhbGN1bGF0b3JcIixcbiAgICAgICAgfTtcbiAgICAgICAgc3RlcFRpbWVzLmxvY2F0aW9uX2NhbGN1bGF0aW9uID0gcGVyZm9ybWFuY2Uubm93KCkgLSBsb2NhdGlvblN0YXJ0O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY3VycmVudERlYnVnRGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgc3RlcDogXCJsb2NhdGlvbl9jYWxjdWxhdGlvblwiLFxuICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU1RFUCAyOiBHZXQgaW5pdGlhbCBwb3NpdGlvbiBmcm9tIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICBjb25zdCBjb29yZGluYXRlU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChjdXJyZW50RGVidWdEYXRhLmNhbGN1bGF0ZWRMb2NhdGlvbikge1xuICAgICAgICAgIGNvbnN0IGluaXRpYWxQb3NpdGlvbiA9IGNvb3JkaW5hdGVTeXN0ZW1TZXJ2aWNlLmdldEluaXRpYWxQb3NpdGlvbihcbiAgICAgICAgICAgIGN1cnJlbnRNb3Rpb25EYXRhLFxuICAgICAgICAgICAgY3VycmVudERlYnVnRGF0YS5jYWxjdWxhdGVkTG9jYXRpb24gYXMgTG9jYXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIGN1cnJlbnREZWJ1Z0RhdGEuaW5pdGlhbFBvc2l0aW9uID0gaW5pdGlhbFBvc2l0aW9uO1xuXG4gICAgICAgICAgY29uc3Qgc2NlbmVDZW50ZXIgPSBjb29yZGluYXRlU3lzdGVtU2VydmljZS5nZXRTY2VuZUNlbnRlcigpO1xuICAgICAgICAgIGNvbnN0IHNjZW5lRGltZW5zaW9ucyA9IGNvb3JkaW5hdGVTeXN0ZW1TZXJ2aWNlLmdldFNjZW5lRGltZW5zaW9ucygpO1xuICAgICAgICAgIGNvbnN0IGhhbmRQb2ludHMgPSBjb29yZGluYXRlU3lzdGVtU2VydmljZS5nZXRBbGxIYW5kUG9pbnRzKCk7XG4gICAgICAgICAgY29uc3QgbGF5ZXIyUG9pbnRzID0gY29vcmRpbmF0ZVN5c3RlbVNlcnZpY2UuZ2V0QWxsTGF5ZXIyUG9pbnRzKCk7XG5cbiAgICAgICAgICBjdXJyZW50RGVidWdEYXRhLmNvb3JkaW5hdGVTeXN0ZW1EZWJ1Z0luZm8gPSB7XG4gICAgICAgICAgICBzY2VuZUNlbnRlcixcbiAgICAgICAgICAgIHNjZW5lRGltZW5zaW9ucyxcbiAgICAgICAgICAgIGhhbmRQb2ludHMsXG4gICAgICAgICAgICBsYXllcjJQb2ludHMsXG4gICAgICAgICAgICB1c2VkQ29vcmRpbmF0ZVNldDpcbiAgICAgICAgICAgICAgY3VycmVudE1vdGlvbkRhdGEubW90aW9uVHlwZSA9PT0gXCJzdGF0aWNcIiB8fFxuICAgICAgICAgICAgICBjdXJyZW50TW90aW9uRGF0YS5tb3Rpb25UeXBlID09PSBcImRhc2hcIlxuICAgICAgICAgICAgICAgID8gXCJoYW5kX3BvaW50c1wiXG4gICAgICAgICAgICAgICAgOiBcImxheWVyMl9wb2ludHNcIixcbiAgICAgICAgICAgIGNvb3JkaW5hdGVTeXN0ZW1UeXBlOiBcIlRLQV85NTB4OTUwXCIsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwVGltZXMuY29vcmRpbmF0ZV9zeXN0ZW0gPSBwZXJmb3JtYW5jZS5ub3coKSAtIGNvb3JkaW5hdGVTdGFydDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGN1cnJlbnREZWJ1Z0RhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIHN0ZXA6IFwiY29vcmRpbmF0ZV9zeXN0ZW1cIixcbiAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNURVAgMzogQ2FsY3VsYXRlIHJvdGF0aW9uXG4gICAgICBjb25zdCByb3RhdGlvblN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoY3VycmVudERlYnVnRGF0YS5jYWxjdWxhdGVkTG9jYXRpb24pIHtcbiAgICAgICAgICBjb25zdCByb3RhdGlvbiA9IHJvdGF0aW9uQ2FsY3VsYXRvci5jYWxjdWxhdGVSb3RhdGlvbihcbiAgICAgICAgICAgIGN1cnJlbnRNb3Rpb25EYXRhLFxuICAgICAgICAgICAgY3VycmVudERlYnVnRGF0YS5jYWxjdWxhdGVkTG9jYXRpb24gYXMgTG9jYXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIGN1cnJlbnREZWJ1Z0RhdGEuZmluYWxSb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXBUaW1lcy5yb3RhdGlvbl9jYWxjdWxhdGlvbiA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcm90YXRpb25TdGFydDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGN1cnJlbnREZWJ1Z0RhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIHN0ZXA6IFwicm90YXRpb25fY2FsY3VsYXRpb25cIixcbiAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNURVAgNDogQ2FsY3VsYXRlIGFkanVzdG1lbnRzXG4gICAgICBjb25zdCBhZGp1c3RtZW50U3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChjdXJyZW50RGVidWdEYXRhLmNhbGN1bGF0ZWRMb2NhdGlvbikge1xuICAgICAgICAgIGNvbnN0IGFkanVzdG1lbnQgPSBhd2FpdCBhZGp1c3RtZW50Q2FsY3VsYXRvci5jYWxjdWxhdGVBZGp1c3RtZW50KFxuICAgICAgICAgICAgc2VsZWN0ZWRQaWN0b2dyYXBoLFxuICAgICAgICAgICAgY3VycmVudE1vdGlvbkRhdGEsXG4gICAgICAgICAgICBzZWxlY3RlZFBpY3RvZ3JhcGgubGV0dGVyIHx8IFwiQVwiLFxuICAgICAgICAgICAgY3VycmVudERlYnVnRGF0YS5jYWxjdWxhdGVkTG9jYXRpb24gYXMgTG9jYXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIGN1cnJlbnREZWJ1Z0RhdGEuZGVmYXVsdEFkanVzdG1lbnQgPSBhZGp1c3RtZW50O1xuXG4gICAgICAgICAgLy8gRm9yIG5vdywgdXNlIHRoZSBhZGp1c3RtZW50IGFzIGZpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgLy8gSW4gYSBtb3JlIHNvcGhpc3RpY2F0ZWQgaW1wbGVtZW50YXRpb24sIHdlJ2QgYXBwbHkgaXQgdG8gdGhlIGluaXRpYWwgcG9zaXRpb25cbiAgICAgICAgICBpZiAoY3VycmVudERlYnVnRGF0YS5pbml0aWFsUG9zaXRpb24gJiYgYWRqdXN0bWVudCkge1xuICAgICAgICAgICAgY3VycmVudERlYnVnRGF0YS5maW5hbFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICB4OiBjdXJyZW50RGVidWdEYXRhLmluaXRpYWxQb3NpdGlvbi54ICsgYWRqdXN0bWVudC54LFxuICAgICAgICAgICAgICB5OiBjdXJyZW50RGVidWdEYXRhLmluaXRpYWxQb3NpdGlvbi55ICsgYWRqdXN0bWVudC55LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudERlYnVnRGF0YS5maW5hbFBvc2l0aW9uID0gY3VycmVudERlYnVnRGF0YS5pbml0aWFsUG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ZXBUaW1lcy5hZGp1c3RtZW50X2NhbGN1bGF0aW9uID0gcGVyZm9ybWFuY2Uubm93KCkgLSBhZGp1c3RtZW50U3RhcnQ7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjdXJyZW50RGVidWdEYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBzdGVwOiBcImFkanVzdG1lbnRfY2FsY3VsYXRpb25cIixcbiAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0b3RhbCB0aW1pbmdcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGN1cnJlbnREZWJ1Z0RhdGEudGltaW5nID0ge1xuICAgICAgICB0b3RhbER1cmF0aW9uOiBlbmRUaW1lIC0gc3RhcnRUaW1lLFxuICAgICAgICBzdGVwRHVyYXRpb25zOiBzdGVwVGltZXMsXG4gICAgICB9O1xuXG4gICAgICBjb25zb2xlLmxvZyhcIvCfjq8gQXJyb3cgcG9zaXRpb25pbmcgY2FsY3VsYXRpb24gY29tcGxldGVkOlwiLCB7XG4gICAgICAgIGxvY2F0aW9uOiBjdXJyZW50RGVidWdEYXRhLmNhbGN1bGF0ZWRMb2NhdGlvbixcbiAgICAgICAgaW5pdGlhbFBvc2l0aW9uOiBjdXJyZW50RGVidWdEYXRhLmluaXRpYWxQb3NpdGlvbixcbiAgICAgICAgZmluYWxQb3NpdGlvbjogY3VycmVudERlYnVnRGF0YS5maW5hbFBvc2l0aW9uLFxuICAgICAgICByb3RhdGlvbjogY3VycmVudERlYnVnRGF0YS5maW5hbFJvdGF0aW9uLFxuICAgICAgICBlcnJvcnM6IGN1cnJlbnREZWJ1Z0RhdGEuZXJyb3JzLFxuICAgICAgICB0aW1pbmc6IGN1cnJlbnREZWJ1Z0RhdGEudGltaW5nLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGN1cnJlbnREZWJ1Z0RhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICBzdGVwOiBcIm92ZXJhbGxfY2FsY3VsYXRpb25cIixcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzQ2FsY3VsYXRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBBdXRvLXVwZGF0ZSBlZmZlY3RcbiAgJGVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKFxuICAgICAgYXV0b1VwZGF0ZSAmJlxuICAgICAgc2VsZWN0ZWRQaWN0b2dyYXBoICYmXG4gICAgICBjdXJyZW50TW90aW9uRGF0YSAmJlxuICAgICAgY3VycmVudEFycm93RGF0YVxuICAgICkge1xuICAgICAgY2FsY3VsYXRlUG9zaXRpb25pbmcoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgLy8gU3RhdGVcbiAgICBnZXQgc2VsZWN0ZWRQaWN0b2dyYXBoKCkge1xuICAgICAgcmV0dXJuIHNlbGVjdGVkUGljdG9ncmFwaDtcbiAgICB9LFxuICAgIHNldCBzZWxlY3RlZFBpY3RvZ3JhcGgodmFsdWU6IFBpY3RvZ3JhcGhEYXRhIHwgbnVsbCkge1xuICAgICAgc2VsZWN0ZWRQaWN0b2dyYXBoID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldCBzZWxlY3RlZEFycm93Q29sb3IoKSB7XG4gICAgICByZXR1cm4gc2VsZWN0ZWRBcnJvd0NvbG9yO1xuICAgIH0sXG4gICAgc2V0IHNlbGVjdGVkQXJyb3dDb2xvcih2YWx1ZTogXCJyZWRcIiB8IFwiYmx1ZVwiKSB7XG4gICAgICBzZWxlY3RlZEFycm93Q29sb3IgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0IGF2YWlsYWJsZVBpY3RvZ3JhcGhzKCkge1xuICAgICAgcmV0dXJuIGF2YWlsYWJsZVBpY3RvZ3JhcGhzO1xuICAgIH0sXG4gICAgc2V0IGF2YWlsYWJsZVBpY3RvZ3JhcGhzKHZhbHVlOiBQaWN0b2dyYXBoRGF0YVtdKSB7XG4gICAgICBhdmFpbGFibGVQaWN0b2dyYXBocyA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXQgc3RlcEJ5U3RlcE1vZGUoKSB7XG4gICAgICByZXR1cm4gc3RlcEJ5U3RlcE1vZGU7XG4gICAgfSxcbiAgICBzZXQgc3RlcEJ5U3RlcE1vZGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgIHN0ZXBCeVN0ZXBNb2RlID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldCBjdXJyZW50U3RlcCgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50U3RlcDtcbiAgICB9LFxuICAgIHNldCBjdXJyZW50U3RlcCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICBjdXJyZW50U3RlcCA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXQgbWF4U3RlcHMoKSB7XG4gICAgICByZXR1cm4gbWF4U3RlcHM7XG4gICAgfSxcblxuICAgIGdldCBzaG93Q29vcmRpbmF0ZUdyaWQoKSB7XG4gICAgICByZXR1cm4gc2hvd0Nvb3JkaW5hdGVHcmlkO1xuICAgIH0sXG4gICAgc2V0IHNob3dDb29yZGluYXRlR3JpZCh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgc2hvd0Nvb3JkaW5hdGVHcmlkID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldCBzaG93SGFuZFBvaW50cygpIHtcbiAgICAgIHJldHVybiBzaG93SGFuZFBvaW50cztcbiAgICB9LFxuICAgIHNldCBzaG93SGFuZFBvaW50cyh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgc2hvd0hhbmRQb2ludHMgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0IHNob3dMYXllcjJQb2ludHMoKSB7XG4gICAgICByZXR1cm4gc2hvd0xheWVyMlBvaW50cztcbiAgICB9LFxuICAgIHNldCBzaG93TGF5ZXIyUG9pbnRzKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICBzaG93TGF5ZXIyUG9pbnRzID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldCBzaG93QWRqdXN0bWVudFZlY3RvcnMoKSB7XG4gICAgICByZXR1cm4gc2hvd0FkanVzdG1lbnRWZWN0b3JzO1xuICAgIH0sXG4gICAgc2V0IHNob3dBZGp1c3RtZW50VmVjdG9ycyh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgc2hvd0FkanVzdG1lbnRWZWN0b3JzID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldCBpc0NhbGN1bGF0aW5nKCkge1xuICAgICAgcmV0dXJuIGlzQ2FsY3VsYXRpbmc7XG4gICAgfSxcbiAgICBnZXQgYXV0b1VwZGF0ZSgpIHtcbiAgICAgIHJldHVybiBhdXRvVXBkYXRlO1xuICAgIH0sXG4gICAgc2V0IGF1dG9VcGRhdGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgIGF1dG9VcGRhdGUgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0IGV4cGFuZGVkU2VjdGlvbnMoKSB7XG4gICAgICByZXR1cm4gZXhwYW5kZWRTZWN0aW9ucztcbiAgICB9LFxuICAgIGdldCBjdXJyZW50RGVidWdEYXRhKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnREZWJ1Z0RhdGE7XG4gICAgfSxcblxuICAgIC8vIEdyaWQgbW9kZSBwcm9wZXJ0aWVzXG4gICAgZ2V0IGdyaWRNb2RlKCkge1xuICAgICAgcmV0dXJuIGdyaWRNb2RlO1xuICAgIH0sXG4gICAgc2V0IGdyaWRNb2RlKHZhbHVlOiBcImRpYW1vbmRcIiB8IFwiYm94XCIpIHtcbiAgICAgIHNldEdyaWRNb2RlKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLy8gQ29tcHV0ZWRcbiAgICBnZXQgY3VycmVudE1vdGlvbkRhdGEoKSB7XG4gICAgICByZXR1cm4gY3VycmVudE1vdGlvbkRhdGE7XG4gICAgfSxcbiAgICBnZXQgY3VycmVudEFycm93RGF0YSgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50QXJyb3dEYXRhO1xuICAgIH0sXG4gICAgZ2V0IGN1cnJlbnRTdGVwRGF0YSgpIHtcbiAgICAgIHJldHVybiBnZXRDdXJyZW50U3RlcERhdGEoKTtcbiAgICB9LFxuICAgIGdldCBjdXJyZW50U3RlcE5hbWUoKSB7XG4gICAgICByZXR1cm4gZ2V0Q3VycmVudFN0ZXBOYW1lKCk7XG4gICAgfSxcblxuICAgIC8vIEFjdGlvbnNcbiAgICB0b2dnbGVTZWN0aW9uLFxuICAgIHNldEdyaWRNb2RlLFxuICAgIGNhbGN1bGF0ZVBvc2l0aW9uaW5nLFxuICAgIGluaXRpYWxpemVSZWFsRGF0YSxcbiAgICBnZXRDdXJyZW50U3RlcERhdGEsXG4gICAgZ2V0Q3VycmVudFN0ZXBOYW1lLFxuICB9O1xufVxuIl0sImZpbGUiOiJGOi9DT0RFL1RLQS93ZWIvc3JjL2xpYi9jb21wb25lbnRzL3RhYnMvYXJyb3ctZGVidWcvZGVidWctc3RhdGUuc3ZlbHRlLnRzIn0=