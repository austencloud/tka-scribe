import { ArrowType, MotionColor } from "/src/lib/domain/index.ts";
import { AttributeKeyGenerator } from "/src/lib/services/positioning/arrows/key_generators/AttributeKeyGenerator.ts";
import { SpecialPlacementOriKeyGenerator } from "/src/lib/services/positioning/arrows/key_generators/SpecialPlacementOriKeyGenerator.ts";
import { TurnsTupleKeyGenerator } from "/src/lib/services/positioning/arrows/key_generators/TurnsTupleKeyGenerator.ts";
import { DefaultPlacementService } from "/src/lib/services/positioning/arrows/placement/DefaultPlacementService.ts";
import { SpecialPlacementService } from "/src/lib/services/positioning/arrows/placement/SpecialPlacementService.ts";
import { ArrowPlacementKeyService } from "/src/lib/services/implementations/positioning/ArrowPlacementKeyService.ts";
import {
  DirectionalTupleCalculator,
  DirectionalTupleProcessor,
  QuadrantIndexCalculator
} from "/src/lib/services/positioning/arrows/processors/DirectionalTupleProcessor.ts";
export class ArrowAdjustmentCalculator {
  /**
   * Consolidated service combining lookup and calculation logic.
   * Eliminates the pure delegation layer while maintaining identical behavior.
   */
  // Lookup services (previously in ArrowAdjustmentLookup)
  specialPlacementService;
  defaultPlacementService;
  orientationKeyService;
  placementKeyService;
  turnsTupleService;
  attributeKeyService;
  // Processing services
  tupleProcessor;
  constructor(options) {
    this.specialPlacementService = options?.specialPlacementService || new SpecialPlacementService();
    this.defaultPlacementService = options?.defaultPlacementService || new DefaultPlacementService();
    this.orientationKeyService = options?.orientationKeyService || new SpecialPlacementOriKeyGenerator();
    this.placementKeyService = options?.placementKeyService || new ArrowPlacementKeyService();
    this.turnsTupleService = options?.turnsTupleService || new TurnsTupleKeyGenerator();
    this.attributeKeyService = options?.attributeKeyService || new AttributeKeyGenerator();
    this.tupleProcessor = options?.tupleProcessor || this.createDefaultTupleProcessor();
  }
  async calculateAdjustment(pictographData, motionData, letter, location, arrowColor) {
    try {
      return await this.calculateAdjustmentResult(
        pictographData,
        motionData,
        letter,
        location,
        arrowColor
      );
    } catch (error) {
      console.error(`Adjustment calculation failed: ${error}`);
      return { x: 0, y: 0 };
    }
  }
  async calculateAdjustmentResult(pictographData, motionData, letter, location, arrowColor) {
    try {
      const baseAdjustment = await this.getBaseAdjustment(
        pictographData,
        motionData,
        letter,
        arrowColor
      );
      const finalAdjustment = this.tupleProcessor.processDirectionalTuples(
        baseAdjustment,
        motionData,
        location
      );
      return finalAdjustment;
    } catch (error) {
      console.error(
        `Adjustment calculation failed for letter ${letter}: ${error}`
      );
      throw new Error(`Arrow adjustment calculation failed: ${error}`);
    }
  }
  // === PRIVATE METHODS - Consolidated from ArrowAdjustmentLookup ===
  async getBaseAdjustment(pictographData, motionData, letter, arrowColor) {
    if (!motionData || !letter) {
      throw new Error("Missing motion or letter data for adjustment lookup");
    }
    try {
      const [oriKey, turnsTuple, attrKey] = this.generateLookupKeys(
        pictographData,
        motionData
      );
      console.debug(
        `Generated keys - ori: ${oriKey}, turns: ${turnsTuple}, attr: ${attrKey}`
      );
      try {
        const specialAdjustment = await this.lookupSpecialPlacement(
          motionData,
          pictographData,
          arrowColor
        );
        if (specialAdjustment) {
          return specialAdjustment;
        }
        console.debug("No special placement found, falling back to default");
      } catch {
        console.debug(
          "Error in special placement lookup, falling back to default"
        );
      }
      const defaultAdjustment = await this.calculateDefaultAdjustment(
        motionData,
        pictographData
      );
      console.debug(
        `Using default adjustment: (${defaultAdjustment.x.toFixed(1)}, ${defaultAdjustment.y.toFixed(1)})`
      );
      return defaultAdjustment;
    } catch (error) {
      console.error("Error in base adjustment lookup:", error);
      throw new Error(`Arrow adjustment lookup failed: ${error}`);
    }
  }
  generateLookupKeys(pictographData, motionData) {
    try {
      const oriKey = this.orientationKeyService.generateOrientationKey(
        motionData,
        pictographData
      );
      const turnsTuple = this.turnsTupleService.generateTurnsTuple(pictographData);
      const color = MotionColor.BLUE;
      const tempArrow = {
        id: "temp",
        arrowType: ArrowType.BLUE,
        color,
        motionType: motionData.motionType || "",
        location: "center",
        start_orientation: motionData.startOrientation || "",
        end_orientation: motionData.endOrientation || "",
        rotationDirection: motionData.rotationDirection || "",
        turns: typeof motionData.turns === "number" ? motionData.turns : 0,
        isMirrored: false,
        position_x: 0,
        position_y: 0,
        rotation_angle: 0,
        isVisible: true,
        is_selected: false
      };
      const attrKey = this.attributeKeyService.getKeyFromArrow(
        tempArrow,
        pictographData
      );
      return [oriKey, turnsTuple.join(","), attrKey];
    } catch (error) {
      console.error("Failed to generate lookup keys:", error);
      throw new Error(`Key generation failed: ${error}`);
    }
  }
  async lookupSpecialPlacement(motionData, pictographData, arrowColor) {
    try {
      const adjustment = await this.specialPlacementService.getSpecialAdjustment(
        motionData,
        pictographData,
        arrowColor
      );
      if (adjustment) {
        return adjustment;
      }
      return null;
    } catch (error) {
      console.error("Error in special placement lookup:", error);
      return null;
    }
  }
  async calculateDefaultAdjustment(motionData, pictographData, gridMode = "diamond") {
    try {
      const keys = await this.defaultPlacementService.getAvailablePlacementKeys(
        motionData.motionType,
        pictographData.gridMode
      );
      const defaultPlacements = Object.fromEntries(
        (keys || []).map((k) => [k, true])
      );
      const availableKeys = Object.keys(defaultPlacements || []);
      const placementKey = this.placementKeyService.generatePlacementKey(
        motionData,
        pictographData,
        availableKeys
      );
      const adjustmentPoint = await this.defaultPlacementService.getDefaultAdjustment(
        placementKey,
        motionData.turns || 0,
        motionData.motionType,
        gridMode
      );
      return adjustmentPoint;
    } catch (error) {
      console.error("Error calculating default adjustment:", error);
      throw new Error(`Default adjustment calculation failed: ${error}`);
    }
  }
  createDefaultTupleProcessor() {
    return new DirectionalTupleProcessor(
      new DirectionalTupleCalculator(),
      new QuadrantIndexCalculator()
    );
  }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkFycm93QWRqdXN0bWVudENhbGN1bGF0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBcnJvdyBBZGp1c3RtZW50IENhbGN1bGF0b3IgLSBDb25zb2xpZGF0ZWQgU2VydmljZVxuICpcbiAqIENvbnNvbGlkYXRlZCBzZXJ2aWNlIHRoYXQgY29tYmluZXMgQXJyb3dBZGp1c3RtZW50Q2FsY3VsYXRvciBhbmQgQXJyb3dBZGp1c3RtZW50TG9va3VwXG4gKiB0byBlbGltaW5hdGUgcHVyZSBkZWxlZ2F0aW9uIGxheWVyLiBNYWludGFpbnMgZXhhY3Qgc2FtZSBpbnRlcmZhY2UgYW5kIGJlaGF2aW9yLlxuICpcbiAqIENPTlNPTElEQVRJT04gQkVORUZJVFM6XG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgZGVsZWdhdGlvbiBsYXllclxuICogLSBNYWludGFpbnMgaWRlbnRpY2FsIGxvZ2ljIGFuZCByZXN1bHRzXG4gKiAtIFByZXNlcnZlcyBhbGwgZXhpc3RpbmcgaW50ZXJmYWNlcyBhbmQgdGVzdCBjb21wYXRpYmlsaXR5XG4gKiAtIEJldHRlciBUeXBlU2NyaXB0IG9yZ2FuaXphdGlvblxuICovXG5cbmltcG9ydCB0eXBlIHsgTW90aW9uRGF0YSwgUGljdG9ncmFwaERhdGEsIEdyaWRNb2RlIH0gZnJvbSBcIiRsaWIvZG9tYWluXCI7XG5pbXBvcnQgeyBBcnJvd1R5cGUsIE1vdGlvbkNvbG9yIH0gZnJvbSBcIiRsaWIvZG9tYWluXCI7XG5pbXBvcnQgdHlwZSB7IElBcnJvd0FkanVzdG1lbnRDYWxjdWxhdG9yIH0gZnJvbSBcIi4uLy4uL2NvcmUtc2VydmljZXNcIjtcbmltcG9ydCB0eXBlIHtcbiAgSUF0dHJpYnV0ZUtleUdlbmVyYXRvcixcbiAgSVNwZWNpYWxQbGFjZW1lbnRPcmlLZXlHZW5lcmF0b3IsXG4gIElUdXJuc1R1cGxlS2V5R2VuZXJhdG9yLFxufSBmcm9tIFwiLi4vLi4vZGF0YS1zZXJ2aWNlc1wiO1xuaW1wb3J0IHR5cGUge1xuICBJRGVmYXVsdFBsYWNlbWVudFNlcnZpY2UsXG4gIElTcGVjaWFsUGxhY2VtZW50U2VydmljZSxcbn0gZnJvbSBcIi4uLy4uL3BsYWNlbWVudC1zZXJ2aWNlc1wiO1xuaW1wb3J0IHR5cGUge1xuICBMb2NhdGlvbixcbiAgTW90aW9uVHlwZSBhcyBNb3Rpb25UeXBlVHlwZSxcbiAgUG9pbnQsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuaW1wb3J0IHsgQXR0cmlidXRlS2V5R2VuZXJhdG9yIH0gZnJvbSBcIi4uL2tleV9nZW5lcmF0b3JzL0F0dHJpYnV0ZUtleUdlbmVyYXRvclwiO1xuaW1wb3J0IHsgU3BlY2lhbFBsYWNlbWVudE9yaUtleUdlbmVyYXRvciB9IGZyb20gXCIuLi9rZXlfZ2VuZXJhdG9ycy9TcGVjaWFsUGxhY2VtZW50T3JpS2V5R2VuZXJhdG9yXCI7XG5pbXBvcnQgeyBUdXJuc1R1cGxlS2V5R2VuZXJhdG9yIH0gZnJvbSBcIi4uL2tleV9nZW5lcmF0b3JzL1R1cm5zVHVwbGVLZXlHZW5lcmF0b3JcIjtcbmltcG9ydCB7IERlZmF1bHRQbGFjZW1lbnRTZXJ2aWNlIH0gZnJvbSBcIi4uL3BsYWNlbWVudC9EZWZhdWx0UGxhY2VtZW50U2VydmljZVwiO1xuaW1wb3J0IHsgU3BlY2lhbFBsYWNlbWVudFNlcnZpY2UgfSBmcm9tIFwiLi4vcGxhY2VtZW50L1NwZWNpYWxQbGFjZW1lbnRTZXJ2aWNlXCI7XG5pbXBvcnQgeyBBcnJvd1BsYWNlbWVudEtleVNlcnZpY2UgfSBmcm9tIFwiLi4vLi4vLi4vaW1wbGVtZW50YXRpb25zL3Bvc2l0aW9uaW5nL0Fycm93UGxhY2VtZW50S2V5U2VydmljZVwiO1xuaW1wb3J0IHtcbiAgRGlyZWN0aW9uYWxUdXBsZUNhbGN1bGF0b3IsXG4gIERpcmVjdGlvbmFsVHVwbGVQcm9jZXNzb3IsXG4gIFF1YWRyYW50SW5kZXhDYWxjdWxhdG9yLFxuICB0eXBlIElEaXJlY3Rpb25hbFR1cGxlUHJvY2Vzc29yLFxufSBmcm9tIFwiLi4vcHJvY2Vzc29ycy9EaXJlY3Rpb25hbFR1cGxlUHJvY2Vzc29yXCI7XG5cbmV4cG9ydCBjbGFzcyBBcnJvd0FkanVzdG1lbnRDYWxjdWxhdG9yIGltcGxlbWVudHMgSUFycm93QWRqdXN0bWVudENhbGN1bGF0b3Ige1xuICAvKipcbiAgICogQ29uc29saWRhdGVkIHNlcnZpY2UgY29tYmluaW5nIGxvb2t1cCBhbmQgY2FsY3VsYXRpb24gbG9naWMuXG4gICAqIEVsaW1pbmF0ZXMgdGhlIHB1cmUgZGVsZWdhdGlvbiBsYXllciB3aGlsZSBtYWludGFpbmluZyBpZGVudGljYWwgYmVoYXZpb3IuXG4gICAqL1xuXG4gIC8vIExvb2t1cCBzZXJ2aWNlcyAocHJldmlvdXNseSBpbiBBcnJvd0FkanVzdG1lbnRMb29rdXApXG4gIHByaXZhdGUgc3BlY2lhbFBsYWNlbWVudFNlcnZpY2U6IElTcGVjaWFsUGxhY2VtZW50U2VydmljZTtcbiAgcHJpdmF0ZSBkZWZhdWx0UGxhY2VtZW50U2VydmljZTogSURlZmF1bHRQbGFjZW1lbnRTZXJ2aWNlO1xuICBwcml2YXRlIG9yaWVudGF0aW9uS2V5U2VydmljZTogSVNwZWNpYWxQbGFjZW1lbnRPcmlLZXlHZW5lcmF0b3I7XG4gIHByaXZhdGUgcGxhY2VtZW50S2V5U2VydmljZTogQXJyb3dQbGFjZW1lbnRLZXlTZXJ2aWNlO1xuICBwcml2YXRlIHR1cm5zVHVwbGVTZXJ2aWNlOiBJVHVybnNUdXBsZUtleUdlbmVyYXRvcjtcbiAgcHJpdmF0ZSBhdHRyaWJ1dGVLZXlTZXJ2aWNlOiBJQXR0cmlidXRlS2V5R2VuZXJhdG9yO1xuXG4gIC8vIFByb2Nlc3Npbmcgc2VydmljZXNcbiAgcHJpdmF0ZSB0dXBsZVByb2Nlc3NvcjogSURpcmVjdGlvbmFsVHVwbGVQcm9jZXNzb3I7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucz86IHtcbiAgICBzcGVjaWFsUGxhY2VtZW50U2VydmljZT86IElTcGVjaWFsUGxhY2VtZW50U2VydmljZTtcbiAgICBkZWZhdWx0UGxhY2VtZW50U2VydmljZT86IElEZWZhdWx0UGxhY2VtZW50U2VydmljZTtcbiAgICBvcmllbnRhdGlvbktleVNlcnZpY2U/OiBJU3BlY2lhbFBsYWNlbWVudE9yaUtleUdlbmVyYXRvcjtcbiAgICBwbGFjZW1lbnRLZXlTZXJ2aWNlPzogQXJyb3dQbGFjZW1lbnRLZXlTZXJ2aWNlO1xuICAgIHR1cm5zVHVwbGVTZXJ2aWNlPzogSVR1cm5zVHVwbGVLZXlHZW5lcmF0b3I7XG4gICAgYXR0cmlidXRlS2V5U2VydmljZT86IElBdHRyaWJ1dGVLZXlHZW5lcmF0b3I7XG4gICAgdHVwbGVQcm9jZXNzb3I/OiBJRGlyZWN0aW9uYWxUdXBsZVByb2Nlc3NvcjtcbiAgfSkge1xuICAgIC8vIEluaXRpYWxpemUgc2VydmljZXMgd2l0aCBkZWZhdWx0cyBpZiBub3QgcHJvdmlkZWRcbiAgICB0aGlzLnNwZWNpYWxQbGFjZW1lbnRTZXJ2aWNlID1cbiAgICAgIG9wdGlvbnM/LnNwZWNpYWxQbGFjZW1lbnRTZXJ2aWNlIHx8IG5ldyBTcGVjaWFsUGxhY2VtZW50U2VydmljZSgpO1xuICAgIHRoaXMuZGVmYXVsdFBsYWNlbWVudFNlcnZpY2UgPVxuICAgICAgb3B0aW9ucz8uZGVmYXVsdFBsYWNlbWVudFNlcnZpY2UgfHwgbmV3IERlZmF1bHRQbGFjZW1lbnRTZXJ2aWNlKCk7XG4gICAgdGhpcy5vcmllbnRhdGlvbktleVNlcnZpY2UgPVxuICAgICAgb3B0aW9ucz8ub3JpZW50YXRpb25LZXlTZXJ2aWNlIHx8IG5ldyBTcGVjaWFsUGxhY2VtZW50T3JpS2V5R2VuZXJhdG9yKCk7XG4gICAgdGhpcy5wbGFjZW1lbnRLZXlTZXJ2aWNlID1cbiAgICAgIG9wdGlvbnM/LnBsYWNlbWVudEtleVNlcnZpY2UgfHwgbmV3IEFycm93UGxhY2VtZW50S2V5U2VydmljZSgpO1xuICAgIHRoaXMudHVybnNUdXBsZVNlcnZpY2UgPVxuICAgICAgb3B0aW9ucz8udHVybnNUdXBsZVNlcnZpY2UgfHwgbmV3IFR1cm5zVHVwbGVLZXlHZW5lcmF0b3IoKTtcbiAgICB0aGlzLmF0dHJpYnV0ZUtleVNlcnZpY2UgPVxuICAgICAgb3B0aW9ucz8uYXR0cmlidXRlS2V5U2VydmljZSB8fCBuZXcgQXR0cmlidXRlS2V5R2VuZXJhdG9yKCk7XG4gICAgdGhpcy50dXBsZVByb2Nlc3NvciA9XG4gICAgICBvcHRpb25zPy50dXBsZVByb2Nlc3NvciB8fCB0aGlzLmNyZWF0ZURlZmF1bHRUdXBsZVByb2Nlc3NvcigpO1xuICB9XG5cbiAgYXN5bmMgY2FsY3VsYXRlQWRqdXN0bWVudChcbiAgICBwaWN0b2dyYXBoRGF0YTogUGljdG9ncmFwaERhdGEsXG4gICAgbW90aW9uRGF0YTogTW90aW9uRGF0YSxcbiAgICBsZXR0ZXI6IHN0cmluZyxcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgYXJyb3dDb2xvcj86IHN0cmluZ1xuICApOiBQcm9taXNlPFBvaW50PiB7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGFycm93IHBvc2l0aW9uIGFkanVzdG1lbnQgLSBJREVOVElDQUwgbG9naWMgdG8gb3JpZ2luYWwuXG4gICAgICovXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNhbGN1bGF0ZUFkanVzdG1lbnRSZXN1bHQoXG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhLFxuICAgICAgICBtb3Rpb25EYXRhLFxuICAgICAgICBsZXR0ZXIsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBhcnJvd0NvbG9yXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBMb2cgZXJyb3IgYW5kIHJldHVybiBkZWZhdWx0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICBjb25zb2xlLmVycm9yKGBBZGp1c3RtZW50IGNhbGN1bGF0aW9uIGZhaWxlZDogJHtlcnJvcn1gKTtcbiAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjYWxjdWxhdGVBZGp1c3RtZW50UmVzdWx0KFxuICAgIHBpY3RvZ3JhcGhEYXRhOiBQaWN0b2dyYXBoRGF0YSxcbiAgICBtb3Rpb25EYXRhOiBNb3Rpb25EYXRhLFxuICAgIGxldHRlcjogc3RyaW5nLFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBhcnJvd0NvbG9yPzogc3RyaW5nXG4gICk6IFByb21pc2U8UG9pbnQ+IHtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgYXJyb3cgcG9zaXRpb24gYWRqdXN0bWVudCB3aXRoIHByb3BlciBlcnJvciBoYW5kbGluZy5cbiAgICAgKiBJREVOVElDQUwgbG9naWMgdG8gb3JpZ2luYWwgQXJyb3dBZGp1c3RtZW50Q2FsY3VsYXRvci5cbiAgICAgKi9cbiAgICB0cnkge1xuICAgICAgLy8gU1RFUCAxOiBMb29rIHVwIGJhc2UgYWRqdXN0bWVudCAoc3BlY2lhbCDihpIgZGVmYXVsdCkgLSBFWEFDVExZIGxpa2UgbGVnYWN5XG4gICAgICBjb25zdCBiYXNlQWRqdXN0bWVudCA9IGF3YWl0IHRoaXMuZ2V0QmFzZUFkanVzdG1lbnQoXG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhLFxuICAgICAgICBtb3Rpb25EYXRhLFxuICAgICAgICBsZXR0ZXIsXG4gICAgICAgIGFycm93Q29sb3JcbiAgICAgICk7XG5cbiAgICAgIC8vIFNURVAgMjogUHJvY2VzcyBkaXJlY3Rpb25hbCB0dXBsZXMgLSBFWEFDVExZIGxpa2UgbGVnYWN5XG4gICAgICBjb25zdCBmaW5hbEFkanVzdG1lbnQgPSB0aGlzLnR1cGxlUHJvY2Vzc29yLnByb2Nlc3NEaXJlY3Rpb25hbFR1cGxlcyhcbiAgICAgICAgYmFzZUFkanVzdG1lbnQsXG4gICAgICAgIG1vdGlvbkRhdGEsXG4gICAgICAgIGxvY2F0aW9uXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gZmluYWxBZGp1c3RtZW50O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgQWRqdXN0bWVudCBjYWxjdWxhdGlvbiBmYWlsZWQgZm9yIGxldHRlciAke2xldHRlcn06ICR7ZXJyb3J9YFxuICAgICAgKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXJyb3cgYWRqdXN0bWVudCBjYWxjdWxhdGlvbiBmYWlsZWQ6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gPT09IFBSSVZBVEUgTUVUSE9EUyAtIENvbnNvbGlkYXRlZCBmcm9tIEFycm93QWRqdXN0bWVudExvb2t1cCA9PT1cblxuICBwcml2YXRlIGFzeW5jIGdldEJhc2VBZGp1c3RtZW50KFxuICAgIHBpY3RvZ3JhcGhEYXRhOiBQaWN0b2dyYXBoRGF0YSxcbiAgICBtb3Rpb25EYXRhOiBNb3Rpb25EYXRhLFxuICAgIGxldHRlcjogc3RyaW5nLFxuICAgIGFycm93Q29sb3I/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxQb2ludD4ge1xuICAgIC8qKlxuICAgICAqIEdldCBiYXNlIGFkanVzdG1lbnQgdXNpbmcgc3RyZWFtbGluZWQgbG9va3VwIGxvZ2ljLlxuICAgICAqIElERU5USUNBTCB0byBBcnJvd0FkanVzdG1lbnRMb29rdXAuZ2V0QmFzZUFkanVzdG1lbnQoKVxuICAgICAqL1xuICAgIGlmICghbW90aW9uRGF0YSB8fCAhbGV0dGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIG1vdGlvbiBvciBsZXR0ZXIgZGF0YSBmb3IgYWRqdXN0bWVudCBsb29rdXBcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdlbmVyYXRlIHJlcXVpcmVkIGtleXMgZm9yIHNwZWNpYWwgcGxhY2VtZW50IGxvb2t1cFxuICAgICAgY29uc3QgW29yaUtleSwgdHVybnNUdXBsZSwgYXR0cktleV0gPSB0aGlzLmdlbmVyYXRlTG9va3VwS2V5cyhcbiAgICAgICAgcGljdG9ncmFwaERhdGEsXG4gICAgICAgIG1vdGlvbkRhdGFcbiAgICAgICk7XG5cbiAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgIGBHZW5lcmF0ZWQga2V5cyAtIG9yaTogJHtvcmlLZXl9LCB0dXJuczogJHt0dXJuc1R1cGxlfSwgYXR0cjogJHthdHRyS2V5fWBcbiAgICAgICk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNwZWNpYWxBZGp1c3RtZW50ID0gYXdhaXQgdGhpcy5sb29rdXBTcGVjaWFsUGxhY2VtZW50KFxuICAgICAgICAgIG1vdGlvbkRhdGEsXG4gICAgICAgICAgcGljdG9ncmFwaERhdGEsXG4gICAgICAgICAgYXJyb3dDb2xvclxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChzcGVjaWFsQWRqdXN0bWVudCkge1xuICAgICAgICAgIHJldHVybiBzcGVjaWFsQWRqdXN0bWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vIHNwZWNpYWwgcGxhY2VtZW50IGZvdW5kIC0gZmFsbCBiYWNrIHRvIGRlZmF1bHRcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhcIk5vIHNwZWNpYWwgcGxhY2VtZW50IGZvdW5kLCBmYWxsaW5nIGJhY2sgdG8gZGVmYXVsdFwiKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBFcnJvciBpbiBzcGVjaWFsIHBsYWNlbWVudCBsb29rdXAgLSBmYWxsIGJhY2sgdG8gZGVmYXVsdFxuICAgICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgIFwiRXJyb3IgaW4gc3BlY2lhbCBwbGFjZW1lbnQgbG9va3VwLCBmYWxsaW5nIGJhY2sgdG8gZGVmYXVsdFwiXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNURVAgMjogRmFsbCBiYWNrIHRvIGRlZmF1bHQgY2FsY3VsYXRpb25cbiAgICAgIGNvbnN0IGRlZmF1bHRBZGp1c3RtZW50ID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVEZWZhdWx0QWRqdXN0bWVudChcbiAgICAgICAgbW90aW9uRGF0YSxcbiAgICAgICAgcGljdG9ncmFwaERhdGFcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICBgVXNpbmcgZGVmYXVsdCBhZGp1c3RtZW50OiAoJHtkZWZhdWx0QWRqdXN0bWVudC54LnRvRml4ZWQoMSl9LCAke2RlZmF1bHRBZGp1c3RtZW50LnkudG9GaXhlZCgxKX0pYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkZWZhdWx0QWRqdXN0bWVudDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGJhc2UgYWRqdXN0bWVudCBsb29rdXA6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXJyb3cgYWRqdXN0bWVudCBsb29rdXAgZmFpbGVkOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVMb29rdXBLZXlzKFxuICAgIHBpY3RvZ3JhcGhEYXRhOiBQaWN0b2dyYXBoRGF0YSxcbiAgICBtb3Rpb25EYXRhOiBNb3Rpb25EYXRhXG4gICk6IFtzdHJpbmcsIHN0cmluZywgc3RyaW5nXSB7XG4gICAgLyoqR2VuZXJhdGUgYWxsIHJlcXVpcmVkIGtleXMgZm9yIHNwZWNpYWwgcGxhY2VtZW50IGxvb2t1cC4qL1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvcmlLZXkgPSB0aGlzLm9yaWVudGF0aW9uS2V5U2VydmljZS5nZW5lcmF0ZU9yaWVudGF0aW9uS2V5KFxuICAgICAgICBtb3Rpb25EYXRhLFxuICAgICAgICBwaWN0b2dyYXBoRGF0YVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHR1cm5zVHVwbGUgPVxuICAgICAgICB0aGlzLnR1cm5zVHVwbGVTZXJ2aWNlLmdlbmVyYXRlVHVybnNUdXBsZShwaWN0b2dyYXBoRGF0YSk7XG5cbiAgICAgIC8vIENyZWF0ZSBtaW5pbWFsIGFycm93IGRhdGEgZm9yIGF0dHJpYnV0ZSBrZXkgZ2VuZXJhdGlvblxuICAgICAgY29uc3QgY29sb3IgPSBNb3Rpb25Db2xvci5CTFVFO1xuICAgICAgY29uc3QgdGVtcEFycm93ID0ge1xuICAgICAgICBpZDogXCJ0ZW1wXCIsXG4gICAgICAgIGFycm93VHlwZTogQXJyb3dUeXBlLkJMVUUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBtb3Rpb25UeXBlOiBtb3Rpb25EYXRhLm1vdGlvblR5cGUgfHwgXCJcIixcbiAgICAgICAgbG9jYXRpb246IFwiY2VudGVyXCIsXG4gICAgICAgIHN0YXJ0X29yaWVudGF0aW9uOiBtb3Rpb25EYXRhLnN0YXJ0T3JpZW50YXRpb24gfHwgXCJcIixcbiAgICAgICAgZW5kX29yaWVudGF0aW9uOiBtb3Rpb25EYXRhLmVuZE9yaWVudGF0aW9uIHx8IFwiXCIsXG4gICAgICAgIHJvdGF0aW9uRGlyZWN0aW9uOiBtb3Rpb25EYXRhLnJvdGF0aW9uRGlyZWN0aW9uIHx8IFwiXCIsXG4gICAgICAgIHR1cm5zOiB0eXBlb2YgbW90aW9uRGF0YS50dXJucyA9PT0gXCJudW1iZXJcIiA/IG1vdGlvbkRhdGEudHVybnMgOiAwLFxuICAgICAgICBpc01pcnJvcmVkOiBmYWxzZSxcbiAgICAgICAgcG9zaXRpb25feDogMCxcbiAgICAgICAgcG9zaXRpb25feTogMCxcbiAgICAgICAgcm90YXRpb25fYW5nbGU6IDAsXG4gICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgaXNfc2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgYXR0cktleSA9IHRoaXMuYXR0cmlidXRlS2V5U2VydmljZS5nZXRLZXlGcm9tQXJyb3coXG4gICAgICAgIHRlbXBBcnJvdyxcbiAgICAgICAgcGljdG9ncmFwaERhdGFcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBbb3JpS2V5LCB0dXJuc1R1cGxlLmpvaW4oXCIsXCIpLCBhdHRyS2V5XTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBsb29rdXAga2V5czpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgZ2VuZXJhdGlvbiBmYWlsZWQ6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBsb29rdXBTcGVjaWFsUGxhY2VtZW50KFxuICAgIG1vdGlvbkRhdGE6IE1vdGlvbkRhdGEsXG4gICAgcGljdG9ncmFwaERhdGE6IFBpY3RvZ3JhcGhEYXRhLFxuICAgIGFycm93Q29sb3I/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxQb2ludCB8IG51bGw+IHtcbiAgICAvKipcbiAgICAgKiBMb29rIHVwIHNwZWNpYWwgcGxhY2VtZW50IHVzaW5nIGV4YWN0IGxlZ2FjeSBsb2dpYy5cbiAgICAgKiBJREVOVElDQUwgdG8gQXJyb3dBZGp1c3RtZW50TG9va3VwLmxvb2t1cFNwZWNpYWxQbGFjZW1lbnQoKVxuICAgICAqL1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhZGp1c3RtZW50ID1cbiAgICAgICAgYXdhaXQgdGhpcy5zcGVjaWFsUGxhY2VtZW50U2VydmljZS5nZXRTcGVjaWFsQWRqdXN0bWVudChcbiAgICAgICAgICBtb3Rpb25EYXRhLFxuICAgICAgICAgIHBpY3RvZ3JhcGhEYXRhLFxuICAgICAgICAgIGFycm93Q29sb3JcbiAgICAgICAgKTtcblxuICAgICAgaWYgKGFkanVzdG1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFkanVzdG1lbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBudWxsIGluc3RlYWQgb2YgdGhyb3dpbmcgd2hlbiBubyBzcGVjaWFsIHBsYWNlbWVudCBmb3VuZFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBzcGVjaWFsIHBsYWNlbWVudCBsb29rdXA6XCIsIGVycm9yKTtcbiAgICAgIC8vIFJldHVybiBudWxsIG9uIGVycm9yIHRvIGFsbG93IGZhbGxiYWNrIHRvIGRlZmF1bHQgYWRqdXN0bWVudFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjYWxjdWxhdGVEZWZhdWx0QWRqdXN0bWVudChcbiAgICBtb3Rpb25EYXRhOiBNb3Rpb25EYXRhLFxuICAgIHBpY3RvZ3JhcGhEYXRhOiBQaWN0b2dyYXBoRGF0YSxcbiAgICBncmlkTW9kZTogc3RyaW5nID0gXCJkaWFtb25kXCJcbiAgKTogUHJvbWlzZTxQb2ludD4ge1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBkZWZhdWx0IGFkanVzdG1lbnQgLSBJREVOVElDQUwgdG8gQXJyb3dBZGp1c3RtZW50TG9va3VwLlxuICAgICAqL1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlzID0gYXdhaXQgdGhpcy5kZWZhdWx0UGxhY2VtZW50U2VydmljZS5nZXRBdmFpbGFibGVQbGFjZW1lbnRLZXlzKFxuICAgICAgICBtb3Rpb25EYXRhLm1vdGlvblR5cGUgYXMgTW90aW9uVHlwZVR5cGUsXG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhLmdyaWRNb2RlIGFzIEdyaWRNb2RlXG4gICAgICApO1xuICAgICAgY29uc3QgZGVmYXVsdFBsYWNlbWVudHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAoa2V5cyB8fCBbXSkubWFwKChrKSA9PiBbaywgdHJ1ZV0pXG4gICAgICApO1xuXG4gICAgICBjb25zdCBhdmFpbGFibGVLZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdFBsYWNlbWVudHMgfHwgW10pO1xuXG4gICAgICBjb25zdCBwbGFjZW1lbnRLZXkgPSB0aGlzLnBsYWNlbWVudEtleVNlcnZpY2UuZ2VuZXJhdGVQbGFjZW1lbnRLZXkoXG4gICAgICAgIG1vdGlvbkRhdGEsXG4gICAgICAgIHBpY3RvZ3JhcGhEYXRhLFxuICAgICAgICBhdmFpbGFibGVLZXlzXG4gICAgICApO1xuXG4gICAgICBjb25zdCBhZGp1c3RtZW50UG9pbnQgPVxuICAgICAgICBhd2FpdCB0aGlzLmRlZmF1bHRQbGFjZW1lbnRTZXJ2aWNlLmdldERlZmF1bHRBZGp1c3RtZW50KFxuICAgICAgICAgIHBsYWNlbWVudEtleSxcbiAgICAgICAgICBtb3Rpb25EYXRhLnR1cm5zIHx8IDAsXG4gICAgICAgICAgbW90aW9uRGF0YS5tb3Rpb25UeXBlIGFzIE1vdGlvblR5cGVUeXBlLFxuICAgICAgICAgIGdyaWRNb2RlIGFzIEdyaWRNb2RlXG4gICAgICAgICk7XG5cbiAgICAgIHJldHVybiBhZGp1c3RtZW50UG9pbnQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYWxjdWxhdGluZyBkZWZhdWx0IGFkanVzdG1lbnQ6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRGVmYXVsdCBhZGp1c3RtZW50IGNhbGN1bGF0aW9uIGZhaWxlZDogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZURlZmF1bHRUdXBsZVByb2Nlc3NvcigpOiBJRGlyZWN0aW9uYWxUdXBsZVByb2Nlc3NvciB7XG4gICAgLyoqQ3JlYXRlIHR1cGxlIHByb2Nlc3NvciB3aXRoIGRlZmF1bHQgZGVwZW5kZW5jaWVzLiovXG4gICAgcmV0dXJuIG5ldyBEaXJlY3Rpb25hbFR1cGxlUHJvY2Vzc29yKFxuICAgICAgbmV3IERpcmVjdGlvbmFsVHVwbGVDYWxjdWxhdG9yKCksXG4gICAgICBuZXcgUXVhZHJhbnRJbmRleENhbGN1bGF0b3IoKVxuICAgICk7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBY0EsU0FBUyxXQUFXLG1CQUFtQjtBQWdCdkMsU0FBUyw2QkFBNkI7QUFDdEMsU0FBUyx1Q0FBdUM7QUFDaEQsU0FBUyw4QkFBOEI7QUFDdkMsU0FBUywrQkFBK0I7QUFDeEMsU0FBUywrQkFBK0I7QUFDeEMsU0FBUyxnQ0FBZ0M7QUFDekM7QUFBQSxFQUNFO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxPQUVLO0FBRUEsYUFBTSwwQkFBZ0U7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFPbkU7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBO0FBQUEsRUFHQTtBQUFBLEVB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