import { createHotContext as __vite__createHotContext } from "/@vite/client";import.meta.hot = __vite__createHotContext("/src/lib/components/pictograph/Prop.svelte");import "/node_modules/.vite/deps/svelte_internal_disclose-version.js?v=de368f3a";

Prop[$.FILENAME] = 'src/lib/components/pictograph/Prop.svelte';

import * as $ from "/node_modules/.vite/deps/svelte_internal_client.js?v=de368f3a";

import {
	Location,
	MotionType,
	Orientation,
	RotationDirection,
	MotionColor
} from "/src/lib/domain/enums.ts";

import { DefaultPropPositioner } from "/src/lib/services/DefaultPropPositioner.ts";
import { PropRotAngleManager } from "/src/lib/services/PropRotAngleManager.ts";
import { BetaOffsetCalculator } from "/src/lib/services/implementations/positioning/BetaOffsetCalculator.ts";
import { BetaPropDirectionCalculator } from "/src/lib/services/implementations/positioning/BetaPropDirectionCalculator.ts";
import { onMount } from "/node_modules/.vite/deps/svelte.js?v=de368f3a";

var root_1 = $.add_locations($.from_svg(`<rect x="-15" y="-15" width="30" height="30" fill="red" opacity="0.5" rx="3" class="s-SUZ92of2eZx8"></rect><text x="0" y="4" text-anchor="middle" font-size="8" fill="white" class="s-SUZ92of2eZx8">!</text>`, 1), Prop[$.FILENAME], [[263, 4], [272, 4]]);
var root_3 = $.add_locations($.from_svg(`<rect x="-12" y="-12" width="24" height="24" opacity="0.3" rx="2" class="s-SUZ92of2eZx8"></rect><animate attributeName="opacity" values="0.3;0.8;0.3" dur="1s" repeatCount="indefinite" class="s-SUZ92of2eZx8"></animate>`, 1), Prop[$.FILENAME], [[275, 4], [284, 4]]);
var root_4 = $.add_locations($.from_svg(`<image preserveAspectRatio="xMidYMid meet" class="prop-svg s-SUZ92of2eZx8"></image>`), Prop[$.FILENAME], [[292, 4]]);
var root = $.add_locations($.from_svg(`<g><!></g>`), Prop[$.FILENAME], [[253, 0]]);

function Prop($$anchor, $$props) {
	$.check_target(new.target);
	$.push($$props, true, Prop);

	let gridMode = $.prop($$props, 'gridMode', 3, "diamond"),
		allProps = $.prop($$props, 'allProps', 19, () => []),
		endsWithBeta = $.prop($$props, 'endsWithBeta', 3, false);

	// NEW: Default to false
	let _propElement = $.tag($.state(null), '_propElement');

	let loaded = $.tag($.state(false), 'loaded');
	let error = $.tag($.state(null), 'error');
	let svgData = $.tag($.state(null), 'svgData');

	const position = $.tag(
		$.derived(() => () => {
			if (!$$props.propData) return { x: 475, y: 475 };

			const location = $$props.propData.location || $$props.motionData?.endLocation;
			const basePosition = DefaultPropPositioner.calculatePosition(location, gridMode());
			const betaOffset = calculateBetaOffset();

			return {
				x: basePosition.x + betaOffset.x,
				y: basePosition.y + betaOffset.y
			};
		}),
		'position'
	);

	function calculateBetaOffset() {
		if (!endsWithBeta()) {
			return { x: 0, y: 0 };
		}

		if (!$$props.propData || !allProps() || allProps().length < 2) {
			return { x: 0, y: 0 };
		}

		const otherProp = allProps().find((p) => $.strict_equals(p.color, $$props.propData.color, false) && $.strict_equals(p.location, $$props.propData.location));

		if (!otherProp) {
			return { x: 0, y: 0 };
		}

		console.log(`\u{1F527} Applying beta offset for ${$$props.propData.color} prop at ${$$props.propData.location} (endsWithBeta: ${endsWithBeta()})`);

		if ($.strict_equals($$props.propData.location, "w") || $.strict_equals($$props.propData.location, "west")) {
			console.log(...$.log_if_contains_state('log', `\u{1F527} [G DEBUG] Beta offset calculation for ${$$props.propData.color} prop:`, {
				location: $$props.propData.location,
				orientation: $$props.propData.orientation,
				rotationDirection: $$props.propData.rotationDirection,

				motionData: $$props.motionData
					? {
						startLocation: $$props.motionData.startLocation,
						endLocation: $$props.motionData.endLocation,
						endOrientation: $$props.motionData.endOrientation,
						rotationDirection: $$props.motionData.rotationDirection
					}
					: "NO_MOTION_DATA",

				allProps: allProps().map((p) => ({
					color: p.color,
					location: p.location,
					orientation: p.orientation
				})),

				endsWithBeta: endsWithBeta(),
				expectedDirection: "Should be UP/DOWN for West location with IN orientation"
			}));
		}

		try {
			const redProp = allProps().find((p) => $.strict_equals(p.color, MotionColor.RED));
			const blueProp = allProps().find((p) => $.strict_equals(p.color, MotionColor.BLUE));

			const redMotion = {
				motionType: MotionType.STATIC,
				rotationDirection: RotationDirection.CLOCKWISE,
				startLocation: redProp?.location || Location.SOUTH,
				endLocation: redProp?.location || Location.SOUTH,
				turns: 0,
				startOrientation: Orientation.IN,
				endOrientation: Orientation.IN,
				isVisible: true
			};

			const blueMotion = {
				motionType: MotionType.STATIC,
				rotationDirection: RotationDirection.CLOCKWISE,
				startLocation: blueProp?.location || Location.SOUTH,
				endLocation: blueProp?.location || Location.SOUTH,
				turns: 0,
				startOrientation: Orientation.IN,
				endOrientation: Orientation.IN,
				isVisible: true
			};

			const directionCalculator = new BetaPropDirectionCalculator({ red: redMotion, blue: blueMotion });
			const direction = directionCalculator.getDirection($$props.propData);

			if ($.strict_equals($$props.propData.location, "w") || $.strict_equals($$props.propData.location, "west")) {
				console.log(...$.log_if_contains_state('log', `\u{1F527} [G DEBUG] Direction calculation result:`, {
					propColor: $$props.propData.color,
					calculatedDirection: direction,
					expectedDirection: "UP or DOWN",

					redMotion: {
						startLocation: redMotion.startLocation,
						endLocation: redMotion.endLocation,
						endOrientation: redMotion.endOrientation
					},

					blueMotion: {
						startLocation: blueMotion.startLocation,
						endLocation: blueMotion.endLocation,
						endOrientation: blueMotion.endOrientation
					}
				}));
			}

			if (!direction) {
				console.log(`\u26A0\uFE0F No direction calculated, using fallback for ${$$props.propData.color}`);

				return $.strict_equals($$props.propData.color, "blue") ? { x: -25, y: 0 } : { x: 25, y: 0 };
			}

			const offsetCalculator = new BetaOffsetCalculator();
			const basePosition = { x: 0, y: 0 };
			const newPosition = offsetCalculator.calculateNewPositionWithOffset(basePosition, direction);

			if ($.strict_equals($$props.propData.location, "w") || $.strict_equals($$props.propData.location, "west")) {
				console.log(...$.log_if_contains_state('log', `\u{1F527} [G DEBUG] Final offset calculation:`, {
					propColor: $$props.propData.color,
					direction,
					calculatedOffset: { x: newPosition.x, y: newPosition.y },

					expectedOffset: direction?.includes("UP")
						? "negative Y"
						: direction?.includes("DOWN") ? "positive Y" : "unknown"
				}));
			}

			return { x: newPosition.x, y: newPosition.y };
		} catch(error2) {
			console.error(...$.log_if_contains_state('error', "Error in beta direction calculation:", error2));

			return $.strict_equals($$props.propData.color, "blue") ? { x: -25, y: 0 } : { x: 25, y: 0 };
		}
	}

	const rotation = $.tag(
		$.derived(() => () => {
			if (!$$props.propData) return 0;

			const location = $$props.propData.location || $$props.motionData?.endLocation;
			const propOrientation = $$props.propData.orientation || "in";
			let orientation;

			switch (propOrientation) {
				case "in":
					orientation = Orientation.IN;
					break;

				case "out":
					orientation = Orientation.OUT;
					break;

				case "clock":
					orientation = Orientation.CLOCK;
					break;

				case "counter":
					orientation = Orientation.COUNTER;
					break;

				default:
					orientation = Orientation.IN;
			}

			const calculatedRotation = PropRotAngleManager.calculateRotation(location, orientation);

			return calculatedRotation;
		}),
		'rotation'
	);

	const parsePropSvg = (svgText) => {
		const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
		const svg = doc.documentElement;
		const viewBoxValues = svg.getAttribute("viewBox")?.split(/\s+/) || ["0", "0", "252.8", "77.8"];

		const viewBox = {
			width: parseFloat(viewBoxValues[2] || "252.8") || 252.8,
			height: parseFloat(viewBoxValues[3] || "77.8") || 77.8
		};

		let center = { x: viewBox.width / 2, y: viewBox.height / 2 };

		try {
			const centerElement = doc.getElementById("centerPoint");

			if (centerElement) {
				center = {
					x: parseFloat(centerElement.getAttribute("cx") || "0") || center.x,
					y: parseFloat(centerElement.getAttribute("cy") || "0") || center.y
				};
			}
		} catch {}

		return { viewBox, center };
	};

	const applyColorToSvg = (svgText, color) => {
		const colorMap = /* @__PURE__ */ new Map([[MotionColor.BLUE, "#2E3192"], [MotionColor.RED, "#ED1C24"]]);
		const targetColor = colorMap.get(color) || "#2E3192";
		let coloredSvg = svgText.replace(/fill="#[0-9A-Fa-f]{6}"/g, `fill="${targetColor}"`);

		coloredSvg = coloredSvg.replace(/fill:\s*#[0-9A-Fa-f]{6}/g, `fill:${targetColor}`);
		coloredSvg = coloredSvg.replace(/<circle[^>]*id="centerPoint"[^>]*\/?>/, "");

		return coloredSvg;
	};

	const loadSvg = async () => {
		try {
			if (!$$props.propData) throw new Error("No prop data available");

			const response = (await $.track_reactivity_loss(fetch(`/images/props/${$$props.propData.propType}.svg`)))();

			if (!response.ok) throw new Error("Failed to fetch SVG");

			const originalSvgText = (await $.track_reactivity_loss(response.text()))();
			const { viewBox, center } = parsePropSvg(originalSvgText);
			const coloredSvgText = applyColorToSvg(originalSvgText, $$props.propData.color);

			$.set(
				svgData,
				{
					imageSrc: `data:image/svg+xml;base64,${btoa(coloredSvgText)}`,
					viewBox,
					center
				},
				true
			);

			$.set(loaded, true);
			$$props.onLoaded?.(`${$$props.propData?.color}-prop`);
		} catch(e) {
			$.set(error, `Failed to load prop SVG: ${e}`);
			$$props.onError?.(`${$$props.propData?.color}-prop`, $.get(error));
			$.set(loaded, true);
		}
	};

	onMount(() => {
		loadSvg();
	});

	var g = root();
	let classes;
	var node = $.child(g);

	{
		var consequent = ($$anchor) => {
			var fragment = root_1();

			$.next();
			$.append($$anchor, fragment);
		};

		var alternate_1 = ($$anchor) => {
			var fragment_1 = $.comment();
			var node_1 = $.first_child(fragment_1);

			{
				var consequent_1 = ($$anchor) => {
					var fragment_2 = root_3();
					var rect = $.first_child(fragment_2);

					$.next();
					$.template_effect(() => $.set_attribute(rect, 'fill', $.strict_equals($$props.propData?.color, "blue") ? "#2E3192" : "#ED1C24"));
					$.append($$anchor, fragment_2);
				};

				var alternate = ($$anchor) => {
					var image = root_4();

					$.template_effect(
						($0, $1, $2) => {
							$.set_attribute(image, 'href', $.get(svgData).imageSrc);

							$.set_attribute(image, 'transform', `
				translate(${$0 ?? ''}, ${$1 ?? ''})
				rotate(${$2 ?? ''})
				translate(${-$.get(svgData).center.x}, ${-$.get(svgData).center.y})
			`);

							$.set_attribute(image, 'width', $.get(svgData).viewBox.width);
							$.set_attribute(image, 'height', $.get(svgData).viewBox.height);
						},
						[
							() => $.get(position)().x,
							() => $.get(position)().y,
							() => $.get(rotation)()
						]
					);

					$.event('error', image, () => {
						$.set(error, "Failed to load prop SVG");
						$$props.onError?.(`${$$props.propData?.color}-prop`, $.get(error));
					});

					$.append($$anchor, image);
				};

				$.add_svelte_meta(
					() => $.if(
						node_1,
						($$render) => {
							if (!$.get(loaded) || !$.get(svgData)) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					),
					'if',
					Prop,
					273,
					2
				);
			}

			$.append($$anchor, fragment_1);
		};

		$.add_svelte_meta(
			() => $.if(node, ($$render) => {
				if ($.get(error)) $$render(consequent); else $$render(alternate_1, false);
			}),
			'if',
			Prop,
			261,
			2
		);
	}

	$.reset(g);
	$.bind_this(g, ($$value) => $.set(_propElement, $$value), () => $.get(_propElement));

	$.template_effect(
		($0) => {
			classes = $.set_class(g, 0, `prop-group ${$$props.propData?.color ?? ''}-prop`, 's-SUZ92of2eZx8', classes, $0);
			$.set_attribute(g, 'data-prop-color', $$props.propData?.color);
			$.set_attribute(g, 'data-prop-type', $$props.propData?.propType);
			$.set_attribute(g, 'data-location', $$props.propData?.location);
		},
		[() => ({ loaded: $.get(loaded) })]
	);

	$.append($$anchor, g);

	return $.pop({ ...$.legacy_api() });
}

if (import.meta.hot) {
	Prop = $.hmr(Prop, () => Prop[$.HMR].source);

	import.meta.hot.acceptExports(["default"],(module) => {
		$.cleanup_styles('s-SUZ92of2eZx8');
		module.default[$.HMR].source = Prop[$.HMR].source;
		$.set(Prop[$.HMR].source, module.default[$.HMR].original);
	});
}

export default Prop;
import "/src/lib/components/pictograph/Prop.svelte?svelte&type=style&lang.css";

//# sourceMappingURL=data:application/json;base64,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OztTQUdVLGlEQUFZO1dBQ3RCO1NBR00saUJBQU07OztJQUVaOztLQUNLIiwibmFtZXMiOlsiZXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiUHJvcC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPCEtLVxuUHJvcCBDb21wb25lbnQgLSBSZW5kZXJzIFNWRyBwcm9wcyB3aXRoIHByb3BlciBwb3NpdGlvbmluZ1xuLS0+XG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICBpbXBvcnQgdHlwZSB7IE1vdGlvbkRhdGEsIFByb3BEYXRhIH0gZnJvbSBcIiRsaWIvZG9tYWluXCI7XG4gIGltcG9ydCB7XG4gICAgTG9jYXRpb24sXG4gICAgTW90aW9uVHlwZSxcbiAgICBPcmllbnRhdGlvbixcbiAgICBSb3RhdGlvbkRpcmVjdGlvbixcbiAgICBNb3Rpb25Db2xvcixcbiAgfSBmcm9tIFwiJGxpYi9kb21haW4vZW51bXNcIjtcbiAgaW1wb3J0IHsgRGVmYXVsdFByb3BQb3NpdGlvbmVyIH0gZnJvbSBcIiRsaWIvc2VydmljZXMvRGVmYXVsdFByb3BQb3NpdGlvbmVyXCI7XG4gIGltcG9ydCB7IFByb3BSb3RBbmdsZU1hbmFnZXIgfSBmcm9tIFwiJGxpYi9zZXJ2aWNlcy9Qcm9wUm90QW5nbGVNYW5hZ2VyXCI7XG4gIGltcG9ydCB7IEJldGFPZmZzZXRDYWxjdWxhdG9yIH0gZnJvbSBcIiRsaWIvc2VydmljZXMvaW1wbGVtZW50YXRpb25zL3Bvc2l0aW9uaW5nL0JldGFPZmZzZXRDYWxjdWxhdG9yXCI7XG4gIGltcG9ydCB7IEJldGFQcm9wRGlyZWN0aW9uQ2FsY3VsYXRvciB9IGZyb20gXCIkbGliL3NlcnZpY2VzL2ltcGxlbWVudGF0aW9ucy9wb3NpdGlvbmluZy9CZXRhUHJvcERpcmVjdGlvbkNhbGN1bGF0b3JcIjtcbiAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICBpbnRlcmZhY2UgUHJvcHMge1xuICAgIHByb3BEYXRhOiBQcm9wRGF0YTtcbiAgICBtb3Rpb25EYXRhPzogTW90aW9uRGF0YTtcbiAgICBncmlkTW9kZT86IHN0cmluZztcbiAgICBhbGxQcm9wcz86IFByb3BEYXRhW107XG4gICAgZW5kc1dpdGhCZXRhPzogYm9vbGVhbjsgLy8gTkVXOiBJbmRpY2F0ZXMgaWYgdGhpcyBwaWN0b2dyYXBoIGFjdHVhbGx5IGVuZHMgd2l0aCBiZXRhXG4gICAgb25Mb2FkZWQ/OiAoY29tcG9uZW50VHlwZTogc3RyaW5nKSA9PiB2b2lkO1xuICAgIG9uRXJyb3I/OiAoY29tcG9uZW50VHlwZTogc3RyaW5nLCBlcnJvcjogc3RyaW5nKSA9PiB2b2lkO1xuICB9XG5cbiAgbGV0IHtcbiAgICBwcm9wRGF0YSxcbiAgICBtb3Rpb25EYXRhLFxuICAgIGdyaWRNb2RlID0gXCJkaWFtb25kXCIsXG4gICAgYWxsUHJvcHMgPSBbXSxcbiAgICBlbmRzV2l0aEJldGEgPSBmYWxzZSwgLy8gTkVXOiBEZWZhdWx0IHRvIGZhbHNlXG4gICAgb25Mb2FkZWQsXG4gICAgb25FcnJvcixcbiAgfTogUHJvcHMgPSAkcHJvcHMoKTtcblxuICAvLyBQcm9wIGVsZW1lbnQgdXNlZCBpbiBiaW5kOnRoaXNcbiAgbGV0IF9wcm9wRWxlbWVudCA9ICRzdGF0ZTxTVkdHRWxlbWVudCB8IG51bGw+KG51bGwpO1xuICBsZXQgbG9hZGVkID0gJHN0YXRlKGZhbHNlKTtcbiAgbGV0IGVycm9yID0gJHN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBsZXQgc3ZnRGF0YSA9ICRzdGF0ZTx7XG4gICAgaW1hZ2VTcmM6IHN0cmluZztcbiAgICB2aWV3Qm94OiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH07XG4gICAgY2VudGVyOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG4gIH0gfCBudWxsPihudWxsKTtcblxuICAvLyBDYWxjdWxhdGUgcG9zaXRpb24gdXNpbmcgRGVmYXVsdFByb3BQb3NpdGlvbmVyIGZvciBjb25zaXN0ZW5jeSB3aXRoIGxlZ2FjeVxuICBjb25zdCBwb3NpdGlvbiA9ICRkZXJpdmVkKCgpID0+IHtcbiAgICBpZiAoIXByb3BEYXRhKSByZXR1cm4geyB4OiA0NzUsIHk6IDQ3NSB9O1xuXG4gICAgLy8gUHJvcHMgdXNlIHRoZWlyIE9XTiBsb2NhdGlvbiwgbm90IG1vdGlvbiBlbmQgbG9jYXRpb25cbiAgICAvLyBUaGlzIGlzIGNyaXRpY2FsIC0gUHJvcFBsYWNlbWVudE1hbmFnZXIgc2V0cyBwcm9wLmxvY2F0aW9uIHdoaWNoIG1heSBkaWZmZXIgZnJvbSBtb3Rpb24uZW5kTG9jYXRpb25cbiAgICBjb25zdCBsb2NhdGlvbiA9IHByb3BEYXRhLmxvY2F0aW9uIHx8IG1vdGlvbkRhdGE/LmVuZExvY2F0aW9uO1xuXG4gICAgLy8gVXNlIERlZmF1bHRQcm9wUG9zaXRpb25lciBmb3IgY29uc2lzdGVudCBwb3NpdGlvbmluZ1xuICAgIGNvbnN0IGJhc2VQb3NpdGlvbiA9IERlZmF1bHRQcm9wUG9zaXRpb25lci5jYWxjdWxhdGVQb3NpdGlvbihcbiAgICAgIGxvY2F0aW9uIGFzIHN0cmluZyxcbiAgICAgIGdyaWRNb2RlXG4gICAgKTtcblxuICAgIC8vIEFwcGx5IGJldGEgYWRqdXN0bWVudCBpZiBuZWVkZWQgKHdoZW4gcHJvcHMgYXJlIGF0IHNhbWUgbG9jYXRpb24pXG4gICAgY29uc3QgYmV0YU9mZnNldCA9IGNhbGN1bGF0ZUJldGFPZmZzZXQoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiBiYXNlUG9zaXRpb24ueCArIGJldGFPZmZzZXQueCxcbiAgICAgIHk6IGJhc2VQb3NpdGlvbi55ICsgYmV0YU9mZnNldC55LFxuICAgIH07XG4gIH0pO1xuXG4gIC8vIENhbGN1bGF0ZSBiZXRhIGFkanVzdG1lbnQgb2Zmc2V0IGZvciBwcm9wIHNlcGFyYXRpb24gdXNpbmcgbGVnYWN5IGRpcmVjdGlvbiBsb2dpY1xuICBmdW5jdGlvbiBjYWxjdWxhdGVCZXRhT2Zmc2V0KCk6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB7XG4gICAgLy8gQ1JJVElDQUwgRklYOiBPbmx5IGFwcGx5IGJldGEgb2Zmc2V0IGlmIHRoZSBwaWN0b2dyYXBoIGFjdHVhbGx5IGVuZHMgd2l0aCBiZXRhXG4gICAgaWYgKCFlbmRzV2l0aEJldGEpIHtcbiAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXByb3BEYXRhIHx8ICFhbGxQcm9wcyB8fCBhbGxQcm9wcy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbm90aGVyIHByb3AgYXQgdGhlIHNhbWUgbG9jYXRpb25cbiAgICBjb25zdCBvdGhlclByb3AgPSBhbGxQcm9wcy5maW5kKFxuICAgICAgKHApID0+IHAuY29sb3IgIT09IHByb3BEYXRhLmNvbG9yICYmIHAubG9jYXRpb24gPT09IHByb3BEYXRhLmxvY2F0aW9uXG4gICAgKTtcblxuICAgIGlmICghb3RoZXJQcm9wKSB7XG4gICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coXG4gICAgICBg8J+UpyBBcHBseWluZyBiZXRhIG9mZnNldCBmb3IgJHtwcm9wRGF0YS5jb2xvcn0gcHJvcCBhdCAke3Byb3BEYXRhLmxvY2F0aW9ufSAoZW5kc1dpdGhCZXRhOiAke2VuZHNXaXRoQmV0YX0pYFxuICAgICk7XG5cbiAgICAvLyBERUJVRzogTG9nIGZvciBHIHBpY3RvZ3JhcGggY2FzZSB3aXRoIGJvdGggcHJvcHMgYXQgV2VzdFxuICAgIGlmIChwcm9wRGF0YS5sb2NhdGlvbiA9PT0gXCJ3XCIgfHwgcHJvcERhdGEubG9jYXRpb24gPT09IFwid2VzdFwiKSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYPCflKcgW0cgREVCVUddIEJldGEgb2Zmc2V0IGNhbGN1bGF0aW9uIGZvciAke3Byb3BEYXRhLmNvbG9yfSBwcm9wOmAsXG4gICAgICAgIHtcbiAgICAgICAgICBsb2NhdGlvbjogcHJvcERhdGEubG9jYXRpb24sXG4gICAgICAgICAgb3JpZW50YXRpb246IHByb3BEYXRhLm9yaWVudGF0aW9uLFxuICAgICAgICAgIHJvdGF0aW9uRGlyZWN0aW9uOiBwcm9wRGF0YS5yb3RhdGlvbkRpcmVjdGlvbixcbiAgICAgICAgICBtb3Rpb25EYXRhOiBtb3Rpb25EYXRhXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBtb3Rpb25EYXRhLnN0YXJ0TG9jYXRpb24sXG4gICAgICAgICAgICAgICAgZW5kTG9jYXRpb246IG1vdGlvbkRhdGEuZW5kTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgZW5kT3JpZW50YXRpb246IG1vdGlvbkRhdGEuZW5kT3JpZW50YXRpb24sXG4gICAgICAgICAgICAgICAgcm90YXRpb25EaXJlY3Rpb246IG1vdGlvbkRhdGEucm90YXRpb25EaXJlY3Rpb24sXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogXCJOT19NT1RJT05fREFUQVwiLFxuICAgICAgICAgIGFsbFByb3BzOiBhbGxQcm9wcy5tYXAoKHApID0+ICh7XG4gICAgICAgICAgICBjb2xvcjogcC5jb2xvcixcbiAgICAgICAgICAgIGxvY2F0aW9uOiBwLmxvY2F0aW9uLFxuICAgICAgICAgICAgb3JpZW50YXRpb246IHAub3JpZW50YXRpb24sXG4gICAgICAgICAgfSkpLFxuICAgICAgICAgIGVuZHNXaXRoQmV0YSxcbiAgICAgICAgICBleHBlY3RlZERpcmVjdGlvbjpcbiAgICAgICAgICAgIFwiU2hvdWxkIGJlIFVQL0RPV04gZm9yIFdlc3QgbG9jYXRpb24gd2l0aCBJTiBvcmllbnRhdGlvblwiLFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFVzZSBsZWdhY3kgZGlyZWN0aW9uIGNhbGN1bGF0b3IgbG9naWMgZm9yIHByb3BlciBiZXRhIHBvc2l0aW9uaW5nXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBtb3Rpb24gZGF0YSBmb3IgYm90aCBwcm9wcyAtIHVzZSB0aGUgbW90aW9uRGF0YSBwcm9wIHBhc3NlZCB0byBjb21wb25lbnRcbiAgICAgIGNvbnN0IHJlZFByb3AgPSBhbGxQcm9wcy5maW5kKChwKSA9PiBwLmNvbG9yID09PSBNb3Rpb25Db2xvci5SRUQpO1xuICAgICAgY29uc3QgYmx1ZVByb3AgPSBhbGxQcm9wcy5maW5kKChwKSA9PiBwLmNvbG9yID09PSBNb3Rpb25Db2xvci5CTFVFKTtcblxuICAgICAgLy8gRm9yIHN0YXJ0IHBvc2l0aW9ucywgd2UgbmVlZCB0byBjb25zdHJ1Y3QgbW90aW9uIGRhdGEgZnJvbSBwcm9wIGRhdGFcbiAgICAgIC8vIFNpbmNlIHN0YXJ0IHBvc2l0aW9ucyBhcmUgc3RhdGljLCB3ZSBjYW4gdXNlIHRoZSBwcm9wIGxvY2F0aW9uIGFzIGJvdGggc3RhcnQgYW5kIGVuZFxuICAgICAgY29uc3QgcmVkTW90aW9uOiBNb3Rpb25EYXRhID0ge1xuICAgICAgICBtb3Rpb25UeXBlOiBNb3Rpb25UeXBlLlNUQVRJQyxcbiAgICAgICAgcm90YXRpb25EaXJlY3Rpb246IFJvdGF0aW9uRGlyZWN0aW9uLkNMT0NLV0lTRSxcbiAgICAgICAgc3RhcnRMb2NhdGlvbjogKHJlZFByb3A/LmxvY2F0aW9uIGFzIExvY2F0aW9uKSB8fCBMb2NhdGlvbi5TT1VUSCxcbiAgICAgICAgZW5kTG9jYXRpb246IChyZWRQcm9wPy5sb2NhdGlvbiBhcyBMb2NhdGlvbikgfHwgTG9jYXRpb24uU09VVEgsXG4gICAgICAgIHR1cm5zOiAwLFxuICAgICAgICBzdGFydE9yaWVudGF0aW9uOiBPcmllbnRhdGlvbi5JTixcbiAgICAgICAgZW5kT3JpZW50YXRpb246IE9yaWVudGF0aW9uLklOLFxuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBibHVlTW90aW9uOiBNb3Rpb25EYXRhID0ge1xuICAgICAgICBtb3Rpb25UeXBlOiBNb3Rpb25UeXBlLlNUQVRJQyxcbiAgICAgICAgcm90YXRpb25EaXJlY3Rpb246IFJvdGF0aW9uRGlyZWN0aW9uLkNMT0NLV0lTRSxcbiAgICAgICAgc3RhcnRMb2NhdGlvbjogKGJsdWVQcm9wPy5sb2NhdGlvbiBhcyBMb2NhdGlvbikgfHwgTG9jYXRpb24uU09VVEgsXG4gICAgICAgIGVuZExvY2F0aW9uOiAoYmx1ZVByb3A/LmxvY2F0aW9uIGFzIExvY2F0aW9uKSB8fCBMb2NhdGlvbi5TT1VUSCxcbiAgICAgICAgdHVybnM6IDAsXG4gICAgICAgIHN0YXJ0T3JpZW50YXRpb246IE9yaWVudGF0aW9uLklOLFxuICAgICAgICBlbmRPcmllbnRhdGlvbjogT3JpZW50YXRpb24uSU4sXG4gICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgIH07XG5cbiAgICAgIC8vIENyZWF0ZSBkaXJlY3Rpb24gY2FsY3VsYXRvclxuICAgICAgY29uc3QgZGlyZWN0aW9uQ2FsY3VsYXRvciA9IG5ldyBCZXRhUHJvcERpcmVjdGlvbkNhbGN1bGF0b3Ioe1xuICAgICAgICByZWQ6IHJlZE1vdGlvbixcbiAgICAgICAgYmx1ZTogYmx1ZU1vdGlvbixcbiAgICAgIH0pO1xuXG4gICAgICAvLyBHZXQgZGlyZWN0aW9uIGZvciB0aGlzIHByb3BcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGRpcmVjdGlvbkNhbGN1bGF0b3IuZ2V0RGlyZWN0aW9uKHByb3BEYXRhKTtcblxuICAgICAgLy8gREVCVUc6IExvZyBkaXJlY3Rpb24gY2FsY3VsYXRpb24gZm9yIFdlc3QgcHJvcHNcbiAgICAgIGlmIChwcm9wRGF0YS5sb2NhdGlvbiA9PT0gXCJ3XCIgfHwgcHJvcERhdGEubG9jYXRpb24gPT09IFwid2VzdFwiKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SnIFtHIERFQlVHXSBEaXJlY3Rpb24gY2FsY3VsYXRpb24gcmVzdWx0OmAsIHtcbiAgICAgICAgICBwcm9wQ29sb3I6IHByb3BEYXRhLmNvbG9yLFxuICAgICAgICAgIGNhbGN1bGF0ZWREaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgICAgICBleHBlY3RlZERpcmVjdGlvbjogXCJVUCBvciBET1dOXCIsXG4gICAgICAgICAgcmVkTW90aW9uOiB7XG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiByZWRNb3Rpb24uc3RhcnRMb2NhdGlvbixcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiByZWRNb3Rpb24uZW5kTG9jYXRpb24sXG4gICAgICAgICAgICBlbmRPcmllbnRhdGlvbjogcmVkTW90aW9uLmVuZE9yaWVudGF0aW9uLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmx1ZU1vdGlvbjoge1xuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYmx1ZU1vdGlvbi5zdGFydExvY2F0aW9uLFxuICAgICAgICAgICAgZW5kTG9jYXRpb246IGJsdWVNb3Rpb24uZW5kTG9jYXRpb24sXG4gICAgICAgICAgICBlbmRPcmllbnRhdGlvbjogYmx1ZU1vdGlvbi5lbmRPcmllbnRhdGlvbixcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYOKaoO+4jyBObyBkaXJlY3Rpb24gY2FsY3VsYXRlZCwgdXNpbmcgZmFsbGJhY2sgZm9yICR7cHJvcERhdGEuY29sb3J9YFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcHJvcERhdGEuY29sb3IgPT09IFwiYmx1ZVwiID8geyB4OiAtMjUsIHk6IDAgfSA6IHsgeDogMjUsIHk6IDAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIG9mZnNldCB1c2luZyBkaXJlY3Rpb25cbiAgICAgIGNvbnN0IG9mZnNldENhbGN1bGF0b3IgPSBuZXcgQmV0YU9mZnNldENhbGN1bGF0b3IoKTtcbiAgICAgIGNvbnN0IGJhc2VQb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9OyAvLyBXZSBvbmx5IHdhbnQgdGhlIG9mZnNldCwgbm90IGFic29sdXRlIHBvc2l0aW9uXG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiA9IG9mZnNldENhbGN1bGF0b3IuY2FsY3VsYXRlTmV3UG9zaXRpb25XaXRoT2Zmc2V0KFxuICAgICAgICBiYXNlUG9zaXRpb24sXG4gICAgICAgIGRpcmVjdGlvblxuICAgICAgKTtcblxuICAgICAgLy8gREVCVUc6IExvZyBmaW5hbCBvZmZzZXQgY2FsY3VsYXRpb24gZm9yIFdlc3QgcHJvcHNcbiAgICAgIGlmIChwcm9wRGF0YS5sb2NhdGlvbiA9PT0gXCJ3XCIgfHwgcHJvcERhdGEubG9jYXRpb24gPT09IFwid2VzdFwiKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SnIFtHIERFQlVHXSBGaW5hbCBvZmZzZXQgY2FsY3VsYXRpb246YCwge1xuICAgICAgICAgIHByb3BDb2xvcjogcHJvcERhdGEuY29sb3IsXG4gICAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICAgIGNhbGN1bGF0ZWRPZmZzZXQ6IHsgeDogbmV3UG9zaXRpb24ueCwgeTogbmV3UG9zaXRpb24ueSB9LFxuICAgICAgICAgIGV4cGVjdGVkT2Zmc2V0OiBkaXJlY3Rpb24/LmluY2x1ZGVzKFwiVVBcIilcbiAgICAgICAgICAgID8gXCJuZWdhdGl2ZSBZXCJcbiAgICAgICAgICAgIDogZGlyZWN0aW9uPy5pbmNsdWRlcyhcIkRPV05cIilcbiAgICAgICAgICAgICAgPyBcInBvc2l0aXZlIFlcIlxuICAgICAgICAgICAgICA6IFwidW5rbm93blwiLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgeDogbmV3UG9zaXRpb24ueCwgeTogbmV3UG9zaXRpb24ueSB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gYmV0YSBkaXJlY3Rpb24gY2FsY3VsYXRpb246XCIsIGVycm9yKTtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIHNpbXBsZSBsZWZ0L3JpZ2h0IHNlcGFyYXRpb25cbiAgICAgIHJldHVybiBwcm9wRGF0YS5jb2xvciA9PT0gXCJibHVlXCIgPyB7IHg6IC0yNSwgeTogMCB9IDogeyB4OiAyNSwgeTogMCB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSByb3RhdGlvbiB1c2luZyBQcm9wUm90QW5nbGVNYW5hZ2VyIGZvciBjb25zaXN0ZW5jeSB3aXRoIGxlZ2FjeVxuICBjb25zdCByb3RhdGlvbiA9ICRkZXJpdmVkKCgpID0+IHtcbiAgICBpZiAoIXByb3BEYXRhKSByZXR1cm4gMDtcblxuICAgIGNvbnN0IGxvY2F0aW9uID0gcHJvcERhdGEubG9jYXRpb24gfHwgbW90aW9uRGF0YT8uZW5kTG9jYXRpb247XG4gICAgLy8gVXNlIHByb3AncyBvd24gb3JpZW50YXRpb24gaW5zdGVhZCBvZiBtb3Rpb24ncyBlbmQgb3JpZW50YXRpb25cbiAgICBjb25zdCBwcm9wT3JpZW50YXRpb24gPSBwcm9wRGF0YS5vcmllbnRhdGlvbiB8fCBcImluXCI7XG5cbiAgICAvLyBDb252ZXJ0IHN0cmluZyBvcmllbnRhdGlvbiB0byBlbnVtXG4gICAgbGV0IG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbjtcbiAgICBzd2l0Y2ggKHByb3BPcmllbnRhdGlvbikge1xuICAgICAgY2FzZSBcImluXCI6XG4gICAgICAgIG9yaWVudGF0aW9uID0gT3JpZW50YXRpb24uSU47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm91dFwiOlxuICAgICAgICBvcmllbnRhdGlvbiA9IE9yaWVudGF0aW9uLk9VVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY2xvY2tcIjpcbiAgICAgICAgb3JpZW50YXRpb24gPSBPcmllbnRhdGlvbi5DTE9DSztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY291bnRlclwiOlxuICAgICAgICBvcmllbnRhdGlvbiA9IE9yaWVudGF0aW9uLkNPVU5URVI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgb3JpZW50YXRpb24gPSBPcmllbnRhdGlvbi5JTjtcbiAgICB9XG5cbiAgICBjb25zdCBjYWxjdWxhdGVkUm90YXRpb24gPSBQcm9wUm90QW5nbGVNYW5hZ2VyLmNhbGN1bGF0ZVJvdGF0aW9uKFxuICAgICAgbG9jYXRpb24gYXMgc3RyaW5nLFxuICAgICAgb3JpZW50YXRpb25cbiAgICApO1xuXG4gICAgcmV0dXJuIGNhbGN1bGF0ZWRSb3RhdGlvbjtcbiAgfSk7XG5cbiAgLy8gUGFyc2UgU1ZHIHRvIGdldCBwcm9wZXIgZGltZW5zaW9ucyBhbmQgY2VudGVyIHBvaW50XG4gIGNvbnN0IHBhcnNlUHJvcFN2ZyA9IChcbiAgICBzdmdUZXh0OiBzdHJpbmdcbiAgKToge1xuICAgIHZpZXdCb3g6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfTtcbiAgICBjZW50ZXI6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcbiAgfSA9PiB7XG4gICAgY29uc3QgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdmdUZXh0LCBcImltYWdlL3N2Zyt4bWxcIik7XG4gICAgY29uc3Qgc3ZnID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuICAgIC8vIEdldCB2aWV3Qm94IGRpbWVuc2lvbnNcbiAgICBjb25zdCB2aWV3Qm94VmFsdWVzID0gc3ZnLmdldEF0dHJpYnV0ZShcInZpZXdCb3hcIik/LnNwbGl0KC9cXHMrLykgfHwgW1xuICAgICAgXCIwXCIsXG4gICAgICBcIjBcIixcbiAgICAgIFwiMjUyLjhcIixcbiAgICAgIFwiNzcuOFwiLFxuICAgIF07XG4gICAgY29uc3Qgdmlld0JveCA9IHtcbiAgICAgIHdpZHRoOiBwYXJzZUZsb2F0KHZpZXdCb3hWYWx1ZXNbMl0gfHwgXCIyNTIuOFwiKSB8fCAyNTIuOCxcbiAgICAgIGhlaWdodDogcGFyc2VGbG9hdCh2aWV3Qm94VmFsdWVzWzNdIHx8IFwiNzcuOFwiKSB8fCA3Ny44LFxuICAgIH07XG5cbiAgICAvLyBHZXQgY2VudGVyIHBvaW50IGZyb20gU1ZHXG4gICAgbGV0IGNlbnRlciA9IHsgeDogdmlld0JveC53aWR0aCAvIDIsIHk6IHZpZXdCb3guaGVpZ2h0IC8gMiB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNlbnRlckVsZW1lbnQgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoXCJjZW50ZXJQb2ludFwiKTtcbiAgICAgIGlmIChjZW50ZXJFbGVtZW50KSB7XG4gICAgICAgIGNlbnRlciA9IHtcbiAgICAgICAgICB4OiBwYXJzZUZsb2F0KGNlbnRlckVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY3hcIikgfHwgXCIwXCIpIHx8IGNlbnRlci54LFxuICAgICAgICAgIHk6IHBhcnNlRmxvYXQoY2VudGVyRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjeVwiKSB8fCBcIjBcIikgfHwgY2VudGVyLnksXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBTVkcgY2VudGVyIGNhbGN1bGF0aW9uIGZhaWxlZCwgdXNpbmcgZGVmYXVsdCBjZW50ZXJcbiAgICB9XG5cbiAgICByZXR1cm4geyB2aWV3Qm94LCBjZW50ZXIgfTtcbiAgfTtcblxuICAvLyBBcHBseSBjb2xvciB0cmFuc2Zvcm1hdGlvbiB0byBTVkcgY29udGVudFxuICBjb25zdCBhcHBseUNvbG9yVG9TdmcgPSAoc3ZnVGV4dDogc3RyaW5nLCBjb2xvcjogTW90aW9uQ29sb3IpOiBzdHJpbmcgPT4ge1xuICAgIC8vIEF2b2lkIENTUyBwYXJzZXIgY29uZmxpY3RzIGJ5IHVzaW5nIGEgZGlmZmVyZW50IGFwcHJvYWNoXG4gICAgY29uc3QgY29sb3JNYXAgPSBuZXcgTWFwKFtcbiAgICAgIFtNb3Rpb25Db2xvci5CTFVFLCBcIiMyRTMxOTJcIl0sXG4gICAgICBbTW90aW9uQ29sb3IuUkVELCBcIiNFRDFDMjRcIl0sXG4gICAgXSk7XG5cbiAgICBjb25zdCB0YXJnZXRDb2xvciA9IGNvbG9yTWFwLmdldChjb2xvcikgfHwgXCIjMkUzMTkyXCI7XG5cbiAgICAvLyBVc2UgcmVnZXggcmVwbGFjZW1lbnQgdG8gY2hhbmdlIGZpbGwgY29sb3JzIGRpcmVjdGx5XG4gICAgbGV0IGNvbG9yZWRTdmcgPSBzdmdUZXh0LnJlcGxhY2UoXG4gICAgICAvZmlsbD1cIiNbMC05QS1GYS1mXXs2fVwiL2csXG4gICAgICBgZmlsbD1cIiR7dGFyZ2V0Q29sb3J9XCJgXG4gICAgKTtcbiAgICBjb2xvcmVkU3ZnID0gY29sb3JlZFN2Zy5yZXBsYWNlKFxuICAgICAgL2ZpbGw6XFxzKiNbMC05QS1GYS1mXXs2fS9nLFxuICAgICAgYGZpbGw6JHt0YXJnZXRDb2xvcn1gXG4gICAgKTtcblxuICAgIC8vIFJlbW92ZSB0aGUgY2VudGVyUG9pbnQgY2lyY2xlIGVudGlyZWx5IHRvIHByZXZlbnQgQ0lSQ0xFX1BST1AgZGV0ZWN0aW9uXG4gICAgY29sb3JlZFN2ZyA9IGNvbG9yZWRTdmcucmVwbGFjZShcbiAgICAgIC88Y2lyY2xlW14+XSppZD1cImNlbnRlclBvaW50XCJbXj5dKlxcLz8+LyxcbiAgICAgIFwiXCJcbiAgICApO1xuXG4gICAgcmV0dXJuIGNvbG9yZWRTdmc7XG4gIH07XG5cbiAgLy8gTG9hZCBTVkcgZGF0YVxuICBjb25zdCBsb2FkU3ZnID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXByb3BEYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm9wIGRhdGEgYXZhaWxhYmxlXCIpO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvaW1hZ2VzL3Byb3BzLyR7cHJvcERhdGEucHJvcFR5cGV9LnN2Z2ApO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIFNWR1wiKTtcblxuICAgICAgY29uc3Qgb3JpZ2luYWxTdmdUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgY29uc3QgeyB2aWV3Qm94LCBjZW50ZXIgfSA9IHBhcnNlUHJvcFN2ZyhvcmlnaW5hbFN2Z1RleHQpO1xuXG4gICAgICAvLyBBcHBseSBjb2xvciB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgU1ZHXG4gICAgICBjb25zdCBjb2xvcmVkU3ZnVGV4dCA9IGFwcGx5Q29sb3JUb1N2ZyhvcmlnaW5hbFN2Z1RleHQsIHByb3BEYXRhLmNvbG9yKTtcblxuICAgICAgc3ZnRGF0YSA9IHtcbiAgICAgICAgaW1hZ2VTcmM6IGBkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LCR7YnRvYShjb2xvcmVkU3ZnVGV4dCl9YCxcbiAgICAgICAgdmlld0JveCxcbiAgICAgICAgY2VudGVyLFxuICAgICAgfTtcblxuICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICAgIG9uTG9hZGVkPy4oYCR7cHJvcERhdGE/LmNvbG9yfS1wcm9wYCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IgPSBgRmFpbGVkIHRvIGxvYWQgcHJvcCBTVkc6ICR7ZX1gO1xuICAgICAgb25FcnJvcj8uKGAke3Byb3BEYXRhPy5jb2xvcn0tcHJvcGAsIGVycm9yKTtcbiAgICAgIC8vIFN0aWxsIG1hcmsgYXMgbG9hZGVkIHRvIHByZXZlbnQgYmxvY2tpbmdcbiAgICAgIGxvYWRlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIGxvYWRTdmcoKTtcbiAgfSk7XG48L3NjcmlwdD5cblxuPCEtLSBQcm9wIEdyb3VwIC0tPlxuPGdcbiAgYmluZDp0aGlzPXtfcHJvcEVsZW1lbnR9XG4gIGNsYXNzPVwicHJvcC1ncm91cCB7cHJvcERhdGE/LmNvbG9yfS1wcm9wXCJcbiAgY2xhc3M6bG9hZGVkXG4gIGRhdGEtcHJvcC1jb2xvcj17cHJvcERhdGE/LmNvbG9yfVxuICBkYXRhLXByb3AtdHlwZT17cHJvcERhdGE/LnByb3BUeXBlfVxuICBkYXRhLWxvY2F0aW9uPXtwcm9wRGF0YT8ubG9jYXRpb259XG4+XG4gIHsjaWYgZXJyb3J9XG4gICAgPCEtLSBFcnJvciBzdGF0ZSAtLT5cbiAgICA8cmVjdFxuICAgICAgeD1cIi0xNVwiXG4gICAgICB5PVwiLTE1XCJcbiAgICAgIHdpZHRoPVwiMzBcIlxuICAgICAgaGVpZ2h0PVwiMzBcIlxuICAgICAgZmlsbD1cInJlZFwiXG4gICAgICBvcGFjaXR5PVwiMC41XCJcbiAgICAgIHJ4PVwiM1wiXG4gICAgLz5cbiAgICA8dGV4dCB4PVwiMFwiIHk9XCI0XCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIiBmb250LXNpemU9XCI4XCIgZmlsbD1cIndoaXRlXCI+ITwvdGV4dD5cbiAgezplbHNlIGlmICFsb2FkZWQgfHwgIXN2Z0RhdGF9XG4gICAgPCEtLSBMb2FkaW5nIHN0YXRlIC0tPlxuICAgIDxyZWN0XG4gICAgICB4PVwiLTEyXCJcbiAgICAgIHk9XCItMTJcIlxuICAgICAgd2lkdGg9XCIyNFwiXG4gICAgICBoZWlnaHQ9XCIyNFwiXG4gICAgICBmaWxsPXtwcm9wRGF0YT8uY29sb3IgPT09IFwiYmx1ZVwiID8gXCIjMkUzMTkyXCIgOiBcIiNFRDFDMjRcIn1cbiAgICAgIG9wYWNpdHk9XCIwLjNcIlxuICAgICAgcng9XCIyXCJcbiAgICAvPlxuICAgIDxhbmltYXRlXG4gICAgICBhdHRyaWJ1dGVOYW1lPVwib3BhY2l0eVwiXG4gICAgICB2YWx1ZXM9XCIwLjM7MC44OzAuM1wiXG4gICAgICBkdXI9XCIxc1wiXG4gICAgICByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIlxuICAgIC8+XG4gIHs6ZWxzZX1cbiAgICA8IS0tIEFjdHVhbCBwcm9wIFNWRyB3aXRoIHByb3BlciBzaXppbmcgYW5kIGNlbnRlcmluZyAtLT5cbiAgICA8aW1hZ2VcbiAgICAgIGhyZWY9e3N2Z0RhdGEuaW1hZ2VTcmN9XG4gICAgICB0cmFuc2Zvcm09XCJcblx0XHRcdFx0dHJhbnNsYXRlKHtwb3NpdGlvbigpLnh9LCB7cG9zaXRpb24oKS55fSlcblx0XHRcdFx0cm90YXRlKHtyb3RhdGlvbigpfSlcblx0XHRcdFx0dHJhbnNsYXRlKHstc3ZnRGF0YS5jZW50ZXIueH0sIHstc3ZnRGF0YS5jZW50ZXIueX0pXG5cdFx0XHRcIlxuICAgICAgd2lkdGg9e3N2Z0RhdGEudmlld0JveC53aWR0aH1cbiAgICAgIGhlaWdodD17c3ZnRGF0YS52aWV3Qm94LmhlaWdodH1cbiAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCJcbiAgICAgIGNsYXNzPVwicHJvcC1zdmdcIlxuICAgICAgb25lcnJvcj17KCkgPT4ge1xuICAgICAgICBlcnJvciA9IFwiRmFpbGVkIHRvIGxvYWQgcHJvcCBTVkdcIjtcbiAgICAgICAgb25FcnJvcj8uKGAke3Byb3BEYXRhPy5jb2xvcn0tcHJvcGAsIGVycm9yKTtcbiAgICAgIH19XG4gICAgLz5cblxuICAgIDwhLS0gRGVidWcgaW5mbyBkaXNhYmxlZCB0byBwcmV2ZW50IENJUkNMRV9QUk9QIGR1cGxpY2F0ZXMgLS0+XG4gICAgPCEtLSBEZWJ1ZyBjaXJjbGVzIHdlcmUgY3JlYXRpbmcgZHVwbGljYXRlIENJUkNMRV9QUk9QIGVsZW1lbnRzIGluIGNvbXBhcmlzb24gdGVzdHMgLS0+XG4gICAgPCEtLSB7I2lmIGltcG9ydC5tZXRhLmVudi5ERVZ9XG5cdFx0XHQ8Y2lyY2xlIHI9XCIyXCIgZmlsbD1cImdyZWVuXCIgb3BhY2l0eT1cIjAuNVwiIGN4PXtwb3NpdGlvbigpLnh9IGN5PXtwb3NpdGlvbigpLnl9IC8+XG5cdFx0XHQ8dGV4dCB4PXtwb3NpdGlvbigpLnh9IHk9e3Bvc2l0aW9uKCkueSAtIDMwfSB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiIGZvbnQtc2l6ZT1cIjZcIiBmaWxsPVwiYmxhY2tcIj5cblx0XHRcdFx0e3Byb3BEYXRhPy5sb2NhdGlvbn1cblx0XHRcdDwvdGV4dD5cblx0XHR7L2lmfSAtLT5cbiAgey9pZn1cbjwvZz5cblxuPHN0eWxlPlxuICAucHJvcC1ncm91cCB7XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuMnMgZWFzZTtcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7XG4gIH1cblxuICAucHJvcC1ncm91cC5sb2FkZWQge1xuICAgIG9wYWNpdHk6IDE7XG4gIH1cblxuICAucHJvcC1zdmcge1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG5cbiAgLyogRW5zdXJlIHByb3BlciBsYXllcmluZyAqL1xuICAucHJvcC1ncm91cCB7XG4gICAgei1pbmRleDogMTtcbiAgfVxuPC9zdHlsZT5cbiJdLCJmaWxlIjoiRjovQ09ERS9US0Evd2ViL3NyYy9saWIvY29tcG9uZW50cy9waWN0b2dyYXBoL1Byb3Auc3ZlbHRlIn0=