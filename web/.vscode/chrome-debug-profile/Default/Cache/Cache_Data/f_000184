import { createHotContext as __vite__createHotContext } from "/@vite/client";import.meta.hot = __vite__createHotContext("/src/lib/components/pictograph/Prop.svelte");import "/node_modules/.vite/deps/svelte_internal_disclose-version.js?v=de368f3a";

Prop[$.FILENAME] = 'src/lib/components/pictograph/Prop.svelte';

import * as $ from "/node_modules/.vite/deps/svelte_internal_client.js?v=de368f3a";

import {
	Location,
	MotionType,
	Orientation,
	RotationDirection,
	MotionColor
} from "/src/lib/domain/enums.ts";

import { DefaultPropPositioner } from "/src/lib/services/DefaultPropPositioner.ts";
import { PropRotAngleManager } from "/src/lib/services/PropRotAngleManager.ts";
import { BetaOffsetCalculator } from "/src/lib/services/implementations/positioning/BetaOffsetCalculator.ts";
import { BetaPropDirectionCalculator } from "/src/lib/services/implementations/positioning/BetaPropDirectionCalculator.ts";
import { onMount } from "/node_modules/.vite/deps/svelte.js?v=de368f3a";

var root_1 = $.add_locations($.from_svg(`<rect x="-15" y="-15" width="30" height="30" fill="red" opacity="0.5" rx="3" class="s-SUZ92of2eZx8"></rect><text x="0" y="4" text-anchor="middle" font-size="8" fill="white" class="s-SUZ92of2eZx8">!</text>`, 1), Prop[$.FILENAME], [[264, 4], [273, 4]]);
var root_3 = $.add_locations($.from_svg(`<rect x="-12" y="-12" width="24" height="24" opacity="0.3" rx="2" class="s-SUZ92of2eZx8"></rect><animate attributeName="opacity" values="0.3;0.8;0.3" dur="1s" repeatCount="indefinite" class="s-SUZ92of2eZx8"></animate>`, 1), Prop[$.FILENAME], [[276, 4], [285, 4]]);
var root_4 = $.add_locations($.from_svg(`<image preserveAspectRatio="xMidYMid meet" class="prop-svg s-SUZ92of2eZx8"></image>`), Prop[$.FILENAME], [[293, 4]]);
var root = $.add_locations($.from_svg(`<g><!></g>`), Prop[$.FILENAME], [[254, 0]]);

function Prop($$anchor, $$props) {
	$.check_target(new.target);
	$.push($$props, true, Prop);

	let gridMode = $.prop($$props, 'gridMode', 3, "diamond"),
		allProps = $.prop($$props, 'allProps', 19, () => []),
		endsWithBeta = $.prop($$props, 'endsWithBeta', 3, false);

	// NEW: Default to false
	let _propElement = $.tag($.state(null), '_propElement');

	let loaded = $.tag($.state(false), 'loaded');
	let error = $.tag($.state(null), 'error');
	let svgData = $.tag($.state(null), 'svgData');

	const position = $.tag(
		$.derived(() => () => {
			if (!$$props.propData) return { x: 475, y: 475 };

			const location = $$props.propData.location || $$props.motionData?.endLocation;
			const basePosition = DefaultPropPositioner.calculatePosition(location, gridMode());
			const betaOffset = calculateBetaOffset();

			return {
				x: basePosition.x + betaOffset.x,
				y: basePosition.y + betaOffset.y
			};
		}),
		'position'
	);

	function calculateBetaOffset() {
		if (!endsWithBeta()) {
			return { x: 0, y: 0 };
		}

		if (!$$props.propData || !allProps() || allProps().length < 2) {
			return { x: 0, y: 0 };
		}

		const otherProp = allProps().find((p) => $.strict_equals(p.color, $$props.propData.color, false) && $.strict_equals(p.location, $$props.propData.location));

		if (!otherProp) {
			return { x: 0, y: 0 };
		}

		console.log(`\u{1F527} Applying beta offset for ${$$props.propData.color} prop at ${$$props.propData.location} (endsWithBeta: ${endsWithBeta()})`);

		debugger;

		if ($.strict_equals($$props.propData.location, "w") || $.strict_equals($$props.propData.location, "west")) {
			console.log(...$.log_if_contains_state('log', `\u{1F527} [G DEBUG] Beta offset calculation for ${$$props.propData.color} prop:`, {
				location: $$props.propData.location,
				orientation: $$props.propData.orientation,
				rotationDirection: $$props.propData.rotationDirection,

				motionData: $$props.motionData
					? {
						startLocation: $$props.motionData.startLocation,
						endLocation: $$props.motionData.endLocation,
						endOrientation: $$props.motionData.endOrientation,
						rotationDirection: $$props.motionData.rotationDirection
					}
					: "NO_MOTION_DATA",

				allProps: allProps().map((p) => ({
					color: p.color,
					location: p.location,
					orientation: p.orientation
				})),

				endsWithBeta: endsWithBeta(),
				expectedDirection: "Should be UP/DOWN for West location with IN orientation"
			}));
		}

		try {
			const redProp = allProps().find((p) => $.strict_equals(p.color, MotionColor.RED));
			const blueProp = allProps().find((p) => $.strict_equals(p.color, MotionColor.BLUE));

			const redMotion = {
				motionType: MotionType.STATIC,
				rotationDirection: RotationDirection.CLOCKWISE,
				startLocation: redProp?.location || Location.SOUTH,
				endLocation: redProp?.location || Location.SOUTH,
				turns: 0,
				startOrientation: Orientation.IN,
				endOrientation: Orientation.IN,
				isVisible: true
			};

			const blueMotion = {
				motionType: MotionType.STATIC,
				rotationDirection: RotationDirection.CLOCKWISE,
				startLocation: blueProp?.location || Location.SOUTH,
				endLocation: blueProp?.location || Location.SOUTH,
				turns: 0,
				startOrientation: Orientation.IN,
				endOrientation: Orientation.IN,
				isVisible: true
			};

			const directionCalculator = new BetaPropDirectionCalculator({ red: redMotion, blue: blueMotion });
			const direction = directionCalculator.getDirection($$props.propData);

			if ($.strict_equals($$props.propData.location, "w") || $.strict_equals($$props.propData.location, "west")) {
				console.log(...$.log_if_contains_state('log', `\u{1F527} [G DEBUG] Direction calculation result:`, {
					propColor: $$props.propData.color,
					calculatedDirection: direction,
					expectedDirection: "UP or DOWN",

					redMotion: {
						startLocation: redMotion.startLocation,
						endLocation: redMotion.endLocation,
						endOrientation: redMotion.endOrientation
					},

					blueMotion: {
						startLocation: blueMotion.startLocation,
						endLocation: blueMotion.endLocation,
						endOrientation: blueMotion.endOrientation
					}
				}));
			}

			if (!direction) {
				console.log(`\u26A0\uFE0F No direction calculated, using fallback for ${$$props.propData.color}`);

				return $.strict_equals($$props.propData.color, "blue") ? { x: -25, y: 0 } : { x: 25, y: 0 };
			}

			const offsetCalculator = new BetaOffsetCalculator();
			const basePosition = { x: 0, y: 0 };
			const newPosition = offsetCalculator.calculateNewPositionWithOffset(basePosition, direction);

			if ($.strict_equals($$props.propData.location, "w") || $.strict_equals($$props.propData.location, "west")) {
				console.log(...$.log_if_contains_state('log', `\u{1F527} [G DEBUG] Final offset calculation:`, {
					propColor: $$props.propData.color,
					direction,
					calculatedOffset: { x: newPosition.x, y: newPosition.y },

					expectedOffset: direction?.includes("UP")
						? "negative Y"
						: direction?.includes("DOWN") ? "positive Y" : "unknown"
				}));
			}

			return { x: newPosition.x, y: newPosition.y };
		} catch(error2) {
			console.error(...$.log_if_contains_state('error', "Error in beta direction calculation:", error2));

			return $.strict_equals($$props.propData.color, "blue") ? { x: -25, y: 0 } : { x: 25, y: 0 };
		}
	}

	const rotation = $.tag(
		$.derived(() => () => {
			if (!$$props.propData) return 0;

			const location = $$props.propData.location || $$props.motionData?.endLocation;
			const propOrientation = $$props.propData.orientation || "in";
			let orientation;

			switch (propOrientation) {
				case "in":
					orientation = Orientation.IN;
					break;

				case "out":
					orientation = Orientation.OUT;
					break;

				case "clock":
					orientation = Orientation.CLOCK;
					break;

				case "counter":
					orientation = Orientation.COUNTER;
					break;

				default:
					orientation = Orientation.IN;
			}

			const calculatedRotation = PropRotAngleManager.calculateRotation(location, orientation);

			return calculatedRotation;
		}),
		'rotation'
	);

	const parsePropSvg = (svgText) => {
		const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
		const svg = doc.documentElement;
		const viewBoxValues = svg.getAttribute("viewBox")?.split(/\s+/) || ["0", "0", "252.8", "77.8"];

		const viewBox = {
			width: parseFloat(viewBoxValues[2] || "252.8") || 252.8,
			height: parseFloat(viewBoxValues[3] || "77.8") || 77.8
		};

		let center = { x: viewBox.width / 2, y: viewBox.height / 2 };

		try {
			const centerElement = doc.getElementById("centerPoint");

			if (centerElement) {
				center = {
					x: parseFloat(centerElement.getAttribute("cx") || "0") || center.x,
					y: parseFloat(centerElement.getAttribute("cy") || "0") || center.y
				};
			}
		} catch {}

		return { viewBox, center };
	};

	const applyColorToSvg = (svgText, color) => {
		const colorMap = /* @__PURE__ */ new Map([[MotionColor.BLUE, "#2E3192"], [MotionColor.RED, "#ED1C24"]]);
		const targetColor = colorMap.get(color) || "#2E3192";
		let coloredSvg = svgText.replace(/fill="#[0-9A-Fa-f]{6}"/g, `fill="${targetColor}"`);

		coloredSvg = coloredSvg.replace(/fill:\s*#[0-9A-Fa-f]{6}/g, `fill:${targetColor}`);
		coloredSvg = coloredSvg.replace(/<circle[^>]*id="centerPoint"[^>]*\/?>/, "");

		return coloredSvg;
	};

	const loadSvg = async () => {
		try {
			if (!$$props.propData) throw new Error("No prop data available");

			const response = (await $.track_reactivity_loss(fetch(`/images/props/${$$props.propData.propType}.svg`)))();

			if (!response.ok) throw new Error("Failed to fetch SVG");

			const originalSvgText = (await $.track_reactivity_loss(response.text()))();
			const { viewBox, center } = parsePropSvg(originalSvgText);
			const coloredSvgText = applyColorToSvg(originalSvgText, $$props.propData.color);

			$.set(
				svgData,
				{
					imageSrc: `data:image/svg+xml;base64,${btoa(coloredSvgText)}`,
					viewBox,
					center
				},
				true
			);

			$.set(loaded, true);
			$$props.onLoaded?.(`${$$props.propData?.color}-prop`);
		} catch(e) {
			$.set(error, `Failed to load prop SVG: ${e}`);
			$$props.onError?.(`${$$props.propData?.color}-prop`, $.get(error));
			$.set(loaded, true);
		}
	};

	onMount(() => {
		loadSvg();
	});

	var g = root();
	let classes;
	var node = $.child(g);

	{
		var consequent = ($$anchor) => {
			var fragment = root_1();

			$.next();
			$.append($$anchor, fragment);
		};

		var alternate_1 = ($$anchor) => {
			var fragment_1 = $.comment();
			var node_1 = $.first_child(fragment_1);

			{
				var consequent_1 = ($$anchor) => {
					var fragment_2 = root_3();
					var rect = $.first_child(fragment_2);

					$.next();
					$.template_effect(() => $.set_attribute(rect, 'fill', $.strict_equals($$props.propData?.color, "blue") ? "#2E3192" : "#ED1C24"));
					$.append($$anchor, fragment_2);
				};

				var alternate = ($$anchor) => {
					var image = root_4();

					$.template_effect(
						($0, $1, $2) => {
							$.set_attribute(image, 'href', $.get(svgData).imageSrc);

							$.set_attribute(image, 'transform', `
				translate(${$0 ?? ''}, ${$1 ?? ''})
				rotate(${$2 ?? ''})
				translate(${-$.get(svgData).center.x}, ${-$.get(svgData).center.y})
			`);

							$.set_attribute(image, 'width', $.get(svgData).viewBox.width);
							$.set_attribute(image, 'height', $.get(svgData).viewBox.height);
						},
						[
							() => $.get(position)().x,
							() => $.get(position)().y,
							() => $.get(rotation)()
						]
					);

					$.event('error', image, () => {
						$.set(error, "Failed to load prop SVG");
						$$props.onError?.(`${$$props.propData?.color}-prop`, $.get(error));
					});

					$.append($$anchor, image);
				};

				$.add_svelte_meta(
					() => $.if(
						node_1,
						($$render) => {
							if (!$.get(loaded) || !$.get(svgData)) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					),
					'if',
					Prop,
					274,
					2
				);
			}

			$.append($$anchor, fragment_1);
		};

		$.add_svelte_meta(
			() => $.if(node, ($$render) => {
				if ($.get(error)) $$render(consequent); else $$render(alternate_1, false);
			}),
			'if',
			Prop,
			262,
			2
		);
	}

	$.reset(g);
	$.bind_this(g, ($$value) => $.set(_propElement, $$value), () => $.get(_propElement));

	$.template_effect(
		($0) => {
			classes = $.set_class(g, 0, `prop-group ${$$props.propData?.color ?? ''}-prop`, 's-SUZ92of2eZx8', classes, $0);
			$.set_attribute(g, 'data-prop-color', $$props.propData?.color);
			$.set_attribute(g, 'data-prop-type', $$props.propData?.propType);
			$.set_attribute(g, 'data-location', $$props.propData?.location);
		},
		[() => ({ loaded: $.get(loaded) })]
	);

	$.append($$anchor, g);

	return $.pop({ ...$.legacy_api() });
}

if (import.meta.hot) {
	Prop = $.hmr(Prop, () => Prop[$.HMR].source);

	import.meta.hot.acceptExports(["default"],(module) => {
		$.cleanup_styles('s-SUZ92of2eZx8');
		module.default[$.HMR].source = Prop[$.HMR].source;
		$.set(Prop[$.HMR].source, module.default[$.HMR].original);
	});
}

export default Prop;
import "/src/lib/components/pictograph/Prop.svelte?t=1755631438752&svelte&type=style&lang.css";

//# sourceMappingURL=data:application/json;base64,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IjpbImVycm9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIlByb3Auc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjwhLS1cblByb3AgQ29tcG9uZW50IC0gUmVuZGVycyBTVkcgcHJvcHMgd2l0aCBwcm9wZXIgcG9zaXRpb25pbmdcbi0tPlxuPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgaW1wb3J0IHR5cGUgeyBNb3Rpb25EYXRhLCBQcm9wRGF0YSB9IGZyb20gXCIkbGliL2RvbWFpblwiO1xuICBpbXBvcnQge1xuICAgIExvY2F0aW9uLFxuICAgIE1vdGlvblR5cGUsXG4gICAgT3JpZW50YXRpb24sXG4gICAgUm90YXRpb25EaXJlY3Rpb24sXG4gICAgTW90aW9uQ29sb3IsXG4gIH0gZnJvbSBcIiRsaWIvZG9tYWluL2VudW1zXCI7XG4gIGltcG9ydCB7IERlZmF1bHRQcm9wUG9zaXRpb25lciB9IGZyb20gXCIkbGliL3NlcnZpY2VzL0RlZmF1bHRQcm9wUG9zaXRpb25lclwiO1xuICBpbXBvcnQgeyBQcm9wUm90QW5nbGVNYW5hZ2VyIH0gZnJvbSBcIiRsaWIvc2VydmljZXMvUHJvcFJvdEFuZ2xlTWFuYWdlclwiO1xuICBpbXBvcnQgeyBCZXRhT2Zmc2V0Q2FsY3VsYXRvciB9IGZyb20gXCIkbGliL3NlcnZpY2VzL2ltcGxlbWVudGF0aW9ucy9wb3NpdGlvbmluZy9CZXRhT2Zmc2V0Q2FsY3VsYXRvclwiO1xuICBpbXBvcnQgeyBCZXRhUHJvcERpcmVjdGlvbkNhbGN1bGF0b3IgfSBmcm9tIFwiJGxpYi9zZXJ2aWNlcy9pbXBsZW1lbnRhdGlvbnMvcG9zaXRpb25pbmcvQmV0YVByb3BEaXJlY3Rpb25DYWxjdWxhdG9yXCI7XG4gIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgaW50ZXJmYWNlIFByb3BzIHtcbiAgICBwcm9wRGF0YTogUHJvcERhdGE7XG4gICAgbW90aW9uRGF0YT86IE1vdGlvbkRhdGE7XG4gICAgZ3JpZE1vZGU/OiBzdHJpbmc7XG4gICAgYWxsUHJvcHM/OiBQcm9wRGF0YVtdO1xuICAgIGVuZHNXaXRoQmV0YT86IGJvb2xlYW47IC8vIE5FVzogSW5kaWNhdGVzIGlmIHRoaXMgcGljdG9ncmFwaCBhY3R1YWxseSBlbmRzIHdpdGggYmV0YVxuICAgIG9uTG9hZGVkPzogKGNvbXBvbmVudFR5cGU6IHN0cmluZykgPT4gdm9pZDtcbiAgICBvbkVycm9yPzogKGNvbXBvbmVudFR5cGU6IHN0cmluZywgZXJyb3I6IHN0cmluZykgPT4gdm9pZDtcbiAgfVxuXG4gIGxldCB7XG4gICAgcHJvcERhdGEsXG4gICAgbW90aW9uRGF0YSxcbiAgICBncmlkTW9kZSA9IFwiZGlhbW9uZFwiLFxuICAgIGFsbFByb3BzID0gW10sXG4gICAgZW5kc1dpdGhCZXRhID0gZmFsc2UsIC8vIE5FVzogRGVmYXVsdCB0byBmYWxzZVxuICAgIG9uTG9hZGVkLFxuICAgIG9uRXJyb3IsXG4gIH06IFByb3BzID0gJHByb3BzKCk7XG5cbiAgLy8gUHJvcCBlbGVtZW50IHVzZWQgaW4gYmluZDp0aGlzXG4gIGxldCBfcHJvcEVsZW1lbnQgPSAkc3RhdGU8U1ZHR0VsZW1lbnQgfCBudWxsPihudWxsKTtcbiAgbGV0IGxvYWRlZCA9ICRzdGF0ZShmYWxzZSk7XG4gIGxldCBlcnJvciA9ICRzdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgbGV0IHN2Z0RhdGEgPSAkc3RhdGU8e1xuICAgIGltYWdlU3JjOiBzdHJpbmc7XG4gICAgdmlld0JveDogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9O1xuICAgIGNlbnRlcjogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuICB9IHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9uIHVzaW5nIERlZmF1bHRQcm9wUG9zaXRpb25lciBmb3IgY29uc2lzdGVuY3kgd2l0aCBsZWdhY3lcbiAgY29uc3QgcG9zaXRpb24gPSAkZGVyaXZlZCgoKSA9PiB7XG4gICAgaWYgKCFwcm9wRGF0YSkgcmV0dXJuIHsgeDogNDc1LCB5OiA0NzUgfTtcblxuICAgIC8vIFByb3BzIHVzZSB0aGVpciBPV04gbG9jYXRpb24sIG5vdCBtb3Rpb24gZW5kIGxvY2F0aW9uXG4gICAgLy8gVGhpcyBpcyBjcml0aWNhbCAtIFByb3BQbGFjZW1lbnRNYW5hZ2VyIHNldHMgcHJvcC5sb2NhdGlvbiB3aGljaCBtYXkgZGlmZmVyIGZyb20gbW90aW9uLmVuZExvY2F0aW9uXG4gICAgY29uc3QgbG9jYXRpb24gPSBwcm9wRGF0YS5sb2NhdGlvbiB8fCBtb3Rpb25EYXRhPy5lbmRMb2NhdGlvbjtcblxuICAgIC8vIFVzZSBEZWZhdWx0UHJvcFBvc2l0aW9uZXIgZm9yIGNvbnNpc3RlbnQgcG9zaXRpb25pbmdcbiAgICBjb25zdCBiYXNlUG9zaXRpb24gPSBEZWZhdWx0UHJvcFBvc2l0aW9uZXIuY2FsY3VsYXRlUG9zaXRpb24oXG4gICAgICBsb2NhdGlvbiBhcyBzdHJpbmcsXG4gICAgICBncmlkTW9kZVxuICAgICk7XG5cbiAgICAvLyBBcHBseSBiZXRhIGFkanVzdG1lbnQgaWYgbmVlZGVkICh3aGVuIHByb3BzIGFyZSBhdCBzYW1lIGxvY2F0aW9uKVxuICAgIGNvbnN0IGJldGFPZmZzZXQgPSBjYWxjdWxhdGVCZXRhT2Zmc2V0KCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogYmFzZVBvc2l0aW9uLnggKyBiZXRhT2Zmc2V0LngsXG4gICAgICB5OiBiYXNlUG9zaXRpb24ueSArIGJldGFPZmZzZXQueSxcbiAgICB9O1xuICB9KTtcblxuICAvLyBDYWxjdWxhdGUgYmV0YSBhZGp1c3RtZW50IG9mZnNldCBmb3IgcHJvcCBzZXBhcmF0aW9uIHVzaW5nIGxlZ2FjeSBkaXJlY3Rpb24gbG9naWNcbiAgZnVuY3Rpb24gY2FsY3VsYXRlQmV0YU9mZnNldCgpOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0ge1xuICAgIC8vIENSSVRJQ0FMIEZJWDogT25seSBhcHBseSBiZXRhIG9mZnNldCBpZiB0aGUgcGljdG9ncmFwaCBhY3R1YWxseSBlbmRzIHdpdGggYmV0YVxuICAgIGlmICghZW5kc1dpdGhCZXRhKSB7XG4gICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgfVxuXG4gICAgaWYgKCFwcm9wRGF0YSB8fCAhYWxsUHJvcHMgfHwgYWxsUHJvcHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYW5vdGhlciBwcm9wIGF0IHRoZSBzYW1lIGxvY2F0aW9uXG4gICAgY29uc3Qgb3RoZXJQcm9wID0gYWxsUHJvcHMuZmluZChcbiAgICAgIChwKSA9PiBwLmNvbG9yICE9PSBwcm9wRGF0YS5jb2xvciAmJiBwLmxvY2F0aW9uID09PSBwcm9wRGF0YS5sb2NhdGlvblxuICAgICk7XG5cbiAgICBpZiAoIW90aGVyUHJvcCkge1xuICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYPCflKcgQXBwbHlpbmcgYmV0YSBvZmZzZXQgZm9yICR7cHJvcERhdGEuY29sb3J9IHByb3AgYXQgJHtwcm9wRGF0YS5sb2NhdGlvbn0gKGVuZHNXaXRoQmV0YTogJHtlbmRzV2l0aEJldGF9KWBcbiAgICApO1xuICAgIFxuICAgIC8vIFVzZSBkZWJ1Z2dlciBzdGF0ZW1lbnQgZm9yIHJlbGlhYmxlIFN2ZWx0ZSBkZWJ1Z2dpbmdcbiAgICBkZWJ1Z2dlcjtcblxuICAgIC8vIERFQlVHOiBMb2cgZm9yIEcgcGljdG9ncmFwaCBjYXNlIHdpdGggYm90aCBwcm9wcyBhdCBXZXN0XG4gICAgaWYgKHByb3BEYXRhLmxvY2F0aW9uID09PSBcIndcIiB8fCBwcm9wRGF0YS5sb2NhdGlvbiA9PT0gXCJ3ZXN0XCIpIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBg8J+UpyBbRyBERUJVR10gQmV0YSBvZmZzZXQgY2FsY3VsYXRpb24gZm9yICR7cHJvcERhdGEuY29sb3J9IHByb3A6YCxcbiAgICAgICAge1xuICAgICAgICAgIGxvY2F0aW9uOiBwcm9wRGF0YS5sb2NhdGlvbixcbiAgICAgICAgICBvcmllbnRhdGlvbjogcHJvcERhdGEub3JpZW50YXRpb24sXG4gICAgICAgICAgcm90YXRpb25EaXJlY3Rpb246IHByb3BEYXRhLnJvdGF0aW9uRGlyZWN0aW9uLFxuICAgICAgICAgIG1vdGlvbkRhdGE6IG1vdGlvbkRhdGFcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IG1vdGlvbkRhdGEuc3RhcnRMb2NhdGlvbixcbiAgICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogbW90aW9uRGF0YS5lbmRMb2NhdGlvbixcbiAgICAgICAgICAgICAgICBlbmRPcmllbnRhdGlvbjogbW90aW9uRGF0YS5lbmRPcmllbnRhdGlvbixcbiAgICAgICAgICAgICAgICByb3RhdGlvbkRpcmVjdGlvbjogbW90aW9uRGF0YS5yb3RhdGlvbkRpcmVjdGlvbixcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBcIk5PX01PVElPTl9EQVRBXCIsXG4gICAgICAgICAgYWxsUHJvcHM6IGFsbFByb3BzLm1hcCgocCkgPT4gKHtcbiAgICAgICAgICAgIGNvbG9yOiBwLmNvbG9yLFxuICAgICAgICAgICAgbG9jYXRpb246IHAubG9jYXRpb24sXG4gICAgICAgICAgICBvcmllbnRhdGlvbjogcC5vcmllbnRhdGlvbixcbiAgICAgICAgICB9KSksXG4gICAgICAgICAgZW5kc1dpdGhCZXRhLFxuICAgICAgICAgIGV4cGVjdGVkRGlyZWN0aW9uOlxuICAgICAgICAgICAgXCJTaG91bGQgYmUgVVAvRE9XTiBmb3IgV2VzdCBsb2NhdGlvbiB3aXRoIElOIG9yaWVudGF0aW9uXCIsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVXNlIGxlZ2FjeSBkaXJlY3Rpb24gY2FsY3VsYXRvciBsb2dpYyBmb3IgcHJvcGVyIGJldGEgcG9zaXRpb25pbmdcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IG1vdGlvbiBkYXRhIGZvciBib3RoIHByb3BzIC0gdXNlIHRoZSBtb3Rpb25EYXRhIHByb3AgcGFzc2VkIHRvIGNvbXBvbmVudFxuICAgICAgY29uc3QgcmVkUHJvcCA9IGFsbFByb3BzLmZpbmQoKHApID0+IHAuY29sb3IgPT09IE1vdGlvbkNvbG9yLlJFRCk7XG4gICAgICBjb25zdCBibHVlUHJvcCA9IGFsbFByb3BzLmZpbmQoKHApID0+IHAuY29sb3IgPT09IE1vdGlvbkNvbG9yLkJMVUUpO1xuXG4gICAgICAvLyBGb3Igc3RhcnQgcG9zaXRpb25zLCB3ZSBuZWVkIHRvIGNvbnN0cnVjdCBtb3Rpb24gZGF0YSBmcm9tIHByb3AgZGF0YVxuICAgICAgLy8gU2luY2Ugc3RhcnQgcG9zaXRpb25zIGFyZSBzdGF0aWMsIHdlIGNhbiB1c2UgdGhlIHByb3AgbG9jYXRpb24gYXMgYm90aCBzdGFydCBhbmQgZW5kXG4gICAgICBjb25zdCByZWRNb3Rpb246IE1vdGlvbkRhdGEgPSB7XG4gICAgICAgIG1vdGlvblR5cGU6IE1vdGlvblR5cGUuU1RBVElDLFxuICAgICAgICByb3RhdGlvbkRpcmVjdGlvbjogUm90YXRpb25EaXJlY3Rpb24uQ0xPQ0tXSVNFLFxuICAgICAgICBzdGFydExvY2F0aW9uOiAocmVkUHJvcD8ubG9jYXRpb24gYXMgTG9jYXRpb24pIHx8IExvY2F0aW9uLlNPVVRILFxuICAgICAgICBlbmRMb2NhdGlvbjogKHJlZFByb3A/LmxvY2F0aW9uIGFzIExvY2F0aW9uKSB8fCBMb2NhdGlvbi5TT1VUSCxcbiAgICAgICAgdHVybnM6IDAsXG4gICAgICAgIHN0YXJ0T3JpZW50YXRpb246IE9yaWVudGF0aW9uLklOLFxuICAgICAgICBlbmRPcmllbnRhdGlvbjogT3JpZW50YXRpb24uSU4sXG4gICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGJsdWVNb3Rpb246IE1vdGlvbkRhdGEgPSB7XG4gICAgICAgIG1vdGlvblR5cGU6IE1vdGlvblR5cGUuU1RBVElDLFxuICAgICAgICByb3RhdGlvbkRpcmVjdGlvbjogUm90YXRpb25EaXJlY3Rpb24uQ0xPQ0tXSVNFLFxuICAgICAgICBzdGFydExvY2F0aW9uOiAoYmx1ZVByb3A/LmxvY2F0aW9uIGFzIExvY2F0aW9uKSB8fCBMb2NhdGlvbi5TT1VUSCxcbiAgICAgICAgZW5kTG9jYXRpb246IChibHVlUHJvcD8ubG9jYXRpb24gYXMgTG9jYXRpb24pIHx8IExvY2F0aW9uLlNPVVRILFxuICAgICAgICB0dXJuczogMCxcbiAgICAgICAgc3RhcnRPcmllbnRhdGlvbjogT3JpZW50YXRpb24uSU4sXG4gICAgICAgIGVuZE9yaWVudGF0aW9uOiBPcmllbnRhdGlvbi5JTixcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgfTtcblxuICAgICAgLy8gQ3JlYXRlIGRpcmVjdGlvbiBjYWxjdWxhdG9yXG4gICAgICBjb25zdCBkaXJlY3Rpb25DYWxjdWxhdG9yID0gbmV3IEJldGFQcm9wRGlyZWN0aW9uQ2FsY3VsYXRvcih7XG4gICAgICAgIHJlZDogcmVkTW90aW9uLFxuICAgICAgICBibHVlOiBibHVlTW90aW9uLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEdldCBkaXJlY3Rpb24gZm9yIHRoaXMgcHJvcFxuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZGlyZWN0aW9uQ2FsY3VsYXRvci5nZXREaXJlY3Rpb24ocHJvcERhdGEpO1xuXG4gICAgICAvLyBERUJVRzogTG9nIGRpcmVjdGlvbiBjYWxjdWxhdGlvbiBmb3IgV2VzdCBwcm9wc1xuICAgICAgaWYgKHByb3BEYXRhLmxvY2F0aW9uID09PSBcIndcIiB8fCBwcm9wRGF0YS5sb2NhdGlvbiA9PT0gXCJ3ZXN0XCIpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflKcgW0cgREVCVUddIERpcmVjdGlvbiBjYWxjdWxhdGlvbiByZXN1bHQ6YCwge1xuICAgICAgICAgIHByb3BDb2xvcjogcHJvcERhdGEuY29sb3IsXG4gICAgICAgICAgY2FsY3VsYXRlZERpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICAgIGV4cGVjdGVkRGlyZWN0aW9uOiBcIlVQIG9yIERPV05cIixcbiAgICAgICAgICByZWRNb3Rpb246IHtcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IHJlZE1vdGlvbi5zdGFydExvY2F0aW9uLFxuICAgICAgICAgICAgZW5kTG9jYXRpb246IHJlZE1vdGlvbi5lbmRMb2NhdGlvbixcbiAgICAgICAgICAgIGVuZE9yaWVudGF0aW9uOiByZWRNb3Rpb24uZW5kT3JpZW50YXRpb24sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBibHVlTW90aW9uOiB7XG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBibHVlTW90aW9uLnN0YXJ0TG9jYXRpb24sXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogYmx1ZU1vdGlvbi5lbmRMb2NhdGlvbixcbiAgICAgICAgICAgIGVuZE9yaWVudGF0aW9uOiBibHVlTW90aW9uLmVuZE9yaWVudGF0aW9uLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBg4pqg77iPIE5vIGRpcmVjdGlvbiBjYWxjdWxhdGVkLCB1c2luZyBmYWxsYmFjayBmb3IgJHtwcm9wRGF0YS5jb2xvcn1gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBwcm9wRGF0YS5jb2xvciA9PT0gXCJibHVlXCIgPyB7IHg6IC0yNSwgeTogMCB9IDogeyB4OiAyNSwgeTogMCB9O1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgb2Zmc2V0IHVzaW5nIGRpcmVjdGlvblxuICAgICAgY29uc3Qgb2Zmc2V0Q2FsY3VsYXRvciA9IG5ldyBCZXRhT2Zmc2V0Q2FsY3VsYXRvcigpO1xuICAgICAgY29uc3QgYmFzZVBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07IC8vIFdlIG9ubHkgd2FudCB0aGUgb2Zmc2V0LCBub3QgYWJzb2x1dGUgcG9zaXRpb25cbiAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gb2Zmc2V0Q2FsY3VsYXRvci5jYWxjdWxhdGVOZXdQb3NpdGlvbldpdGhPZmZzZXQoXG4gICAgICAgIGJhc2VQb3NpdGlvbixcbiAgICAgICAgZGlyZWN0aW9uXG4gICAgICApO1xuXG4gICAgICAvLyBERUJVRzogTG9nIGZpbmFsIG9mZnNldCBjYWxjdWxhdGlvbiBmb3IgV2VzdCBwcm9wc1xuICAgICAgaWYgKHByb3BEYXRhLmxvY2F0aW9uID09PSBcIndcIiB8fCBwcm9wRGF0YS5sb2NhdGlvbiA9PT0gXCJ3ZXN0XCIpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflKcgW0cgREVCVUddIEZpbmFsIG9mZnNldCBjYWxjdWxhdGlvbjpgLCB7XG4gICAgICAgICAgcHJvcENvbG9yOiBwcm9wRGF0YS5jb2xvcixcbiAgICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgICAgY2FsY3VsYXRlZE9mZnNldDogeyB4OiBuZXdQb3NpdGlvbi54LCB5OiBuZXdQb3NpdGlvbi55IH0sXG4gICAgICAgICAgZXhwZWN0ZWRPZmZzZXQ6IGRpcmVjdGlvbj8uaW5jbHVkZXMoXCJVUFwiKVxuICAgICAgICAgICAgPyBcIm5lZ2F0aXZlIFlcIlxuICAgICAgICAgICAgOiBkaXJlY3Rpb24/LmluY2x1ZGVzKFwiRE9XTlwiKVxuICAgICAgICAgICAgICA/IFwicG9zaXRpdmUgWVwiXG4gICAgICAgICAgICAgIDogXCJ1bmtub3duXCIsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyB4OiBuZXdQb3NpdGlvbi54LCB5OiBuZXdQb3NpdGlvbi55IH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBiZXRhIGRpcmVjdGlvbiBjYWxjdWxhdGlvbjpcIiwgZXJyb3IpO1xuICAgICAgLy8gRmFsbGJhY2sgdG8gc2ltcGxlIGxlZnQvcmlnaHQgc2VwYXJhdGlvblxuICAgICAgcmV0dXJuIHByb3BEYXRhLmNvbG9yID09PSBcImJsdWVcIiA/IHsgeDogLTI1LCB5OiAwIH0gOiB7IHg6IDI1LCB5OiAwIH07XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHJvdGF0aW9uIHVzaW5nIFByb3BSb3RBbmdsZU1hbmFnZXIgZm9yIGNvbnNpc3RlbmN5IHdpdGggbGVnYWN5XG4gIGNvbnN0IHJvdGF0aW9uID0gJGRlcml2ZWQoKCkgPT4ge1xuICAgIGlmICghcHJvcERhdGEpIHJldHVybiAwO1xuXG4gICAgY29uc3QgbG9jYXRpb24gPSBwcm9wRGF0YS5sb2NhdGlvbiB8fCBtb3Rpb25EYXRhPy5lbmRMb2NhdGlvbjtcbiAgICAvLyBVc2UgcHJvcCdzIG93biBvcmllbnRhdGlvbiBpbnN0ZWFkIG9mIG1vdGlvbidzIGVuZCBvcmllbnRhdGlvblxuICAgIGNvbnN0IHByb3BPcmllbnRhdGlvbiA9IHByb3BEYXRhLm9yaWVudGF0aW9uIHx8IFwiaW5cIjtcblxuICAgIC8vIENvbnZlcnQgc3RyaW5nIG9yaWVudGF0aW9uIHRvIGVudW1cbiAgICBsZXQgb3JpZW50YXRpb246IE9yaWVudGF0aW9uO1xuICAgIHN3aXRjaCAocHJvcE9yaWVudGF0aW9uKSB7XG4gICAgICBjYXNlIFwiaW5cIjpcbiAgICAgICAgb3JpZW50YXRpb24gPSBPcmllbnRhdGlvbi5JTjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib3V0XCI6XG4gICAgICAgIG9yaWVudGF0aW9uID0gT3JpZW50YXRpb24uT1VUO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjbG9ja1wiOlxuICAgICAgICBvcmllbnRhdGlvbiA9IE9yaWVudGF0aW9uLkNMT0NLO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjb3VudGVyXCI6XG4gICAgICAgIG9yaWVudGF0aW9uID0gT3JpZW50YXRpb24uQ09VTlRFUjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBvcmllbnRhdGlvbiA9IE9yaWVudGF0aW9uLklOO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGN1bGF0ZWRSb3RhdGlvbiA9IFByb3BSb3RBbmdsZU1hbmFnZXIuY2FsY3VsYXRlUm90YXRpb24oXG4gICAgICBsb2NhdGlvbiBhcyBzdHJpbmcsXG4gICAgICBvcmllbnRhdGlvblxuICAgICk7XG5cbiAgICByZXR1cm4gY2FsY3VsYXRlZFJvdGF0aW9uO1xuICB9KTtcblxuICAvLyBQYXJzZSBTVkcgdG8gZ2V0IHByb3BlciBkaW1lbnNpb25zIGFuZCBjZW50ZXIgcG9pbnRcbiAgY29uc3QgcGFyc2VQcm9wU3ZnID0gKFxuICAgIHN2Z1RleHQ6IHN0cmluZ1xuICApOiB7XG4gICAgdmlld0JveDogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9O1xuICAgIGNlbnRlcjogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuICB9ID0+IHtcbiAgICBjb25zdCBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHN2Z1RleHQsIFwiaW1hZ2Uvc3ZnK3htbFwiKTtcbiAgICBjb25zdCBzdmcgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgLy8gR2V0IHZpZXdCb3ggZGltZW5zaW9uc1xuICAgIGNvbnN0IHZpZXdCb3hWYWx1ZXMgPSBzdmcuZ2V0QXR0cmlidXRlKFwidmlld0JveFwiKT8uc3BsaXQoL1xccysvKSB8fCBbXG4gICAgICBcIjBcIixcbiAgICAgIFwiMFwiLFxuICAgICAgXCIyNTIuOFwiLFxuICAgICAgXCI3Ny44XCIsXG4gICAgXTtcbiAgICBjb25zdCB2aWV3Qm94ID0ge1xuICAgICAgd2lkdGg6IHBhcnNlRmxvYXQodmlld0JveFZhbHVlc1syXSB8fCBcIjI1Mi44XCIpIHx8IDI1Mi44LFxuICAgICAgaGVpZ2h0OiBwYXJzZUZsb2F0KHZpZXdCb3hWYWx1ZXNbM10gfHwgXCI3Ny44XCIpIHx8IDc3LjgsXG4gICAgfTtcblxuICAgIC8vIEdldCBjZW50ZXIgcG9pbnQgZnJvbSBTVkdcbiAgICBsZXQgY2VudGVyID0geyB4OiB2aWV3Qm94LndpZHRoIC8gMiwgeTogdmlld0JveC5oZWlnaHQgLyAyIH07XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2VudGVyRWxlbWVudCA9IGRvYy5nZXRFbGVtZW50QnlJZChcImNlbnRlclBvaW50XCIpO1xuICAgICAgaWYgKGNlbnRlckVsZW1lbnQpIHtcbiAgICAgICAgY2VudGVyID0ge1xuICAgICAgICAgIHg6IHBhcnNlRmxvYXQoY2VudGVyRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjeFwiKSB8fCBcIjBcIikgfHwgY2VudGVyLngsXG4gICAgICAgICAgeTogcGFyc2VGbG9hdChjZW50ZXJFbGVtZW50LmdldEF0dHJpYnV0ZShcImN5XCIpIHx8IFwiMFwiKSB8fCBjZW50ZXIueSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIFNWRyBjZW50ZXIgY2FsY3VsYXRpb24gZmFpbGVkLCB1c2luZyBkZWZhdWx0IGNlbnRlclxuICAgIH1cblxuICAgIHJldHVybiB7IHZpZXdCb3gsIGNlbnRlciB9O1xuICB9O1xuXG4gIC8vIEFwcGx5IGNvbG9yIHRyYW5zZm9ybWF0aW9uIHRvIFNWRyBjb250ZW50XG4gIGNvbnN0IGFwcGx5Q29sb3JUb1N2ZyA9IChzdmdUZXh0OiBzdHJpbmcsIGNvbG9yOiBNb3Rpb25Db2xvcik6IHN0cmluZyA9PiB7XG4gICAgLy8gQXZvaWQgQ1NTIHBhcnNlciBjb25mbGljdHMgYnkgdXNpbmcgYSBkaWZmZXJlbnQgYXBwcm9hY2hcbiAgICBjb25zdCBjb2xvck1hcCA9IG5ldyBNYXAoW1xuICAgICAgW01vdGlvbkNvbG9yLkJMVUUsIFwiIzJFMzE5MlwiXSxcbiAgICAgIFtNb3Rpb25Db2xvci5SRUQsIFwiI0VEMUMyNFwiXSxcbiAgICBdKTtcblxuICAgIGNvbnN0IHRhcmdldENvbG9yID0gY29sb3JNYXAuZ2V0KGNvbG9yKSB8fCBcIiMyRTMxOTJcIjtcblxuICAgIC8vIFVzZSByZWdleCByZXBsYWNlbWVudCB0byBjaGFuZ2UgZmlsbCBjb2xvcnMgZGlyZWN0bHlcbiAgICBsZXQgY29sb3JlZFN2ZyA9IHN2Z1RleHQucmVwbGFjZShcbiAgICAgIC9maWxsPVwiI1swLTlBLUZhLWZdezZ9XCIvZyxcbiAgICAgIGBmaWxsPVwiJHt0YXJnZXRDb2xvcn1cImBcbiAgICApO1xuICAgIGNvbG9yZWRTdmcgPSBjb2xvcmVkU3ZnLnJlcGxhY2UoXG4gICAgICAvZmlsbDpcXHMqI1swLTlBLUZhLWZdezZ9L2csXG4gICAgICBgZmlsbDoke3RhcmdldENvbG9yfWBcbiAgICApO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBjZW50ZXJQb2ludCBjaXJjbGUgZW50aXJlbHkgdG8gcHJldmVudCBDSVJDTEVfUFJPUCBkZXRlY3Rpb25cbiAgICBjb2xvcmVkU3ZnID0gY29sb3JlZFN2Zy5yZXBsYWNlKFxuICAgICAgLzxjaXJjbGVbXj5dKmlkPVwiY2VudGVyUG9pbnRcIltePl0qXFwvPz4vLFxuICAgICAgXCJcIlxuICAgICk7XG5cbiAgICByZXR1cm4gY29sb3JlZFN2ZztcbiAgfTtcblxuICAvLyBMb2FkIFNWRyBkYXRhXG4gIGNvbnN0IGxvYWRTdmcgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghcHJvcERhdGEpIHRocm93IG5ldyBFcnJvcihcIk5vIHByb3AgZGF0YSBhdmFpbGFibGVcIik7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9pbWFnZXMvcHJvcHMvJHtwcm9wRGF0YS5wcm9wVHlwZX0uc3ZnYCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggU1ZHXCIpO1xuXG4gICAgICBjb25zdCBvcmlnaW5hbFN2Z1RleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBjb25zdCB7IHZpZXdCb3gsIGNlbnRlciB9ID0gcGFyc2VQcm9wU3ZnKG9yaWdpbmFsU3ZnVGV4dCk7XG5cbiAgICAgIC8vIEFwcGx5IGNvbG9yIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBTVkdcbiAgICAgIGNvbnN0IGNvbG9yZWRTdmdUZXh0ID0gYXBwbHlDb2xvclRvU3ZnKG9yaWdpbmFsU3ZnVGV4dCwgcHJvcERhdGEuY29sb3IpO1xuXG4gICAgICBzdmdEYXRhID0ge1xuICAgICAgICBpbWFnZVNyYzogYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtidG9hKGNvbG9yZWRTdmdUZXh0KX1gLFxuICAgICAgICB2aWV3Qm94LFxuICAgICAgICBjZW50ZXIsXG4gICAgICB9O1xuXG4gICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgb25Mb2FkZWQ/LihgJHtwcm9wRGF0YT8uY29sb3J9LXByb3BgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvciA9IGBGYWlsZWQgdG8gbG9hZCBwcm9wIFNWRzogJHtlfWA7XG4gICAgICBvbkVycm9yPy4oYCR7cHJvcERhdGE/LmNvbG9yfS1wcm9wYCwgZXJyb3IpO1xuICAgICAgLy8gU3RpbGwgbWFyayBhcyBsb2FkZWQgdG8gcHJldmVudCBibG9ja2luZ1xuICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgbG9hZFN2ZygpO1xuICB9KTtcbjwvc2NyaXB0PlxuXG48IS0tIFByb3AgR3JvdXAgLS0+XG48Z1xuICBiaW5kOnRoaXM9e19wcm9wRWxlbWVudH1cbiAgY2xhc3M9XCJwcm9wLWdyb3VwIHtwcm9wRGF0YT8uY29sb3J9LXByb3BcIlxuICBjbGFzczpsb2FkZWRcbiAgZGF0YS1wcm9wLWNvbG9yPXtwcm9wRGF0YT8uY29sb3J9XG4gIGRhdGEtcHJvcC10eXBlPXtwcm9wRGF0YT8ucHJvcFR5cGV9XG4gIGRhdGEtbG9jYXRpb249e3Byb3BEYXRhPy5sb2NhdGlvbn1cbj5cbiAgeyNpZiBlcnJvcn1cbiAgICA8IS0tIEVycm9yIHN0YXRlIC0tPlxuICAgIDxyZWN0XG4gICAgICB4PVwiLTE1XCJcbiAgICAgIHk9XCItMTVcIlxuICAgICAgd2lkdGg9XCIzMFwiXG4gICAgICBoZWlnaHQ9XCIzMFwiXG4gICAgICBmaWxsPVwicmVkXCJcbiAgICAgIG9wYWNpdHk9XCIwLjVcIlxuICAgICAgcng9XCIzXCJcbiAgICAvPlxuICAgIDx0ZXh0IHg9XCIwXCIgeT1cIjRcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiIGZvbnQtc2l6ZT1cIjhcIiBmaWxsPVwid2hpdGVcIj4hPC90ZXh0PlxuICB7OmVsc2UgaWYgIWxvYWRlZCB8fCAhc3ZnRGF0YX1cbiAgICA8IS0tIExvYWRpbmcgc3RhdGUgLS0+XG4gICAgPHJlY3RcbiAgICAgIHg9XCItMTJcIlxuICAgICAgeT1cIi0xMlwiXG4gICAgICB3aWR0aD1cIjI0XCJcbiAgICAgIGhlaWdodD1cIjI0XCJcbiAgICAgIGZpbGw9e3Byb3BEYXRhPy5jb2xvciA9PT0gXCJibHVlXCIgPyBcIiMyRTMxOTJcIiA6IFwiI0VEMUMyNFwifVxuICAgICAgb3BhY2l0eT1cIjAuM1wiXG4gICAgICByeD1cIjJcIlxuICAgIC8+XG4gICAgPGFuaW1hdGVcbiAgICAgIGF0dHJpYnV0ZU5hbWU9XCJvcGFjaXR5XCJcbiAgICAgIHZhbHVlcz1cIjAuMzswLjg7MC4zXCJcbiAgICAgIGR1cj1cIjFzXCJcbiAgICAgIHJlcGVhdENvdW50PVwiaW5kZWZpbml0ZVwiXG4gICAgLz5cbiAgezplbHNlfVxuICAgIDwhLS0gQWN0dWFsIHByb3AgU1ZHIHdpdGggcHJvcGVyIHNpemluZyBhbmQgY2VudGVyaW5nIC0tPlxuICAgIDxpbWFnZVxuICAgICAgaHJlZj17c3ZnRGF0YS5pbWFnZVNyY31cbiAgICAgIHRyYW5zZm9ybT1cIlxuXHRcdFx0XHR0cmFuc2xhdGUoe3Bvc2l0aW9uKCkueH0sIHtwb3NpdGlvbigpLnl9KVxuXHRcdFx0XHRyb3RhdGUoe3JvdGF0aW9uKCl9KVxuXHRcdFx0XHR0cmFuc2xhdGUoey1zdmdEYXRhLmNlbnRlci54fSwgey1zdmdEYXRhLmNlbnRlci55fSlcblx0XHRcdFwiXG4gICAgICB3aWR0aD17c3ZnRGF0YS52aWV3Qm94LndpZHRofVxuICAgICAgaGVpZ2h0PXtzdmdEYXRhLnZpZXdCb3guaGVpZ2h0fVxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIlxuICAgICAgY2xhc3M9XCJwcm9wLXN2Z1wiXG4gICAgICBvbmVycm9yPXsoKSA9PiB7XG4gICAgICAgIGVycm9yID0gXCJGYWlsZWQgdG8gbG9hZCBwcm9wIFNWR1wiO1xuICAgICAgICBvbkVycm9yPy4oYCR7cHJvcERhdGE/LmNvbG9yfS1wcm9wYCwgZXJyb3IpO1xuICAgICAgfX1cbiAgICAvPlxuXG4gICAgPCEtLSBEZWJ1ZyBpbmZvIGRpc2FibGVkIHRvIHByZXZlbnQgQ0lSQ0xFX1BST1AgZHVwbGljYXRlcyAtLT5cbiAgICA8IS0tIERlYnVnIGNpcmNsZXMgd2VyZSBjcmVhdGluZyBkdXBsaWNhdGUgQ0lSQ0xFX1BST1AgZWxlbWVudHMgaW4gY29tcGFyaXNvbiB0ZXN0cyAtLT5cbiAgICA8IS0tIHsjaWYgaW1wb3J0Lm1ldGEuZW52LkRFVn1cblx0XHRcdDxjaXJjbGUgcj1cIjJcIiBmaWxsPVwiZ3JlZW5cIiBvcGFjaXR5PVwiMC41XCIgY3g9e3Bvc2l0aW9uKCkueH0gY3k9e3Bvc2l0aW9uKCkueX0gLz5cblx0XHRcdDx0ZXh0IHg9e3Bvc2l0aW9uKCkueH0geT17cG9zaXRpb24oKS55IC0gMzB9IHRleHQtYW5jaG9yPVwibWlkZGxlXCIgZm9udC1zaXplPVwiNlwiIGZpbGw9XCJibGFja1wiPlxuXHRcdFx0XHR7cHJvcERhdGE/LmxvY2F0aW9ufVxuXHRcdFx0PC90ZXh0PlxuXHRcdHsvaWZ9IC0tPlxuICB7L2lmfVxuPC9nPlxuXG48c3R5bGU+XG4gIC5wcm9wLWdyb3VwIHtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4ycyBlYXNlO1xuICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlcjtcbiAgfVxuXG4gIC5wcm9wLWdyb3VwLmxvYWRlZCB7XG4gICAgb3BhY2l0eTogMTtcbiAgfVxuXG4gIC5wcm9wLXN2ZyB7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIH1cblxuICAvKiBFbnN1cmUgcHJvcGVyIGxheWVyaW5nICovXG4gIC5wcm9wLWdyb3VwIHtcbiAgICB6LWluZGV4OiAxO1xuICB9XG48L3N0eWxlPlxuIl0sImZpbGUiOiJGOi9DT0RFL1RLQS93ZWIvc3JjL2xpYi9jb21wb25lbnRzL3BpY3RvZ3JhcGgvUHJvcC5zdmVsdGUifQ==