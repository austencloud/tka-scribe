import { createHotContext as __vite__createHotContext } from "/@vite/client";import.meta.hot = __vite__createHotContext("/src/lib/components/pictograph/TKAGlyph.svelte");import "/node_modules/.vite/deps/svelte_internal_disclose-version.js?v=de368f3a";

TKAGlyph[$.FILENAME] = 'src/lib/components/pictograph/TKAGlyph.svelte';

import * as $ from "/node_modules/.vite/deps/svelte_internal_client.js?v=de368f3a";
import { getLetterImagePath } from "/src/lib/utils/letter-type-classification.ts";
import { MotionColor } from "/src/lib/domain/enums.ts";

var root_3 = $.add_locations($.from_svg(`<circle r="12" stroke="white" stroke-width="2" opacity="0.9" class="s-X_6UOtCCgcv0"></circle><text text-anchor="middle" dominant-baseline="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="white" class="s-X_6UOtCCgcv0"> </text>`, 1), TKAGlyph[$.FILENAME], [[165, 10], [176, 10]]);
var root_2 = $.add_locations($.from_svg(`<g class="turn-indicators s-X_6UOtCCgcv0"></g>`), TKAGlyph[$.FILENAME], [[162, 6]]);
var root_4 = $.add_locations($.from_svg(`<text x="0" text-anchor="middle" font-family="Arial, sans-serif" font-weight="normal" fill="#6b7280" opacity="0.8" class="s-X_6UOtCCgcv0"> </text>`), TKAGlyph[$.FILENAME], [[194, 6]]);
var root_5 = $.add_locations($.from_svg(`<g class="debug-overlay s-X_6UOtCCgcv0"><circle x="0" y="0" r="3" fill="#8b5cf6" opacity="0.8" class="s-X_6UOtCCgcv0"></circle><text x="20" y="-20" font-size="8" fill="#8b5cf6" font-family="monospace" class="s-X_6UOtCCgcv0"> </text><text x="20" y="-10" font-size="8" fill="#8b5cf6" font-family="monospace" class="s-X_6UOtCCgcv0"> </text></g>`), TKAGlyph[$.FILENAME], [[210, 6, [[212, 8], [215, 8], [224, 8]]]]);
var root_1 = $.add_locations($.from_svg(`<g class="tka-glyph s-X_6UOtCCgcv0"><image x="0" y="0" preserveAspectRatio="xMinYMin meet" class="letter-image s-X_6UOtCCgcv0"></image><!><!><!></g>`), TKAGlyph[$.FILENAME], [[143, 2, [[150, 4]]]]);

function TKAGlyph($$anchor, $$props) {
	$.check_target(new.target);
	$.push($$props, true, TKAGlyph);

	let x = $.prop($$props, 'x', 3, 50),
		// Match legacy positioning exactly
		y = $.prop($$props, 'y', 3, 800),
		// Match legacy positioning exactly
		turnsTuple = $.prop($$props, 'turnsTuple', 3, "(s, 0, 0)"),
		// color = '#4b5563',
		debug = $.prop($$props, 'debug', 3, false),
		scale = $.prop($$props, 'scale', 3, 1);

	// Match legacy default scale
	const fontSize = 16;

	let letterDimensions = $.tag($.state($.proxy({ width: 0, height: 0 })), 'letterDimensions');
	let isLetterLoaded = $.tag($.state(false), 'isLetterLoaded');
	const dimensionsCache = /* @__PURE__ */ new Map();

	async function loadLetterDimensions(currentLetter) {
		if (!currentLetter) return;

		const cacheKey = currentLetter;

		if (dimensionsCache.has(cacheKey)) {
			$.set(letterDimensions, dimensionsCache.get(cacheKey), true);
			$.set(isLetterLoaded, true);

			return;
		}

		try {
			const svgPath = getLetterImagePath(currentLetter);
			const response = (await $.track_reactivity_loss(fetch(svgPath)))();

			if (!response.ok) throw new Error(`Failed to fetch ${svgPath}: ${response.status}`);

			const svgText = (await $.track_reactivity_loss(response.text()))();
			const viewBoxMatch = svgText.match(/viewBox\s*=\s*"[\d.-]+\s+[\d.-]+\s+([\d.-]+)\s+([\d.-]+)"/i);

			if (!viewBoxMatch) {
				console.warn(`SVG at ${svgPath} has no valid viewBox, using defaults`);
				$.set(letterDimensions, { width: 100, height: 100 }, true);
			} else {
				$.set(
					letterDimensions,
					{
						width: parseFloat(viewBoxMatch[1] || "100"),
						height: parseFloat(viewBoxMatch[2] || "100")
					},
					true
				);
			}

			dimensionsCache.set(cacheKey, $.get(letterDimensions));
			$.set(isLetterLoaded, true);
		} catch(error) {
			console.error(...$.log_if_contains_state('error', `Failed to load letter dimensions for ${currentLetter}:`, error));
			$.set(letterDimensions, { width: 50, height: 50 }, true);
			$.set(isLetterLoaded, true);
		}
	}

	$.user_effect(() => {
		if ($$props.letter) {
			$.set(isLetterLoaded, false);
			loadLetterDimensions($$props.letter);
		}
	});

	const hasLetter = $.tag(
		$.derived(() => () => {
			return $.equals($$props.letter, null, false) && $.strict_equals($$props.letter.trim(), "", false);
		}),
		'hasLetter'
	);

	const parsedTurns = $.tag(
		$.derived(() => () => {
			if (!turnsTuple()) return { timing: "s", blue: 0, red: 0 };

			try {
				const cleaned = turnsTuple().replace(/[()]/g, "").trim();
				const parts = cleaned.split(",").map((s) => s.trim());

				if ($.strict_equals(parts.length, 3, false)) {
					return { timing: "s", blue: 0, red: 0 };
				}

				return {
					timing: parts[0] || "",
					blue: parseFloat(parts[1] || "0") || 0,
					red: parseFloat(parts[2] || "0") || 0
				};
			} catch(error) {
				if (debug()) {
					console.warn(...$.log_if_contains_state('warn', "Failed to parse turns tuple:", turnsTuple(), error));
				}

				return { timing: "s", blue: 0, red: 0 };
			}
		}),
		'parsedTurns'
	);

	const showTurns = $.tag(
		$.derived(() => () => {
			return false;
		}),
		'showTurns'
	);

	const turnDisplays = $.tag(
		$.derived(() => () => {
			const turns = $.get(parsedTurns)();
			const displays = [];

			if ($.strict_equals(turns.blue, 0, false)) {
				displays.push({
					color: MotionColor.BLUE,
					value: turns.blue,
					displayText: formatTurnValue(turns.blue)
				});
			}

			if ($.strict_equals(turns.red, 0, false)) {
				displays.push({
					color: MotionColor.RED,
					value: turns.red,
					displayText: formatTurnValue(turns.red)
				});
			}

			return displays;
		}),
		'turnDisplays'
	);

	function formatTurnValue(value) {
		if ($.strict_equals(value, 0)) return "";
		if ($.strict_equals(value % 1, 0)) return value.toString();

		return value.toFixed(1);
	}

	function getTurnColor(color) {
		switch (color) {
			case "blue":
				return "#3b82f6";

			case "red":
				return "#ef4444";

			default:
				return "#6b7280";
		}
	}

	const turnPositions = $.tag(
		$.derived(() => () => {
			const displays = $.get(turnDisplays)();
			const spacing = 40;
			const startX = x() - (displays.length - 1) * spacing / 2;

			return displays.map((display, index) => ({ ...display, x: startX + index * spacing, y: y() + 30

			// Below the letter
			 }));
		}),
		'turnPositions'
	);

	var fragment = $.comment();
	var node = $.first_child(fragment);

	{
		var consequent_3 = ($$anchor) => {
			var g = root_1();
			var image = $.child(g);
			var node_1 = $.sibling(image);

			{
				var consequent = ($$anchor) => {
					var g_1 = root_2();

					$.validate_each_keys(() => $.get(turnPositions)(), (turn) => turn.color);

					$.add_svelte_meta(
						() => $.each(g_1, 21, () => $.get(turnPositions)(), (turn) => turn.color, ($$anchor, turn) => {
							var fragment_1 = root_3();
							var circle = $.first_child(fragment_1);
							var text = $.sibling(circle);
							var text_1 = $.child(text, true);

							$.reset(text);

							$.template_effect(
								($0) => {
									$.set_attribute(circle, 'cx', $.get(turn).x);
									$.set_attribute(circle, 'cy', $.get(turn).y);
									$.set_attribute(circle, 'fill', $0);
									$.set_attribute(text, 'x', $.get(turn).x);
									$.set_attribute(text, 'y', $.get(turn).y);
									$.set_text(text_1, $.get(turn).displayText);
								},
								[() => getTurnColor($.get(turn).color)]
							);

							$.append($$anchor, fragment_1);
						}),
						'each',
						TKAGlyph,
						163,
						8
					);

					$.reset(g_1);
					$.append($$anchor, g_1);
				};

				$.add_svelte_meta(
					() => $.if(node_1, ($$render) => {
						if ($.get(showTurns)()) $$render(consequent);
					}),
					'if',
					TKAGlyph,
					161,
					4
				);
			}

			var node_2 = $.sibling(node_1);

			{
				var consequent_1 = ($$anchor) => {
					var text_2 = root_4();

					$.set_attribute(text_2, 'y', -fontSize - 10);
					$.set_attribute(text_2, 'font-size', fontSize * 0.6);

					var text_3 = $.child(text_2, true);

					$.reset(text_2);
					$.template_effect(($0) => $.set_text(text_3, $0), [() => $.get(parsedTurns)()?.timing?.toUpperCase() || ""]);
					$.append($$anchor, text_2);
				};

				$.add_svelte_meta(
					() => $.if(node_2, ($$render) => {
						if ($.strict_equals($.get(parsedTurns)().timing, "s", false)) $$render(consequent_1);
					}),
					'if',
					TKAGlyph,
					193,
					4
				);
			}

			var node_3 = $.sibling(node_2);

			{
				var consequent_2 = ($$anchor) => {
					var g_2 = root_5();
					var text_4 = $.sibling($.child(g_2));
					var text_5 = $.child(text_4);

					$.reset(text_4);

					var text_6 = $.sibling(text_4);
					var text_7 = $.child(text_6);

					$.reset(text_6);
					$.reset(g_2);

					$.template_effect(() => {
						$.set_text(text_5, `Letter: ${$$props.letter ?? ''}`);
						$.set_text(text_7, `Turns: ${turnsTuple() ?? ''}`);
					});

					$.append($$anchor, g_2);
				};

				$.add_svelte_meta(
					() => $.if(node_3, ($$render) => {
						if (debug()) $$render(consequent_2);
					}),
					'if',
					TKAGlyph,
					208,
					4
				);
			}

			$.reset(g);

			$.template_effect(
				($0) => {
					$.set_attribute(g, 'data-letter', $$props.letter);
					$.set_attribute(g, 'data-turns', turnsTuple());
					$.set_attribute(g, 'transform', `translate(${x() ?? ''}, ${y() ?? ''}) scale(${scale() ?? ''})`);
					$.set_attribute(image, 'href', $0);
					$.set_attribute(image, 'width', $.get(letterDimensions).width);
					$.set_attribute(image, 'height', $.get(letterDimensions).height);
				},
				[
					() => $$props.letter ? getLetterImagePath($$props.letter) : ""
				]
			);

			$.append($$anchor, g);
		};

		$.add_svelte_meta(
			() => $.if(node, ($$render) => {
				if ($.get(hasLetter)() && $.get(isLetterLoaded)) $$render(consequent_3);
			}),
			'if',
			TKAGlyph,
			142,
			0
		);
	}

	$.append($$anchor, fragment);

	return $.pop({ ...$.legacy_api() });
}

if (import.meta.hot) {
	TKAGlyph = $.hmr(TKAGlyph, () => TKAGlyph[$.HMR].source);

	import.meta.hot.acceptExports(["default"],(module) => {
		$.cleanup_styles('s-X_6UOtCCgcv0');
		module.default[$.HMR].source = TKAGlyph[$.HMR].source;
		$.set(TKAGlyph[$.HMR].source, module.default[$.HMR].original);
	});
}

export default TKAGlyph;
import "/src/lib/components/pictograph/TKAGlyph.svelte?svelte&type=style&lang.css";

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6Ijs7Ozs7U0FRVywwQkFBbUI7U0FtQnhCOzs7Ozs7OztxQ0EzQk4sQ0FBQzs7OztLQXVESzs7RUFDQTs7RUFDRjs7RUFJRSxvQ0FBTTtFQUNOLG9DQUFNOzs7T0FLTixXQUFNOztLQUlOLDJDQUFtQjtLQUNqQiwrQkFBdUI7T0FHdkIsc0NBQW1COztnQkFHbkI7T0FDRjs7UUFJRixXQUFnQjs7TUFDZCxnQkFBUTtTQUNOLDhDQUF3QztTQUN4Qzs7O0VBR0Y7O01BRUY7U0FJTSxVQUFNO1NBQ1IsMENBQVE7O1FBQ1YsdUJBQ0EseUJBQTJCOztTQUU5QjtTQUdLLGVBQXFCLFFBQU0sTUFDL0I7O1FBS0ssY0FBWTtJQUViO1VBRUYsb0JBQWdCLE9BQVcsS0FBUSxRQUFTO0dBQzVDLE9BQU07O0tBRUY7O01BQ0YsT0FBUyxXQUFhLGFBQVMsQ0FBSyxLQUFFO01BQ3hDOzs7O0dBR0U7O0dBRUEsZ0JBQWdCLG9CQUFZLGdCQUFRO1NBQ3RDO0VBQ0YsUUFBUyxPQUFPO0dBQ2QsUUFBSSxrRkFDVyxhQUFnQyxLQUMvQztTQUdIO1NBSUssZ0JBQVk7RUFHaEI7Q0FDRDs7Q0FLQyxvQkFBTTtzQkFFSTtTQUNSLGdCQUFjO0dBQ1o7RUFBbUI7Q0FDTjs7T0FLYjt3QkFBaUI7bUNBQ0w7RUFBQTs7OztPQUliO3dCQUFBO1FBQ0g7O09BR0Q7VUFJSyxVQUFhLGFBQU87VUFDcEIsUUFBYyxRQUFHLE1BQU8sR0FBTSxhQUFTOzt3QkFFN0M7Y0FHUyxRQUFhLEtBQXVCO0lBQzNDOzs7S0FHRSxRQUFLO0tBQ0gsTUFBTztLQUNUOztHQUVGO1FBQ0Y7S0FHTSxnRkFBK0I7SUFDbkM7O2FBQ00sUUFBVTtHQUNoQjtFQUVBOzs7O09BR1M7d0JBQUE7VUFHTDs7Ozs7T0FJTDt3QkFBQTtTQUNPLGNBQUs7U0FDTjs7dUJBRUwsTUFBVSxNQUFDLFdBQVc7SUFDeEI7S0FDTSxPQUFNLFlBQVk7S0FDckI7S0FDRyxhQUFFOztHQUVWOzt1QkFFTSxNQUFRO0lBQ1I7S0FDQSxPQUFPLFlBQVk7S0FDcEI7OztHQUdEOztVQUVNO0VBQ1Y7Ozs7VUFHQSxnQkFBc0I7c0JBQ3RCLE9BQWlCO3NCQUNqQixRQUFnQixHQUFFLFdBQWEsTUFBSzs7U0FDcEMsTUFBWSxRQUFhO0NBQ3pCOzs7VUFJWTtRQUNEO1dBQ0k7O1FBQ2Y7V0FDWTs7O1dBRUE7O0NBRVo7O09BR0E7d0JBQTZCO1NBQ25CLGlCQUFNO1NBQ04sVUFBSTtTQUNMOztpREFHQSxTQUNILEdBQUcsaUJBQWMsU0FDakIsR0FBQzs7OztFQUVQOzs7Ozs7Ozs7Ozs7Ozs7OztzQ0F5QlE7Ozt3Q0FBQTs7Ozs7Ozs7Ozs2Q0FHQzs2Q0FDTTs7MENBVVY7MENBQ0Q7a0NBUU0sSUFBTTs7ZUFqQkQsWUFBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBUnRCLFNBQWlCOzs7Ozs7Ozs7Ozs7Ozs7bUNBbUNiLFFBQWdCLEdBQUcsRUFBRTs7Ozs7Ozs7Ozs7O2dDQUh2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzQ0EvQ08sVUFBZTtrREFDWjs7MkNBT0gsZ0JBQW9CLEVBQUMsS0FBSTs7Ozs0QkFEYixrQkFBYTs7Ozs7Ozs7O2NBWGxDLFNBQWEsYUFBTyxjQUFPOzs7Ozs7Ozs7Ozs7Q0FIM0IiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIlRLQUdseXBoLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8IS0tXG5US0FHbHlwaC5zdmVsdGUgLSBNb2Rlcm4gUnVuZS1CYXNlZCBUS0EgR2x5cGggQ29tcG9uZW50XG5cblJlbmRlcnMgbGV0dGVycywgdHVybiBpbmRpY2F0b3JzLCBhbmQgb3RoZXIgVEtBIG5vdGF0aW9uIGVsZW1lbnRzLlxuVXNlcyBwdXJlIHJ1bmVzIGluc3RlYWQgb2Ygc3RvcmVzIGZvciByZWFjdGl2aXR5LlxuLS0+XG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICBpbXBvcnQgeyBnZXRMZXR0ZXJJbWFnZVBhdGggfSBmcm9tIFwiJGxpYi91dGlscy9sZXR0ZXItdHlwZS1jbGFzc2lmaWNhdGlvblwiO1xuICBpbXBvcnQgeyBNb3Rpb25Db2xvciB9IGZyb20gXCIkbGliL2RvbWFpbi9lbnVtc1wiO1xuXG4gIGludGVyZmFjZSBQcm9wcyB7XG4gICAgLyoqIFRoZSBsZXR0ZXIgdG8gZGlzcGxheSAqL1xuICAgIGxldHRlcjogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgICAvKiogUG9zaXRpb24gWCBjb29yZGluYXRlICovXG4gICAgeD86IG51bWJlcjtcbiAgICAvKiogUG9zaXRpb24gWSBjb29yZGluYXRlICovXG4gICAgeT86IG51bWJlcjtcbiAgICAvKiogVHVybnMgdHVwbGUgaW4gZm9ybWF0IFwiKHMsIDAsIDApXCIgKi9cbiAgICB0dXJuc1R1cGxlPzogc3RyaW5nO1xuICAgIC8qKiBUZXh0IGNvbG9yICovXG4gICAgY29sb3I/OiBzdHJpbmc7XG4gICAgLyoqIERlYnVnIG1vZGUgKi9cbiAgICBkZWJ1Zz86IGJvb2xlYW47XG4gICAgLyoqIFNjYWxlIGZhY3RvciAtIG1hdGNoIGxlZ2FjeSBiZWhhdmlvciAqL1xuICAgIHNjYWxlPzogbnVtYmVyO1xuICB9XG5cbiAgbGV0IHtcbiAgICBsZXR0ZXIsXG4gICAgeCA9IDUwLCAvLyBNYXRjaCBsZWdhY3kgcG9zaXRpb25pbmcgZXhhY3RseVxuICAgIHkgPSA4MDAsIC8vIE1hdGNoIGxlZ2FjeSBwb3NpdGlvbmluZyBleGFjdGx5XG4gICAgdHVybnNUdXBsZSA9IFwiKHMsIDAsIDApXCIsXG4gICAgLy8gY29sb3IgPSAnIzRiNTU2MycsXG4gICAgZGVidWcgPSBmYWxzZSxcbiAgICBzY2FsZSA9IDEsIC8vIE1hdGNoIGxlZ2FjeSBkZWZhdWx0IHNjYWxlXG4gIH06IFByb3BzID0gJHByb3BzKCk7XG5cbiAgLy8gRm9udCBzaXplIGZvciB0aW1pbmcgaW5kaWNhdG9yc1xuICBjb25zdCBmb250U2l6ZSA9IDE2O1xuXG4gIC8vIExldHRlciBkaW1lbnNpb25zIHN0YXRlIC0gbWF0Y2ggbGVnYWN5IGJlaGF2aW9yXG4gIGxldCBsZXR0ZXJEaW1lbnNpb25zID0gJHN0YXRlKHsgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcbiAgbGV0IGlzTGV0dGVyTG9hZGVkID0gJHN0YXRlKGZhbHNlKTtcblxuICAvLyBDYWNoZSBmb3IgU1ZHIGRpbWVuc2lvbnMgKHNpbXBsZSBpbi1tZW1vcnkgY2FjaGUpXG4gIGNvbnN0IGRpbWVuc2lvbnNDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH0+KCk7XG5cbiAgLy8gTG9hZCBsZXR0ZXIgZGltZW5zaW9ucyB1c2luZyBTVkcgdmlld0JveCBsaWtlIGxlZ2FjeSB2ZXJzaW9uXG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWRMZXR0ZXJEaW1lbnNpb25zKGN1cnJlbnRMZXR0ZXI6IHN0cmluZykge1xuICAgIGlmICghY3VycmVudExldHRlcikgcmV0dXJuO1xuXG4gICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcbiAgICBjb25zdCBjYWNoZUtleSA9IGN1cnJlbnRMZXR0ZXI7XG4gICAgaWYgKGRpbWVuc2lvbnNDYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICBsZXR0ZXJEaW1lbnNpb25zID0gZGltZW5zaW9uc0NhY2hlLmdldChjYWNoZUtleSkhO1xuICAgICAgaXNMZXR0ZXJMb2FkZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgY29ycmVjdCBwYXRoIGJhc2VkIG9uIGxldHRlciB0eXBlIGFuZCBzYWZlIGZpbGVuYW1lXG4gICAgICBjb25zdCBzdmdQYXRoID0gZ2V0TGV0dGVySW1hZ2VQYXRoKGN1cnJlbnRMZXR0ZXIpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChzdmdQYXRoKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoICR7c3ZnUGF0aH06ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuXG4gICAgICBjb25zdCBzdmdUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgY29uc3Qgdmlld0JveE1hdGNoID0gc3ZnVGV4dC5tYXRjaChcbiAgICAgICAgL3ZpZXdCb3hcXHMqPVxccypcIltcXGQuLV0rXFxzK1tcXGQuLV0rXFxzKyhbXFxkLi1dKylcXHMrKFtcXGQuLV0rKVwiL2lcbiAgICAgICk7XG5cbiAgICAgIGlmICghdmlld0JveE1hdGNoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgU1ZHIGF0ICR7c3ZnUGF0aH0gaGFzIG5vIHZhbGlkIHZpZXdCb3gsIHVzaW5nIGRlZmF1bHRzYCk7XG4gICAgICAgIGxldHRlckRpbWVuc2lvbnMgPSB7IHdpZHRoOiAxMDAsIGhlaWdodDogMTAwIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXR0ZXJEaW1lbnNpb25zID0ge1xuICAgICAgICAgIHdpZHRoOiBwYXJzZUZsb2F0KHZpZXdCb3hNYXRjaFsxXSB8fCBcIjEwMFwiKSxcbiAgICAgICAgICBoZWlnaHQ6IHBhcnNlRmxvYXQodmlld0JveE1hdGNoWzJdIHx8IFwiMTAwXCIpLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBkaW1lbnNpb25zQ2FjaGUuc2V0KGNhY2hlS2V5LCBsZXR0ZXJEaW1lbnNpb25zKTtcbiAgICAgIGlzTGV0dGVyTG9hZGVkID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBsb2FkIGxldHRlciBkaW1lbnNpb25zIGZvciAke2N1cnJlbnRMZXR0ZXJ9OmAsXG4gICAgICAgIGVycm9yXG4gICAgICApO1xuICAgICAgLy8gRmFsbGJhY2sgZGltZW5zaW9uc1xuICAgICAgbGV0dGVyRGltZW5zaW9ucyA9IHsgd2lkdGg6IDUwLCBoZWlnaHQ6IDUwIH07XG4gICAgICBpc0xldHRlckxvYWRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gTG9hZCBkaW1lbnNpb25zIHdoZW4gbGV0dGVyIGNoYW5nZXNcbiAgJGVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGxldHRlcikge1xuICAgICAgaXNMZXR0ZXJMb2FkZWQgPSBmYWxzZTtcbiAgICAgIGxvYWRMZXR0ZXJEaW1lbnNpb25zKGxldHRlcik7XG4gICAgfVxuICB9KTtcblxuICAvLyBEZXJpdmVkIHN0YXRlIC0gY2hlY2sgaWYgd2UgaGF2ZSBhIHZhbGlkIGxldHRlclxuICBjb25zdCBoYXNMZXR0ZXIgPSAkZGVyaXZlZCgoKSA9PiB7XG4gICAgcmV0dXJuIGxldHRlciAhPSBudWxsICYmIGxldHRlci50cmltKCkgIT09IFwiXCI7XG4gIH0pO1xuXG4gIC8vIERlcml2ZWQgc3RhdGUgLSBwYXJzZSB0dXJucyB0dXBsZVxuICBjb25zdCBwYXJzZWRUdXJucyA9ICRkZXJpdmVkKCgpID0+IHtcbiAgICBpZiAoIXR1cm5zVHVwbGUpIHJldHVybiB7IHRpbWluZzogXCJzXCIsIGJsdWU6IDAsIHJlZDogMCB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFJlbW92ZSBwYXJlbnRoZXNlcyBhbmQgc3BsaXQgYnkgY29tbWFcbiAgICAgIGNvbnN0IGNsZWFuZWQgPSB0dXJuc1R1cGxlLnJlcGxhY2UoL1soKV0vZywgXCJcIikudHJpbSgpO1xuICAgICAgY29uc3QgcGFydHMgPSBjbGVhbmVkLnNwbGl0KFwiLFwiKS5tYXAoKHMpID0+IHMudHJpbSgpKTtcblxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICByZXR1cm4geyB0aW1pbmc6IFwic1wiLCBibHVlOiAwLCByZWQ6IDAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGltaW5nOiBwYXJ0c1swXSB8fCBcIlwiLFxuICAgICAgICBibHVlOiBwYXJzZUZsb2F0KHBhcnRzWzFdIHx8IFwiMFwiKSB8fCAwLFxuICAgICAgICByZWQ6IHBhcnNlRmxvYXQocGFydHNbMl0gfHwgXCIwXCIpIHx8IDAsXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHBhcnNlIHR1cm5zIHR1cGxlOlwiLCB0dXJuc1R1cGxlLCBlcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0aW1pbmc6IFwic1wiLCBibHVlOiAwLCByZWQ6IDAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIERlcml2ZWQgc3RhdGUgLSBjaGVjayBpZiB3ZSBzaG91bGQgc2hvdyB0dXJuIGluZGljYXRvcnNcbiAgLy8gVEVNUE9SQVJJTFkgRElTQUJMRUQ6IFR1cm4gaW5kaWNhdG9ycyB3ZXJlIGNyZWF0aW5nIENJUkNMRV9QUk9QIGR1cGxpY2F0ZXMgaW4gY29tcGFyaXNvbiB0ZXN0c1xuICBjb25zdCBzaG93VHVybnMgPSAkZGVyaXZlZCgoKSA9PiB7XG4gICAgLy8gY29uc3QgdHVybnMgPSBwYXJzZWRUdXJucygpO1xuICAgIC8vIHJldHVybiB0dXJucy5ibHVlICE9PSAwIHx8IHR1cm5zLnJlZCAhPT0gMDtcbiAgICByZXR1cm4gZmFsc2U7IC8vIERpc2FibGUgdHVybiBpbmRpY2F0b3JzIHRvIHByZXZlbnQgQ0lSQ0xFX1BST1AgZHVwbGljYXRlc1xuICB9KTtcblxuICAvLyBEZXJpdmVkIHN0YXRlIC0gZm9ybWF0IHR1cm4gZGlzcGxheXNcbiAgY29uc3QgdHVybkRpc3BsYXlzID0gJGRlcml2ZWQoKCkgPT4ge1xuICAgIGNvbnN0IHR1cm5zID0gcGFyc2VkVHVybnMoKTtcbiAgICBjb25zdCBkaXNwbGF5cyA9IFtdO1xuXG4gICAgaWYgKHR1cm5zLmJsdWUgIT09IDApIHtcbiAgICAgIGRpc3BsYXlzLnB1c2goe1xuICAgICAgICBjb2xvcjogTW90aW9uQ29sb3IuQkxVRSxcbiAgICAgICAgdmFsdWU6IHR1cm5zLmJsdWUsXG4gICAgICAgIGRpc3BsYXlUZXh0OiBmb3JtYXRUdXJuVmFsdWUodHVybnMuYmx1ZSksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHVybnMucmVkICE9PSAwKSB7XG4gICAgICBkaXNwbGF5cy5wdXNoKHtcbiAgICAgICAgY29sb3I6IE1vdGlvbkNvbG9yLlJFRCxcbiAgICAgICAgdmFsdWU6IHR1cm5zLnJlZCxcbiAgICAgICAgZGlzcGxheVRleHQ6IGZvcm1hdFR1cm5WYWx1ZSh0dXJucy5yZWQpLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpc3BsYXlzO1xuICB9KTtcblxuICAvLyBGb3JtYXQgdHVybiB2YWx1ZSBmb3IgZGlzcGxheVxuICBmdW5jdGlvbiBmb3JtYXRUdXJuVmFsdWUodmFsdWU6IG51bWJlcik6IHN0cmluZyB7XG4gICAgaWYgKHZhbHVlID09PSAwKSByZXR1cm4gXCJcIjtcbiAgICBpZiAodmFsdWUgJSAxID09PSAwKSByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTsgLy8gV2hvbGUgbnVtYmVyXG4gICAgcmV0dXJuIHZhbHVlLnRvRml4ZWQoMSk7IC8vIERlY2ltYWxcbiAgfVxuXG4gIC8vIEdldCBjb2xvciBmb3IgdHVybiBpbmRpY2F0b3JzXG4gIGZ1bmN0aW9uIGdldFR1cm5Db2xvcihjb2xvcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKGNvbG9yKSB7XG4gICAgICBjYXNlIFwiYmx1ZVwiOlxuICAgICAgICByZXR1cm4gXCIjM2I4MmY2XCI7XG4gICAgICBjYXNlIFwicmVkXCI6XG4gICAgICAgIHJldHVybiBcIiNlZjQ0NDRcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcIiM2YjcyODBcIjtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgcG9zaXRpb25zIGZvciB0dXJuIGluZGljYXRvcnNcbiAgY29uc3QgdHVyblBvc2l0aW9ucyA9ICRkZXJpdmVkKCgpID0+IHtcbiAgICBjb25zdCBkaXNwbGF5cyA9IHR1cm5EaXNwbGF5cygpO1xuICAgIGNvbnN0IHNwYWNpbmcgPSA0MDtcbiAgICBjb25zdCBzdGFydFggPSB4IC0gKChkaXNwbGF5cy5sZW5ndGggLSAxKSAqIHNwYWNpbmcpIC8gMjtcblxuICAgIHJldHVybiBkaXNwbGF5cy5tYXAoKGRpc3BsYXksIGluZGV4KSA9PiAoe1xuICAgICAgLi4uZGlzcGxheSxcbiAgICAgIHg6IHN0YXJ0WCArIGluZGV4ICogc3BhY2luZyxcbiAgICAgIHk6IHkgKyAzMCwgLy8gQmVsb3cgdGhlIGxldHRlclxuICAgIH0pKTtcbiAgfSk7XG48L3NjcmlwdD5cblxuPCEtLSBUS0EgR2x5cGggR3JvdXAgLS0+XG57I2lmIGhhc0xldHRlcigpICYmIGlzTGV0dGVyTG9hZGVkfVxuICA8Z1xuICAgIGNsYXNzPVwidGthLWdseXBoXCJcbiAgICBkYXRhLWxldHRlcj17bGV0dGVyfVxuICAgIGRhdGEtdHVybnM9e3R1cm5zVHVwbGV9XG4gICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKHt4fSwge3l9KSBzY2FsZSh7c2NhbGV9KVwiXG4gID5cbiAgICA8IS0tIE1haW4gbGV0dGVyIHdpdGggZXhhY3QgbGVnYWN5IGRpbWVuc2lvbnMgLS0+XG4gICAgPGltYWdlXG4gICAgICB4PVwiMFwiXG4gICAgICB5PVwiMFwiXG4gICAgICBocmVmPXtsZXR0ZXIgPyBnZXRMZXR0ZXJJbWFnZVBhdGgobGV0dGVyKSA6IFwiXCJ9XG4gICAgICB3aWR0aD17bGV0dGVyRGltZW5zaW9ucy53aWR0aH1cbiAgICAgIGhlaWdodD17bGV0dGVyRGltZW5zaW9ucy5oZWlnaHR9XG4gICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwieE1pbllNaW4gbWVldFwiXG4gICAgICBjbGFzcz1cImxldHRlci1pbWFnZVwiXG4gICAgLz5cblxuICAgIDwhLS0gVHVybiBpbmRpY2F0b3JzIC0tPlxuICAgIHsjaWYgc2hvd1R1cm5zKCl9XG4gICAgICA8ZyBjbGFzcz1cInR1cm4taW5kaWNhdG9yc1wiPlxuICAgICAgICB7I2VhY2ggdHVyblBvc2l0aW9ucygpIGFzIHR1cm4gKHR1cm4uY29sb3IpfVxuICAgICAgICAgIDwhLS0gVHVybiBjaXJjbGUgYmFja2dyb3VuZCAtLT5cbiAgICAgICAgICA8Y2lyY2xlXG4gICAgICAgICAgICBjeD17dHVybi54fVxuICAgICAgICAgICAgY3k9e3R1cm4ueX1cbiAgICAgICAgICAgIHI9XCIxMlwiXG4gICAgICAgICAgICBmaWxsPXtnZXRUdXJuQ29sb3IodHVybi5jb2xvcil9XG4gICAgICAgICAgICBzdHJva2U9XCJ3aGl0ZVwiXG4gICAgICAgICAgICBzdHJva2Utd2lkdGg9XCIyXCJcbiAgICAgICAgICAgIG9wYWNpdHk9XCIwLjlcIlxuICAgICAgICAgIC8+XG5cbiAgICAgICAgICA8IS0tIFR1cm4gdmFsdWUgdGV4dCAtLT5cbiAgICAgICAgICA8dGV4dFxuICAgICAgICAgICAgeD17dHVybi54fVxuICAgICAgICAgICAgeT17dHVybi55fVxuICAgICAgICAgICAgdGV4dC1hbmNob3I9XCJtaWRkbGVcIlxuICAgICAgICAgICAgZG9taW5hbnQtYmFzZWxpbmU9XCJtaWRkbGVcIlxuICAgICAgICAgICAgZm9udC1mYW1pbHk9XCJBcmlhbCwgc2Fucy1zZXJpZlwiXG4gICAgICAgICAgICBmb250LXNpemU9XCIxMVwiXG4gICAgICAgICAgICBmb250LXdlaWdodD1cImJvbGRcIlxuICAgICAgICAgICAgZmlsbD1cIndoaXRlXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICB7dHVybi5kaXNwbGF5VGV4dH1cbiAgICAgICAgICA8L3RleHQ+XG4gICAgICAgIHsvZWFjaH1cbiAgICAgIDwvZz5cbiAgICB7L2lmfVxuXG4gICAgPCEtLSBUaW1pbmcgaW5kaWNhdG9yIChpZiBub3QgJ3MnIC0gc2ltdWx0YW5lb3VzKSAtLT5cbiAgICB7I2lmIHBhcnNlZFR1cm5zKCkudGltaW5nICE9PSBcInNcIn1cbiAgICAgIDx0ZXh0XG4gICAgICAgIHg9XCIwXCJcbiAgICAgICAgeT17LWZvbnRTaXplIC0gMTB9XG4gICAgICAgIHRleHQtYW5jaG9yPVwibWlkZGxlXCJcbiAgICAgICAgZm9udC1mYW1pbHk9XCJBcmlhbCwgc2Fucy1zZXJpZlwiXG4gICAgICAgIGZvbnQtc2l6ZT17Zm9udFNpemUgKiAwLjZ9XG4gICAgICAgIGZvbnQtd2VpZ2h0PVwibm9ybWFsXCJcbiAgICAgICAgZmlsbD1cIiM2YjcyODBcIlxuICAgICAgICBvcGFjaXR5PVwiMC44XCJcbiAgICAgID5cbiAgICAgICAge3BhcnNlZFR1cm5zKCk/LnRpbWluZz8udG9VcHBlckNhc2UoKSB8fCBcIlwifVxuICAgICAgPC90ZXh0PlxuICAgIHsvaWZ9XG5cbiAgICB7I2lmIGRlYnVnfVxuICAgICAgPCEtLSBEZWJ1ZyBvdmVybGF5IC0tPlxuICAgICAgPGcgY2xhc3M9XCJkZWJ1Zy1vdmVybGF5XCI+XG4gICAgICAgIDwhLS0gUG9zaXRpb24gaW5kaWNhdG9yIC0tPlxuICAgICAgICA8Y2lyY2xlIHg9XCIwXCIgeT1cIjBcIiByPVwiM1wiIGZpbGw9XCIjOGI1Y2Y2XCIgb3BhY2l0eT1cIjAuOFwiIC8+XG5cbiAgICAgICAgPCEtLSBEZWJ1ZyBpbmZvIC0tPlxuICAgICAgICA8dGV4dFxuICAgICAgICAgIHg9XCIyMFwiXG4gICAgICAgICAgeT1cIi0yMFwiXG4gICAgICAgICAgZm9udC1zaXplPVwiOFwiXG4gICAgICAgICAgZmlsbD1cIiM4YjVjZjZcIlxuICAgICAgICAgIGZvbnQtZmFtaWx5PVwibW9ub3NwYWNlXCJcbiAgICAgICAgPlxuICAgICAgICAgIExldHRlcjoge2xldHRlcn1cbiAgICAgICAgPC90ZXh0PlxuICAgICAgICA8dGV4dFxuICAgICAgICAgIHg9XCIyMFwiXG4gICAgICAgICAgeT1cIi0xMFwiXG4gICAgICAgICAgZm9udC1zaXplPVwiOFwiXG4gICAgICAgICAgZmlsbD1cIiM4YjVjZjZcIlxuICAgICAgICAgIGZvbnQtZmFtaWx5PVwibW9ub3NwYWNlXCJcbiAgICAgICAgPlxuICAgICAgICAgIFR1cm5zOiB7dHVybnNUdXBsZX1cbiAgICAgICAgPC90ZXh0PlxuICAgICAgPC9nPlxuICAgIHsvaWZ9XG4gIDwvZz5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgLnRrYS1nbHlwaCB7XG4gICAgLyogR2x5cGhzIGFyZSByZW5kZXJlZCBvbiB0b3AgbGF5ZXIgYWJvdmUgYXJyb3dzICovXG4gICAgei1pbmRleDogNDtcbiAgfVxuXG4gIC5sZXR0ZXItaW1hZ2Uge1xuICAgIC8qIFNtb290aCBpbWFnZSByZW5kZXJpbmcgKi9cbiAgICBpbWFnZS1yZW5kZXJpbmc6IG9wdGltaXplUXVhbGl0eTtcbiAgfVxuXG4gIC50dXJuLWluZGljYXRvcnMgY2lyY2xlIHtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4ycyBlYXNlO1xuICB9XG5cbiAgLnR1cm4taW5kaWNhdG9ycyBjaXJjbGU6aG92ZXIge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMS4xKTtcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7XG4gIH1cblxuICAuZGVidWctb3ZlcmxheSB7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIH1cbjwvc3R5bGU+XG4iXSwiZmlsZSI6IkY6L0NPREUvVEtBL3dlYi9zcmMvbGliL2NvbXBvbmVudHMvcGljdG9ncmFwaC9US0FHbHlwaC5zdmVsdGUifQ==