import { createHotContext as __vite__createHotContext } from "/@vite/client";import.meta.hot = __vite__createHotContext("/src/lib/components/pictograph/Grid.svelte");import "/node_modules/.vite/deps/svelte_internal_disclose-version.js?v=cc8aba6c";

Grid[$.FILENAME] = 'src/lib/components/pictograph/Grid.svelte';

import * as $ from "/node_modules/.vite/deps/svelte_internal_client.js?v=cc8aba6c";
import { createGridData } from "/src/lib/data/gridCoordinates.ts";

var root_1 = $.add_locations($.from_svg(`<image x="0" y="0" width="950" height="950" preserveAspectRatio="none" class="s-D5eydLQZOhBn"></image>`), Grid[$.FILENAME], [[92, 4]]);
var root_5 = $.add_locations($.from_svg(`<circle r="2" fill="#ef4444" class="s-D5eydLQZOhBn"></circle><text font-size="8" fill="#ef4444" font-family="monospace" class="s-D5eydLQZOhBn"> </text>`, 1), Grid[$.FILENAME], [[121, 12], [127, 12]]);
var root_2 = $.add_locations($.from_svg(`<g class="fallback-grid s-D5eydLQZOhBn"><path fill="none" stroke="#e5e7eb" stroke-width="2" stroke-dasharray="5,5" class="s-D5eydLQZOhBn"></path><circle cx="475" cy="475" r="3" fill="#9ca3af" class="s-D5eydLQZOhBn"></circle><!></g>`), Grid[$.FILENAME], [[105, 4, [[106, 6], [115, 6]]]]);
var root_6 = $.add_locations($.from_svg(`<g class="debug-overlay s-D5eydLQZOhBn"><rect x="10" y="10" width="200" height="60" fill="rgba(0, 0, 0, 0.8)" rx="4" class="s-D5eydLQZOhBn"></rect><text x="20" y="30" font-size="12" fill="white" font-family="monospace" class="s-D5eydLQZOhBn"> </text><text x="20" y="45" font-size="10" fill="white" font-family="monospace" class="s-D5eydLQZOhBn"> </text><text x="20" y="60" font-size="10" fill="white" font-family="monospace" class="s-D5eydLQZOhBn"> </text></g>`), Grid[$.FILENAME], [[144, 4, [[145, 6], [153, 6], [156, 6], [159, 6]]]]);
var root = $.add_locations($.from_svg(`<g><!><!></g>`), Grid[$.FILENAME], [[84, 0]]);

function Grid($$anchor, $$props) {
	$.check_target(new.target);
	$.push($$props, true, Grid);

	let gridMode = $.prop($$props, 'gridMode', 3, "diamond"),
		debug = $.prop($$props, 'debug', 3, false);

	let isLoaded = $.tag($.state(false), 'isLoaded');
	let hasError = $.tag($.state(false), 'hasError');
	let errorMessage = $.tag($.state(null), 'errorMessage');
	let _imageElement = $.tag($.state(null), '_imageElement');

	const gridImagePath = $.tag(
		$.derived(() => () => {
			return `/images/grid/${gridMode()}_grid.svg`;
		}),
		'gridImagePath'
	);

	const gridData = $.tag(
		$.derived(() => () => {
			return createGridData(gridMode());
		}),
		'gridData'
	);

	$.user_effect(() => {
		$.set(isLoaded, false);
		$.set(hasError, false);
		$.set(errorMessage, null);

		if (debug()) {
			console.log(`Grid: Loading ${gridMode()} grid from ${$.get(gridImagePath)()}`);
		}
	});

	function handleImageLoad() {
		$.set(isLoaded, true);
		$.set(hasError, false);
		$.set(errorMessage, null);

		if (debug()) {
			console.log(`Grid: Successfully loaded ${gridMode()} grid`);
		}

		$$props.onLoaded?.();
	}

	function handleImageError() {
		$.set(hasError, true);
		$.set(errorMessage, `Failed to load ${gridMode()} grid image`);

		if (debug()) {
			console.error(`Grid: ${$.get(errorMessage)}`);
		}

		$$props.onError?.($.get(errorMessage));
		$$props.onLoaded?.();
	}

	const fallbackGridPath = $.tag(
		$.derived(() => () => {
			const data = $.get(gridData)();

			if ($.strict_equals(gridMode(), "diamond")) {
				const points = [
					data.allHandPointsNormal.n_diamond_hand_point?.coordinates,
					data.allHandPointsNormal.e_diamond_hand_point?.coordinates,
					data.allHandPointsNormal.s_diamond_hand_point?.coordinates,
					data.allHandPointsNormal.w_diamond_hand_point?.coordinates
				].filter(Boolean);

				if ($.strict_equals(points.length, 4)) {
					return `M ${points[0].x},${points[0].y} L ${points[1].x},${points[1].y} L ${points[2].x},${points[2].y} L ${points[3].x},${points[3].y} Z`;
				}
			} else {
				const points = [
					data.allHandPointsNormal.nw_box_hand_point?.coordinates,
					data.allHandPointsNormal.ne_box_hand_point?.coordinates,
					data.allHandPointsNormal.se_box_hand_point?.coordinates,
					data.allHandPointsNormal.sw_box_hand_point?.coordinates
				].filter(Boolean);

				if ($.strict_equals(points.length, 4)) {
					return `M ${points[0].x},${points[0].y} L ${points[1].x},${points[1].y} L ${points[2].x},${points[2].y} L ${points[3].x},${points[3].y} Z`;
				}
			}

			const center = { x: 475, y: 475 };
			const size = 143;

			if ($.strict_equals(gridMode(), "diamond")) {
				return `M ${center.x},${center.y - size} L ${center.x + size},${center.y} L ${center.x},${center.y + size} L ${center.x - size},${center.y} Z`;
			} else {
				return `M ${center.x - size},${center.y - size} L ${center.x + size},${center.y - size} L ${center.x + size},${center.y + size} L ${center.x - size},${center.y + size} Z`;
			}
		}),
		'fallbackGridPath'
	);

	var g = root();
	let classes;
	var node = $.child(g);

	{
		var consequent = ($$anchor) => {
			var image = root_1();

			$.bind_this(image, ($$value) => $.set(_imageElement, $$value), () => $.get(_imageElement));
			$.template_effect(($0) => $.set_attribute(image, 'href', $0), [() => $.get(gridImagePath)()]);
			$.event('load', image, handleImageLoad);
			$.event('error', image, handleImageError);
			$.append($$anchor, image);
		};

		var alternate = ($$anchor) => {
			var g_1 = root_2();
			var path = $.child(g_1);
			var node_1 = $.sibling(path, 2);

			{
				var consequent_2 = ($$anchor) => {
					var fragment = $.comment();
					var node_2 = $.first_child(fragment);

					$.add_svelte_meta(
						() => $.each(node_2, 17, () => Object.entries($.get(gridData)().allHandPointsNormal), $.index, ($$anchor, $$item) => {
							var $$array = $.derived(() => $.to_array($.get($$item), 2));
							let key = () => $.get($$array)[0];

							key();

							let point = () => $.get($$array)[1];

							point();

							var fragment_1 = $.comment();
							var node_3 = $.first_child(fragment_1);

							{
								var consequent_1 = ($$anchor) => {
									var fragment_2 = root_5();
									var circle = $.first_child(fragment_2);
									var text = $.sibling(circle);
									var text_1 = $.child(text, true);

									$.reset(text);

									$.template_effect(
										($0) => {
											$.set_attribute(circle, 'cx', point().coordinates.x);
											$.set_attribute(circle, 'cy', point().coordinates.y);
											$.set_attribute(text, 'x', point().coordinates.x + 5);
											$.set_attribute(text, 'y', point().coordinates.y - 5);
											$.set_text(text_1, $0);
										},
										[
											() => key().replace("_hand_point", "").replace(`_${gridMode()}`, "")
										]
									);

									$.append($$anchor, fragment_2);
								};

								$.add_svelte_meta(
									() => $.if(node_3, ($$render) => {
										if (point().coordinates) $$render(consequent_1);
									}),
									'if',
									Grid,
									120,
									10
								);
							}

							$.append($$anchor, fragment_1);
						}),
						'each',
						Grid,
						119,
						8
					);

					$.append($$anchor, fragment);
				};

				$.add_svelte_meta(
					() => $.if(node_1, ($$render) => {
						if (debug()) $$render(consequent_2);
					}),
					'if',
					Grid,
					117,
					6
				);
			}

			$.reset(g_1);
			$.template_effect(($0) => $.set_attribute(path, 'd', $0), [() => $.get(fallbackGridPath)()]);
			$.append($$anchor, g_1);
		};

		$.add_svelte_meta(
			() => $.if(node, ($$render) => {
				if (!$.get(hasError)) $$render(consequent); else $$render(alternate, false);
			}),
			'if',
			Grid,
			90,
			2
		);
	}

	var node_4 = $.sibling(node);

	{
		var consequent_3 = ($$anchor) => {
			var g_2 = root_6();
			var text_2 = $.sibling($.child(g_2));
			var text_3 = $.child(text_2);

			$.reset(text_2);

			var text_4 = $.sibling(text_2);
			var text_5 = $.child(text_4);

			$.reset(text_4);

			var text_6 = $.sibling(text_4);
			var text_7 = $.child(text_6);

			$.reset(text_6);
			$.reset(g_2);

			$.template_effect(() => {
				$.set_text(text_3, `Grid: ${gridMode() ?? ''}`);
				$.set_text(text_5, `Loaded: ${$.get(isLoaded) ? "YES" : "NO"}`);
				$.set_text(text_7, `Error: ${$.get(hasError) ? "YES" : "NO"}`);
			});

			$.append($$anchor, g_2);
		};

		$.add_svelte_meta(
			() => $.if(node_4, ($$render) => {
				if (debug()) $$render(consequent_3);
			}),
			'if',
			Grid,
			142,
			2
		);
	}

	$.reset(g);

	$.template_effect(
		($0) => {
			classes = $.set_class(g, 0, 'grid s-D5eydLQZOhBn', null, classes, $0);
			$.set_attribute(g, 'data-grid-mode', gridMode());
		},
		[
			() => ({
				'grid-loaded': $.get(isLoaded),
				'grid-error': $.get(hasError)
			})
		]
	);

	$.append($$anchor, g);

	return $.pop({ ...$.legacy_api() });
}

if (import.meta.hot) {
	Grid = $.hmr(Grid, () => Grid[$.HMR].source);

	import.meta.hot.acceptExports(["default"],(module) => {
		$.cleanup_styles('s-D5eydLQZOhBn');
		module.default[$.HMR].source = Grid[$.HMR].source;
		$.set(Grid[$.HMR].source, module.default[$.HMR].original);
	});
}

export default Grid;
import "/src/lib/components/pictograph/Grid.svelte?svelte&type=style&lang.css";

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6Ijs7Ozs7U0FvQk07Ozs7Ozs7O2lDQXBCTixDQUFDOzs7O0tBeUNHLDBDQUFPO0VBS1A7O0tBS0UseUJBQVk7S0FDZDtLQUNEO0tBSUMsOEJBQVc7O09BSVA7d0JBQU87MEJBQ0c7RUFDZDs7OztPQUtGO3dCQUE0QjtVQUMxQixlQUFXO0VBQ1g7Ozs7Q0FJQTtRQUVBLFVBQVU7UUFHVixVQUFXO1FBQ2I7O01BSVEsU0FBTztHQUVULDZCQUF3QjtFQUUxQjtDQUFlOztVQUlSO1FBQ1AsVUFBUztRQUVULFVBQVc7UUFDVCxjQUFZOztNQUVoQixTQUFPO0dBRUwsUUFBTSxpQ0FBUztFQUFBOzs7Q0FHK0I7O1VBSTFDLG1CQUFxQjtRQUN2QixVQUFPO1FBQ1Q7O01BSUk7R0FDTixRQUFNLHFCQUFPO0VBRWI7OzBCQUVPOztDQUlUOztPQUdEO3dCQUFBO1NBQ1EsYUFBSTs7dUJBRUwsWUFBWSxZQUFRO1VBRTVCO0tBQ1EseUJBQVE7S0FDUixLQUFDLG9CQUFxQjtLQUN6QjtLQUNDLEtBQUssb0JBQW1CO01BQ3hCLE9BQU07O3dCQUVGO2lCQUNNO0lBQ1Y7R0FDTixPQUFNO1VBRUE7S0FDRDtLQUNHO0tBQ0EsS0FBQyxvQkFBd0IsbUJBQUU7S0FDNUIsS0FBTSxvQkFBZTtNQUNyQjs7d0JBRUMsT0FBTSxRQUFJO2lCQUNELE9BQU07SUFDdkI7R0FDQTs7U0FHVSxXQUFRLEdBQU0sS0FBRTtTQUNuQixPQUFVOzt1QkFFVCxZQUFRO2dCQUNFLE9BQU8sQ0FBQyxJQUFFO0dBQzVCLE9BQVU7Z0JBQ0ssT0FBTSxRQUFXO0dBQ2hDO0VBQ0E7Ozs7Ozs7Ozs7Ozt5Q0FhYyxhQUFJLHdCQUFKLGFBQUk7OEVBQ04sYUFBRTswQkFNRjsyQkFDRyxnQkFBZ0I7Ozs7Ozs7Ozs7Ozs7OztxQ0FrQm5COztXQUFBOzs7O1dBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5Q0FHVDs7c0NBTUQ7Ozs7Ozs7Ozs7Ozs7O2NBUks7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VUFISSxLQUFJOzs7Ozs7Ozs7OzBFQVZQLGdCQUFVOzs7Ozs7ZUFqQmxCLFFBQWM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0NBRkksUUFBUTs7Ozt5QkFGVCxRQUFNO3dCQUNOLFFBQU07Ozs7Ozs7O0NBTnZCIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJHcmlkLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8IS0tXG5HcmlkLnN2ZWx0ZSAtIE1vZGVybiBSdW5lLUJhc2VkIEdyaWQgQ29tcG9uZW50XG5cblJlbmRlcnMgdGhlIGRpYW1vbmQgb3IgYm94IGdyaWQgYmFja2dyb3VuZCB1c2luZyByZWFsIFNWRyBhc3NldHMuXG5Vc2VzIHB1cmUgcnVuZXMgaW5zdGVhZCBvZiBzdG9yZXMgZm9yIHJlYWN0aXZpdHkuXG4tLT5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gIGltcG9ydCB7IGNyZWF0ZUdyaWREYXRhIH0gZnJvbSBcIiRsaWIvZGF0YS9ncmlkQ29vcmRpbmF0ZXNcIjtcblxuICBpbnRlcmZhY2UgUHJvcHMge1xuICAgIC8qKiBHcmlkIG1vZGUgLSBkaWFtb25kIG9yIGJveCAqL1xuICAgIGdyaWRNb2RlPzogXCJkaWFtb25kXCIgfCBcImJveFwiO1xuICAgIC8qKiBDYWxsZWQgd2hlbiBncmlkIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWQgKi9cbiAgICBvbkxvYWRlZD86ICgpID0+IHZvaWQ7XG4gICAgLyoqIENhbGxlZCB3aGVuIGdyaWQgbG9hZGluZyBmYWlscyAqL1xuICAgIG9uRXJyb3I/OiAoZXJyb3I6IHN0cmluZykgPT4gdm9pZDtcbiAgICAvKiogRGVidWcgbW9kZSAqL1xuICAgIGRlYnVnPzogYm9vbGVhbjtcbiAgfVxuXG4gIGxldCB7XG4gICAgZ3JpZE1vZGUgPSBcImRpYW1vbmRcIixcbiAgICBvbkxvYWRlZCxcbiAgICBvbkVycm9yLFxuICAgIGRlYnVnID0gZmFsc2UsXG4gIH06IFByb3BzID0gJHByb3BzKCk7XG5cbiAgLy8gU3RhdGUgdXNpbmcgcnVuZXNcbiAgbGV0IGlzTG9hZGVkID0gJHN0YXRlKGZhbHNlKTtcbiAgbGV0IGhhc0Vycm9yID0gJHN0YXRlKGZhbHNlKTtcbiAgbGV0IGVycm9yTWVzc2FnZSA9ICRzdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgLy8gSW1hZ2UgZWxlbWVudCBmb3IgcG90ZW50aWFsIGZ1dHVyZSB1c2VcbiAgbGV0IF9pbWFnZUVsZW1lbnQgPSAkc3RhdGU8U1ZHSW1hZ2VFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gRGVyaXZlZCBzdGF0ZSAtIGdyaWQgaW1hZ2UgcGF0aFxuICBjb25zdCBncmlkSW1hZ2VQYXRoID0gJGRlcml2ZWQoKCkgPT4ge1xuICAgIHJldHVybiBgL2ltYWdlcy9ncmlkLyR7Z3JpZE1vZGV9X2dyaWQuc3ZnYDtcbiAgfSk7XG5cbiAgLy8gRGVyaXZlZCBzdGF0ZSAtIGdyaWQgZGF0YSBmb3IgcG9zaXRpb25pbmcgKGluIGNhc2UgcGFyZW50IGNvbXBvbmVudHMgbmVlZCBpdClcbiAgY29uc3QgZ3JpZERhdGEgPSAkZGVyaXZlZCgoKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZUdyaWREYXRhKGdyaWRNb2RlKTtcbiAgfSk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBsb2FkaW5nIHN0YXRlIHdoZW4gZ3JpZCBtb2RlIGNoYW5nZXNcbiAgJGVmZmVjdCgoKSA9PiB7XG4gICAgaXNMb2FkZWQgPSBmYWxzZTtcbiAgICBoYXNFcnJvciA9IGZhbHNlO1xuICAgIGVycm9yTWVzc2FnZSA9IG51bGw7XG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBHcmlkOiBMb2FkaW5nICR7Z3JpZE1vZGV9IGdyaWQgZnJvbSAke2dyaWRJbWFnZVBhdGgoKX1gKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEV2ZW50IGhhbmRsZXJzXG4gIGZ1bmN0aW9uIGhhbmRsZUltYWdlTG9hZCgpIHtcbiAgICBpc0xvYWRlZCA9IHRydWU7XG4gICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICBlcnJvck1lc3NhZ2UgPSBudWxsO1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhgR3JpZDogU3VjY2Vzc2Z1bGx5IGxvYWRlZCAke2dyaWRNb2RlfSBncmlkYCk7XG4gICAgfVxuXG4gICAgb25Mb2FkZWQ/LigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlSW1hZ2VFcnJvcigpIHtcbiAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgZXJyb3JNZXNzYWdlID0gYEZhaWxlZCB0byBsb2FkICR7Z3JpZE1vZGV9IGdyaWQgaW1hZ2VgO1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBHcmlkOiAke2Vycm9yTWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBvbkVycm9yPy4oZXJyb3JNZXNzYWdlKTtcblxuICAgIC8vIFN0aWxsIGNhbGwgb25Mb2FkZWQgdG8gcHJldmVudCBibG9ja2luZyB0aGUgcGFyZW50IGNvbXBvbmVudFxuICAgIG9uTG9hZGVkPy4oKTtcbiAgfVxuXG4gIC8vIEZhbGxiYWNrIGdyaWQgcmVuZGVyaW5nIHVzaW5nIGNvb3JkaW5hdGVzXG4gIGNvbnN0IGZhbGxiYWNrR3JpZFBhdGggPSAkZGVyaXZlZCgoKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGdyaWREYXRhKCk7XG5cbiAgICBpZiAoZ3JpZE1vZGUgPT09IFwiZGlhbW9uZFwiKSB7XG4gICAgICAvLyBDcmVhdGUgZGlhbW9uZCBzaGFwZSBmcm9tIGhhbmQgcG9pbnRzXG4gICAgICBjb25zdCBwb2ludHMgPSBbXG4gICAgICAgIGRhdGEuYWxsSGFuZFBvaW50c05vcm1hbC5uX2RpYW1vbmRfaGFuZF9wb2ludD8uY29vcmRpbmF0ZXMsXG4gICAgICAgIGRhdGEuYWxsSGFuZFBvaW50c05vcm1hbC5lX2RpYW1vbmRfaGFuZF9wb2ludD8uY29vcmRpbmF0ZXMsXG4gICAgICAgIGRhdGEuYWxsSGFuZFBvaW50c05vcm1hbC5zX2RpYW1vbmRfaGFuZF9wb2ludD8uY29vcmRpbmF0ZXMsXG4gICAgICAgIGRhdGEuYWxsSGFuZFBvaW50c05vcm1hbC53X2RpYW1vbmRfaGFuZF9wb2ludD8uY29vcmRpbmF0ZXMsXG4gICAgICBdLmZpbHRlcihCb29sZWFuKTtcblxuICAgICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgcmV0dXJuIGBNICR7cG9pbnRzWzBdIS54fSwke3BvaW50c1swXSEueX0gTCAke3BvaW50c1sxXSEueH0sJHtwb2ludHNbMV0hLnl9IEwgJHtwb2ludHNbMl0hLnh9LCR7cG9pbnRzWzJdIS55fSBMICR7cG9pbnRzWzNdIS54fSwke3BvaW50c1szXSEueX0gWmA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyZWF0ZSBib3ggc2hhcGUgZnJvbSBoYW5kIHBvaW50c1xuICAgICAgY29uc3QgcG9pbnRzID0gW1xuICAgICAgICBkYXRhLmFsbEhhbmRQb2ludHNOb3JtYWwubndfYm94X2hhbmRfcG9pbnQ/LmNvb3JkaW5hdGVzLFxuICAgICAgICBkYXRhLmFsbEhhbmRQb2ludHNOb3JtYWwubmVfYm94X2hhbmRfcG9pbnQ/LmNvb3JkaW5hdGVzLFxuICAgICAgICBkYXRhLmFsbEhhbmRQb2ludHNOb3JtYWwuc2VfYm94X2hhbmRfcG9pbnQ/LmNvb3JkaW5hdGVzLFxuICAgICAgICBkYXRhLmFsbEhhbmRQb2ludHNOb3JtYWwuc3dfYm94X2hhbmRfcG9pbnQ/LmNvb3JkaW5hdGVzLFxuICAgICAgXS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICAgIGlmIChwb2ludHMubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHJldHVybiBgTSAke3BvaW50c1swXSEueH0sJHtwb2ludHNbMF0hLnl9IEwgJHtwb2ludHNbMV0hLnh9LCR7cG9pbnRzWzFdIS55fSBMICR7cG9pbnRzWzJdIS54fSwke3BvaW50c1syXSEueX0gTCAke3BvaW50c1szXSEueH0sJHtwb2ludHNbM10hLnl9IFpgO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVsdGltYXRlIGZhbGxiYWNrIC0gc2ltcGxlIGNlbnRlcmVkIHNoYXBlXG4gICAgY29uc3QgY2VudGVyID0geyB4OiA0NzUsIHk6IDQ3NSB9O1xuICAgIGNvbnN0IHNpemUgPSAxNDM7XG5cbiAgICBpZiAoZ3JpZE1vZGUgPT09IFwiZGlhbW9uZFwiKSB7XG4gICAgICByZXR1cm4gYE0gJHtjZW50ZXIueH0sJHtjZW50ZXIueSAtIHNpemV9IEwgJHtjZW50ZXIueCArIHNpemV9LCR7Y2VudGVyLnl9IEwgJHtjZW50ZXIueH0sJHtjZW50ZXIueSArIHNpemV9IEwgJHtjZW50ZXIueCAtIHNpemV9LCR7Y2VudGVyLnl9IFpgO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYE0gJHtjZW50ZXIueCAtIHNpemV9LCR7Y2VudGVyLnkgLSBzaXplfSBMICR7Y2VudGVyLnggKyBzaXplfSwke2NlbnRlci55IC0gc2l6ZX0gTCAke2NlbnRlci54ICsgc2l6ZX0sJHtjZW50ZXIueSArIHNpemV9IEwgJHtjZW50ZXIueCAtIHNpemV9LCR7Y2VudGVyLnkgKyBzaXplfSBaYDtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjwhLS0gR3JpZCBHcm91cCAtLT5cbjxnXG4gIGNsYXNzPVwiZ3JpZFwiXG4gIGNsYXNzOmdyaWQtbG9hZGVkPXtpc0xvYWRlZH1cbiAgY2xhc3M6Z3JpZC1lcnJvcj17aGFzRXJyb3J9XG4gIGRhdGEtZ3JpZC1tb2RlPXtncmlkTW9kZX1cbj5cbiAgeyNpZiAhaGFzRXJyb3J9XG4gICAgPCEtLSBQcmltYXJ5IGdyaWQgaW1hZ2UgLS0+XG4gICAgPGltYWdlXG4gICAgICBiaW5kOnRoaXM9e19pbWFnZUVsZW1lbnR9XG4gICAgICBocmVmPXtncmlkSW1hZ2VQYXRoKCl9XG4gICAgICB4PVwiMFwiXG4gICAgICB5PVwiMFwiXG4gICAgICB3aWR0aD1cIjk1MFwiXG4gICAgICBoZWlnaHQ9XCI5NTBcIlxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbz1cIm5vbmVcIlxuICAgICAgb25sb2FkPXtoYW5kbGVJbWFnZUxvYWR9XG4gICAgICBvbmVycm9yPXtoYW5kbGVJbWFnZUVycm9yfVxuICAgIC8+XG4gIHs6ZWxzZX1cbiAgICA8IS0tIEZhbGxiYWNrIGdyaWQgcmVuZGVyaW5nIC0tPlxuICAgIDxnIGNsYXNzPVwiZmFsbGJhY2stZ3JpZFwiPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD17ZmFsbGJhY2tHcmlkUGF0aCgpfVxuICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgIHN0cm9rZT1cIiNlNWU3ZWJcIlxuICAgICAgICBzdHJva2Utd2lkdGg9XCIyXCJcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheT1cIjUsNVwiXG4gICAgICAvPlxuXG4gICAgICA8IS0tIENlbnRlciBwb2ludCAtLT5cbiAgICAgIDxjaXJjbGUgY3g9XCI0NzVcIiBjeT1cIjQ3NVwiIHI9XCIzXCIgZmlsbD1cIiM5Y2EzYWZcIiAvPlxuXG4gICAgICB7I2lmIGRlYnVnfVxuICAgICAgICA8IS0tIERlYnVnIHBvaW50cyAtLT5cbiAgICAgICAgeyNlYWNoIE9iamVjdC5lbnRyaWVzKGdyaWREYXRhKCkuYWxsSGFuZFBvaW50c05vcm1hbCkgYXMgW2tleSwgcG9pbnRdfVxuICAgICAgICAgIHsjaWYgcG9pbnQuY29vcmRpbmF0ZXN9XG4gICAgICAgICAgICA8Y2lyY2xlXG4gICAgICAgICAgICAgIGN4PXtwb2ludC5jb29yZGluYXRlcy54fVxuICAgICAgICAgICAgICBjeT17cG9pbnQuY29vcmRpbmF0ZXMueX1cbiAgICAgICAgICAgICAgcj1cIjJcIlxuICAgICAgICAgICAgICBmaWxsPVwiI2VmNDQ0NFwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPHRleHRcbiAgICAgICAgICAgICAgeD17cG9pbnQuY29vcmRpbmF0ZXMueCArIDV9XG4gICAgICAgICAgICAgIHk9e3BvaW50LmNvb3JkaW5hdGVzLnkgLSA1fVxuICAgICAgICAgICAgICBmb250LXNpemU9XCI4XCJcbiAgICAgICAgICAgICAgZmlsbD1cIiNlZjQ0NDRcIlxuICAgICAgICAgICAgICBmb250LWZhbWlseT1cIm1vbm9zcGFjZVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtrZXkucmVwbGFjZShcIl9oYW5kX3BvaW50XCIsIFwiXCIpLnJlcGxhY2UoYF8ke2dyaWRNb2RlfWAsIFwiXCIpfVxuICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgIHsvaWZ9XG4gICAgICAgIHsvZWFjaH1cbiAgICAgIHsvaWZ9XG4gICAgPC9nPlxuICB7L2lmfVxuXG4gIHsjaWYgZGVidWd9XG4gICAgPCEtLSBEZWJ1ZyBvdmVybGF5IHNob3dpbmcgZ3JpZCBzdGF0ZSAtLT5cbiAgICA8ZyBjbGFzcz1cImRlYnVnLW92ZXJsYXlcIj5cbiAgICAgIDxyZWN0XG4gICAgICAgIHg9XCIxMFwiXG4gICAgICAgIHk9XCIxMFwiXG4gICAgICAgIHdpZHRoPVwiMjAwXCJcbiAgICAgICAgaGVpZ2h0PVwiNjBcIlxuICAgICAgICBmaWxsPVwicmdiYSgwLCAwLCAwLCAwLjgpXCJcbiAgICAgICAgcng9XCI0XCJcbiAgICAgIC8+XG4gICAgICA8dGV4dCB4PVwiMjBcIiB5PVwiMzBcIiBmb250LXNpemU9XCIxMlwiIGZpbGw9XCJ3aGl0ZVwiIGZvbnQtZmFtaWx5PVwibW9ub3NwYWNlXCI+XG4gICAgICAgIEdyaWQ6IHtncmlkTW9kZX1cbiAgICAgIDwvdGV4dD5cbiAgICAgIDx0ZXh0IHg9XCIyMFwiIHk9XCI0NVwiIGZvbnQtc2l6ZT1cIjEwXCIgZmlsbD1cIndoaXRlXCIgZm9udC1mYW1pbHk9XCJtb25vc3BhY2VcIj5cbiAgICAgICAgTG9hZGVkOiB7aXNMb2FkZWQgPyBcIllFU1wiIDogXCJOT1wifVxuICAgICAgPC90ZXh0PlxuICAgICAgPHRleHQgeD1cIjIwXCIgeT1cIjYwXCIgZm9udC1zaXplPVwiMTBcIiBmaWxsPVwid2hpdGVcIiBmb250LWZhbWlseT1cIm1vbm9zcGFjZVwiPlxuICAgICAgICBFcnJvcjoge2hhc0Vycm9yID8gXCJZRVNcIiA6IFwiTk9cIn1cbiAgICAgIDwvdGV4dD5cbiAgICA8L2c+XG4gIHsvaWZ9XG48L2c+XG5cbjxzdHlsZT5cbiAgLmdyaWQge1xuICAgIC8qIEdyaWQgaXMgcmVuZGVyZWQgZmlyc3QsIHNvIGl0J3MgaW4gdGhlIGJhY2tncm91bmQgKi9cbiAgICB6LWluZGV4OiAxO1xuICB9XG5cbiAgLmdyaWQtbG9hZGVkIHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zcyBlYXNlO1xuICB9XG5cbiAgLmdyaWQtZXJyb3IgLmZhbGxiYWNrLWdyaWQge1xuICAgIG9wYWNpdHk6IDAuNztcbiAgfVxuXG4gIC5mYWxsYmFjay1ncmlkIHBhdGgge1xuICAgIGFuaW1hdGlvbjogZGFzaCAycyBsaW5lYXIgaW5maW5pdGU7XG4gIH1cblxuICBAa2V5ZnJhbWVzIGRhc2gge1xuICAgIHRvIHtcbiAgICAgIHN0cm9rZS1kYXNob2Zmc2V0OiAtMTA7XG4gICAgfVxuICB9XG5cbiAgLmRlYnVnLW92ZXJsYXkge1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG48L3N0eWxlPlxuIl0sImZpbGUiOiJGOi9DT0RFL1RLQS93ZWIvc3JjL2xpYi9jb21wb25lbnRzL3BpY3RvZ3JhcGgvR3JpZC5zdmVsdGUifQ==