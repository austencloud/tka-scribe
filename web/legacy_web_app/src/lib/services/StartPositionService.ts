/**
 * Start Position Service
 * 
 * Manages start position selection and operations
 */

import type { PictographData } from "$legacyLib/types/PictographData";

/**
 * Service class for managing start positions
 */
class StartPositionService {
  /**
   * Add a start position to the sequence
   */
  async addStartPosition(pictographData: PictographData): Promise<void> {
    try {
      // Create a safe copy without circular references
      const startPosCopy = this.safeCopyPictographData(pictographData);

      // Save to localStorage (like modern app)
      try {
        localStorage.setItem("start_position", JSON.stringify(startPosCopy));
      } catch (error) {
        console.error("Failed to save start position to localStorage:", error);
      }

      // Dispatch custom event to notify components (like modern app)
      if (typeof document !== "undefined") {
        const customEvent = new CustomEvent("start-position-selected", {
          detail: { startPosition: startPosCopy },
          bubbles: true,
        });
        document.dispatchEvent(customEvent);
      }

      // NOTE: We do NOT add the start position to the sequence beats array
      // The start position is managed separately and should only appear in the start position beat area

    } catch (error) {
      console.error("Error adding start position:", error);
      throw error;
    }
  }

  /**
   * Get the current start position from localStorage
   */
  getCurrentStartPosition(): PictographData | null {
    try {
      const startPosData = localStorage.getItem("start_position");
      return startPosData ? JSON.parse(startPosData) : null;
    } catch (error) {
      console.error("Error getting start position from localStorage:", error);
      return null;
    }
  }

  /**
   * Check if a start position exists
   */
  hasStartPosition(): boolean {
    return this.getCurrentStartPosition() !== null;
  }

  /**
   * Remove the start position
   */
  removeStartPosition(): void {
    try {
      localStorage.removeItem("start_position");

      // Dispatch event to notify components
      if (typeof document !== "undefined") {
        const customEvent = new CustomEvent("start-position-removed", {
          bubbles: true,
        });
        document.dispatchEvent(customEvent);
      }
    } catch (error) {
      console.error("Error removing start position:", error);
    }
  }

  /**
   * Get available start positions based on grid mode
   */
  getAvailableStartPositions(gridMode: "diamond" | "box" = "diamond"): string[] {
    if (gridMode === "diamond") {
      return ["alpha1_alpha1", "beta5_beta5", "gamma11_gamma11"];
    } else {
      return ["alpha2_alpha2", "beta4_beta4", "gamma12_gamma12"];
    }
  }

  /**
   * Validate if a pictograph can be used as a start position
   */
  isValidStartPosition(pictographData: PictographData): boolean {
    return !!(
      pictographData &&
      pictographData.redMotionData &&
      pictographData.blueMotionData &&
      pictographData.startPos &&
      pictographData.endPos
    );
  }

  /**
   * Create a safe copy of pictograph data without circular references
   */
  private safeCopyPictographData(data: PictographData): PictographData {
    const safeCopy: PictographData = {
      letter: data.letter,
      startPos: data.startPos,
      endPos: data.endPos,
      timing: data.timing,
      direction: data.direction,
      gridMode: data.gridMode,
      grid: data.grid,
      isStartPosition: true, // Mark this as a start position

      // Copy motion data and make it static for start position
      redMotionData: data.redMotionData ? {
        ...data.redMotionData,
        motionType: "static",
        endLoc: data.redMotionData.startLoc,
        endOri: data.redMotionData.startOri,
        turns: 0
      } : null,

      blueMotionData: data.blueMotionData ? {
        ...data.blueMotionData,
        motionType: "static",
        endLoc: data.blueMotionData.startLoc,
        endOri: data.blueMotionData.startOri,
        turns: 0
      } : null,

      // These will be generated by the Pictograph component
      redPropData: null,
      bluePropData: null,
      redArrowData: null,
      blueArrowData: null,
      gridData: null,

      // Copy arrays safely
      motions: [],
      redMotion: null,
      blueMotion: null,
      props: [],
    };

    return safeCopy;
  }
}

// Create and export a singleton instance
const startPositionService = new StartPositionService();
export default startPositionService;