<!--
  CAP Type Labeling Tool
  Navigate to /test/cap-labeler to use

  Purpose: Manually label circular sequences with their correct CAP type
  to build ground truth data for improving detection algorithms.
-->
<script lang="ts">
  import { onMount } from "svelte";
  import { page } from "$app/stores";
  import { goto } from "$app/navigation";
  import {
    CAPType,
    CAP_TYPE_LABELS,
    SliceSize,
  } from "$lib/features/create/generate/circular/domain/models/circular-models";
  import { getFirestoreInstance } from "$lib/shared/auth/firebase";
  import { collection, doc, setDoc, getDocs, deleteDoc, type Firestore } from "firebase/firestore";

  // BeatGrid imports for real pictograph rendering
  import type { BeatData } from "$lib/features/create/shared/domain/models/BeatData";
  import type { StartPositionData } from "$lib/features/create/shared/domain/models/StartPositionData";
  import { createMotionData } from "$lib/shared/pictograph/shared/domain/models/MotionData";
  import { GridLocation, GridPosition, GridMode } from "$lib/shared/pictograph/grid/domain/enums/grid-enums";
  import { MotionColor, MotionType, Orientation, RotationDirection } from "$lib/shared/pictograph/shared/domain/enums/pictograph-enums";
  import { PropType } from "$lib/shared/pictograph/prop/domain/enums/PropType";
  import BeatGrid from "$lib/features/create/shared/workspace-panel/sequence-display/components/BeatGrid.svelte";
  import type { Letter } from "$lib/shared/foundation/domain/models/Letter";
  import FontAwesomeIcon from "$lib/shared/foundation/ui/FontAwesomeIcon.svelte";

  // Section colors for visual differentiation
  const SECTION_COLORS = [
    { bg: "rgba(59, 130, 246, 0.35)", border: "rgba(59, 130, 246, 0.8)" },   // Blue
    { bg: "rgba(168, 85, 247, 0.35)", border: "rgba(168, 85, 247, 0.8)" },   // Purple
    { bg: "rgba(34, 197, 94, 0.35)", border: "rgba(34, 197, 94, 0.8)" },     // Green
    { bg: "rgba(249, 115, 22, 0.35)", border: "rgba(249, 115, 22, 0.8)" },   // Orange
    { bg: "rgba(236, 72, 153, 0.35)", border: "rgba(236, 72, 153, 0.8)" },   // Pink
    { bg: "rgba(20, 184, 166, 0.35)", border: "rgba(20, 184, 166, 0.8)" },   // Teal
  ] as const;

  // Firebase Firestore instance (lazy loaded)
  let firestore: Firestore | null = null;

  // Base CAP components that can be combined
  // Icons and colors match the Generate tab's CAP component buttons
  const BASE_COMPONENTS = [
    { id: "rotated", label: "Rotated", description: "Positions rotate 180° (or 90°)", icon: "rotate", color: "#36c3ff" },
    { id: "swapped", label: "Swapped", description: "Blue/Red hands swap roles", icon: "shuffle", color: "#26e600" },
    { id: "mirrored", label: "Mirrored", description: "Positions mirror vertically (left↔right)", icon: "left-right", color: "#6F2DA8" },
    { id: "flipped", label: "Flipped", description: "Positions mirror horizontally (top↔bottom)", icon: "up-down", color: "#14b8a6" },
    { id: "inverted", label: "Inverted", description: "Pro ↔ Anti motion types flip", icon: "yin-yang", color: "#eb7d00" },
    { id: "rewound", label: "Rewound", description: "Second half plays in reverse", icon: "backward", color: "#ec4899" },
  ] as const;

  type ComponentId = typeof BASE_COMPONENTS[number]["id"];

  // Map component combinations to CAPType
  function componentsToCAPType(components: Set<ComponentId>): string | null {
    if (components.size === 0) return null;

    const sorted = Array.from(components).sort().join("_");

    // Map combinations to CAPType enum values
    const mapping: Record<string, CAPType | string> = {
      "rotated": CAPType.STRICT_ROTATED,
      "mirrored": CAPType.STRICT_MIRRORED,
      "flipped": "strict_flipped",
      "swapped": CAPType.STRICT_SWAPPED,
      "inverted": CAPType.STRICT_INVERTED,
      "inverted_swapped": CAPType.SWAPPED_INVERTED,
      "inverted_rotated": CAPType.ROTATED_INVERTED,
      "mirrored_swapped": CAPType.MIRRORED_SWAPPED,
      "flipped_swapped": "flipped_swapped",
      "inverted_mirrored": CAPType.MIRRORED_INVERTED,
      "flipped_inverted": "flipped_inverted",
      "rotated_swapped": CAPType.ROTATED_SWAPPED,
      "mirrored_rotated": CAPType.MIRRORED_ROTATED,
      "flipped_rotated": "flipped_rotated",
      "inverted_mirrored_rotated": CAPType.MIRRORED_INVERTED_ROTATED,
      "inverted_mirrored_rotated_swapped": CAPType.MIRRORED_ROTATED_INVERTED_SWAPPED,
      "rewound": "rewound",
      "inverted_rewound": "rewound_inverted",
      // Add more combinations as needed
    };

    return mapping[sorted] ?? `custom_${sorted}`;
  }

  interface SequenceEntry {
    id: string;  // Unique sequence identifier
    word: string;
    isCircular: boolean;
    capType: string | null;
    thumbnails: string[];
    sequenceLength: number;
    gridMode: string;
    fullMetadata?: {
      sequence?: RawBeatData[];
    };
  }

  // Raw beat data from sequence-index.json (camelCase format)
  interface RawBeatData {
    beat?: number;
    letter?: string;
    startPos?: string;
    endPos?: string;
    sequenceStartPosition?: string;
    blueAttributes?: RawMotionAttributes;
    redAttributes?: RawMotionAttributes;
    // Metadata object (first item in sequence array) fields
    word?: string;
    author?: string;
    level?: number;
    propType?: string;
    isCircular?: boolean;
    gridMode?: string;  // Authoritative grid mode
  }

  interface RawMotionAttributes {
    motionType?: string;
    startLoc?: string;
    endLoc?: string;
    startOri?: string;
    endOri?: string;
    propRotDir?: string;
    turns?: number | string;
  }

  interface CAPDesignation {
    components: ComponentId[];
    capType: string | null;
    sliceSize?: SliceSize | null; // Only relevant when "rotated" component is selected
  }

  interface LabeledSequence {
    word: string;
    designations: CAPDesignation[];  // Multiple valid designations (whole sequence)
    sections?: SectionDesignation[];  // Section-based designations
    beatPairs?: BeatPairRelationship[];  // Beat-pair relationships
    isFreeform: boolean;  // Circular but no recognizable pattern
    isUnknown?: boolean;  // Needs further analysis/review
    labeledAt: string;
    notes: string;
  }

  // State
  let sequences = $state<SequenceEntry[]>([]);
  let labels = $state<Map<string, LabeledSequence>>(new Map());
  let currentIndex = $state(0);
  let loading = $state(true);
  let filterMode = $state<"all" | "unlabeled" | "labeled" | "unknown">("unlabeled");
  let notes = $state("");
  let showExport = $state(false);
  let selectedComponents = $state<Set<ComponentId>>(new Set());
  let isFreeform = $state(false);  // Circular but no recognizable pattern
  let pendingDesignations = $state<CAPDesignation[]>([]);  // Multiple designations being built
  let selectedSliceSize = $state<SliceSize | null>(null); // Slice size for Rotated component
  let copiedToast = $state(false);
  let syncStatus = $state<"synced" | "syncing" | "error">("synced");

  // Parsed beat data for BeatGrid rendering
  let parsedBeats = $state<BeatData[]>([]);
  let parsedStartPosition = $state<(StartPositionData & { beatNumber: number; isBlank: boolean }) | null>(null);
  let selectedBeatNumber = $state<number | null>(null);

  // Labeling mode: whole-sequence, section-based, or beat-pair analysis
  type LabelingMode = "whole" | "section" | "beatpair";
  let labelingMode = $state<LabelingMode>("whole");

  // Section mode state
  let selectedBeats = $state<Set<number>>(new Set());
  let lastClickedBeat = $state<number | null>(null);
  let isShiftHeld = $state(false); // Track shift key state globally

  // Drag selection state
  let isDragging = $state(false);
  let dragStartBeat = $state<number | null>(null);

  // Saved sections for the current sequence (persisted immediately, not staged)
  let savedSections = $state<SectionDesignation[]>([]);

  // Beat pair mode state
  let firstBeat = $state<number | null>(null);  // Key beat
  let secondBeat = $state<number | null>(null); // Corresponding beat
  let beatPairAnalysis = $state<BeatPairRelationship | null>(null);

  interface BeatPairRelationship {
    keyBeat: number;
    correspondingBeat: number;
    detectedTransformations: string[]; // e.g., ["FLIPPED", "ROTATED_180 + SWAPPED"]
    confirmedTransformation?: string;  // User-selected interpretation
  }

  // Saved beat-pair relationships for current sequence
  let savedBeatPairs = $state<BeatPairRelationship[]>([]);

  interface SectionDesignation {
    beats: number[]; // Beat numbers in this section
    components: ComponentId[];
    capType: string | null;
    sliceSize?: SliceSize | null; // Only relevant when "rotated" component is selected
  }

  // Column count preference (persists to localStorage)
  const COLUMN_STORAGE_KEY = "cap_labeler_column_count";
  let manualColumnCount = $state<number | null>(null);

  // Toggle for showing start position (persists to localStorage)
  const START_POS_STORAGE_KEY = "cap_labeler_show_start_position";
  let showStartPosition = $state(true);
  let startPosInitialized = $state(false);

  // Available column options based on beat count
  const availableColumnOptions = $derived.by(() => {
    const beatCount = parsedBeats.length;
    if (beatCount === 0) return [2, 4];
    // Common options: 2, 4, 5, 6, 8 - filtered to what makes sense for this sequence
    const maxViable = Math.min(beatCount, 8);
    const options: number[] = [];
    if (maxViable >= 2) options.push(2);
    if (maxViable >= 4) options.push(4);
    if (maxViable >= 5) options.push(5);
    if (maxViable >= 6) options.push(6);
    if (maxViable >= 8) options.push(8);
    return options;
  });

  // Effective column count: combines manual preference with smart defaults
  const effectiveColumnCount = $derived.by(() => {
    // If user manually set a preference, use it
    if (manualColumnCount !== null) return manualColumnCount;

    // Smart defaults based on sequence length
    const beatCount = parsedBeats.length;
    // 16-beat sequences look best as 4x4 grid
    if (beatCount === 16) return 4;
    // 8-beat sequences also work well as 4x2
    if (beatCount === 8) return 4;

    // Let BeatGrid auto-determine for other lengths
    return null;
  });

  // Map beat numbers to their section colors (for saved sections)
  const beatSectionColors = $derived.by(() => {
    const colorMap = new Map<number, { bg: string; border: string; sectionIndex: number }>();
    savedSections.forEach((section, sectionIndex) => {
      const color = SECTION_COLORS[sectionIndex % SECTION_COLORS.length]!;
      section.beats.forEach(beatNum => {
        colorMap.set(beatNum, { bg: color.bg, border: color.border, sectionIndex });
      });
    });
    return colorMap;
  });

  // Combined highlight map for BeatGrid (handles all three modes)
  const highlightedBeats = $derived.by(() => {
    const map = new Map<number, { bg: string; border: string }>();

    // Section mode: show saved sections + current selection
    if (labelingMode === "section") {
      // Add saved section colors first (each section gets a unique color from SECTION_COLORS)
      beatSectionColors.forEach((color, beatNum) => {
        map.set(beatNum, { bg: color.bg, border: color.border });
      });

      // Add currently selected beats (bright yellow/gold to distinguish from saved sections)
      const selectionColor = { bg: "rgba(251, 191, 36, 0.35)", border: "rgba(251, 191, 36, 0.9)" };
      selectedBeats.forEach(beatNum => {
        map.set(beatNum, selectionColor);
      });
    }

    // Beat pair mode: highlight selected beats for comparison
    if (labelingMode === "beatpair") {
      // First beat (key) - green
      if (firstBeat !== null) {
        map.set(firstBeat, {
          bg: "rgba(34, 197, 94, 0.35)",
          border: "rgba(34, 197, 94, 0.9)"
        });
      }
      // Second beat (corresponding) - purple
      if (secondBeat !== null) {
        map.set(secondBeat, {
          bg: "rgba(168, 85, 247, 0.35)",
          border: "rgba(168, 85, 247, 0.9)"
        });
      }
    }

    return map.size > 0 ? map : null;
  });

  // Check if there's pending work that would be lost by clicking Next
  const hasPendingWork = $derived.by(() => {
    if (labelingMode === "section") {
      // In section mode: pending if beats are selected OR components are chosen
      return selectedBeats.size > 0 || selectedComponents.size > 0;
    }
    if (labelingMode === "beatpair") {
      // In beat pair mode: pending if any beat is selected OR analysis exists
      return firstBeat !== null || secondBeat !== null || beatPairAnalysis !== null;
    }
    return false;
  });

  // URL sync: Update URL when current sequence changes (for refresh persistence)
  function updateUrlWithSequence(sequenceId: string | null) {
    if (typeof window === "undefined") return;
    const url = new URL(window.location.href);
    if (sequenceId) {
      url.searchParams.set("seq", sequenceId);
    } else {
      url.searchParams.delete("seq");
    }
    // Use replaceState to avoid polluting browser history
    window.history.replaceState({}, "", url.toString());
  }

  // Sync current sequence to URL
  $effect(() => {
    if (currentSequence?.id) {
      updateUrlWithSequence(currentSequence.id);
    }
  });

  // Firebase collection reference
  const CAP_LABELS_COLLECTION = "cap-labels";

  // Derived CAP type from selected components
  const derivedCapType = $derived(
    isFreeform ? null : componentsToCAPType(selectedComponents)
  );

  // Check if rotated is selected (to show slice size selector)
  const isRotatedSelected = $derived(selectedComponents.has("rotated"));

  // Human-readable label for current selection
  const selectionLabel = $derived.by(() => {
    if (isFreeform) return "Freeform";
    if (selectedComponents.size === 0) return "Select components...";
    const names = Array.from(selectedComponents).map(
      id => BASE_COMPONENTS.find(c => c.id === id)?.label ?? id
    );
    return names.join(" + ");
  });

  // Format a designation for display
  function formatDesignation(d: CAPDesignation | SectionDesignation): string {
    if (d.components.length === 0) return "Freeform";
    let label = d.components.map(c =>
      BASE_COMPONENTS.find(b => b.id === c)?.label ?? c
    ).join(" + ");
    // Add slice size if rotated and has a slice size
    if (d.components.includes("rotated") && d.sliceSize) {
      const sliceLabel = d.sliceSize === SliceSize.HALVED ? "180°" : "90°";
      label += ` (${sliceLabel})`;
    }
    return label;
  }

  // Filter to only circular sequences
  const circularSequences = $derived(
    sequences.filter((s) => s.isCircular)
  );

  // Apply filter mode
  const filteredSequences = $derived.by(() => {
    if (filterMode === "all") return circularSequences;
    if (filterMode === "unlabeled") {
      return circularSequences.filter((s) => !labels.has(s.word));
    }
    if (filterMode === "unknown") {
      return circularSequences.filter((s) => labels.get(s.word)?.isUnknown === true);
    }
    return circularSequences.filter((s) => labels.has(s.word));
  });

  const currentSequence = $derived(filteredSequences[currentIndex] ?? null);
  const currentLabel = $derived(
    currentSequence ? labels.get(currentSequence.word) : null
  );

  const currentThumbnailUrl = $derived(
    currentSequence?.thumbnails?.[0]
  );

  // Stats
  const stats = $derived({
    total: circularSequences.length,
    labeled: labels.size,
    remaining: circularSequences.length - labels.size,
    unknown: Array.from(labels.values()).filter(l => l.isUnknown === true).length,
  });

  // ============================================================================
  // Beat Data Conversion Functions
  // ============================================================================

  function parseMotionType(value: string | undefined): MotionType {
    const str = String(value || "").toLowerCase();
    switch (str) {
      case "pro": return MotionType.PRO;
      case "anti": return MotionType.ANTI;
      case "float": return MotionType.FLOAT;
      case "dash": return MotionType.DASH;
      case "static": return MotionType.STATIC;
      default: return MotionType.STATIC;
    }
  }

  function parseLocation(value: string | undefined): GridLocation {
    const str = String(value || "").toUpperCase();
    const locationMap: Record<string, GridLocation> = {
      N: GridLocation.NORTH,
      NORTH: GridLocation.NORTH,
      E: GridLocation.EAST,
      EAST: GridLocation.EAST,
      S: GridLocation.SOUTH,
      SOUTH: GridLocation.SOUTH,
      W: GridLocation.WEST,
      WEST: GridLocation.WEST,
      NE: GridLocation.NORTHEAST,
      NORTHEAST: GridLocation.NORTHEAST,
      SE: GridLocation.SOUTHEAST,
      SOUTHEAST: GridLocation.SOUTHEAST,
      SW: GridLocation.SOUTHWEST,
      SOUTHWEST: GridLocation.SOUTHWEST,
      NW: GridLocation.NORTHWEST,
      NORTHWEST: GridLocation.NORTHWEST,
    };
    return locationMap[str] ?? GridLocation.NORTH;
  }

  function parseGridPosition(value: string | undefined): GridPosition | null {
    if (!value) return null;
    const str = String(value).toLowerCase();
    const enumKey = str.toUpperCase();
    const positionValue = GridPosition[enumKey as keyof typeof GridPosition];
    if (positionValue) return positionValue;
    for (const key in GridPosition) {
      if (GridPosition[key as keyof typeof GridPosition] === str) {
        return str as GridPosition;
      }
    }
    return null;
  }

  function parseOrientation(value: string | undefined): Orientation {
    const str = String(value || "").toLowerCase();
    switch (str) {
      case "in": return Orientation.IN;
      case "out": return Orientation.OUT;
      case "clock": case "clockwise": return Orientation.CLOCK;
      case "counter": case "counterclockwise": return Orientation.COUNTER;
      default: return Orientation.IN;
    }
  }

  function parseRotationDirection(value: string | undefined): RotationDirection {
    const str = String(value || "").toLowerCase();
    switch (str) {
      case "cw": case "clockwise": return RotationDirection.CLOCKWISE;
      case "ccw": case "counterclockwise": case "counter_clockwise": return RotationDirection.COUNTER_CLOCKWISE;
      case "no_rotation": case "norotation": return RotationDirection.NO_ROTATION;
      default: return RotationDirection.NO_ROTATION;
    }
  }

  function parseTurns(value: string | number | undefined): number | "fl" {
    if (value === "fl" || value === "float") return "fl";
    const num = Number(value);
    return isNaN(num) ? 0 : num;
  }

  function convertRawToBeats(
    sequenceName: string,
    rawSequence: RawBeatData[],
    gridMode: GridMode
  ): { beats: BeatData[]; startPosition: (StartPositionData & { beatNumber: number; isBlank: boolean }) | null } {
    if (!rawSequence || rawSequence.length === 0) {
      return { beats: [], startPosition: null };
    }

    // JSON structure:
    // - Element 0: Metadata (word, author, level, etc.) - no sequenceStartPosition, no blue/red attributes
    // - Element 1: Start position with beat=0, sequenceStartPosition, blue/red attributes
    // - Element 2+: Actual beats with beat>=1

    // Find the start position element (has sequenceStartPosition AND beat === 0)
    const startPosElement = rawSequence.find(el =>
      "sequenceStartPosition" in el && el.beat === 0
    );

    // Parse start position if found
    // NOTE: We add beatNumber: 0 and isBlank: false so BeatGrid/BeatCell
    // properly recognize and render this as the start position with "Start" label
    // Using type assertion because StartPositionData doesn't include these runtime fields
    let startPosition: (StartPositionData & { beatNumber: number; isBlank: boolean }) | null = null;
    if (startPosElement) {
      const blueAttrs = startPosElement.blueAttributes;
      const redAttrs = startPosElement.redAttributes;
      const gridPosition = parseGridPosition(startPosElement.sequenceStartPosition);

      startPosition = {
        id: `start-${sequenceName}`,
        isStartPosition: true as const,
        beatNumber: 0, // Required for BeatCell to identify as start position
        isBlank: false, // Required for BeatGrid to show start position
        letter: (startPosElement.letter as Letter | null) ?? null,
        gridPosition,
        startPosition: gridPosition,
        endPosition: null,
        motions: {
          [MotionColor.BLUE]: blueAttrs
            ? createMotionData({
                color: MotionColor.BLUE,
                motionType: parseMotionType(blueAttrs.motionType),
                startLocation: parseLocation(blueAttrs.startLoc),
                endLocation: parseLocation(blueAttrs.endLoc),
                startOrientation: parseOrientation(blueAttrs.startOri),
                endOrientation: parseOrientation(blueAttrs.endOri),
                rotationDirection: parseRotationDirection(blueAttrs.propRotDir),
                turns: parseTurns(blueAttrs.turns),
                isVisible: true,
                propType: PropType.STAFF,
                arrowLocation: parseLocation(blueAttrs.startLoc) || GridLocation.NORTH,
                gridMode,
              })
            : undefined,
          [MotionColor.RED]: redAttrs
            ? createMotionData({
                color: MotionColor.RED,
                motionType: parseMotionType(redAttrs.motionType),
                startLocation: parseLocation(redAttrs.startLoc),
                endLocation: parseLocation(redAttrs.endLoc),
                startOrientation: parseOrientation(redAttrs.startOri),
                endOrientation: parseOrientation(redAttrs.endOri),
                rotationDirection: parseRotationDirection(redAttrs.propRotDir),
                turns: parseTurns(redAttrs.turns),
                isVisible: true,
                propType: PropType.STAFF,
                arrowLocation: parseLocation(redAttrs.startLoc) || GridLocation.SOUTH,
                gridMode,
              })
            : undefined,
        },
      };
    }

    // Filter to only actual beats: must have blue/red attributes AND beat >= 1
    // This excludes: metadata elements (no attributes) AND start position (beat === 0)
    const actualBeats = rawSequence.filter(el =>
      (el.blueAttributes || el.redAttributes) &&
      el.beat !== undefined &&
      el.beat >= 1
    );

    const beats: BeatData[] = actualBeats.map((step, index) => {
      const blueAttrs = step.blueAttributes;
      const redAttrs = step.redAttributes;

      return {
        id: `beat-${sequenceName}-${index + 1}`,
        letter: step.letter as Letter ?? null,
        startPosition: parseGridPosition(step.startPos) || parseGridPosition(step.sequenceStartPosition),
        endPosition: parseGridPosition(step.endPos),
        motions: {
          [MotionColor.BLUE]: blueAttrs
            ? createMotionData({
                color: MotionColor.BLUE,
                motionType: parseMotionType(blueAttrs.motionType),
                startLocation: parseLocation(blueAttrs.startLoc),
                endLocation: parseLocation(blueAttrs.endLoc),
                startOrientation: parseOrientation(blueAttrs.startOri),
                endOrientation: parseOrientation(blueAttrs.endOri),
                rotationDirection: parseRotationDirection(blueAttrs.propRotDir),
                turns: parseTurns(blueAttrs.turns),
                isVisible: true,
                propType: PropType.STAFF,
                arrowLocation: parseLocation(blueAttrs.startLoc) || GridLocation.NORTH,
                gridMode,
              })
            : undefined,
          [MotionColor.RED]: redAttrs
            ? createMotionData({
                color: MotionColor.RED,
                motionType: parseMotionType(redAttrs.motionType),
                startLocation: parseLocation(redAttrs.startLoc),
                endLocation: parseLocation(redAttrs.endLoc),
                startOrientation: parseOrientation(redAttrs.startOri),
                endOrientation: parseOrientation(redAttrs.endOri),
                rotationDirection: parseRotationDirection(redAttrs.propRotDir),
                turns: parseTurns(redAttrs.turns),
                isVisible: true,
                propType: PropType.STAFF,
                arrowLocation: parseLocation(redAttrs.startLoc) || GridLocation.SOUTH,
                gridMode,
              })
            : undefined,
        },
        // Use step.beat directly (it's guaranteed >= 1 from filter)
        beatNumber: step.beat!,
        duration: 1.0,
        blueReversal: false,
        redReversal: false,
        isBlank: false,
      } as BeatData;
    });

    return { beats, startPosition };
  }

  // Get the authoritative gridMode for a sequence
  // Prefer fullMetadata.sequence[0].gridMode (the metadata object) over top-level gridMode
  // because the top-level gridMode is sometimes incorrect
  function getAuthoritativeGridMode(seq: SequenceEntry): GridMode {
    const metadataGridMode = seq.fullMetadata?.sequence?.[0]?.gridMode;
    const rawGridMode = metadataGridMode ?? seq.gridMode;
    return rawGridMode === "box" ? GridMode.BOX : GridMode.DIAMOND;
  }

  // Derived authoritative grid mode for current sequence
  const authoritativeGridMode = $derived(
    currentSequence ? getAuthoritativeGridMode(currentSequence) : GridMode.DIAMOND
  );

  // Update parsed beats when current sequence changes
  $effect(() => {
    if (currentSequence?.fullMetadata?.sequence) {
      const gridMode = getAuthoritativeGridMode(currentSequence);
      const { beats, startPosition } = convertRawToBeats(
        currentSequence.word,
        currentSequence.fullMetadata.sequence,
        gridMode
      );
      parsedBeats = beats;
      parsedStartPosition = startPosition;
      selectedBeatNumber = null;
    } else {
      parsedBeats = [];
      parsedStartPosition = null;
      selectedBeatNumber = null;
    }
  });

  // Load saved data when viewing a labeled sequence
  $effect(() => {
    if (currentLabel?.sections) {
      savedSections = [...currentLabel.sections];
      labelingMode = "section"; // Auto-enter section mode if viewing section-labeled sequence
    } else {
      savedSections = [];
    }
    if (currentLabel?.beatPairs) {
      savedBeatPairs = [...currentLabel.beatPairs];
      labelingMode = "beatpair"; // Auto-enter beatpair mode if viewing beatpair-labeled sequence
    } else {
      savedBeatPairs = [];
    }
    // Clear current selection when sequence changes
    selectedBeats = new Set();
    selectedComponents = new Set();
    firstBeat = null;
    secondBeat = null;
    beatPairAnalysis = null;
  });

  function handleBeatClick(beatNumber: number) {
    // Whole sequence mode: single beat selection for editing
    if (labelingMode === "whole") {
      selectedBeatNumber = selectedBeatNumber === beatNumber ? null : beatNumber;
      return;
    }

    // Section mode: multi-select with shift-range support
    if (labelingMode === "section") {
      if (isShiftHeld && lastClickedBeat !== null) {
        // Range selection: select all beats between lastClickedBeat and current
        const start = Math.min(lastClickedBeat, beatNumber);
        const end = Math.max(lastClickedBeat, beatNumber);
        const newSet = new Set(selectedBeats);
        for (let i = start; i <= end; i++) {
          newSet.add(i);
        }
        selectedBeats = newSet;
      } else {
        // Toggle single beat
        const newSet = new Set(selectedBeats);
        if (newSet.has(beatNumber)) {
          newSet.delete(beatNumber);
        } else {
          newSet.add(beatNumber);
        }
        selectedBeats = newSet;
      }
      lastClickedBeat = beatNumber;
      return;
    }

    // Beat pair mode: select first beat, then second beat
    if (labelingMode === "beatpair") {
      if (firstBeat === null) {
        firstBeat = beatNumber;
        secondBeat = null;
        beatPairAnalysis = null;
      } else if (secondBeat === null && beatNumber !== firstBeat) {
        secondBeat = beatNumber;
        // Trigger analysis
        analyzeBeatPair();
      } else {
        // Reset and start over
        firstBeat = beatNumber;
        secondBeat = null;
        beatPairAnalysis = null;
      }
    }
  }

  // Analyze beat pair and detect CAP transformations
  function analyzeBeatPair() {
    if (firstBeat === null || secondBeat === null) return;

    const beat1 = parsedBeats.find(b => b.beatNumber === firstBeat);
    const beat2 = parsedBeats.find(b => b.beatNumber === secondBeat);

    if (!beat1 || !beat2) return;

    const transformations: string[] = [];

    // Check ROTATED (180° or 90°)
    if (isRotated(beat1, beat2)) {
      transformations.push("ROTATED");
    }

    // Check SWAPPED (blue/red swap)
    if (isSwapped(beat1, beat2)) {
      transformations.push("SWAPPED");
    }

    // Check MIRRORED (vertical flip n↔s)
    if (isMirrored(beat1, beat2)) {
      transformations.push("MIRRORED");
    }

    // Check FLIPPED (horizontal flip e↔w)
    if (isFlipped(beat1, beat2)) {
      transformations.push("FLIPPED");
    }

    // Check INVERTED (pro↔anti)
    if (isInverted(beat1, beat2)) {
      transformations.push("INVERTED");
    }

    // Check common combinations
    if (transformations.includes("ROTATED") && transformations.includes("SWAPPED")) {
      transformations.push("ROTATED + SWAPPED");
    }
    if (transformations.includes("FLIPPED") && transformations.includes("MIRRORED")) {
      transformations.push("FLIPPED + MIRRORED");
    }
    if (transformations.includes("ROTATED") && transformations.includes("INVERTED")) {
      transformations.push("ROTATED + INVERTED");
    }

    beatPairAnalysis = {
      keyBeat: firstBeat,
      correspondingBeat: secondBeat,
      detectedTransformations: transformations.length > 0 ? transformations : ["UNKNOWN/COMPLEX"],
    };
  }

  // Helper: Check if beat2 is a rotated version of beat1
  function isRotated(beat1: BeatData, beat2: BeatData): boolean {
    // Simplified check: locations should be rotated 180°
    const rotate180 = (loc: string) => {
      const map: Record<string, string> = {
        n: 's', s: 'n', e: 'w', w: 'e',
        ne: 'sw', sw: 'ne', nw: 'se', se: 'nw'
      };
      return map[loc.toLowerCase()] || loc;
    };

    return (
      rotate180(beat1.blueMotion.startLocation) === beat2.blueMotion.startLocation.toLowerCase() &&
      rotate180(beat1.blueMotion.endLocation) === beat2.blueMotion.endLocation.toLowerCase() &&
      rotate180(beat1.redMotion.startLocation) === beat2.redMotion.startLocation.toLowerCase() &&
      rotate180(beat1.redMotion.endLocation) === beat2.redMotion.endLocation.toLowerCase()
    );
  }

  // Helper: Check if beat2 is a swapped version of beat1 (blue↔red)
  function isSwapped(beat1: BeatData, beat2: BeatData): boolean {
    return (
      beat1.blueMotion.startLocation === beat2.redMotion.startLocation &&
      beat1.blueMotion.endLocation === beat2.redMotion.endLocation &&
      beat1.redMotion.startLocation === beat2.blueMotion.startLocation &&
      beat1.redMotion.endLocation === beat2.blueMotion.endLocation
    );
  }

  // Helper: Check if beat2 is a mirrored version of beat1 (vertical flip)
  function isMirrored(beat1: BeatData, beat2: BeatData): boolean {
    const mirrorVertical = (loc: string) => {
      const map: Record<string, string> = {
        n: 's', s: 'n', e: 'e', w: 'w',
        ne: 'se', se: 'ne', nw: 'sw', sw: 'nw'
      };
      return map[loc.toLowerCase()] || loc;
    };

    return (
      mirrorVertical(beat1.blueMotion.startLocation) === beat2.blueMotion.startLocation.toLowerCase() &&
      mirrorVertical(beat1.blueMotion.endLocation) === beat2.blueMotion.endLocation.toLowerCase() &&
      mirrorVertical(beat1.redMotion.startLocation) === beat2.redMotion.startLocation.toLowerCase() &&
      mirrorVertical(beat1.redMotion.endLocation) === beat2.redMotion.endLocation.toLowerCase()
    );
  }

  // Helper: Check if beat2 is a flipped version of beat1 (horizontal flip)
  function isFlipped(beat1: BeatData, beat2: BeatData): boolean {
    const flipHorizontal = (loc: string) => {
      const map: Record<string, string> = {
        n: 'n', s: 's', e: 'w', w: 'e',
        ne: 'nw', nw: 'ne', se: 'sw', sw: 'se'
      };
      return map[loc.toLowerCase()] || loc;
    };

    return (
      flipHorizontal(beat1.blueMotion.startLocation) === beat2.blueMotion.startLocation.toLowerCase() &&
      flipHorizontal(beat1.blueMotion.endLocation) === beat2.blueMotion.endLocation.toLowerCase() &&
      flipHorizontal(beat1.redMotion.startLocation) === beat2.redMotion.startLocation.toLowerCase() &&
      flipHorizontal(beat1.redMotion.endLocation) === beat2.redMotion.endLocation.toLowerCase()
    );
  }

  // Helper: Check if beat2 is an inverted version of beat1 (pro↔anti)
  function isInverted(beat1: BeatData, beat2: BeatData): boolean {
    const invert = (type: MotionType) => {
      if (type === MotionType.PRO) return MotionType.ANTI;
      if (type === MotionType.ANTI) return MotionType.PRO;
      return type;
    };

    return (
      invert(beat1.blueMotion.motionType) === beat2.blueMotion.motionType &&
      invert(beat1.redMotion.motionType) === beat2.redMotion.motionType
    );
  }

  // Add current selection as a section and save immediately
  async function addSectionDesignation() {
    if (!currentSequence) return;
    if (selectedBeats.size === 0 || selectedComponents.size === 0) return;

    const section: SectionDesignation = {
      beats: Array.from(selectedBeats).sort((a, b) => a - b),
      components: Array.from(selectedComponents),
      capType: derivedCapType,
      sliceSize: selectedComponents.has("rotated") ? selectedSliceSize : null,
    };

    // Add to saved sections immediately
    savedSections = [...savedSections, section];

    // Save to Firebase immediately
    const label: LabeledSequence = {
      word: currentSequence.word,
      designations: [],
      sections: savedSections,
      isFreeform: false,
      labeledAt: new Date().toISOString(),
      notes: notes,
    };
    labels.set(currentSequence.word, label);
    labels = new Map(labels);
    saveLabels();
    await saveLabelToFirebase(currentSequence.word, label);

    // Clear selection for next section
    selectedComponents = new Set();
    selectedBeats = new Set();
    lastClickedBeat = null;
    selectedSliceSize = null;
  }

  // Remove a saved section
  async function removeSectionDesignation(index: number) {
    if (!currentSequence) return;

    savedSections = savedSections.filter((_, i) => i !== index);

    // Update Firebase immediately
    if (savedSections.length > 0) {
      const label: LabeledSequence = {
        word: currentSequence.word,
        designations: [],
        sections: savedSections,
        isFreeform: false,
        labeledAt: new Date().toISOString(),
        notes: notes,
      };
      labels.set(currentSequence.word, label);
      labels = new Map(labels);
      saveLabels();
      await saveLabelToFirebase(currentSequence.word, label);
    } else {
      // If no sections left, remove the label entirely
      labels.delete(currentSequence.word);
      labels = new Map(labels);
      saveLabels();
      if (firestore) {
        try {
          await deleteDoc(doc(firestore, CAP_LABELS_COLLECTION, currentSequence.word));
        } catch (error) {
          console.error("Failed to delete label from Firebase:", error);
        }
      }
    }
  }

  // Save a beat pair relationship
  async function saveBeatPair() {
    if (!currentSequence || !beatPairAnalysis) return;
    if (!beatPairAnalysis.confirmedTransformation) return;

    // Add to saved beat pairs
    savedBeatPairs = [...savedBeatPairs, beatPairAnalysis];

    // Save to Firebase immediately
    const label: LabeledSequence = {
      word: currentSequence.word,
      designations: [],
      beatPairs: savedBeatPairs,
      isFreeform: false,
      labeledAt: new Date().toISOString(),
      notes: notes,
    };
    labels.set(currentSequence.word, label);
    labels = new Map(labels);
    saveLabels();
    await saveLabelToFirebase(currentSequence.word, label);

    // Clear selection for next beat pair
    firstBeat = null;
    secondBeat = null;
    beatPairAnalysis = null;
  }

  // Remove a saved beat pair
  async function removeBeatPair(index: number) {
    if (!currentSequence) return;

    savedBeatPairs = savedBeatPairs.filter((_, i) => i !== index);

    // Update Firebase immediately
    if (savedBeatPairs.length > 0) {
      const label: LabeledSequence = {
        word: currentSequence.word,
        designations: [],
        beatPairs: savedBeatPairs,
        isFreeform: false,
        labeledAt: new Date().toISOString(),
        notes: notes,
      };
      labels.set(currentSequence.word, label);
      labels = new Map(labels);
      saveLabels();
      await saveLabelToFirebase(currentSequence.word, label);
    } else {
      // If no beat pairs left, remove the label entirely
      labels.delete(currentSequence.word);
      labels = new Map(labels);
      saveLabels();
      if (firestore) {
        try {
          await deleteDoc(doc(firestore, CAP_LABELS_COLLECTION, currentSequence.word));
        } catch (error) {
          console.error("Failed to delete label from Firebase:", error);
        }
      }
    }
  }

  // Drag selection handlers for beat grid
  function handleDragStart(beatNumber: number) {
    if (labelingMode !== "section") return;
    isDragging = true;
    dragStartBeat = beatNumber;
    selectedBeats = new Set([beatNumber]);
  }

  function handleDragMove(beatNumber: number) {
    if (labelingMode !== "section" || !isDragging || dragStartBeat === null) return;

    // Select range from drag start to current beat
    const start = Math.min(dragStartBeat, beatNumber);
    const end = Math.max(dragStartBeat, beatNumber);
    const newSelection = new Set<number>();
    for (let i = start; i <= end; i++) {
      newSelection.add(i);
    }
    selectedBeats = newSelection;
  }

  function handleDragEnd() {
    isDragging = false;
    dragStartBeat = null;
  }

  // Format section beats for display (e.g., "1-4" or "1,3,5")
  function formatSectionBeats(beats: number[]): string {
    if (beats.length === 0) return "";
    if (beats.length === 1) return `Beat ${beats[0]}`;

    // Check if consecutive
    const sorted = [...beats].sort((a, b) => a - b);
    let isConsecutive = true;
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i]! !== sorted[i - 1]! + 1) {
        isConsecutive = false;
        break;
      }
    }

    if (isConsecutive) {
      return `Beats ${sorted[0]}-${sorted[sorted.length - 1]}`;
    } else {
      return `Beats ${sorted.join(", ")}`;
    }
  }


  // Persist column changes to localStorage
  $effect(() => {
    if (typeof localStorage !== "undefined") {
      localStorage.setItem(COLUMN_STORAGE_KEY, JSON.stringify(manualColumnCount));
    }
  });

  // Persist start position toggle to localStorage (only after initialization)
  $effect(() => {
    if (startPosInitialized && typeof localStorage !== "undefined") {
      localStorage.setItem(START_POS_STORAGE_KEY, JSON.stringify(showStartPosition));
    }
  });

  function setColumnCount(count: number | null) {
    manualColumnCount = count;
  }

  onMount(() => {
    // Track shift key state for range selection
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === "Shift") isShiftHeld = true;
    };
    const handleKeyUp = (e: KeyboardEvent) => {
      if (e.key === "Shift") isShiftHeld = false;
    };
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);

    // Load column preference from localStorage
    try {
      const saved = localStorage.getItem(COLUMN_STORAGE_KEY);
      if (saved) {
        manualColumnCount = JSON.parse(saved);
      }
    } catch (e) {
      // Ignore localStorage errors
    }

    // Load start position toggle from localStorage
    try {
      const savedStartPos = localStorage.getItem(START_POS_STORAGE_KEY);
      if (savedStartPos !== null) {
        showStartPosition = JSON.parse(savedStartPos);
      }
    } catch (e) {
      // Ignore localStorage errors
    }
    // Mark as initialized so $effect can now persist changes
    startPosInitialized = true;

    // Initialize async resources (fire and forget - cleanup handled below)
    initializeAsyncResources();

    // Cleanup on unmount
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  });

  async function initializeAsyncResources() {
    // Initialize Firestore
    try {
      firestore = await getFirestoreInstance();
      console.log("Firestore initialized for CAP labeler");
    } catch (error) {
      console.error("Failed to initialize Firestore:", error);
    }

    // Load sequences
    try {
      const response = await fetch("/data/sequence-index.json");
      const data = await response.json();
      sequences = data.sequences || [];
    } catch (error) {
      console.error("Failed to load sequences:", error);
    }

    // Check URL for sequence ID to navigate to (handled after labels load)
    const urlSeqId = $page.url.searchParams.get("seq");
    // Store for later use after labels are loaded
    const pendingUrlNav = urlSeqId;

    // Load saved labels from Firebase first, fall back to localStorage
    if (firestore) {
      try {
        const snapshot = await getDocs(collection(firestore, CAP_LABELS_COLLECTION));
        if (!snapshot.empty) {
          const firebaseLabels = new Map<string, LabeledSequence>();
          snapshot.forEach((docSnap) => {
            firebaseLabels.set(docSnap.id, docSnap.data() as LabeledSequence);
          });
          labels = firebaseLabels;
          console.log(`Loaded ${labels.size} labels from Firebase`);
        } else {
          // Fall back to localStorage
          const saved = localStorage.getItem("cap-labels");
          if (saved) {
            const parsed = JSON.parse(saved);
            labels = new Map(Object.entries(parsed));
            console.log(`Loaded ${labels.size} labels from localStorage`);
          }
        }
      } catch (error) {
        console.error("Failed to load from Firebase, using localStorage:", error);
        const saved = localStorage.getItem("cap-labels");
        if (saved) {
          const parsed = JSON.parse(saved);
          labels = new Map(Object.entries(parsed));
        }
      }
    } else {
      // No Firestore, use localStorage
      const saved = localStorage.getItem("cap-labels");
      if (saved) {
        const parsed = JSON.parse(saved);
        labels = new Map(Object.entries(parsed));
        console.log(`Loaded ${labels.size} labels from localStorage (no Firestore)`);
      }
    }

    // Now handle URL navigation (after labels are loaded so we know filter state)
    if (pendingUrlNav && sequences.length > 0) {
      const circularSeqs = sequences.filter((s: SequenceEntry) => s.isCircular);
      const targetSeq = circularSeqs.find((s: SequenceEntry) => s.id === pendingUrlNav);

      if (targetSeq) {
        const isLabeled = labels.has(targetSeq.word);

        // Adjust filter mode if necessary to show the target sequence
        if (isLabeled && filterMode === "unlabeled") {
          filterMode = "all";
        } else if (!isLabeled && filterMode === "labeled") {
          filterMode = "all";
        }

        // Now find the index in the filtered list
        // Re-compute filtered sequences with current filter mode
        let filtered: SequenceEntry[];
        if (filterMode === "all") {
          filtered = circularSeqs;
        } else if (filterMode === "unlabeled") {
          filtered = circularSeqs.filter((s: SequenceEntry) => !labels.has(s.word));
        } else {
          filtered = circularSeqs.filter((s: SequenceEntry) => labels.has(s.word));
        }

        const targetIndex = filtered.findIndex((s: SequenceEntry) => s.id === pendingUrlNav);
        if (targetIndex >= 0) {
          currentIndex = targetIndex;
          console.log(`Navigated to sequence "${pendingUrlNav}" from URL (index ${targetIndex}, filter: ${filterMode})`);
        }
      } else {
        console.warn(`Sequence "${pendingUrlNav}" from URL not found in circular sequences`);
      }
    }

    loading = false;
  }

  async function saveLabels() {
    // Save to localStorage as backup
    const obj = Object.fromEntries(labels);
    localStorage.setItem("cap-labels", JSON.stringify(obj));
  }

  // Save a single label to Firebase
  async function saveLabelToFirebase(word: string, label: LabeledSequence) {
    if (!firestore) {
      console.warn("Firestore not initialized, skipping save");
      return;
    }
    syncStatus = "syncing";
    try {
      await setDoc(doc(firestore, CAP_LABELS_COLLECTION, word), {
        ...label,
        updatedAt: new Date().toISOString(),
      });
      syncStatus = "synced";
      console.log(`Saved label for "${word}" to Firebase`);
    } catch (error) {
      console.error("Failed to save to Firebase:", error);
      syncStatus = "error";
    }
  }

  // Delete a label from Firebase
  async function deleteLabelFromFirebase(word: string) {
    if (!firestore) {
      console.warn("Firestore not initialized, skipping delete");
      return;
    }
    syncStatus = "syncing";
    try {
      await deleteDoc(doc(firestore, CAP_LABELS_COLLECTION, word));
      syncStatus = "synced";
      console.log(`Deleted label for "${word}" from Firebase`);
    } catch (error) {
      console.error("Failed to delete from Firebase:", error);
      syncStatus = "error";
    }
  }

  // Sync all localStorage labels to Firebase
  async function syncLocalStorageToFirebase() {
    if (!firestore) {
      alert("Firestore not initialized yet. Please wait and try again.");
      return;
    }

    const saved = localStorage.getItem("cap-labels");
    if (!saved) {
      console.log("No localStorage labels to sync");
      alert("No labels in localStorage to sync");
      return;
    }

    const parsed = JSON.parse(saved);
    const entries = Object.entries(parsed);

    if (entries.length === 0) {
      console.log("No labels to sync");
      alert("No labels to sync");
      return;
    }

    syncStatus = "syncing";
    console.log(`Syncing ${entries.length} labels to Firebase...`);

    let successCount = 0;
    for (const [word, label] of entries) {
      try {
        await setDoc(doc(firestore, CAP_LABELS_COLLECTION, word), {
          ...(label as LabeledSequence),
          updatedAt: new Date().toISOString(),
        });
        successCount++;
      } catch (error) {
        console.error(`Failed to sync "${word}":`, error);
      }
    }

    syncStatus = successCount === entries.length ? "synced" : "error";
    console.log(`Synced ${successCount}/${entries.length} labels to Firebase`);
    alert(`Synced ${successCount}/${entries.length} labels to Firebase`);
  }

  function toggleComponent(id: ComponentId) {
    if (isFreeform) {
      isFreeform = false;
    }
    const newSet = new Set(selectedComponents);
    if (newSet.has(id)) {
      newSet.delete(id);
    } else {
      newSet.add(id);
    }
    selectedComponents = newSet;
  }

  function setFreeform() {
    isFreeform = true;
    selectedComponents = new Set();
  }

  async function markAsUnknown() {
    if (!currentSequence) return;

    const label: LabeledSequence = {
      word: currentSequence.word,
      designations: [],
      sections: undefined,
      isFreeform: false,
      isUnknown: true,
      labeledAt: new Date().toISOString(),
      notes: notes,
    };

    labels.set(currentSequence.word, label);
    labels = new Map(labels); // Trigger reactivity
    saveLabels();

    // Save to Firebase
    await saveLabelToFirebase(currentSequence.word, label);

    // Reset and auto-advance
    resetSelection();
    if (currentIndex < filteredSequences.length - 1) {
      currentIndex++;
    }
  }

  function resetSelection() {
    selectedComponents = new Set();
    isFreeform = false;
    pendingDesignations = [];
    savedSections = [];
    savedBeatPairs = [];
    labelingMode = "whole";
    selectedBeats = new Set();
    lastClickedBeat = null;
    selectedSliceSize = null;
    notes = "";
    firstBeat = null;
    secondBeat = null;
    beatPairAnalysis = null;
  }

  // Add current selection as a designation (for multiple designations)
  function addDesignation() {
    if (selectedComponents.size === 0) return;

    const designation: CAPDesignation = {
      components: Array.from(selectedComponents),
      capType: derivedCapType,
      sliceSize: selectedComponents.has("rotated") ? selectedSliceSize : null,
    };

    // Check if this exact combination already exists
    const exists = pendingDesignations.some(
      d => d.components.sort().join(",") === designation.components.sort().join(",")
    );

    if (!exists) {
      pendingDesignations = [...pendingDesignations, designation];
    }

    // Clear selection for next designation
    selectedComponents = new Set();
    selectedSliceSize = null;
  }

  // Remove a pending designation
  function removeDesignation(index: number) {
    pendingDesignations = pendingDesignations.filter((_, i) => i !== index);
  }

  async function labelSequence() {
    if (!currentSequence) return;

    // In section mode, sections are already saved - just advance
    if (labelingMode === "section") {
      // If there's a current selection, add it first
      if (selectedBeats.size > 0 && selectedComponents.size > 0) {
        await addSectionDesignation();
      }

      // Only advance if we have sections saved
      if (savedSections.length > 0) {
        resetSelection();
        if (currentIndex < filteredSequences.length - 1) {
          currentIndex++;
        }
      }
      return;
    }

    // Whole-sequence mode
    const hasWholeSequenceData = isFreeform || pendingDesignations.length > 0 || selectedComponents.size > 0;
    if (!hasWholeSequenceData) return;

    // If there's a current selection, add it first
    if (selectedComponents.size > 0) {
      addDesignation();
    }

    const label: LabeledSequence = {
      word: currentSequence.word,
      designations: isFreeform ? [] : pendingDesignations,
      sections: undefined,
      isFreeform,
      labeledAt: new Date().toISOString(),
      notes: notes,
    };

    labels.set(currentSequence.word, label);
    labels = new Map(labels); // Trigger reactivity
    saveLabels();

    // Save to Firebase
    await saveLabelToFirebase(currentSequence.word, label);

    // Reset and auto-advance
    resetSelection();
    if (currentIndex < filteredSequences.length - 1) {
      currentIndex++;
    }
  }

  // Navigate to next sequence (used in section mode when sections are already saved)
  function nextSequence() {
    resetSelection();
    if (currentIndex < filteredSequences.length - 1) {
      currentIndex++;
    }
  }

  // Copy sequence JSON to clipboard (includes current designations)
  async function copySequenceJson() {
    if (!currentSequence) return;

    // Find the full sequence data from the raw JSON
    const response = await fetch("/data/sequence-index.json");
    const data = await response.json();
    const fullSeq = data.sequences?.find((s: SequenceEntry) => s.word === currentSequence.word);

    if (fullSeq) {
      // Build current designations (pending + current selection if any)
      const allDesignations = [...pendingDesignations];
      if (selectedComponents.size > 0) {
        allDesignations.push({
          components: Array.from(selectedComponents),
          capType: derivedCapType,
        });
      }

      // Create export object with designations
      const exportData = {
        ...fullSeq,
        _myDesignations: isFreeform
          ? { isFreeform: true, designations: [] }
          : {
              isFreeform: false,
              designations: allDesignations.map(d => ({
                components: d.components,
                capType: d.capType,
                humanReadable: formatDesignation(d)
              }))
            },
        _notes: notes || undefined,
      };

      await navigator.clipboard.writeText(JSON.stringify(exportData, null, 2));
      copiedToast = true;
      setTimeout(() => copiedToast = false, 2000);
    }
  }

  function skipSequence() {
    resetSelection();
    if (currentIndex < filteredSequences.length - 1) {
      currentIndex++;
    }
  }

  function previousSequence() {
    resetSelection();
    if (currentIndex > 0) {
      currentIndex--;
    }
  }

  async function removeLabel() {
    if (!currentSequence) return;
    labels.delete(currentSequence.word);
    labels = new Map(labels);
    saveLabels();
    await deleteLabelFromFirebase(currentSequence.word);
  }

  function exportLabels() {
    const data = Object.fromEntries(labels);
    const blob = new Blob([JSON.stringify(data, null, 2)], {
      type: "application/json",
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `cap-labels-${new Date().toISOString().split("T")[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }

  function importLabels(event: Event) {
    const input = event.target as HTMLInputElement;
    const file = input.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target?.result as string);
        labels = new Map(Object.entries(data));
        saveLabels();
      } catch (error) {
        console.error("Failed to import labels:", error);
      }
    };
    reader.readAsText(file);
  }
</script>

<div class="labeler-page">
  <header class="header">
    <h1>CAP Type Labeler</h1>
    <div class="stats">
      <span class="stat">{stats.labeled} labeled</span>
      <span class="stat">{stats.remaining} remaining</span>
      <span class="stat">{stats.total} total circular</span>
      <span class="sync-status" class:syncing={syncStatus === "syncing"} class:error={syncStatus === "error"}>
        {#if syncStatus === "syncing"}
          ⟳ Syncing...
        {:else if syncStatus === "error"}
          ⚠ Sync error
        {:else}
          ✓ Firebase
        {/if}
      </span>
    </div>
  </header>

  <div class="controls-bar">
    <div class="filter-chips">
      <button
        class="filter-chip"
        class:active={filterMode === "unlabeled"}
        onclick={() => filterMode = "unlabeled"}
      >
        Unlabeled
      </button>
      <button
        class="filter-chip"
        class:active={filterMode === "labeled"}
        onclick={() => filterMode = "labeled"}
      >
        Labeled
      </button>
      <button
        class="filter-chip"
        class:active={filterMode === "unknown"}
        onclick={() => filterMode = "unknown"}
      >
        Unknown ({stats.unknown})
      </button>
      <button
        class="filter-chip"
        class:active={filterMode === "all"}
        onclick={() => filterMode = "all"}
      >
        All
      </button>
    </div>

    <div class="io-controls">
      <button class="btn-secondary" onclick={() => (showExport = !showExport)}>
        Import/Export
      </button>
    </div>
  </div>

  {#if showExport}
    <div class="export-panel">
      <button class="btn-primary" onclick={exportLabels}>
        Export Labels JSON
      </button>
      <label class="btn-secondary">
        Import Labels
        <input
          type="file"
          accept=".json"
          onchange={importLabels}
          style="display: none"
        />
      </label>
      <button class="btn-sync" onclick={syncLocalStorageToFirebase}>
        ↑ Sync localStorage → Firebase
      </button>
    </div>
  {/if}

  {#if loading}
    <div class="loading">Loading sequences...</div>
  {:else if !currentSequence}
    <div class="empty">
      {#if filterMode === "unlabeled"}
        🎉 All circular sequences have been labeled!
      {:else}
        No sequences match the current filter.
      {/if}
    </div>
  {:else}
    <div class="main-content">
      <!-- Sequence Preview -->
      <div class="sequence-preview">
        <div class="sequence-header">
          <div class="sequence-info">
            <h2>{currentSequence.word}</h2>
            <div class="meta">
              <span class="meta-id" title="Sequence ID">ID: {currentSequence.id}</span>
              <span>Length: {currentSequence.sequenceLength}</span>
              <span class="grid-mode-badge" class:box={authoritativeGridMode === GridMode.BOX}>
                {authoritativeGridMode === GridMode.BOX ? "◇ BOX" : "◆ DIAMOND"}
              </span>
              {#if currentSequence.fullMetadata?.sequence?.[0]?.gridMode && currentSequence.fullMetadata.sequence[0].gridMode !== currentSequence.gridMode}
                <span class="grid-mode-mismatch" title="Top-level gridMode differs from metadata">
                  ⚠️ Fix: top says "{currentSequence.gridMode}"
                </span>
              {/if}
              <span>CAP: {currentSequence.capType || "none"}</span>
            </div>
          </div>
          <button class="copy-json-btn" onclick={copySequenceJson}>
            {copiedToast ? "✓ Copied!" : "Copy JSON"}
          </button>
        </div>

        <!-- BeatGrid with real Pictographs -->
        {#if parsedBeats.length > 0}
          <div class="beat-grid-section">
            <!-- Grid controls bar -->
            <div class="grid-controls-bar">
              <!-- Start position toggle + Column chips -->
              <div class="control-group">
                <button
                  class="control-chip"
                  class:active={showStartPosition}
                  onclick={() => showStartPosition = !showStartPosition}
                >
                  Start
                </button>
                <span class="control-divider">|</span>
                <span class="control-label">Cols:</span>
                <div class="chip-group">
                  <button
                    class="control-chip"
                    class:active={manualColumnCount === null}
                    onclick={() => setColumnCount(null)}
                  >
                    Auto{manualColumnCount === null && effectiveColumnCount !== null ? ` (${effectiveColumnCount})` : ""}
                  </button>
                  {#each availableColumnOptions as colCount}
                    <button
                      class="control-chip"
                      class:active={manualColumnCount === colCount}
                      onclick={() => setColumnCount(colCount)}
                    >
                      {colCount}
                    </button>
                  {/each}
                </div>
              </div>
            </div>

            <div class="beat-grid-wrapper" class:section-mode={labelingMode === "section"}>
              <BeatGrid
                beats={parsedBeats}
                startPosition={showStartPosition ? parsedStartPosition : null}
                onBeatClick={handleBeatClick}
                selectedBeatNumber={labelingMode === "whole" ? selectedBeatNumber : null}
                manualColumnCount={effectiveColumnCount}
                {highlightedBeats}
              />
            </div>
          </div>
        {:else if currentThumbnailUrl}
          <!-- Fallback to thumbnail if no beat data -->
          <img
            src={currentThumbnailUrl}
            alt={currentSequence.word}
            class="thumbnail"
          />
        {:else}
          <div class="no-thumbnail">No beat data available</div>
        {/if}

        {#if currentLabel}
          <div class="current-label">
            <strong>Labeled as:</strong>
            {#if currentLabel.isFreeform}
              <span class="freeform-tag">Freeform</span>
            {:else if currentLabel.sections && currentLabel.sections.length > 0}
              <!-- Section-based labels -->
              <div class="label-sections">
                {#each currentLabel.sections as section}
                  <div class="label-section-item">
                    <span class="section-beats">{formatSectionBeats(section.beats)}</span>
                    <span class="section-components">{formatDesignation(section)}</span>
                  </div>
                {/each}
              </div>
            {:else if currentLabel.designations?.length > 0}
              <div class="label-designations">
                {#each currentLabel.designations as d, i}
                  <span class="designation-tag">
                    {formatDesignation(d)}
                    <span class="designation-type">({d.capType})</span>
                  </span>
                  {#if i < currentLabel.designations.length - 1}
                    <span class="designation-or">OR</span>
                  {/if}
                {/each}
              </div>
            {:else}
              Freeform
            {/if}
            {#if currentLabel.notes}
              <div class="label-notes">Notes: {currentLabel.notes}</div>
            {/if}
          </div>
        {/if}
      </div>

      <!-- Labeling Controls -->
      <div class="labeling-section">
        <h3>Select CAP Components:</h3>

        <!-- Base component checkboxes -->
        <div class="component-grid">
          {#each BASE_COMPONENTS as component}
            <button
              class="component-btn"
              class:selected={selectedComponents.has(component.id)}
              style="--component-color: {component.color}"
              onclick={() => toggleComponent(component.id)}
            >
              <div class="component-icon">
                <FontAwesomeIcon icon={component.icon} size="1.5em" color={component.color} />
              </div>
              <div class="component-text">
                <span class="component-name">{component.label}</span>
                <span class="component-desc">{component.description}</span>
              </div>
            </button>
          {/each}
        </div>

        <!-- Slice size selector (only shown when Rotated is selected) -->
        {#if isRotatedSelected}
          <div class="slice-size-selector">
            <span class="slice-size-label">Rotation Size:</span>
            <div class="slice-size-options">
              <button
                class="slice-size-btn"
                class:selected={selectedSliceSize === SliceSize.HALVED}
                onclick={() => selectedSliceSize = SliceSize.HALVED}
              >
                <span class="slice-name">Halved</span>
                <span class="slice-desc">180° per half</span>
              </button>
              <button
                class="slice-size-btn"
                class:selected={selectedSliceSize === SliceSize.QUARTERED}
                onclick={() => selectedSliceSize = SliceSize.QUARTERED}
              >
                <span class="slice-name">Quartered</span>
                <span class="slice-desc">90° per quarter</span>
              </button>
            </div>
          </div>
        {/if}

        <!-- Mode Toggle: Whole Sequence vs Section Mode vs Beat Pair -->
        <div class="mode-toggle-container">
          <button
            class="mode-toggle-btn"
            class:active={labelingMode === "whole"}
            onclick={() => labelingMode = "whole"}
          >
            <FontAwesomeIcon icon="layer-group" size="1em" />
            Whole Sequence
          </button>
          <button
            class="mode-toggle-btn"
            class:active={labelingMode === "section"}
            onclick={() => labelingMode = "section"}
          >
            <FontAwesomeIcon icon="grip" size="1em" />
            Section Mode
          </button>
          <button
            class="mode-toggle-btn"
            class:active={labelingMode === "beatpair"}
            onclick={() => labelingMode = "beatpair"}
          >
            <FontAwesomeIcon icon="link" size="1em" />
            Beat Pair
          </button>
        </div>

        {#if labelingMode === "section"}
          <!-- SECTION MODE -->
          <div class="section-mode-panel">
            <div class="section-mode-hint">
              Click beats to select, hold Shift for range. Then pick components and click "Add Section".
            </div>

            <!-- Current selection status -->
            {#if selectedBeats.size > 0}
              <div class="current-selection-status">
                <span class="selection-count">{selectedBeats.size} beats selected</span>
                {#if selectedComponents.size > 0}
                  <span class="selection-arrow">→</span>
                  <span class="selection-components">{selectionLabel}</span>
                {/if}
              </div>
            {/if}

            <!-- Add Section button -->
            <button
              class="add-section-btn"
              onclick={addSectionDesignation}
              disabled={selectedBeats.size === 0 || selectedComponents.size === 0}
            >
              <FontAwesomeIcon icon="plus" size="1em" />
              Add Section
            </button>

            <!-- Unknown button (for sequences that need review) -->
            <button
              class="unknown-btn"
              onclick={markAsUnknown}
            >
              Unknown - Review Later
            </button>

            <!-- Saved sections -->
            {#if savedSections.length > 0}
              <div class="saved-sections">
                <span class="saved-label">Saved sections:</span>
                {#each savedSections as section, i}
                  <div class="saved-section-tag" style="--section-color: {SECTION_COLORS[i % SECTION_COLORS.length]?.border}">
                    <span class="section-beats">{formatSectionBeats(section.beats)}</span>
                    <span class="section-components">{formatDesignation(section)}</span>
                    <button class="remove-btn" onclick={() => removeSectionDesignation(i)}>×</button>
                  </div>
                {/each}
              </div>
            {/if}

            <!-- Next button (disabled if there's unsaved work) -->
            {#if savedSections.length > 0}
              <button
                class="next-btn"
                onclick={nextSequence}
                disabled={hasPendingWork}
                title={hasPendingWork ? "Save or clear your current selection first" : "Go to next sequence"}
              >
                Next →
              </button>
            {/if}
          </div>

        {:else if labelingMode === "beatpair"}
          <!-- BEAT PAIR MODE -->
          <div class="beatpair-mode-panel">
            <div class="beatpair-mode-hint">
              Click first beat (key), then second beat (corresponding) to analyze their relationship.
            </div>

            <!-- Current selection status -->
            {#if firstBeat !== null || secondBeat !== null}
              <div class="beatpair-selection-status">
                <div class="beatpair-selection-info">
                  {#if firstBeat !== null}
                    <span class="beatpair-key">
                      <span class="beatpair-indicator" style="background: rgba(34, 197, 94, 0.35); border: 2px solid rgba(34, 197, 94, 0.9);"></span>
                      Key Beat: {firstBeat}
                    </span>
                  {/if}
                  {#if secondBeat !== null}
                    <span class="beatpair-arrow">→</span>
                    <span class="beatpair-corresponding">
                      <span class="beatpair-indicator" style="background: rgba(168, 85, 247, 0.35); border: 2px solid rgba(168, 85, 247, 0.9);"></span>
                      Corresponding: {secondBeat}
                    </span>
                  {/if}
                </div>
                <button
                  class="clear-selection-btn"
                  onclick={() => {
                    firstBeat = null;
                    secondBeat = null;
                    beatPairAnalysis = null;
                  }}
                  title="Clear selection and start over"
                >
                  <FontAwesomeIcon icon="times" size="1em" />
                  Clear
                </button>
              </div>
            {/if}

            <!-- Detected transformations -->
            {#if beatPairAnalysis}
              <div class="detected-transformations">
                <span class="transformations-label">Detected Transformations:</span>
                <div class="transformations-list">
                  {#each beatPairAnalysis.detectedTransformations as transformation}
                    <button
                      class="transformation-option"
                      class:selected={beatPairAnalysis.confirmedTransformation === transformation}
                      onclick={() => {
                        if (beatPairAnalysis) {
                          beatPairAnalysis.confirmedTransformation = transformation;
                        }
                      }}
                    >
                      {transformation}
                    </button>
                  {/each}
                </div>
              </div>

              <!-- Save beat pair button -->
              <button
                class="save-beatpair-btn"
                onclick={saveBeatPair}
                disabled={!beatPairAnalysis.confirmedTransformation}
              >
                <FontAwesomeIcon icon="save" size="1em" />
                Save Beat Pair
              </button>
            {/if}

            <!-- Unknown button -->
            <button
              class="unknown-btn"
              onclick={markAsUnknown}
            >
              Unknown - Review Later
            </button>

            <!-- Saved beat pairs -->
            {#if savedBeatPairs.length > 0}
              <div class="saved-beatpairs">
                <span class="saved-label">Saved Beat Pairs:</span>
                {#each savedBeatPairs as pair, i}
                  <div class="saved-beatpair-tag">
                    <span class="beatpair-beats">{pair.keyBeat} ↔ {pair.correspondingBeat}</span>
                    <span class="beatpair-transformation">{pair.confirmedTransformation || pair.detectedTransformations[0]}</span>
                    <button class="remove-btn" onclick={() => removeBeatPair(i)}>×</button>
                  </div>
                {/each}
              </div>
            {/if}

            <!-- Next button (disabled if there's unsaved work) -->
            {#if savedBeatPairs.length > 0}
              <button
                class="next-btn"
                onclick={nextSequence}
                disabled={hasPendingWork}
                title={hasPendingWork ? "Save or clear your current beat pair first" : "Go to next sequence"}
              >
                Next →
              </button>
            {/if}
          </div>

        {:else}
          <!-- WHOLE SEQUENCE MODE -->
          <div class="whole-sequence-panel">
            <div class="selection-display">
              <span class="selection-label">Components:</span>
              <span class="selection-value" class:empty={!isFreeform && selectedComponents.size === 0}>
                {selectionLabel}
              </span>
              {#if derivedCapType && !isFreeform}
                <span class="derived-type">→ {derivedCapType}</span>
              {/if}
              {#if selectedComponents.size > 0}
                <button class="add-another-btn" onclick={addDesignation}>
                  + Add alternate
                </button>
              {/if}
            </div>

            <!-- Pending designations -->
            {#if pendingDesignations.length > 0}
              <div class="pending-designations">
                <span class="pending-label">Designations:</span>
                {#each pendingDesignations as d, i}
                  <div class="pending-tag">
                    <span>{formatDesignation(d)}</span>
                    <button class="remove-btn" onclick={() => removeDesignation(i)}>×</button>
                  </div>
                  {#if i < pendingDesignations.length - 1}
                    <span class="or-divider">OR</span>
                  {/if}
                {/each}
              </div>
            {/if}

            <!-- Action buttons -->
            <div class="action-buttons">
              <button
                class="freeform-btn"
                class:selected={isFreeform}
                onclick={setFreeform}
              >
                Freeform (no pattern)
              </button>

              <button
                class="unknown-btn"
                onclick={markAsUnknown}
              >
                Unknown - Review Later
              </button>

              <button
                class="save-btn"
                onclick={labelSequence}
                disabled={!isFreeform &&
                pendingDesignations.length === 0 &&
                selectedComponents.size === 0}
            >
              Save & Next
            </button>
            </div>
          </div>
        {/if}

        <div class="notes-section">
          <label>
            Notes (optional):
            <input
              type="text"
              bind:value={notes}
              placeholder="Any observations about this sequence..."
            />
          </label>
        </div>

        <div class="navigation">
          <button
            class="btn-nav"
            onclick={previousSequence}
            disabled={currentIndex === 0}
          >
            ← Previous
          </button>
          <span class="position">
            {currentIndex + 1} / {filteredSequences.length}
          </span>
          <button class="btn-nav" onclick={skipSequence}>
            Skip →
          </button>
        </div>

        {#if currentLabel}
          <button class="btn-danger" onclick={removeLabel}>
            Remove Label
          </button>
        {/if}
      </div>
    </div>
  {/if}
</div>

<style>
  /* ============================================================================
     DESIGN TOKENS - Consistent primitives for the CAP Labeler
     ============================================================================ */

  .labeler-page {
    /* Border Radius Scale */
    --radius-xs: 4px;      /* Inline tags, badges */
    --radius-sm: 6px;      /* Small buttons, inputs */
    --radius-md: 8px;      /* Cards, panels, medium elements */
    --radius-lg: 12px;     /* Large panels, major sections */
    --radius-pill: 9999px; /* Pill-shaped chips */

    /* Spacing Scale */
    --space-xs: 4px;
    --space-sm: 8px;
    --space-md: 12px;
    --space-lg: 16px;
    --space-xl: 20px;
    --space-2xl: 24px;

    /* Font Sizes */
    --text-xs: 11px;
    --text-sm: 12px;
    --text-md: 13px;
    --text-lg: 14px;
    --text-xl: 15px;
    --text-2xl: 16px;
    --text-3xl: 24px;
    --text-4xl: 28px;

    /* Surface Colors */
    --surface-base: #0f0f1a;
    --surface-raised: rgba(255, 255, 255, 0.05);
    --surface-overlay: rgba(255, 255, 255, 0.08);
    --surface-inset: rgba(0, 0, 0, 0.3);

    /* Border Colors */
    --border-subtle: rgba(255, 255, 255, 0.1);
    --border-default: rgba(255, 255, 255, 0.15);
    --border-strong: rgba(255, 255, 255, 0.2);

    /* Text Colors */
    --text-primary: #fff;
    --text-secondary: rgba(255, 255, 255, 0.7);
    --text-muted: rgba(255, 255, 255, 0.5);
    --text-faint: rgba(255, 255, 255, 0.4);

    /* Accent Colors */
    --accent-primary: #6366f1;
    --accent-primary-soft: rgba(99, 102, 241, 0.3);
    --accent-success: #22c55e;
    --accent-success-soft: rgba(34, 197, 94, 0.2);
    --accent-warning: #eab308;
    --accent-warning-soft: rgba(234, 179, 8, 0.2);
    --accent-danger: #ef4444;
    --accent-danger-soft: rgba(239, 68, 68, 0.2);
    --accent-blue: #3b82f6;
    --accent-blue-soft: rgba(59, 130, 246, 0.2);

    /* Transition */
    --transition-fast: 0.1s ease;
    --transition-default: 0.15s ease;
    --transition-smooth: 0.2s cubic-bezier(0.4, 0, 0.2, 1);

    /* Layout */
    min-height: 100vh;
    background: var(--surface-base);
    color: var(--text-primary);
    padding: var(--space-xl);
    font-family: system-ui, sans-serif;
    max-width: 1500px;
    margin: 0 auto;
  }

  /* ============================================================================
     HEADER
     ============================================================================ */

  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-xl);
    padding-bottom: var(--space-lg);
    border-bottom: 1px solid var(--border-subtle);
  }

  .header h1 {
    margin: 0;
    font-size: var(--text-3xl);
  }

  .stats {
    display: flex;
    gap: var(--space-lg);
  }

  .stat {
    background: var(--surface-overlay);
    padding: var(--space-xs) var(--space-md);
    border-radius: var(--radius-sm);
    font-size: var(--text-md);
  }

  .sync-status {
    padding: var(--space-xs) var(--space-md);
    border-radius: var(--radius-sm);
    font-size: var(--text-sm);
    background: var(--accent-success-soft);
    color: var(--accent-success);
  }

  .sync-status.syncing {
    background: var(--accent-warning-soft);
    color: var(--accent-warning);
    animation: pulse 1s infinite;
  }

  .sync-status.error {
    background: var(--accent-danger-soft);
    color: var(--accent-danger);
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }

  /* ============================================================================
     CONTROLS BAR & FILTER CHIPS
     ============================================================================ */

  .controls-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-xl);
  }

  .filter-chips {
    display: flex;
    gap: var(--space-sm);
  }

  .filter-chip {
    padding: var(--space-sm) var(--space-lg);
    background: var(--surface-overlay);
    border: 1px solid var(--border-default);
    border-radius: var(--radius-pill);
    color: var(--text-secondary);
    cursor: pointer;
    font-size: var(--text-md);
    transition: var(--transition-default);
  }

  .filter-chip:hover {
    background: rgba(255, 255, 255, 0.12);
  }

  .filter-chip.active {
    background: var(--accent-primary-soft);
    border-color: var(--accent-primary);
    color: var(--text-primary);
  }

  .export-panel {
    display: flex;
    gap: var(--space-md);
    margin-bottom: var(--space-xl);
    padding: var(--space-lg);
    background: var(--surface-raised);
    border-radius: var(--radius-md);
  }

  .btn-sync {
    padding: 10px var(--space-lg);
    background: var(--accent-success-soft);
    border: 1px solid rgba(34, 197, 94, 0.4);
    border-radius: var(--radius-sm);
    color: var(--accent-success);
    cursor: pointer;
    font-size: var(--text-md);
    transition: var(--transition-default);
  }

  .btn-sync:hover {
    background: rgba(34, 197, 94, 0.3);
  }

  /* ============================================================================
     LOADING & EMPTY STATES
     ============================================================================ */

  .loading,
  .empty {
    text-align: center;
    padding: 60px;
    font-size: 18px;
    color: var(--text-muted);
  }

  /* ============================================================================
     MAIN CONTENT LAYOUT
     ============================================================================ */

  .main-content {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-2xl);
  }

  .sequence-preview {
    background: var(--surface-raised);
    border-radius: var(--radius-lg);
    padding: var(--space-xl);
  }

  .sequence-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: var(--space-lg);
  }

  .sequence-info h2 {
    margin: 0 0 var(--space-md);
    font-size: var(--text-4xl);
  }

  .meta {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-md);
    font-size: var(--text-md);
    color: var(--text-muted);
  }

  .meta-id {
    font-family: monospace;
    color: var(--text-faint);
    font-size: var(--text-xs);
  }

  .grid-mode-badge {
    padding: 2px var(--space-sm);
    border-radius: var(--radius-xs);
    font-weight: 600;
    font-size: var(--text-xs);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    background: var(--accent-primary-soft);
    color: #a5b4fc;
    border: 1px solid rgba(99, 102, 241, 0.5);
  }

  .grid-mode-badge.box {
    background: var(--accent-warning-soft);
    color: #fde047;
    border-color: rgba(234, 179, 8, 0.5);
  }

  .grid-mode-mismatch {
    font-size: var(--text-xs);
    color: #fbbf24;
    background: rgba(251, 191, 36, 0.15);
    padding: 2px var(--space-xs);
    border-radius: var(--radius-xs);
  }

  .copy-json-btn {
    padding: var(--space-sm) var(--space-md);
    background: var(--surface-overlay);
    border: 1px solid var(--border-strong);
    border-radius: var(--radius-sm);
    color: var(--text-primary);
    cursor: pointer;
    font-size: var(--text-sm);
    transition: var(--transition-default);
    white-space: nowrap;
  }

  .copy-json-btn:hover {
    background: rgba(255, 255, 255, 0.15);
  }

  /* ============================================================================
     BEAT GRID
     ============================================================================ */

  .beat-grid-section {
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
  }

  .beat-grid-wrapper {
    width: 100%;
    min-height: 200px;
    max-height: none;
    background: var(--surface-inset);
    border-radius: var(--radius-lg);
    padding: var(--space-lg);
    box-sizing: border-box;
    overflow: visible;
  }

  .beat-grid-wrapper.section-mode {
    border: 2px solid rgba(59, 130, 246, 0.4);
    cursor: pointer;
  }

  .thumbnail {
    width: 100%;
    max-width: 500px;
    border-radius: var(--radius-md);
    background: #1a1a2e;
  }

  .no-thumbnail {
    width: 100%;
    height: 300px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--surface-raised);
    border-radius: var(--radius-md);
    color: var(--text-faint);
  }

  /* ============================================================================
     GRID CONTROLS BAR
     ============================================================================ */

  .grid-controls-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: var(--space-xl);
    margin-bottom: var(--space-sm);
  }

  .control-group {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
  }

  .control-label {
    font-size: var(--text-xs);
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .control-divider {
    color: var(--border-strong);
    margin: 0 var(--space-xs);
  }

  .chip-group {
    display: flex;
    gap: var(--space-xs);
  }

  .control-chip {
    padding: 5px 10px;
    background: var(--surface-overlay);
    border: 1px solid var(--border-default);
    border-radius: var(--radius-sm);
    color: var(--text-secondary);
    font-size: var(--text-sm);
    cursor: pointer;
    transition: var(--transition-fast);
  }

  .control-chip:hover {
    background: rgba(255, 255, 255, 0.12);
    color: var(--text-primary);
  }

  .control-chip.active {
    background: var(--accent-primary-soft);
    border-color: var(--accent-primary);
    color: var(--text-primary);
  }

  /* ============================================================================
     CURRENT LABEL DISPLAY
     ============================================================================ */

  .current-label {
    margin-top: var(--space-lg);
    padding: var(--space-md);
    background: var(--accent-primary-soft);
    border-radius: var(--radius-md);
    font-size: var(--text-lg);
  }

  .label-notes {
    margin-top: var(--space-sm);
    font-size: var(--text-sm);
    color: var(--text-muted);
  }

  .label-designations {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: var(--space-sm);
    margin-top: var(--space-sm);
  }

  .designation-tag {
    display: inline-flex;
    align-items: center;
    gap: var(--space-xs);
    padding: var(--space-xs) 10px;
    background: var(--accent-success-soft);
    border-radius: var(--radius-sm);
    font-size: var(--text-md);
  }

  .designation-type {
    font-size: 10px;
    color: var(--text-faint);
    font-family: monospace;
  }

  .designation-or, .or-divider {
    font-size: var(--text-xs);
    color: var(--text-faint);
    font-weight: 600;
  }

  .freeform-tag {
    padding: var(--space-xs) 10px;
    background: var(--accent-danger-soft);
    border-radius: var(--radius-sm);
    font-size: var(--text-md);
  }

  .label-sections {
    display: flex;
    flex-direction: column;
    gap: var(--space-xs);
    margin-top: var(--space-sm);
  }

  .label-section-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: var(--space-xs) 10px;
    background: rgba(59, 130, 246, 0.15);
    border-radius: var(--radius-sm);
    font-size: var(--text-md);
  }

  .label-section-item .section-beats {
    font-weight: 600;
    color: #60a5fa;
    min-width: 70px;
  }

  .label-section-item .section-components {
    color: rgba(255, 255, 255, 0.8);
  }

  /* ============================================================================
     LABELING SECTION
     ============================================================================ */

  .labeling-section {
    background: var(--surface-raised);
    border-radius: var(--radius-lg);
    padding: var(--space-xl);
  }

  .labeling-section h3 {
    margin: 0 0 var(--space-lg);
  }

  /* ============================================================================
     COMPONENT BUTTONS
     ============================================================================ */

  .component-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    margin-bottom: var(--space-md);
  }

  .component-btn {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: var(--space-md);
    padding: var(--space-md) var(--space-md);
    background: linear-gradient(
      135deg,
      color-mix(in srgb, var(--component-color) 15%, rgba(0, 0, 0, 0.4)) 0%,
      rgba(0, 0, 0, 0.3) 100%
    );
    border: 2px solid color-mix(in srgb, var(--component-color) 35%, rgba(255, 255, 255, 0.15));
    border-radius: var(--radius-md);
    color: var(--text-primary);
    cursor: pointer;
    text-align: left;
    transition: var(--transition-smooth);
  }

  .component-btn:hover {
    background: linear-gradient(
      135deg,
      color-mix(in srgb, var(--component-color) 25%, rgba(0, 0, 0, 0.35)) 0%,
      rgba(0, 0, 0, 0.25) 100%
    );
    border-color: color-mix(in srgb, var(--component-color) 50%, rgba(255, 255, 255, 0.2));
    transform: translateY(-1px);
    box-shadow: 0 4px 12px color-mix(in srgb, var(--component-color) 30%, transparent);
  }

  .component-btn.selected {
    background: linear-gradient(
      135deg,
      color-mix(in srgb, var(--component-color) 35%, rgba(255, 255, 255, 0.1)) 0%,
      color-mix(in srgb, var(--component-color) 20%, rgba(0, 0, 0, 0.3)) 100%
    );
    border-color: var(--component-color);
    border-width: 3px;
    box-shadow:
      0 0 20px color-mix(in srgb, var(--component-color) 40%, transparent),
      inset 0 0 15px color-mix(in srgb, var(--component-color) 10%, transparent);
  }

  .component-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    flex-shrink: 0;
  }

  .component-text {
    display: flex;
    flex-direction: column;
    gap: 2px;
    min-width: 0;
  }

  .component-name {
    font-size: var(--text-xl);
    font-weight: 600;
  }

  .component-desc {
    font-size: var(--text-xs);
    color: var(--text-muted);
  }

  .component-btn.selected .component-desc {
    color: var(--text-secondary);
  }

  /* ============================================================================
     SELECTION DISPLAY
     ============================================================================ */

  .selection-display {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    padding: var(--space-md) var(--space-lg);
    background: var(--surface-inset);
    border-radius: var(--radius-md);
    margin-bottom: var(--space-md);
    flex-wrap: wrap;
  }

  .selection-label {
    font-size: var(--text-md);
    color: var(--text-muted);
  }

  .selection-value {
    font-size: var(--text-xl);
    font-weight: 600;
    color: var(--accent-success);
  }

  .selection-value.empty {
    color: var(--text-faint);
    font-weight: 400;
  }

  .derived-type {
    font-size: var(--text-sm);
    color: var(--text-faint);
    font-family: monospace;
  }

  .add-another-btn {
    padding: var(--space-xs) var(--space-md);
    background: var(--accent-success-soft);
    border: 1px solid rgba(34, 197, 94, 0.4);
    border-radius: var(--radius-sm);
    color: var(--accent-success);
    cursor: pointer;
    font-size: var(--text-sm);
    margin-left: auto;
    transition: var(--transition-default);
  }

  .add-another-btn:hover {
    background: rgba(34, 197, 94, 0.3);
  }

  /* ============================================================================
     PENDING DESIGNATIONS
     ============================================================================ */

  .pending-designations {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: var(--space-sm);
    padding: var(--space-md) var(--space-lg);
    background: rgba(34, 197, 94, 0.1);
    border: 1px solid rgba(34, 197, 94, 0.3);
    border-radius: var(--radius-md);
    margin-bottom: var(--space-md);
  }

  .pending-label {
    font-size: var(--text-sm);
    color: var(--text-muted);
    margin-right: var(--space-xs);
  }

  .pending-tag {
    display: inline-flex;
    align-items: center;
    gap: var(--space-xs);
    padding: var(--space-xs) 10px;
    background: rgba(34, 197, 94, 0.25);
    border-radius: var(--radius-sm);
    font-size: var(--text-md);
    font-weight: 500;
  }

  .remove-btn {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 0 2px;
    font-size: var(--text-2xl);
    line-height: 1;
  }

  .remove-btn:hover {
    color: var(--accent-danger);
  }

  /* ============================================================================
     SECTION DISPLAY
     ============================================================================ */

  .section-beats {
    font-weight: 600;
    color: #60a5fa;
    min-width: 80px;
  }

  .section-components {
    color: rgba(255, 255, 255, 0.9);
    flex: 1;
  }

  /* ============================================================================
     ACTION BUTTONS
     ============================================================================ */

  .action-buttons {
    display: flex;
    gap: var(--space-md);
    margin-bottom: var(--space-lg);
  }

  .freeform-btn {
    flex: 1;
    padding: var(--space-md) var(--space-lg);
    background: var(--surface-raised);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    color: var(--text-secondary);
    cursor: pointer;
    font-size: var(--text-md);
    transition: var(--transition-default);
  }

  .freeform-btn:hover {
    background: var(--surface-overlay);
  }

  .freeform-btn.selected {
    background: rgba(239, 68, 68, 0.25);
    border-color: var(--accent-danger);
    color: var(--text-primary);
  }

  .unknown-btn {
    flex: 1;
    padding: var(--space-md) var(--space-lg);
    background: rgba(234, 179, 8, 0.15);
    border: 1px solid rgba(234, 179, 8, 0.4);
    border-radius: var(--radius-md);
    color: #eab308;
    cursor: pointer;
    font-size: var(--text-md);
    font-weight: 500;
    transition: var(--transition-default);
  }

  .unknown-btn:hover {
    background: rgba(234, 179, 8, 0.25);
    border-color: rgba(234, 179, 8, 0.6);
  }

  .save-btn {
    flex: 2;
    padding: var(--space-md) var(--space-xl);
    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
    border: none;
    border-radius: var(--radius-md);
    color: var(--text-primary);
    font-size: var(--text-2xl);
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition-default);
  }

  .save-btn:hover:not(:disabled) {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
  }

  .save-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }

  /* ============================================================================
     NOTES SECTION
     ============================================================================ */

  .notes-section {
    margin-top: var(--space-xl);
  }

  .notes-section label {
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
    font-size: var(--text-lg);
  }

  .notes-section input {
    padding: 10px var(--space-md);
    background: var(--surface-inset);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-sm);
    color: var(--text-primary);
    font-size: var(--text-lg);
  }

  /* ============================================================================
     NAVIGATION
     ============================================================================ */

  .navigation {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-lg);
    margin-top: var(--space-2xl);
  }

  .position {
    font-size: var(--text-lg);
    color: var(--text-muted);
  }

  .btn-nav,
  .btn-primary,
  .btn-secondary,
  .btn-danger {
    padding: 10px var(--space-xl);
    border-radius: var(--radius-sm);
    cursor: pointer;
    font-size: var(--text-lg);
    border: none;
    transition: var(--transition-default);
  }

  .btn-nav {
    background: var(--surface-overlay);
    color: var(--text-primary);
  }

  .btn-nav:hover:not(:disabled) {
    background: rgba(255, 255, 255, 0.15);
  }

  .btn-nav:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }

  .btn-primary {
    background: var(--accent-primary);
    color: var(--text-primary);
  }

  .btn-secondary {
    background: var(--surface-overlay);
    color: var(--text-primary);
  }

  .btn-danger {
    background: var(--accent-danger-soft);
    color: var(--text-primary);
    margin-top: var(--space-lg);
    width: 100%;
  }

  .btn-danger:hover {
    background: rgba(239, 68, 68, 0.5);
  }

  /* ============================================================================
     SLICE SIZE SELECTOR
     ============================================================================ */

  .slice-size-selector {
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
    padding: var(--space-md) var(--space-lg);
    background: rgba(234, 179, 8, 0.1);
    border: 1px solid rgba(234, 179, 8, 0.3);
    border-radius: var(--radius-md);
    margin-bottom: var(--space-md);
  }

  .slice-size-label {
    font-size: var(--text-md);
    color: var(--text-secondary);
    font-weight: 500;
  }

  .slice-size-options {
    display: flex;
    gap: 10px;
  }

  .slice-size-btn {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 2px;
    padding: 10px var(--space-md);
    background: var(--surface-overlay);
    border: 2px solid var(--border-default);
    border-radius: var(--radius-md);
    color: var(--text-primary);
    cursor: pointer;
    text-align: left;
    transition: var(--transition-default);
  }

  .slice-size-btn:hover {
    background: rgba(255, 255, 255, 0.12);
    border-color: var(--border-strong);
  }

  .slice-size-btn.selected {
    background: rgba(234, 179, 8, 0.25);
    border-color: var(--accent-warning);
  }

  .slice-name {
    font-size: var(--text-lg);
    font-weight: 600;
  }

  .slice-desc {
    font-size: var(--text-xs);
    color: var(--text-muted);
  }

  .slice-size-btn.selected .slice-desc {
    color: var(--text-secondary);
  }

  /* ============================================================================
     MODE TOGGLE
     ============================================================================ */

  .mode-toggle-container {
    display: flex;
    gap: var(--space-xs);
    padding: var(--space-xs);
    background: var(--surface-inset);
    border-radius: var(--radius-md);
    margin-bottom: var(--space-lg);
  }

  .mode-toggle-btn {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
    padding: var(--space-sm) var(--space-md);
    background: transparent;
    border: none;
    border-radius: var(--radius-sm);
    color: var(--text-muted);
    font-size: var(--text-md);
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition-default);
  }

  .mode-toggle-btn:hover {
    color: var(--text-secondary);
    background: var(--surface-overlay);
  }

  .mode-toggle-btn.active {
    background: var(--accent-primary);
    color: var(--text-primary);
    font-weight: 600;
  }

  /* ============================================================================
     SECTION MODE PANEL
     ============================================================================ */

  .section-mode-panel {
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
  }

  .section-mode-hint {
    font-size: var(--text-sm);
    color: var(--text-muted);
    padding: var(--space-sm) var(--space-md);
    background: var(--surface-raised);
    border-radius: var(--radius-sm);
    border-left: 3px solid var(--accent-primary);
  }

  .current-selection-status {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    padding: var(--space-md);
    background: rgba(251, 191, 36, 0.15);
    border: 1px solid rgba(251, 191, 36, 0.5);
    border-radius: var(--radius-md);
  }

  .selection-count {
    font-weight: 600;
    color: #fbbf24;
  }

  .selection-arrow {
    color: var(--text-muted);
  }

  .selection-components {
    color: var(--text-primary);
  }

  .add-section-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
    padding: var(--space-md) var(--space-xl);
    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
    border: none;
    border-radius: var(--radius-md);
    color: var(--text-primary);
    font-size: var(--text-lg);
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition-smooth);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
  }

  .add-section-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(99, 102, 241, 0.4);
  }

  .add-section-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }

  .saved-sections {
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
    padding: var(--space-md);
    background: var(--surface-raised);
    border-radius: var(--radius-md);
  }

  .saved-label {
    font-size: var(--text-sm);
    font-weight: 600;
    color: var(--text-secondary);
    margin-bottom: var(--space-xs);
  }

  .saved-section-tag {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    padding: var(--space-sm) var(--space-md);
    background: rgba(0, 0, 0, 0.2);
    border-radius: var(--radius-sm);
    border-left: 4px solid var(--section-color, rgba(59, 130, 246, 0.8));
  }

  .saved-section-tag .section-beats {
    font-weight: 600;
    color: var(--text-primary);
  }

  .saved-section-tag .section-components {
    flex: 1;
    color: var(--text-secondary);
  }

  .saved-section-tag .remove-btn {
    padding: var(--space-xs);
    background: transparent;
    border: none;
    color: var(--text-muted);
    font-size: var(--text-lg);
    cursor: pointer;
    transition: var(--transition-fast);
    line-height: 1;
  }

  .saved-section-tag .remove-btn:hover {
    color: var(--accent-danger);
  }

  .next-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
    padding: var(--space-md) var(--space-xl);
    background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
    border: none;
    border-radius: var(--radius-md);
    color: var(--text-primary);
    font-size: var(--text-lg);
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition-smooth);
    box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
  }

  .next-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(34, 197, 94, 0.4);
  }

  .next-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none;
    box-shadow: 0 2px 6px rgba(34, 197, 94, 0.2);
  }

  /* ============================================================================
     BEAT PAIR MODE PANEL
     ============================================================================ */

  .beatpair-mode-panel {
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
  }

  .beatpair-mode-hint {
    font-size: var(--text-sm);
    color: var(--text-muted);
    padding: var(--space-sm) var(--space-md);
    background: var(--surface-raised);
    border-radius: var(--radius-sm);
    border-left: 3px solid var(--accent-primary);
  }

  .beatpair-selection-status {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--space-md);
    padding: var(--space-md);
    background: rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: var(--radius-md);
  }

  .beatpair-selection-info {
    display: flex;
    align-items: center;
    gap: var(--space-md);
    flex: 1;
  }

  .beatpair-key,
  .beatpair-corresponding {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    font-weight: 600;
    color: var(--text-primary);
  }

  .clear-selection-btn {
    display: flex;
    align-items: center;
    gap: var(--space-xs);
    padding: var(--space-sm) var(--space-md);
    background: rgba(239, 68, 68, 0.15);
    border: 1px solid rgba(239, 68, 68, 0.3);
    border-radius: var(--radius-sm);
    color: #ef4444;
    font-size: var(--text-sm);
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition-fast);
    white-space: nowrap;
  }

  .clear-selection-btn:hover {
    background: rgba(239, 68, 68, 0.25);
    border-color: rgba(239, 68, 68, 0.5);
  }

  .beatpair-indicator {
    width: 16px;
    height: 16px;
    border-radius: var(--radius-xs);
  }

  .beatpair-arrow {
    color: var(--text-muted);
    font-size: var(--text-lg);
  }

  .detected-transformations {
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
  }

  .transformations-label {
    font-size: var(--text-sm);
    font-weight: 600;
    color: var(--text-secondary);
  }

  .transformations-list {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-sm);
  }

  .transformation-option {
    padding: var(--space-sm) var(--space-md);
    background: rgba(0, 0, 0, 0.2);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: var(--radius-sm);
    color: var(--text-secondary);
    font-size: var(--text-sm);
    cursor: pointer;
    transition: var(--transition-fast);
  }

  .transformation-option:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.4);
  }

  .transformation-option.selected {
    background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
    border-color: #8b5cf6;
    color: var(--text-primary);
    font-weight: 600;
  }

  .save-beatpair-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
    padding: var(--space-md) var(--space-xl);
    background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
    border: none;
    border-radius: var(--radius-md);
    color: var(--text-primary);
    font-size: var(--text-lg);
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition-smooth);
    box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
  }

  .save-beatpair-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(139, 92, 246, 0.4);
  }

  .save-beatpair-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }

  .saved-beatpairs {
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
    padding: var(--space-md);
    background: var(--surface-raised);
    border-radius: var(--radius-md);
  }

  .saved-beatpair-tag {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    padding: var(--space-sm) var(--space-md);
    background: rgba(0, 0, 0, 0.2);
    border-radius: var(--radius-sm);
    border-left: 4px solid rgba(139, 92, 246, 0.8);
  }

  .saved-beatpair-tag .beatpair-beats {
    font-weight: 600;
    color: var(--text-primary);
    min-width: 60px;
  }

  .saved-beatpair-tag .beatpair-transformation {
    flex: 1;
    color: var(--text-secondary);
  }

  .saved-beatpair-tag .remove-btn {
    padding: var(--space-xs);
    background: transparent;
    border: none;
    color: var(--text-muted);
    font-size: var(--text-lg);
    cursor: pointer;
    transition: var(--transition-fast);
    line-height: 1;
  }

  .saved-beatpair-tag .remove-btn:hover {
    color: var(--accent-danger);
  }

  /* ============================================================================
     WHOLE SEQUENCE PANEL
     ============================================================================ */

  .whole-sequence-panel {
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
  }
</style>
