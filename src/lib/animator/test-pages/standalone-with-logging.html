<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Standalone Animator with Comprehensive Logging</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background: #f5f5f5;
      }
      .container {
        max-width: 1400px;
        margin: 0 auto;
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      .test-header {
        text-align: center;
        margin-bottom: 30px;
        padding-bottom: 20px;
        border-bottom: 2px solid #eee;
      }
      .main-content {
        display: flex;
        gap: 20px;
      }
      .animation-section {
        flex: 1;
      }
      .logging-section {
        flex: 0 0 400px;
        background: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
      }
      .controls {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }
      .control-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      .control-group label {
        font-weight: bold;
        font-size: 12px;
      }
      .control-group input,
      .control-group button {
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      .control-group button {
        background: #007bff;
        color: white;
        cursor: pointer;
        font-weight: bold;
      }
      .control-group button:hover {
        background: #0056b3;
      }
      .control-group button:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }
      .info-display {
        background: #e9ecef;
        padding: 15px;
        border-radius: 4px;
        font-family: monospace;
        font-size: 12px;
        margin-bottom: 20px;
      }
      .canvas-container {
        text-align: center;
        margin-bottom: 20px;
      }
      #animationCanvas {
        border: 2px solid #ddd;
        border-radius: 8px;
        background: white;
      }
      .log-controls {
        margin-bottom: 15px;
      }
      .log-controls button {
        margin-right: 10px;
        padding: 5px 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: #fff;
        cursor: pointer;
      }
      .log-controls button.active {
        background: #007bff;
        color: white;
      }
      .log-output {
        height: 300px;
        overflow-y: auto;
        background: #fff;
        border: 1px solid #ddd;
        padding: 10px;
        font-family: monospace;
        font-size: 10px;
        white-space: pre-wrap;
        margin-bottom: 10px;
      }
      .log-stats {
        background: #e9ecef;
        padding: 10px;
        border-radius: 4px;
        font-size: 12px;
      }
      .error {
        color: #dc3545;
        background: #f8d7da;
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
      }
      .success {
        color: #155724;
        background: #d4edda;
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
      }
      .sequence-input {
        width: 100%;
        height: 100px;
        margin-bottom: 10px;
        font-family: monospace;
        font-size: 11px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="test-header">
        <h1>Standalone Animator with Comprehensive Logging</h1>
        <p>
          Enhanced standalone animator with detailed animation property logging
          for comparison testing
        </p>
      </div>

      <div id="status" class="error" style="display: none"></div>

      <div class="main-content">
        <div class="animation-section">
          <div class="controls">
            <div class="control-group">
              <label>Load Sequence</label>
              <button id="loadDefaultBtn">Load ALFBBLFA</button>
            </div>
            <div class="control-group">
              <label>Playback</label>
              <button id="playPauseBtn" disabled>‚ñ∂ Play</button>
            </div>
            <div class="control-group">
              <label>Control</label>
              <button id="stopBtn" disabled>‚èπ Stop</button>
            </div>
            <div class="control-group">
              <label for="speedSlider"
                >Speed: <span id="speedValue">1.0</span>x</label
              >
              <input
                type="range"
                id="speedSlider"
                min="0.1"
                max="3.0"
                step="0.1"
                value="1.0"
              />
            </div>
            <div class="control-group">
              <label for="beatSlider"
                >Beat: <span id="beatValue">0.00</span></label
              >
              <input
                type="range"
                id="beatSlider"
                min="0"
                max="8"
                step="0.01"
                value="0"
                disabled
              />
            </div>
            <div class="control-group">
              <label> <input type="checkbox" id="loopCheckbox" /> Loop </label>
            </div>
          </div>

          <div class="info-display">
            <div>
              <strong>Sequence:</strong> <span id="sequenceWord">-</span>
            </div>
            <div>
              <strong>Author:</strong> <span id="sequenceAuthor">-</span>
            </div>
            <div>
              <strong>Total Beats:</strong> <span id="totalBeats">-</span>
            </div>
            <div>
              <strong>Current Beat:</strong>
              <span id="currentBeatDisplay">0.00</span>
            </div>
            <div>
              <strong>Status:</strong> <span id="animationStatus">Stopped</span>
            </div>
            <div>
              <strong>Frame Count:</strong> <span id="frameCount">0</span>
            </div>
          </div>

          <div class="canvas-container">
            <canvas id="animationCanvas" width="500" height="500"></canvas>
          </div>

          <div>
            <h4>Custom Sequence Input</h4>
            <textarea
              id="sequenceInput"
              class="sequence-input"
              placeholder="Paste sequence JSON data here..."
            ></textarea>
            <button id="loadCustomBtn">Load Custom Sequence</button>
          </div>
        </div>

        <div class="logging-section">
          <h3>Animation Logging</h3>

          <div class="log-controls">
            <button id="startLoggingBtn">Start Logging</button>
            <button id="stopLoggingBtn" disabled>Stop Logging</button>
            <button id="clearLogBtn">Clear Log</button>
            <button id="exportLogBtn" disabled>Export JSON</button>
            <button id="exportCSVBtn" disabled>Export CSV</button>
          </div>

          <div class="log-stats">
            <div>
              <strong>Logging Status:</strong>
              <span id="loggingStatus">Stopped</span>
            </div>
            <div>
              <strong>Entries Logged:</strong> <span id="entriesCount">0</span>
            </div>
            <div>
              <strong>Session Duration:</strong>
              <span id="sessionDuration">0s</span>
            </div>
          </div>

          <div id="logOutput" class="log-output"></div>
        </div>
      </div>
    </div>

    <!-- Import the test sequence data and logging utilities -->
    <script type="module">
      // Import test data
      import { ALFBBLFA_SEQUENCE } from "../test-data/alfbblfa-sequence.js";
      import { AnimationLogger } from "../utils/animation-logger.js";

      // Enhanced Standalone Animator with Logging
      class StandaloneAnimatorWithLogging {
        constructor() {
          // Animation state (copied from original standalone)
          this.animationFrameId = null;
          this.isPlaying = false;
          this.currentBeat = 0;
          this.lastTimestamp = null;
          this.speed = 1.0;
          this.continuousLoop = false;
          this.totalBeats = 0;
          this.parsedSteps = [];
          this.currentSequence = null;
          this.frameCounter = 0;

          // Prop states
          this.bluePropState = {
            centerPathAngle: 0,
            staffRotationAngle: 0,
            x: 0,
            y: 0,
          };
          this.redPropState = {
            centerPathAngle: 0,
            staffRotationAngle: 0,
            x: 0,
            y: 0,
          };

          // Canvas and rendering
          this.canvas = null;
          this.ctx = null;
          this.canvasSize = 500;
          this.gridScaleFactor = this.canvasSize / 950;
          this.scaledHalfwayRadius = 151.5 * this.gridScaleFactor;

          // Logging
          this.logger = new AnimationLogger("STANDALONE");
          this.isLogging = false;
          this.sessionStartTime = 0;

          // Constants from original
          this.GRID_VIEWBOX_SIZE = 950;
          this.GRID_CENTER = this.GRID_VIEWBOX_SIZE / 2;
          this.GRID_HALFWAY_POINT_OFFSET = 151.5;
        }

        async initialize() {
          try {
            console.log("üé¨ Initializing Standalone Animator with Logging...");

            // Get canvas and context
            this.canvas = document.getElementById("animationCanvas");
            this.ctx = this.canvas.getContext("2d");

            if (!this.ctx) {
              throw new Error("Failed to get canvas context");
            }

            // Setup event listeners
            this.setupEventListeners();

            // Show success status
            this.showStatus(
              "Standalone Animator with Logging initialized successfully",
              "success"
            );

            console.log("‚úÖ Standalone Animator with Logging ready");
          } catch (error) {
            console.error("‚ùå Failed to initialize:", error);
            this.showStatus(`Initialization failed: ${error.message}`, "error");
          }
        }

        setupEventListeners() {
          // Load default sequence
          document
            .getElementById("loadDefaultBtn")
            .addEventListener("click", () => {
              this.loadSequence(ALFBBLFA_SEQUENCE);
            });

          // Load custom sequence
          document
            .getElementById("loadCustomBtn")
            .addEventListener("click", () => {
              const input = document
                .getElementById("sequenceInput")
                .value.trim();
              if (input) {
                try {
                  const customSequence = JSON.parse(input);
                  this.loadSequence(customSequence);
                } catch (error) {
                  this.showStatus(`Invalid JSON: ${error.message}`, "error");
                }
              }
            });

          // Play/pause
          document
            .getElementById("playPauseBtn")
            .addEventListener("click", () => {
              this.togglePlayPause();
            });

          // Stop
          document.getElementById("stopBtn").addEventListener("click", () => {
            this.stop();
          });

          // Speed control
          document
            .getElementById("speedSlider")
            .addEventListener("input", (e) => {
              this.speed = parseFloat(e.target.value);
              document.getElementById("speedValue").textContent =
                this.speed.toFixed(1);
            });

          // Beat control
          document
            .getElementById("beatSlider")
            .addEventListener("input", (e) => {
              if (!this.isPlaying) {
                this.currentBeat = parseFloat(e.target.value);
                this.updateBeat(this.currentBeat, true);
              }
            });

          // Loop control
          document
            .getElementById("loopCheckbox")
            .addEventListener("change", (e) => {
              this.continuousLoop = e.target.checked;
            });

          // Logging controls
          document
            .getElementById("startLoggingBtn")
            .addEventListener("click", () => {
              this.startLogging();
            });

          document
            .getElementById("stopLoggingBtn")
            .addEventListener("click", () => {
              this.stopLogging();
            });

          document
            .getElementById("clearLogBtn")
            .addEventListener("click", () => {
              this.clearLog();
            });

          document
            .getElementById("exportLogBtn")
            .addEventListener("click", () => {
              this.exportLog("json");
            });

          document
            .getElementById("exportCSVBtn")
            .addEventListener("click", () => {
              this.exportLog("csv");
            });
        }

        loadSequence(sequenceData) {
          try {
            console.log("üì• Loading sequence:", sequenceData);

            this.pause();
            this.currentBeat = 0;
            this.currentSequence = sequenceData;
            this.processSequenceData(this.currentSequence);

            // Update UI
            const metadata = this.currentSequence[0] || {};
            document.getElementById("sequenceWord").textContent =
              metadata.word || "Unknown";
            document.getElementById("sequenceAuthor").textContent =
              metadata.author || "Unknown";
            document.getElementById("totalBeats").textContent = this.totalBeats;
            document.getElementById("beatSlider").max = this.totalBeats;

            // Enable controls
            document.getElementById("playPauseBtn").disabled = false;
            document.getElementById("stopBtn").disabled = false;
            document.getElementById("beatSlider").disabled = false;

            this.showStatus(
              `Sequence "${metadata.word || "Unknown"}" loaded successfully (${
                this.totalBeats
              } beats)`,
              "success"
            );

            // Clear sequence input
            document.getElementById("sequenceInput").value = "";
          } catch (error) {
            console.error("‚ùå Failed to load sequence:", error);
            this.showStatus(
              `Failed to load sequence: ${error.message}`,
              "error"
            );
          }
        }

        processSequenceData(sequenceArray) {
          console.log("üîß Processing sequence data...");

          // Log first beat data for comparison
          if (sequenceArray.length > 2) {
            const firstBeat = sequenceArray[2];
            console.log(
              "üéØ [STANDALONE LOGGING] First beat data:",
              JSON.stringify(firstBeat, null, 2)
            );
            if (firstBeat.blue_attributes) {
              console.log(
                "üîµ [STANDALONE LOGGING] Blue motion_type:",
                firstBeat.blue_attributes.motion_type
              );
            }
            if (firstBeat.red_attributes) {
              console.log(
                "üî¥ [STANDALONE LOGGING] Red motion_type:",
                firstBeat.red_attributes.motion_type
              );
            }
          }

          this.parsedSteps = sequenceArray.map((step, index) => ({
            ...step,
            arrayIndex: index,
          }));
          this.totalBeats = this.parsedSteps.length - 2; // Exclude metadata and start state

          if (this.totalBeats <= 0) {
            throw new Error("Sequence has no animation steps.");
          }

          console.log(`‚úÖ Processed ${this.totalBeats} beats`);
          this.initializeState();
        }

        initializeState() {
          if (!this.parsedSteps || this.parsedSteps.length < 2) return;

          // Use index 1 (original beat 0) for initial state
          const startStateStep = this.parsedSteps[1];

          // Initialize blue prop
          this.bluePropState.centerPathAngle = this.mapPositionToAngle("s");
          this.bluePropState.staffRotationAngle =
            this.bluePropState.centerPathAngle + Math.PI;

          // Initialize red prop
          this.redPropState.centerPathAngle = this.mapPositionToAngle("n");
          this.redPropState.staffRotationAngle =
            this.redPropState.centerPathAngle + Math.PI;

          // Update coordinates
          this.updateCoordinates();
          this.render();
          this.updateUI();
        }

        // Math utilities (copied from standalone)
        mapPositionToAngle(loc) {
          const locationAngles = {
            n: -Math.PI / 2,
            ne: -Math.PI / 4,
            e: 0,
            se: Math.PI / 4,
            s: Math.PI / 2,
            sw: (3 * Math.PI) / 4,
            w: Math.PI,
            nw: (-3 * Math.PI) / 4,
          };
          return locationAngles[loc?.toLowerCase()] || 0;
        }

        normalizeAnglePositive(angle) {
          return ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
        }

        normalizeAngleSigned(angle) {
          let norm = this.normalizeAnglePositive(angle);
          return norm > Math.PI ? norm - 2 * Math.PI : norm;
        }

        lerpAngle(a, b, t) {
          const d = this.normalizeAngleSigned(b - a);
          return this.normalizeAnglePositive(a + d * t);
        }

        updateCoordinates() {
          // Update blue prop coordinates
          this.bluePropState.x =
            Math.cos(this.bluePropState.centerPathAngle) *
            this.GRID_HALFWAY_POINT_OFFSET;
          this.bluePropState.y =
            Math.sin(this.bluePropState.centerPathAngle) *
            this.GRID_HALFWAY_POINT_OFFSET;

          // Update red prop coordinates
          this.redPropState.x =
            Math.cos(this.redPropState.centerPathAngle) *
            this.GRID_HALFWAY_POINT_OFFSET;
          this.redPropState.y =
            Math.sin(this.redPropState.centerPathAngle) *
            this.GRID_HALFWAY_POINT_OFFSET;
        }

        // Animation controls
        togglePlayPause() {
          if (this.isPlaying) {
            this.pause();
          } else {
            this.play();
          }
        }

        play() {
          if (this.isPlaying) return;
          this.isPlaying = true;
          document.getElementById("playPauseBtn").textContent = "‚è∏ Pause";
          document.getElementById("animationStatus").textContent = "Playing";
          this.lastTimestamp = null;
          this.animationFrameId = requestAnimationFrame((timestamp) =>
            this.animationLoop(timestamp)
          );
        }

        pause() {
          if (!this.isPlaying) return;
          this.isPlaying = false;
          document.getElementById("playPauseBtn").textContent = "‚ñ∂ Play";
          document.getElementById("animationStatus").textContent = "Paused";
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
          }
        }

        stop() {
          this.isPlaying = false;
          this.currentBeat = 0;
          document.getElementById("playPauseBtn").textContent = "‚ñ∂ Play";
          document.getElementById("animationStatus").textContent = "Stopped";
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
          }
          this.initializeState();
        }

        // Animation loop with comprehensive logging
        animationLoop(timestamp) {
          if (!this.isPlaying) return;

          if (this.lastTimestamp === null) this.lastTimestamp = timestamp;
          const deltaTime = timestamp - this.lastTimestamp;
          this.lastTimestamp = timestamp;
          const effectiveSpeed = Math.max(0.01, this.speed);
          this.currentBeat += (deltaTime / 1000) * effectiveSpeed;

          // Loop handling
          if (this.currentBeat >= this.totalBeats) {
            if (this.continuousLoop) {
              this.currentBeat = 0;
              this.lastTimestamp = timestamp;
              console.log("üîÅ STANDALONE: Looping back to time 0");
            } else {
              this.currentBeat = this.totalBeats;
              this.pause();
              console.log("üèÅ STANDALONE: Animation ended");
              this.updateBeat(this.currentBeat, true);
              this.updateUI();
              return;
            }
          }

          // State calculation for current frame
          const clampedBeat = Math.max(
            0,
            Math.min(this.currentBeat, this.totalBeats)
          );
          const currentAnimationStepIndex = Math.floor(
            clampedBeat === this.totalBeats ? this.totalBeats - 1 : clampedBeat
          );
          const currentStepArrayIndex = currentAnimationStepIndex + 2;
          const t =
            clampedBeat === this.totalBeats
              ? 1.0
              : clampedBeat - currentAnimationStepIndex;

          const stepDefinition = this.parsedSteps[currentStepArrayIndex];

          if (!stepDefinition) {
            console.error(
              `STANDALONE: No step definition for array index ${currentStepArrayIndex} (beat: ${clampedBeat})`
            );
            this.pause();
            return;
          }

          // Calculate endpoints and update prop states
          const blueEndpoints = this.calculateStepEndpoints(
            stepDefinition,
            "blue"
          );
          const redEndpoints = this.calculateStepEndpoints(
            stepDefinition,
            "red"
          );

          if (blueEndpoints && redEndpoints) {
            this.bluePropState.centerPathAngle = this.lerpAngle(
              blueEndpoints.startCenterAngle,
              blueEndpoints.targetCenterAngle,
              t
            );
            this.bluePropState.staffRotationAngle = this.lerpAngle(
              blueEndpoints.startStaffAngle,
              blueEndpoints.targetStaffAngle,
              t
            );
            this.redPropState.centerPathAngle = this.lerpAngle(
              redEndpoints.startCenterAngle,
              redEndpoints.targetCenterAngle,
              t
            );
            this.redPropState.staffRotationAngle = this.lerpAngle(
              redEndpoints.startStaffAngle,
              redEndpoints.targetStaffAngle,
              t
            );

            // Handle pro motion special case
            if (stepDefinition.blue_attributes?.motion_type === "pro") {
              this.bluePropState.staffRotationAngle =
                this.calculateProIsolationStaffAngle(
                  this.bluePropState.centerPathAngle,
                  stepDefinition.blue_attributes.prop_rot_dir
                );
            }
            if (stepDefinition.red_attributes?.motion_type === "pro") {
              this.redPropState.staffRotationAngle =
                this.calculateProIsolationStaffAngle(
                  this.redPropState.centerPathAngle,
                  stepDefinition.red_attributes.prop_rot_dir
                );
            }

            // Update coordinates
            this.updateCoordinates();

            // Log frame data if logging is enabled
            if (this.isLogging) {
              this.logger.logFrame({
                beat: this.currentBeat,
                blueProp: { ...this.bluePropState },
                redProp: { ...this.redPropState },
                timing: {
                  deltaTime: deltaTime,
                  speed: this.speed,
                  isPlaying: this.isPlaying,
                },
                step: {
                  stepIndex: currentAnimationStepIndex,
                  arrayIndex: currentStepArrayIndex,
                  t: t,
                  motionTypes: {
                    blue: stepDefinition.blue_attributes?.motion_type,
                    red: stepDefinition.red_attributes?.motion_type,
                  },
                },
              });
            }
          }

          this.frameCounter++;
          this.render();
          this.updateUI();

          if (this.isPlaying) {
            this.animationFrameId = requestAnimationFrame((timestamp) =>
              this.animationLoop(timestamp)
            );
          }
        }

        // Calculate step endpoints (copied from standalone)
        calculateStepEndpoints(stepDefinition, propType) {
          const attributes =
            propType === "blue"
              ? stepDefinition.blue_attributes
              : stepDefinition.red_attributes;
          if (!attributes) return null;

          const {
            start_loc,
            end_loc,
            start_ori,
            end_ori,
            motion_type,
            prop_rot_dir,
            turns = 0,
          } = attributes;

          const startCenterAngle = this.mapPositionToAngle(start_loc);
          const startStaffAngle = this.mapOrientationToAngle(
            start_ori || "in",
            startCenterAngle
          );
          const targetCenterAngle = this.mapPositionToAngle(end_loc);

          let calculatedTargetStaffAngle;

          if (motion_type === "pro") {
            calculatedTargetStaffAngle = this.calculateProIsolationStaffAngle(
              targetCenterAngle,
              prop_rot_dir || "cw"
            );
          } else if (motion_type === "anti") {
            calculatedTargetStaffAngle = this.mapOrientationToAngle(
              end_ori || "in",
              targetCenterAngle
            );
          } else if (motion_type === "static") {
            calculatedTargetStaffAngle = startStaffAngle;
          } else if (motion_type === "float") {
            calculatedTargetStaffAngle = startStaffAngle;
          } else {
            calculatedTargetStaffAngle = this.mapOrientationToAngle(
              end_ori || "in",
              targetCenterAngle
            );
          }

          return {
            startCenterAngle,
            startStaffAngle,
            targetCenterAngle,
            targetStaffAngle: calculatedTargetStaffAngle,
          };
        }

        mapOrientationToAngle(ori, centerPathAngle) {
          if (!ori) return centerPathAngle + Math.PI;
          if (ori.toLowerCase() === "in") {
            return this.normalizeAnglePositive(centerPathAngle + Math.PI);
          }
          if (ori.toLowerCase() === "out") {
            return this.normalizeAnglePositive(centerPathAngle);
          }
          return this.normalizeAnglePositive(centerPathAngle + Math.PI);
        }

        calculateProIsolationStaffAngle(centerPathAngle, propRotDir) {
          const baseAngle = centerPathAngle + Math.PI / 2;
          return propRotDir === "ccw" ? baseAngle + Math.PI : baseAngle;
        }

        // Rendering
        render() {
          if (!this.ctx) return;

          this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);
          this.drawGrid();
          this.drawStaff(this.bluePropState, "#2E3192");
          this.drawStaff(this.redPropState, "#ED1C24");
        }

        drawGrid() {
          const centerX = this.canvasSize / 2;
          const centerY = this.canvasSize / 2;

          this.ctx.strokeStyle = "#ddd";
          this.ctx.lineWidth = 1;

          // Draw center circle
          this.ctx.beginPath();
          this.ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
          this.ctx.fillStyle = "#000";
          this.ctx.fill();

          // Draw halfway circle
          this.ctx.beginPath();
          this.ctx.arc(
            centerX,
            centerY,
            this.scaledHalfwayRadius,
            0,
            Math.PI * 2
          );
          this.ctx.stroke();

          // Draw cardinal points
          const points = [
            { x: centerX, y: centerY - this.scaledHalfwayRadius }, // North
            { x: centerX + this.scaledHalfwayRadius, y: centerY }, // East
            { x: centerX, y: centerY + this.scaledHalfwayRadius }, // South
            { x: centerX - this.scaledHalfwayRadius, y: centerY }, // West
          ];

          points.forEach((point) => {
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
            this.ctx.fillStyle = "#000";
            this.ctx.fill();
          });
        }

        drawStaff(propState, color) {
          const centerX = this.canvasSize / 2;
          const centerY = this.canvasSize / 2;

          const propX = centerX + propState.x * this.gridScaleFactor;
          const propY = centerY + propState.y * this.gridScaleFactor;

          this.ctx.save();
          this.ctx.translate(propX, propY);
          this.ctx.rotate(propState.staffRotationAngle);

          // Draw staff as rectangle
          this.ctx.fillStyle = color;
          this.ctx.fillRect(-25, -5, 50, 10);

          // Draw center point
          this.ctx.fillStyle = "#FF0000";
          this.ctx.beginPath();
          this.ctx.arc(0, 0, 3, 0, Math.PI * 2);
          this.ctx.fill();

          this.ctx.restore();
        }

        // UI updates
        updateUI() {
          document.getElementById("beatValue").textContent =
            this.currentBeat.toFixed(2);
          document.getElementById("currentBeatDisplay").textContent =
            this.currentBeat.toFixed(2);
          document.getElementById("beatSlider").value = this.currentBeat;
          document.getElementById("frameCount").textContent = this.frameCounter;

          if (this.isLogging) {
            document.getElementById("entriesCount").textContent =
              this.logger.getEntries().length;
            const duration = (
              (performance.now() - this.sessionStartTime) /
              1000
            ).toFixed(1);
            document.getElementById(
              "sessionDuration"
            ).textContent = `${duration}s`;
          }
        }

        updateBeat(beat, renderImmediately = false) {
          this.currentBeat = beat;
          // Simplified beat update for manual scrubbing
          this.updateCoordinates();
          if (renderImmediately) this.render();
          this.updateUI();
        }

        // Logging controls
        startLogging() {
          this.logger.startLogging();
          this.isLogging = true;
          this.sessionStartTime = performance.now();

          document.getElementById("startLoggingBtn").disabled = true;
          document.getElementById("stopLoggingBtn").disabled = false;
          document.getElementById("exportLogBtn").disabled = true;
          document.getElementById("exportCSVBtn").disabled = true;
          document.getElementById("loggingStatus").textContent = "Recording";

          console.log("üé¨ STANDALONE: Logging started");
        }

        stopLogging() {
          this.logger.stopLogging();
          this.isLogging = false;

          document.getElementById("startLoggingBtn").disabled = false;
          document.getElementById("stopLoggingBtn").disabled = true;
          document.getElementById("exportLogBtn").disabled = false;
          document.getElementById("exportCSVBtn").disabled = false;
          document.getElementById("loggingStatus").textContent = "Stopped";

          console.log("üèÅ STANDALONE: Logging stopped");
        }

        clearLog() {
          this.logger.clearEntries();
          document.getElementById("logOutput").textContent = "";
          document.getElementById("entriesCount").textContent = "0";
          document.getElementById("sessionDuration").textContent = "0s";
        }

        exportLog(format) {
          const entries = this.logger.getEntries();
          if (entries.length === 0) {
            this.showStatus("No log entries to export", "error");
            return;
          }

          let content, filename, mimeType;

          if (format === "json") {
            content = this.logger.exportAsJSON();
            filename = `standalone-animation-log-${Date.now()}.json`;
            mimeType = "application/json";
          } else if (format === "csv") {
            content = this.logger.exportAsCSV();
            filename = `standalone-animation-log-${Date.now()}.csv`;
            mimeType = "text/csv";
          }

          // Download file
          const blob = new Blob([content], { type: mimeType });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = filename;
          a.click();
          URL.revokeObjectURL(url);

          this.showStatus(
            `Exported ${entries.length} entries as ${format.toUpperCase()}`,
            "success"
          );
        }

        showStatus(message, type) {
          const statusEl = document.getElementById("status");
          statusEl.textContent = message;
          statusEl.className = type;
          statusEl.style.display = "block";

          if (type === "success") {
            setTimeout(() => {
              statusEl.style.display = "none";
            }, 3000);
          }
        }
      }

      // Initialize when DOM is ready
      window.addEventListener("DOMContentLoaded", async () => {
        window.standaloneAnimatorWithLogging =
          new StandaloneAnimatorWithLogging();
        await window.standaloneAnimatorWithLogging.initialize();
      });
    </script>
  </body>
</html>
