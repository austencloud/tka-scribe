/**
 * Special Placement Service for Modern Arrow Positioning
 *
 * Orchestrates special placement logic by coordinating specialized services.
 * Provides pixel-perfect special placement adjustments for specific pictograph configurations.
 *
 * ORCHESTRATES SPECIAL PLACEMENT PIPELINE:
 * - Data loading (SpecialPlacementDataService)
 * - Orientation key generation (SpecialPlacementOriKeyGenerator)
 * - Turns tuple generation (TurnsTupleGeneratorService)
 * - Placement lookup with fallback strategies (SpecialPlacementLookupService)
 *
 * Direct TypeScript mirror of reference/modern/application/services/positioning/arrows/placement/special_placement_service.py
 */

import { Point } from "fabric";
import { inject, injectable } from "inversify";
import { resolve, TYPES } from "../../../../../../inversify";
import { type IGridModeDeriver, GridMode } from "../../../../../grid";
import { type MotionData, type PictographData } from "../../../../../shared";
import { SpecialPlacementOriKeyGenerator } from "../../../key-generation";
import type { ISpecialPlacementService } from "../contracts";
import type { ISpecialPlacementDataService } from "../contracts/ISpecialPlacementDataService";
import type { ITurnsTupleGeneratorService } from "../contracts/ITurnsTupleGeneratorService";
import type { ISpecialPlacementLookupService } from "../contracts/ISpecialPlacementLookupService";

@injectable()
export class SpecialPlacementService implements ISpecialPlacementService {
  private oriKeyGenerator: SpecialPlacementOriKeyGenerator;
  private gridModeService: IGridModeDeriver | null = null;

  constructor(
    @inject(TYPES.ISpecialPlacementDataService)
    private readonly dataService: ISpecialPlacementDataService,
    @inject(TYPES.ITurnsTupleGeneratorService)
    private readonly tupleGenerator: ITurnsTupleGeneratorService,
    @inject(TYPES.ISpecialPlacementLookupService)
    private readonly lookupService: ISpecialPlacementLookupService
  ) {
    this.oriKeyGenerator = new SpecialPlacementOriKeyGenerator();
  }

  /**
   * Get special adjustment for arrow based on special placement logic.
   *
   * Orchestrates the pipeline:
   * 1. Generate orientation key
   * 2. Determine grid mode
   * 3. Generate turns tuple
   * 4. Load letter data
   * 5. Lookup adjustment with fallback strategies
   *
   * @param motionData Motion data containing motion information
   * @param pictographData Pictograph data containing letter and context
   * @param arrowColor Color of the arrow ('red' or 'blue')
   * @param attributeKey Optional attribute key for precise lookup
   * @returns Point with special adjustment or null if no special placement found
   */
  async getSpecialAdjustment(
    motionData: MotionData,
    pictographData: PictographData,
    arrowColor?: string,
    attributeKey?: string
  ): Promise<Point | null> {
    if (!motionData || !pictographData.letter) {
      return null;
    }

    const letter = pictographData.letter;

    // Step 1: Generate orientation key
    const oriKey = this.oriKeyGenerator.generateOrientationKey(
      motionData,
      pictographData
    );

    // Step 2: Determine grid mode
    const gridMode = this.getGridMode(pictographData);

    // Step 3: Generate turns tuple
    const turnsTuple = this.tupleGenerator.generateTurnsTuple(pictographData);

    // Step 4: Load letter data
    const letterData = await this.dataService.getLetterData(
      gridMode,
      oriKey,
      letter
    );

    if (!letterData || Object.keys(letterData).length === 0) {
      return null;
    }

    // Step 5: Lookup adjustment with fallback strategies
    return this.lookupService.lookupAdjustment(
      letterData,
      turnsTuple,
      motionData,
      pictographData,
      arrowColor,
      attributeKey
    );
  }

  /**
   * Check if rotation angle override exists for this motion.
   *
   * Orchestrates the pipeline for rotation override checking:
   * 1. Validate motion type (only DASH/STATIC)
   * 2. Generate orientation key and turns tuple
   * 3. Load letter data
   * 4. Lookup rotation override flag
   *
   * @param motionData Motion data containing motion information
   * @param pictographData Pictograph data containing letter and context
   * @param rotationOverrideKey Key generated by RotationAngleOverrideKeyGenerator
   * @returns true if rotation override flag is present in special placement data
   */
  async hasRotationAngleOverride(
    motionData: MotionData,
    pictographData: PictographData,
    rotationOverrideKey: string
  ): Promise<boolean> {
    if (!motionData || !pictographData.letter) {
      return false;
    }

    // Only DASH and STATIC motions can have rotation overrides
    const motionType = motionData.motionType?.toLowerCase();
    if (motionType !== "dash" && motionType !== "static") {
      return false;
    }

    const letter = pictographData.letter;

    // Step 1: Generate orientation key
    const oriKey = this.oriKeyGenerator.generateOrientationKey(
      motionData,
      pictographData
    );

    // Step 2: Determine grid mode
    const gridMode = this.getGridMode(pictographData);

    // Step 3: Generate turns tuple
    const turnsTuple = this.tupleGenerator.generateTurnsTuple(pictographData);

    // Step 4: Load letter data
    const letterData = await this.dataService.getLetterData(
      gridMode,
      oriKey,
      letter
    );

    if (!letterData || Object.keys(letterData).length === 0) {
      return false;
    }

    // Step 5: Lookup rotation override
    return this.lookupService.lookupRotationOverride(
      letterData,
      turnsTuple,
      rotationOverrideKey
    );
  }

  /**
   * Get grid mode from pictograph data
   */
  private getGridMode(pictographData: PictographData): string {
    if (pictographData.motions?.blue && pictographData.motions?.red) {
      return this.getGridModeService().deriveGridMode(
        pictographData.motions.blue,
        pictographData.motions.red
      );
    }
    return GridMode.DIAMOND;
  }

  /**
   * Lazy-load grid mode service
   */
  private getGridModeService(): IGridModeDeriver {
    if (!this.gridModeService) {
      this.gridModeService = resolve<IGridModeDeriver>(TYPES.IGridModeDeriver);
    }
    return this.gridModeService;
  }
}
