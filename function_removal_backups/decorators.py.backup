"""
TKA Desktop Decorators

This module provides decorators for cross-cutting concerns like error handling,
performance monitoring, and logging across the TKA Desktop application.

DECORATORS:
- handle_service_errors: Standardized error handling for service methods
- validate_inputs: Input validation decorator
- log_operation: Operation logging decorator
- retry_on_failure: Retry decorator for transient failures
"""

import functools
import logging
import time
from collections.abc import Callable
from typing import Any

from .exceptions import (
    TKABaseException,
    ValidationError,
    service_error,
)

# Configure logger for decorators
logger = logging.getLogger(__name__)


def handle_service_errors(
    operation_name: str | None = None,
    reraise_validation_errors: bool = True,
    default_return: Any = None,
    log_level: int = logging.ERROR,
) -> Callable:
    """
    Decorator for standardized service error handling.

    This decorator provides consistent error handling across all service methods,
    converting unexpected exceptions to ServiceOperationError while preserving
    validation errors and providing detailed logging.

    Args:
        operation_name: Custom operation name (defaults to class.method)
        reraise_validation_errors: Whether to re-raise ValidationError as-is
        default_return: Default return value on error (if not re-raising)
        log_level: Logging level for error messages

    Returns:
        Decorated function with error handling

    Example:
        @handle_service_errors("calculate_layout")
        def calculate_layout(self, data: LayoutData) -> LayoutResult:
            # Implementation here
    """

    def decorator(func: Callable) -> Callable:
        return wrapper
        return wrapper

    return decorator


def log_operation(
    log_level: int = logging.INFO,
    include_args: bool = False,
    include_result: bool = False,
    include_duration: bool = True,
) -> Callable:
    """
    Decorator for operation logging.

    Args:
        log_level: Logging level for operation messages
        include_args: Whether to log function arguments
        include_result: Whether to log function result
        include_duration: Whether to log operation duration

    Returns:
        Decorated function with operation logging
    """

    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.perf_counter() if include_duration else None

            # Determine operation name
    return decorator


def performance_critical(
    max_duration_ms: float | None = None,
    max_memory_mb: float | None = None,
    warn_threshold_ms: float | None = None,
) -> Callable:
    """
    Decorator for performance-critical operations.

    Args:
        max_duration_ms: Maximum allowed duration in milliseconds
        max_memory_mb: Maximum allowed memory usage in MB
        warn_threshold_ms: Warning threshold for duration

    Returns:
        Decorated function with performance monitoring
    """

    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            import psutil

            from .exceptions import PerformanceError

            start_time = time.perf_counter()
            start_memory = psutil.Process().memory_info().rss / 1024 / 1024

            try:
                result = func(*args, **kwargs)

                # Check performance metrics
                end_time = time.perf_counter()
                end_memory = psutil.Process().memory_info().rss / 1024 / 1024

                duration_ms = (end_time - start_time) * 1000
                memory_used_mb = end_memory - start_memory

                op_name = (
                    f"{args[0].__class__.__name__}.{func.__name__}"
                    if args
                    else func.__name__
                )

                # Check duration thresholds
                if max_duration_ms and duration_ms > max_duration_ms:
                    raise PerformanceError(
                        message="Operation exceeded maximum duration",
                        operation=op_name,
                        threshold=max_duration_ms,
                        actual=duration_ms,
                        metric_type="duration_ms",
                    )

                if warn_threshold_ms and duration_ms > warn_threshold_ms:
                    logger.warning(
                        f"Performance warning: {op_name} took {duration_ms:.1f}ms "
                        f"(threshold: {warn_threshold_ms}ms)"
                    )

                # Check memory thresholds
                if max_memory_mb and memory_used_mb > max_memory_mb:
                    raise PerformanceError(
                        message="Operation exceeded maximum memory usage",
                        operation=op_name,
                        threshold=max_memory_mb,
                        actual=memory_used_mb,
                        metric_type="memory_mb",
                    )

                return result

            except Exception:
                raise

        return wrapper

    return decorator
